-- 테이블 전부 삭제
DROP TABLE IF EXISTS choice;
DROP TABLE IF EXISTS diagnosis;
DROP TABLE IF EXISTS user_exam_answer;
DROP TABLE IF EXISTS exam;
DROP TABLE IF EXISTS user_content;
DROP TABLE IF EXISTS total_content;
DROP TABLE IF EXISTS chapter;
DROP TABLE IF EXISTS roadmap;
DROP TABLE IF EXISTS roadmap_management;
DROP TABLE IF EXISTS feedback;
DROP TABLE IF EXISTS user_interview_reply;
DROP TABLE IF EXISTS interview;
DROP TABLE IF EXISTS subject;
DROP TABLE IF EXISTS track;
DROP TABLE IF EXISTS chat;
DROP TABLE IF EXISTS users;
DROP TABLE IF EXISTS feedback_fail_log;

-- users 테이블 생성
CREATE TABLE users (
                       user_id BIGINT AUTO_INCREMENT PRIMARY KEY,
                       email VARCHAR(255) NOT NULL,
                       nickname VARCHAR(255) NOT NULL,
                       password VARCHAR(255),
                       login_type VARCHAR(50) NOT NULL,
                       is_active BOOLEAN NOT NULL DEFAULT TRUE,
                       lecture_amount VARCHAR(255),
                       price_level VARCHAR(255),
                       likes_books BOOLEAN,
                       privacy_status BOOLEAN
);

-- diagnosis 테이블 생성
CREATE TABLE diagnosis (
                           diagnosis_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                           question TEXT NOT NULL,
                           question_type VARCHAR(50) NOT NULL,
                           created_dt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- choice 테이블 생성
CREATE TABLE choice (
                        choice_id BIGINT AUTO_INCREMENT PRIMARY KEY,
                        choice_num INT NOT NULL,
                        choice TEXT NOT NULL,
                        value VARCHAR(255) NOT NULL,
                        created_dt DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        diagnosis_id BIGINT NOT NULL,
                        CONSTRAINT fk_choice_diagnosis FOREIGN KEY (diagnosis_id) REFERENCES diagnosis(diagnosis_id)
);

-- 공통 질문 1
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (1, '어느 분야에서 성장하고 싶으신가요?', 'COMMON');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (1, 1, '프론트엔드', 'FE'),
                                                                 (1, 2, '백엔드', 'BE');

-- 공통 질문 2
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (2, '당신이 원하는 강의 분량은 어느정도 인가요?', 'COMMON');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (2, 1, '가볍게 1시간!', '0'),
                                                                 (2, 2, '짧고 굵게 3시간!', '1'),
                                                                 (2, 3, '찐득하게 5시간!', '2'),
                                                                 (2, 4, '깊게 공부하는게 좋아 10시간!', '3'),
                                                                 (2, 5, '나는야 공부벌레 10시간 이상!', '4');

-- 공통 질문 3
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (3, '한 강의에 얼마까지 투자할 생각이 있으신가요?', 'COMMON');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (3, 1, '무료', '0'),
                                                                 (3, 2, '5만원 이하', '1'),
                                                                 (3, 3, '5만원 ~ 10만원', '2'),
                                                                 (3, 4, '10만원 ~ 20만원', '3'),
                                                                 (3, 5, '20만원 ~ 50만원', '4'),
                                                                 (3, 6, '50만원 이상', '5');

-- 공통 질문 4
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (4, '책을 통해 공부하는 것을 좋아하시나요?', 'COMMON');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (4, 1, '네.', 'Y'),
                                                                 (4, 2, '아니오.', 'N');

-- 프론트엔드 질문 1
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (5, '배우고 싶은 프레임워크가 무엇인가요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (5, 1, 'React', 'React'),
                                                                 (5, 2, 'Vue', 'Vue'),
                                                                 (5, 3, 'Angular', 'Angular');

-- 프론트엔드 질문 2
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (6, '코드를 깔끔하고 일관되게 관리하는 방법(EsLint & Prettier)에 대해 배우고 싶나요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (6, 1, '네', 'Y'),
                                                                 (6, 2, '아니오', 'N');

-- 프론트엔드 질문 3
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (7, 'UI를 깔끔하고 체계적으로 만들기 위한 디자인 시스템과 스타일링 방법을 배워보고 싶나요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (7, 1, '네', 'Y'),
                                                                 (7, 2, '아니오', 'N');

-- 프론트엔드 질문 4
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (8, '프론트엔드 배포를 자동화하는 과정(CI/CD)에 대해 배우고 싶나요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (8, 1, '네', 'Y'),
                                                                 (8, 2, '아니오', 'N');

-- 프론트엔드 질문 5
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (9, '컴포넌트 단위의 UI 테스트 방법론(예: Storybook, Jest + React Testing Library)을 배우고 싶나요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (9, 1, '네', 'Y'),
                                                                 (9, 2, '아니오', 'N');

-- 프론트엔드 질문 6
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (10, '사용자의 실제 사용 흐름(E2E 테스트, Cypress 등)을 테스트하는 방법에 대해 배우고 싶나요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (10, 1, '네', 'Y'),
                                                                 (10, 2, '아니오', 'N');

-- 백엔드 질문 1
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (11, '선호하는 프레임워크는 무엇인가요?', 'BE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (11, 1, 'Java/Spring', 'Java/Spring'),
                                                                 (11, 2, 'Python/Flask', 'Python/Flask'),
                                                                 (11, 3, 'Python/Django', 'Python/Django'),
                                                                 (11, 4, 'JavaScript/Node.js', 'Js/Node'),
                                                                 (11, 5, 'Kotlin/Spring', 'Kotlin/Spring');

-- 백엔드 질문 2
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (12, 'RDB 종류별 장단점을 학습하고 싶으신가요?', 'BE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (12, 1, '네', 'Y'),
                                                                 (12, 2, '아니오', 'N');

-- 백엔드 질문 3
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (13, '쿼리 최적화, 데이터 정규화에 대해 학습하고 싶으신가요?', 'BE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (13, 1, '네', 'Y'),
                                                                 (13, 2, '아니오', 'N');

-- 백엔드 질문 4
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (14, '프레임워크 라이브러리 종류를 학습하고 싶으신가요?', 'BE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (14, 1, '네', 'Y'),
                                                                 (14, 2, '아니오', 'N');

-- 백엔드 질문 5
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (15, '프로젝트 운영 배포 방법을 학습하고 싶으신가요?', 'BE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
                                                                 (15, 1, '네', 'Y'),
                                                                 (15, 2, '아니오', 'N');

-- track(과정) 테이블 생성
CREATE TABLE track(
                      track_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                      track_nm VARCHAR(255) NOT NULL,
                      UNIQUE KEY uk_track (track_nm)
);

-- subject(과목) 테이블 생성
CREATE TABLE subject(
                        sub_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                        sub_nm VARCHAR(255) NOT NULL,
                        sub_type VARCHAR(50) NOT NULL,
                        sub_essential VARCHAR(1) NOT NULL,
                        base_sub_order INT NOT NULL,
                        sub_overview LONGTEXT,
                        track_id BIGINT NOT NULL,
                        CONSTRAINT fk_subject_track FOREIGN KEY (track_id) REFERENCES track(track_id)
);

-- roadmap_management(로드맵 관리) 테이블 생성
CREATE TABLE roadmap_management(
                                   roadmap_management_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                                   roadmap_nm VARCHAR(255),
                                   roadmap_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                                   user_id BIGINT NOT NULL,
                                   CONSTRAINT fk_roadmap_management_users FOREIGN KEY (user_id) REFERENCES users(user_id)
);

-- roadmap(로드맵) 테이블 생성
CREATE TABLE roadmap(
                        roadmap_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                        order_sub INT NOT NULL,
                        sub_id BIGINT NOT NULL,
                        roadmap_management_id BIGINT NOT NULL,
                        is_complete BOOLEAN NOT NULL DEFAULT FALSE,
                        pre_submit_count INT NOT NULL,
                        post_submit_count INT NOT NULL,
                        level INT NOT NULL DEFAULT 0,
                        CONSTRAINT fk_roadmap_subject FOREIGN KEY (sub_id) REFERENCES subject(sub_id),
                        CONSTRAINT fk_roadmap_roadmap_management FOREIGN KEY (roadmap_management_id) REFERENCES roadmap_management(roadmap_management_id)
);

-- chapter(단원) 테이블 생성
CREATE TABLE chapter(
                        chapter_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                        chapter_nm VARCHAR(255) NOT NULL,
                        chapter_order INT NOT NULL,
                        sub_id BIGINT NOT NULL,
                        CONSTRAINT fk_chapter_subject FOREIGN KEY (sub_id) REFERENCES subject(sub_id)
);

-- track(과정) 정보 주입
INSERT INTO track (track_id, track_nm) VALUES
                                           (1, '기초지식'),
                                           (2, 'VCS'),
                                           (3, 'HTTP 통신 및 상태 동기화 고도화'),
                                           (4, 'React 기본'),
                                           (5, 'Vue 기본'),
                                           (6, 'Angular 기본'),
                                           (7, '디자인'),
                                           (8, '상태관리'),
                                           (9, 'React 심화'),
                                           (10, 'Vue 심화'),
                                           (11, 'Angular 심화'),
                                           (12, '번들링과 빌드 최적화'),
                                           (13, '배포 자동화 및 인프라 연계'),
                                           (14, '컴포넌트 테스트 방법론'),
                                           (15, '화면 테스트 방법론'),
                                           (16, 'Linux & Internet'),
                                           (17, 'Java'),
                                           (18, 'Python'),
                                           (19, 'JavaScript'),
                                           (20, 'Kotlin'),
                                           (21, 'SQL문'),
                                           (22, 'More About Database'),
                                           (23, 'Scaling Database'),
                                           (24, 'Spring & Spring Boot(Java)'),
                                           (25, 'Node.js & Express.js'),
                                           (26, 'Django'),
                                           (27, 'Flask'),
                                           (28, 'Spring & Spring Boot(Kotlin)'),
                                           (29, 'Java Advanced'),
                                           (30, 'Kotlin Advanced'),
                                           (31, 'Java & Kotlin Advanced'),
                                           (32, 'Node.js Advanced'),
                                           (33, 'Django Advanced'),
                                           (34, 'Flask Advanced');

-- subject(과목) 정보 주입
INSERT INTO subject (sub_id, sub_nm, track_id, sub_type, sub_essential, base_sub_order, sub_overview) VALUES
                                                                                                          (1, 'HTML', 1, 'FE', 'Y', 1, 'HTML이란? 웹페이지의 뼈대!웹사이트에서 내용을 담당해요.예를 들면, 제목, 글, 버튼, 이미지, 표 같은 걸 HTML로 만들어줍니다.마치 건물의 설계도 같다고 생각하면 돼요. 벽이 어디 있는지, 문은 어디 있는지 알려주는 거죠.'),
                                                                                                          (2, 'CSS', 1, 'FE', 'Y', 2, 'CSS란? 웹페이지에 스타일을 입히는 도구!색깔, 크기, 글꼴, 위치 같은 디자인 요소를 조절해요.예를 들면, 글자의 색을 바꾸거나 버튼의 모양을 다듬고,이미지 간 간격을 조정하고 배경 색을 설정할 수 있어요.마치 집 안을 꾸미는 인테리어처럼,보는 사람이 더 편하고 예쁘게 느낄 수 있도록 만드는 역할을 해요.'),
                                                                                                          (3, 'JavaScript', 1, 'FE', 'Y', 3, 'JavaScript란? 웹페이지를 움직이게 하는 도구!클릭, 입력, 스크롤 같은 사용자 행동에 반응하게 만들어요.예를 들면, 버튼을 누르면 팝업이 뜨거나,입력한 정보를 검사하고, 이미지가 자동으로 바뀌는 기능을 만들 수 있어요.마치 리모컨을 눌렀을 때 TV가 반응하듯,웹페이지에 동작과 반응을 더해주는 역할을 해요.'),
                                                                                                          (4, 'TypeScript', 1, 'FE', 'Y', 4, 'TypeScript란? 더 안전하고 체계적인 코드를 쓰게 도와주는 도구!코드를 작성할 때 변수의 타입을 미리 정해서, 실수를 줄이고 예측 가능한 코드를 만들 수 있어요.예를 들면, 숫자만 받아야 하는 자리에 문자를 넣으면 작성 단계에서 오류를 알려줘요.협업할 때 서로의 코드가 어떻게 작동하는지 쉽게 이해할 수 있도록 도와줘요.마치 도면에 치수를 적어두는 것처럼,코드에 규칙과 설명을 더해서 더 튼튼하고 믿을 수 있는 프로그램을 만들게 해줘요.'),
                                                                                                          (5, 'Virtual DOM', 1, 'FE', 'Y', 5, 'Virtual DOM이란? 웹페이지의 변화를 더 빠르게 처리하기 위한 가상의 화면!화면 전체를 매번 다시 그리지 않고, 변경된 부분만 똑똑하게 찾아서 업데이트해줘요.예를 들면, 리스트 하나만 바뀌었을 때 전체를 새로 그리는 대신바뀐 리스트 항목만 바꿔주는 식으로 효율적으로 작동해요.마치 복사본을 두고 비교해서 바뀐 부분만 바꿔주는 것처럼,화면 성능을 높이고 부드럽게 동작하도록 도와주는 기술이에요.'),
                                                                                                          (6, 'Git & GitHub', 2, 'FE', 'Y', 6, 'Git & GitHub란? 코드를 안전하게 관리하고, 함께 작업할 수 있게 해주는 도구!코드를 버전별로 저장하고, 이전 상태로 되돌리거나 여러 사람이 동시에 작업해도 충돌 없이 관리할 수 있어요.예를 들면, 실수로 코드를 잘못 고쳐도 이전 상태로 복원할 수 있고,팀원이 만든 기능을 병합하거나 비교할 수도 있어요.Git은 버전 관리 시스템,GitHub는 이 Git 저장소를 인터넷에 저장하고 협업할 수 있게 해주는 서비스라고 생각하면 돼요.'),
                                                                                                          (7, 'Git Hook 자동화', 2, 'FE', 'Y', 7, 'Git Hook (Husky, lint-staged) 자동화란? 코드 저장 전에 자동으로 검사하거나 정리해주는 도구!커밋하거나 푸시할 때, 코드 스타일을 체크하거나 테스트를 실행해서실수나 버그를 미리 막아주는 역할을 해요.예를 들면, 커밋 전에 코드 포맷을 자동으로 맞추거나,오류가 있는 코드는 커밋되지 않도록 차단할 수 있어요.마치 택배를 보내기 전에 포장 상태를 검사하는 것처럼,코드를 안전하게 관리하고 팀의 품질 기준을 지킬 수 있도록 도와주는 도구예요.'),
                                                                                                          (8, 'Axios 관리', 3, 'FE', 'Y', 8, 'Axios 인스턴스 관리, 공통 인터셉터 구성이란? API 요청을 더 효율적이고 일관되게 관리하는 방법!반복되는 설정을 줄이고, 요청이나 응답에 공통적으로 해야 할 작업을 자동으로 처리할 수 있어요.예를 들면, 모든 요청에 토큰을 자동으로 넣거나,오류가 났을 때 공통 에러 처리 로직을 한 번에 적용할 수 있어요.마치 배달을 보낼 때마다 포장, 주소, 확인 절차를 자동화하는 것처럼,코드 중복을 줄이고 안정적인 통신 흐름을 만들어주는 설정 방식이에요.'),
                                                                                                          (9, 'REST API', 3, 'FE', 'Y', 9, 'REST API 기반 에러 처리 / 재시도 로직이란? API 통신 중 문제가 생겼을 때, 똑똑하게 대응하는 방법!요청이 실패했을 때 사용자에게 알리고,필요하면 자동으로 다시 시도하거나 적절한 조치를 취할 수 있어요.예를 들면, 네트워크 오류로 요청이 실패하면 일정 시간 뒤 다시 보내거나,인증 오류가 나면 자동으로 로그아웃 처리하는 식이에요.마치 배달 실패 시 다시 시도하거나 고객에게 안내하는 시스템처럼,더 안정적이고 사용자 친화적인 API 통신 흐름을 만드는 데 꼭 필요한 기술이에요.'),
                                                                                                          (10, 'React', 4, 'FE', 'N', 10, 'React란? 웹페이지를 빠르고 효율적으로 만들 수 있게 도와주는 JavaScript 라이브러리!화면을 여러 개의 컴포넌트로 나누어 관리하고,데이터가 바뀌면 필요한 부분만 다시 그려줘요.예를 들면, 버튼을 누르면 숫자가 증가하거나,리스트가 자동으로 갱신되는 인터페이스를 쉽게 만들 수 있어요.마치 블록처럼 조각을 쌓아 올리듯 화면을 구성하고,변화에 빠르게 반응하는 인터랙티브한 웹앱을 만들 수 있는 도구예요.'),
                                                                                                          (11, 'Redux', 4, 'FE', 'N', 11, 'Redux란? 복잡한 상태(state)를 한 곳에서 깔끔하게 관리해주는 도구!여러 컴포넌트들이 사용하는 데이터를 중앙에서 모아서 관리하고,필요할 때만 정확하게 바꿔줘요.예를 들면, 로그인 상태, 장바구니 정보, 알림 같은 걸 앱 전체에서 공유하고 업데이트할 수 있어요.마치 중앙 창고에서 필요한 물건을 꺼내 쓰고 바꾸는 것처럼,예측 가능한 방식으로 상태를 관리해서 큰 규모의 앱도 안정적으로 만들 수 있어요.'),
                                                                                                          (12, 'Zustand', 4, 'FE', 'N', 12, 'Zustand란? 가볍고 간단하게 상태를 관리할 수 있는 상태 관리 라이브러리!코드가 적고 구조가 단순해서, 빠르게 사용할 수 있고필요한 데이터만 골라서 효율적으로 관리할 수 있어요.예를 들면, 버튼 클릭으로 숫자를 바꾸거나,로그인 상태를 여러 컴포넌트에서 쉽게 공유할 수 있어요.마치 작은 도구 상자처럼 꼭 필요한 기능만 담겨 있어서,리액트 앱의 상태를 부담 없이 관리할 수 있는 실용적인 도구예요.'),
                                                                                                          (13, 'Vue', 5, 'FE', 'N', 13, 'Vue란? 직관적이고 빠르게 웹 인터페이스를 만들 수 있는 프론트엔드 프레임워크!HTML, CSS, JavaScript를 함께 사용해 화면을 구성하고 데이터와 연결하는 작업을 쉽게 할 수 있어요.예를 들면, 입력한 내용을 화면에 바로 보여주거나,버튼 클릭에 따라 리스트가 자동으로 바뀌는 기능을 간단하게 만들 수 있어요.마치 조립식 블록처럼 구조가 명확하고 유연해서,초보자도 쉽게 배우고, 복잡한 앱도 빠르게 개발할 수 있는 도구예요.'),
                                                                                                          (14, 'Vuex & Pinia', 5, 'FE', 'N', 14, 'Vuex & Pinia란? Vue 앱에서 상태를 체계적으로 관리하기 위한 도구들이에요!Vuex는 **중앙 저장소(store)**를 통해 모든 컴포넌트가 공유하는 데이터를 관리하고,Pinia는 이를 더 간단하고 직관적으로 사용할 수 있도록 도와주는 경량 도구예요.예를 들면, 로그인 정보, 사용자 설정, 장바구니처럼 여러 컴포넌트에서 함께 사용하는 데이터를한 곳에 모아서 변경하고 추적할 수 있어요. 마치 모든 정보를 기록하는 하나의 통제 센터처럼,Vue 애플리케이션을 예측 가능하고 안정적으로 유지해주는 역할을 해요.'),
                                                                                                          (15, 'Angular', 6, 'FE', 'N', 15, 'Angular란? 대규모 웹 애플리케이션을 체계적으로 만들 수 있는 프레임워크! 컴포넌트 기반 구조와 강력한 타입 시스템, 모듈, 라우팅, 폼, HTTP 처리까지웹 개발에 필요한 기능을 하나의 도구로 통합해서 제공해요. 예를 들면, 사용자 인증, 데이터 처리, 화면 전환 등 복잡한 기능들을 분리된 구성으로 깔끔하게 관리할 수 있어요. 마치 잘 정리된 설계도와 작업 도구가 모두 갖춰진 공장처럼, 복잡한 웹앱을 안정적이고 효율적으로 개발할 수 있게 도와주는 프레임워크예요.'),
                                                                                                          (16, 'NgRx', 6, 'FE', 'N', 16, 'NgRx란? Angular에서 애플리케이션의 상태를 일관되게 관리할 수 있도록 도와주는 라이브러리! Redux 패턴을 기반으로 해서, 액션(action), 리듀서(reducer), 스토어(store)를 통해상태의 흐름을 예측 가능하고 체계적으로 관리할 수 있어요. 예를 들면, 사용자 정보, 알림 상태, 페이지 전환 등앱 전체에서 공유되는 데이터를 한 곳에서 처리하고 추적할 수 있어요. 마치 중앙 지휘본부에서 모든 정보를 받아 분석하고 지시하는 것처럼, 복잡한 Angular 앱의 상태를 명확하게 관리해주는 강력한 도구예요.'),
                                                                                                          (17, 'Storybook', 7, 'FE', 'N', 17, '컴포넌트 디자인 시스템 (Storybook)이란? 컴포넌트를 독립적으로 만들고, 테스트하고, 문서화할 수 있는 도구! UI 컴포넌트를 실제 화면처럼 하나씩 확인하고 조작해보면서, 디자인과 기능이 제대로 작동하는지 쉽게 검토할 수 있어요. 예를 들면, 버튼, 카드, 모달 같은 컴포넌트를 페이지와 분리해서 개발하고, 다양한 상태나 테마로 미리보기할 수 있어요. 마치 부품을 미리 조립해보는 전시 공간처럼, 컴포넌트를 체계적으로 관리하고 재사용성을 높여주는 개발 환경이에요.'),
                                                                                                          (18, 'Tailwind CSS', 7, 'FE', 'N', 18, 'Tailwind CSS란? 클래스 이름만으로 빠르게 스타일을 적용할 수 있는 유틸리티 기반 CSS 프레임워크!미리 정의된 클래스들을 조합해서 디자인을 만들 수 있어서,별도로 CSS 파일을 작성하지 않고도 바로 스타일링할 수 있어요.예를 들면, bg-blue-500, text-center, p-4 같은 클래스를 조합해서배경색, 정렬, 여백을 한눈에 설정할 수 있어요. 마치 레고 블록을 조립하듯 필요한 스타일만 골라 붙이는 방식이라서, 반응형 디자인과 빠른 개발에 특히 유용한 도구예요.'),
                                                                                                          (19, 'SCSS', 7, 'FE', 'N', 19, 'SCSS란? CSS를 더 편리하고 체계적으로 작성할 수 있게 도와주는 스타일 확장 문법!중첩, 변수, 함수, 반복문 같은 기능을 활용해서 복잡한 스타일도 재사용 가능하고 깔끔하게 관리할 수 있어요.예를 들면, 색상 값을 변수로 저장하거나,버튼 스타일을 한 번에 정의해서 여러 곳에서 쓸 수 있어요.마치 정리된 노트처럼 규칙 있고 효율적인 방식으로 스타일을 관리할 수 있게 해주는 도구예요.'),
                                                                                                          (20, 'styled', 7, 'FE', 'N', 20, 'styled란? JavaScript 코드 안에서 스타일을 바로 작성할 수 있게 해주는 CSS-in-JS 도구! 컴포넌트 단위로 스타일을 만들 수 있어서, 디자인과 기능을 하나로 묶어 재사용성과 유지보수성을 높일 수 있어요. 예를 들면, styled.button을 만들어서 버튼 스타일을 설정하고, 필요한 곳에 불러와서 바로 사용할 수 있어요. 마치 디자인과 코드를 하나의 부품처럼 함께 관리하는 방식이라서, React 개발에 특히 잘 어울리는 스타일링 도구예요.'),
                                                                                                          (21, 'EsLint & Prettier', 8, 'FE', 'N', 21, 'ESLint & Prettier란? 코드의 품질과 스타일을 자동으로 검사하고 정리해주는 도구! ESLint는 코드에서 잘못된 문법이나 위험한 패턴을 찾아내고, Prettier는 들여쓰기, 줄바꿈, 공백 같은 스타일을 자동으로 정리해줘요. 예를 들면, 세미콜론이 빠졌거나, 들여쓰기가 틀렸을 때 자동으로 수정하거나 경고를 띄워줘서 실수를 줄일 수 있어요. 마치 글을 쓰기 전에 맞춤법 검사기와 문장 정리기를 함께 사용하는 것처럼, 코드를 더 깔끔하고 일관되게 유지해주는 필수 개발 도구예요.'),
                                                                                                          (22, 'Next.js', 9, 'FE', 'N', 22, 'Next.js란? 빠르고 효율적인 웹앱을 만들 수 있게 해주는 React 기반 프레임워크! 정적 사이트 생성(SSG), 서버 사이드 렌더링(SSR), 라우팅, API 구성 같은 기능이 기본으로 제공돼요. 예를 들면, 페이지를 미리 만들어 빠르게 보여주거나, 사용자 요청에 따라 서버에서 데이터를 받아 동적으로 화면을 그릴 수 있어요. 마치 기능이 갖춰진 올인원 개발 도구 세트처럼, 복잡한 설정 없이도 강력한 웹 서비스를 빠르게 개발할 수 있는 프레임워크예요.'),
                                                                                                          (23, 'React 렌더링', 9, 'FE', 'N', 23, 'React 렌더링 최적화란? 불필요한 컴포넌트 렌더링을 줄여서 앱을 더 빠르게 만드는 방법! React.memo, useMemo, useCallback 같은 기능을 활용하면 변경이 없는 부분은 다시 그리지 않고, 계산 비용이 큰 작업도 효율적으로 처리할 수 있어요. 예를 들면, 같은 props를 가진 컴포넌트를 다시 그리지 않거나, 계산된 값을 기억해서 다시 계산하지 않게 할 수 있어요. 마치 필요한 부분만 다시 고치는 스마트한 설계 방식처럼, 성능을 높이고 렌더링을 효율적으로 관리하는 데 꼭 필요한 기술이에요.'),
                                                                                                          (24, 'React Query 심화', 9, 'FE', 'N', 24, 'React Query 심화란? 데이터를 똑똑하게 미리 불러오고, 효율적으로 갱신할 수 있는 고급 기술! Prefetch로 사용자가 보기 전에 데이터를 미리 준비하고, Query Keys로 요청을 구분하고 관리하며, Invalidation으로 필요한 시점에 데이터를 자동으로 다시 가져올 수 있어요. 예를 들면, 목록 화면에서 상세 정보를 미리 받아두거나, 수정 후 자동으로 데이터를 새로 고치는 기능을 쉽게 구현할 수 있어요. 마치 냉장고에 미리 음식을 채워두고, 바뀐 재료만 새로 담는 것처럼, 사용자 경험을 끊김 없이 유지하고 네트워크 요청을 최적화할 수 있는 기술이에요.'),
                                                                                                          (25, 'Vue Test Utils', 10, 'FE', 'N', 25, 'Vue Test Utils란? Vue 컴포넌트를 테스트할 수 있도록 도와주는 공식 테스트 도구! 컴포넌트를 렌더링하고, 내부 동작을 검사하거나 사용자 이벤트를 시뮬레이션할 수 있어요. 예를 들면, 버튼 클릭 시 이벤트가 잘 작동하는지 확인하거나, 전달된 props에 따라 화면이 올바르게 바뀌는지를 테스트할 수 있어요. 마치 부품 하나하나를 따로 꺼내서 기능을 점검하는 검사 장비처럼, Vue 컴포넌트의 동작을 정확하고 안정적으로 검증할 수 있게 해주는 도구예요.'),
                                                                                                          (26, 'Nuxt.js', 10, 'FE', 'N', 26, 'Nuxt.js란? Vue 기반의 웹 애플리케이션을 더 빠르고 쉽게 만들 수 있게 해주는 프레임워크! 페이지 라우팅, 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG) 등 복잡한 설정 없이도 강력한 기능을 바로 사용할 수 있어요. 예를 들면, 파일만 만들어도 자동으로 라우팅되고, SEO에 유리한 방식으로 페이지를 미리 렌더링할 수 있어요. 마치 기본 기능이 잘 갖춰진 웹 개발 전용 템플릿처럼, Vue로 만들 수 있는 프로젝트를 더 효율적이고 확장성 있게 개발할 수 있게 해주는 도구예요.'),
                                                                                                          (27, 'Angular Universal', 11, 'FE', 'N', 27, 'Angular Universal이란? Angular 애플리케이션을 서버에서 먼저 렌더링해주는 도구! 브라우저가 아닌 서버에서 HTML을 먼저 만들어서 사용자에게 빠르게 보여주고, 검색 엔진(SEO)에도 잘 노출될 수 있도록 도와줘요. 예를 들면, 사용자가 페이지를 열었을 때 화면이 바로 보이고, 뒤늦게 Angular가 연결되어 상호작용이 이어지는 구조예요. 마치 공장에서 미리 조립된 제품을 바로 전달하는 것처럼, 초기 로딩 속도와 검색 최적화에 강한 Angular 전용 서버 사이드 렌더링 기술이에요.'),
                                                                                                          (28, 'Jasmine', 11, 'FE', 'N', 28, 'Jasmine이란? Angular 애플리케이션의 기능이 제대로 동작하는지 확인할 수 있게 해주는 테스트 프레임워크! 함수나 컴포넌트의 결과가 예상대로 나오는지 자동으로 검사할 수 있어요. 테스트 코드를 통해 버그를 줄이고, 리팩터링도 더 안전하게 할 수 있어요. 예를 들면, 특정 함수가 정확한 값을 반환하는지, 버튼 클릭 시 원하는 동작이 일어나는지를 미리 확인할 수 있어요. 마치 기계를 출고하기 전에 작동 여부를 테스트하는 품질 검사 도구처럼, Angular 코드의 신뢰성과 안정성을 높여주는 중요한 테스트 도구예요.'),
                                                                                                          (29, 'Webpack 개념과 설정', 12, 'FE', 'Y', 29, 'Webpack이란? 웹 애플리케이션에서 사용하는 파일들을 하나로 묶어주는 모듈 번들러! HTML, CSS, JavaScript, 이미지 같은 자원들을 의존성에 따라 정리하고, 브라우저가 효율적으로 로딩할 수 있게 하나로 패키징해줘요. 예를 들면, 여러 개의 JS 파일을 하나로 합치거나, 코드를 압축하고, 필요할 때만 불러오도록 설정할 수 있어요. 마치 여러 자재를 정리해서 하나의 박스로 포장하는 공정처럼, 웹 프로젝트를 최적화하고 배포하기 좋게 만들어주는 핵심 도구예요.'),
                                                                                                          (30, '빌드/배포 자동화', 13, 'FE', 'N', 30, 'GitHub Actions로 빌드/배포 자동화란? 코드가 변경될 때마다 자동으로 테스트하고, 빌드하고, 배포까지 해주는 자동화 도구!정해진 조건에 따라 작업이 자동으로 실행되기 때문에 수작업 없이도 일관된 개발과 배포 환경을 유지할 수 있어요. 예를 들면, 코드를 푸시하면 테스트가 돌고, 빌드가 완료되면 서버에 자동으로 배포되도록 설정할 수 있어요. 마치 공장 자동화 시스템처럼 정해진 순서로 작업이 척척 진행되게 만들어주는 도구로, 지속적인 통합(CI)과 지속적인 배포(CD)를 손쉽게 구현할 수 있어요.'),
                                                                                                          (31, '프론트엔드 앱 배포', 13, 'FE', 'N', 31, 'Dockerize된 프론트엔드 앱 배포란? 프론트엔드 애플리케이션을 Docker로 감싸서 어디서든 쉽게 실행하고 배포할 수 있게 만드는 방법! 앱을 Nginx 같은 웹 서버에 올리고, Docker 이미지로 만들면 환경에 상관없이 동일한 방식으로 실행할 수 있어요. 예를 들면, React나 Vue 앱을 빌드한 후 Nginx에 연결하고, 이걸 하나의 Docker 이미지로 만들어서 서버나 클라우드에 배포할 수 있어요. 마치 앱을 하나의 컨테이너에 담아 포장한 후 어떤 환경에서도 똑같이 꺼내 쓸 수 있게 만드는 것처럼, 배포 속도와 안정성을 높여주는 현대적인 프론트엔드 배포 방식이에요.'),
                                                                                                          (32, 'AWS S3 + CloudFront 배포', 13, 'FE', 'N', 32, 'AWS S3 + CloudFront 기반 SPA 배포란? 정적 웹 애플리케이션(SPA)을 빠르고 안정적으로 전 세계에 배포하는 방법! S3에 앱 파일을 저장하고, CloudFront를 통해 전 세계 사용자에게 빠르게 전달할 수 있어요. 예를 들면, React나 Vue로 만든 앱을 S3에 업로드하고, CloudFront를 통해 CDN으로 연결하면 지연 없이 콘텐츠를 제공할 수 있어요. 마치 전 세계에 배포 센터를 두고 가장 가까운 곳에서 파일을 꺼내주는 구조처럼, SPA를 빠르고 안정적으로 서비스할 수 있는 클라우드 배포 방식이에요.'),
                                                                                                          (33, 'Component Test', 14, 'FE', 'N', 33, 'Unit Test, Snapshot Test, Integration Test란? 코드가 의도한 대로 작동하는지 다양한 수준에서 확인하는 테스트 기법들이에요! Unit Test는 함수나 컴포넌트 하나만 따로 검사하고, Snapshot Test는 출력 결과가 이전과 같은지 자동으로 비교하며, Integration Test는 여러 기능이 함께 잘 작동하는지를 확인해요. 예를 들면, 버튼 클릭 시 동작하는 함수만 테스트하거나, 컴포넌트가 렌더링하는 HTML이 바뀌지 않았는지를 체크하거나, 로그인 → 페이지 이동 흐름까지 전체를 점검할 수 있어요. 마치 부품 테스트, 조립 상태 확인, 실제 작동 테스트를 모두 거치는 품질 검증 과정처럼, 안정적이고 신뢰할 수 있는 코드를 만들기 위한 중요한 개발 절차예요.'),
                                                                                                          (34, 'Visual Test', 15, 'FE', 'N', 34, 'E2E Test, Visual Regression Test란? 앱의 모든 흐름이 실제 사용자처럼 잘 작동하는지, 화면이 이상 없이 보이는지 확인하는 테스트 방법이에요! E2E 테스트는 사용자가 버튼을 클릭하거나 페이지를 이동하는 과정을 자동화된 시나리오로 실행해보고, Visual Regression 테스트는 UI가 예전과 달라진 부분이 없는지 화면을 이미지로 비교해요. 예를 들면, 로그인 → 상품 선택 → 결제 완료까지의 과정을 자동으로 따라가며 검증하거나, 디자인이 바뀌었는지 픽셀 단위로 비교해서 알려줄 수 있어요. 마치 사람처럼 앱을 실제로 사용해보고, 화면을 눈으로 비교하는 것처럼, 전체 동작과 시각적인 완성도를 함께 검증할 수 있는 고급 테스트 방식이에요.'),
                                                                                                          (35, 'Linux', 16, 'BE', 'Y', 1, '리눅스 명령어란? 터미널에서 직접 컴퓨터를 조작할 수 있게 해주는 텍스트 기반의 도구! 파일 생성, 복사, 이동부터 시스템 관리, 프로세스 확인, 서버 설정까지 명령어 한 줄로 다양한 작업을 빠르고 정확하게 수행할 수 있어요. 예를 들면, ls로 폴더 목록을 확인하고, cd로 위치를 옮기거나, chmod, ps, top 같은 명령어로 권한과 시스템 상태를 관리할 수 있어요. 마치 명령 센터에서 키워드 하나로 기계를 제어하듯, 개발과 운영 환경에서 효율적이고 강력한 제어력을 제공해주는 기본 도구예요.'),
                                                                                                          (36, '인터넷 & 네트워크', 16, 'BE', 'Y', 2, 'HTTP, HTTPS, DNS, TCP/IP 기본 개념이란? 인터넷이 어떻게 작동하는지를 이해하는 데 꼭 필요한 핵심 네트워크 개념들이에요! HTTP/HTTPS는 웹에서 정보를 주고받는 방식이고, DNS는 사람이 기억하기 쉬운 주소(도메인)를 숫자 IP로 바꿔주는 시스템이며, TCP/IP는 데이터가 안전하고 정확하게 목적지에 도착하도록 돕는 전달 규칙이에요. 예를 들면, 브라우저에 주소를 입력하면 DNS가 서버를 찾아주고, HTTP가 서버에 요청을 보내고, TCP/IP가 그 데이터를 안정적으로 전달해줘요. 마치 우편 주소를 찾아 편지를 보내고, 정확히 배달되는 전체 과정처럼, 웹과 앱이 원활하게 통신할 수 있도록 돕는 기본 원리들이에요.'),
                                                                                                          (37, 'Git & GitHub', 2, 'BE', 'Y', 3, 'Git & GitHub란? 코드를 안전하게 관리하고, 함께 작업할 수 있게 해주는 도구! 코드를 버전별로 저장하고, 이전 상태로 되돌리거나 여러 사람이 동시에 작업해도 충돌 없이 관리할 수 있어요. 예를 들면, 실수로 코드를 잘못 고쳐도 이전 상태로 복원할 수 있고, 팀원이 만든 기능을 병합하거나 비교할 수도 있어요. Git은 버전 관리 시스템, GitHub는 이 Git 저장소를 인터넷에 저장하고 협업할 수 있게 해주는 서비스라고 생각하면 돼요.'),
                                                                                                          (38, 'Git Hook 자동화', 2, 'BE', 'Y', 4, 'Git Hook (Husky, lint-staged) 자동화란?코드 저장 전에 자동으로 검사하거나 정리해주는 도구!커밋하거나 푸시할 때, 코드 스타일을 체크하거나 테스트를 실행해서실수나 버그를 미리 막아주는 역할을 해요.예를 들면, 커밋 전에 코드 포맷을 자동으로 맞추거나,오류가 있는 코드는 커밋되지 않도록 차단할 수 있어요.마치 택배를 보내기 전에 포장 상태를 검사하는 것처럼,코드를 안전하게 관리하고 팀의 품질 기준을 지킬 수 있도록 도와주는 도구예요.'),
                                                                                                          (39, 'Java', 17, 'BE', 'N', 5, 'Java란? 안정적이고 확장성 있는 프로그램을 만들 수 있는 대표적인 객체지향 프로그래밍 언어! 운영체제에 상관없이 어디서나 실행할 수 있고, 대규모 시스템부터 모바일 앱, 웹 서비스, 서버 개발까지 폭넓게 사용돼요. 예를 들면, 은행의 거래 시스템, 안드로이드 앱, 기업용 백엔드 서버 등이 Java로 만들어져요. 마치 한 번 만들면 어디서든 쓸 수 있는 범용 기계처럼, 신뢰성과 이식성이 뛰어난 실무 중심의 프로그래밍 언어예요.'),
                                                                                                          (40, 'Python', 18, 'BE', 'N', 6, 'Python이란? 간결하고 읽기 쉬운 문법으로 다양한 분야에서 활용되는 범용 프로그래밍 언어! 웹 개발, 데이터 분석, 인공지능, 자동화 스크립트 등 다양한 목적에 맞게 빠르게 개발할 수 있어요. 예를 들면, 웹 서버를 만들거나, 엑셀 데이터를 처리하거나, AI 모델을 학습시키는 작업도 Python으로 할 수 있어요. 마치 쉽고 유연한 만능 도구처럼, 입문자부터 전문가까지 널리 사용하는 실용적인 프로그래밍 언어예요.'),
                                                                                                          (41, 'JavaScript', 19, 'BE', 'N', 7, 'JavaScript란? 웹페이지에 동작을 추가하고 사용자와의 상호작용을 가능하게 해주는 프로그래밍 언어! 클릭, 입력, 스크롤 같은 이벤트에 반응하거나 화면의 내용을 동적으로 바꾸는 기능을 구현할 수 있어요. 예를 들면, 버튼을 눌렀을 때 팝업이 뜨거나, 실시간으로 입력값을 확인하고 결과를 보여줄 수 있어요. 마치 정적인 화면에 생명을 불어넣는 조종 장치처럼, 웹을 더 풍부하고 인터랙티브하게 만들어주는 핵심 기술이에요.'),
                                                                                                          (42, 'Kotlin', 20, 'BE', 'N', 8, 'Kotlin이란? 간결하면서도 안정적인 코드를 작성할 수 있게 해주는 현대적인 프로그래밍 언어! Java보다 적은 코드로 동일한 기능을 구현할 수 있고, 안드로이드 앱 개발을 비롯해 서버, 웹, 데스크탑 등 다양한 분야에서 사용돼요. 예를 들면, 앱의 버튼 클릭 동작을 쉽게 구현하거나, 안전한 방식으로 null 값을 처리할 수 있어요. 마치 사용하기 편하면서도 강력한 기능이 담긴 도구 상자처럼, 생산성과 안정성을 모두 갖춘 실용적인 프로그래밍 언어예요.'),
                                                                                                          (43, 'SQL문', 21, 'BE', 'Y', 9, 'SQL문이란? 데이터베이스에 저장된 정보를 조회하고 수정할 수 있게 해주는 데이터 처리 언어! 데이터를 추가하거나 검색하고, 변경하거나 삭제하는 작업을 명령문 한 줄로 빠르고 정확하게 실행할 수 있어요. 예를 들면, 회원 목록을 불러오거나, 특정 조건에 맞는 데이터를 찾고, 필요한 내용을 새로 추가하거나 삭제할 수도 있어요. 마치 창고 안의 정보를 검색하고 정리하는 명령어 세트처럼, 데이터를 다루는 데 꼭 필요한 기본 도구예요.'),
                                                                                                          (44, 'More About Database', 22, 'BE', 'N', 10, 'More About Database란? 다양한 형태의 데이터베이스 구조와 특성을 이해하고, 상황에 맞게 선택할 수 있도록 돕는 개념이에요! 관계형 데이터베이스(RDB)는 표 형식으로 데이터를 저장하고 SQL로 관리하며, NoSQL은 유연한 구조로 대규모 데이터나 빠른 처리에 적합한 방식이에요. 예를 들면, MySQL, PostgreSQL 같은 RDB는 정형 데이터를 정확하게 관리할 때, MongoDB, Redis 같은 NoSQL은 유동적인 데이터나 실시간 처리에 자주 사용돼요. 마치 서류 캐비닛처럼 정리된 방식과, 메모장처럼 자유로운 방식을 모두 이해하는 것처럼, 데이터의 성격과 목적에 따라 적절한 저장 방식을 선택하는 데 필요한 핵심 지식이에요.'),
                                                                                                          (45, 'Scaling Databases', 23, 'BE', 'N', 11, 'Scaling Databases란? 많은 데이터를 빠르고 안정적으로 처리하기 위해 데이터베이스를 최적화하는 방법이에요! 쿼리 튜닝은 느린 쿼리를 분석하고 개선해서 성능을 높이는 작업이고, 정규화는 데이터를 구조적으로 나눠 중복을 줄이고 일관성을 유지하는 방식이에요. 예를 들면, 느린 검색 속도를 개선하거나, 하나의 테이블을 여러 개로 나눠 효율적으로 관리할 수 있어요. 마치 창고의 물건을 빠르게 찾기 위해 선반을 정리하고 동선을 최적화하는 것처럼, 데이터를 효과적으로 저장하고 처리하기 위한 필수적인 설계와 운영 기술이에요.'),
                                                                                                          (46, 'Spring Boot(Java)', 24, 'BE', 'N', 12, 'Java & Spring이란? 견고하고 확장성 있는 백엔드 애플리케이션을 만들기 위한 대표적인 기술 조합이에요! Java는 안정성과 범용성이 뛰어난 프로그래밍 언어이고, Spring은 Java 기반으로 웹 서버, API, 데이터 처리 등을 효율적으로 구성할 수 있게 도와주는 프레임워크예요. 예를 들면, 회원가입 기능이나 데이터베이스 연동, API 서버 구축을 안정적으로 구현할 수 있어요. 마치 튼튼한 재료(Java) 위에 체계적인 설계도(Spring)를 얹는 건축처럼, 기업에서도 널리 사용하는 신뢰도 높은 백엔드 개발 기술이에요.'),
                                                                                                          (47, 'Node.js & Express.js', 25, 'BE', 'N', 13, 'Node.js란? JavaScript로 서버를 만들 수 있게 해주는 런타임 환경이에요! 비동기 처리와 이벤트 기반 구조 덕분에 가볍고 빠르게 동작하며, 웹 서버, API, 실시간 채팅, 파일 처리 등 다양한 백엔드 기능을 구현할 수 있어요. 예를 들면, 웹사이트의 로그인 처리나 데이터 전송 API, 실시간 메시징 기능 같은 서버 역할을 JavaScript로 만들 수 있어요. 마치 한 가지 언어로 프론트엔드와 백엔드를 모두 다룰 수 있는 멀티툴처럼, 유연하고 효율적인 웹 서비스 구축에 적합한 서버 사이드 기술이에요.'),
                                                                                                          (48, 'Django', 26, 'BE', 'N', 14, 'Django란? 빠르고 효율적으로 웹 애플리케이션을 만들 수 있게 도와주는 Python 기반의 웹 프레임워크예요! 프로젝트 구조, 관리자 페이지, 인증 시스템 같은 기능이 기본으로 포함돼 있어서 복잡한 웹 서비스를 빠르게 개발할 수 있어요. 예를 들면, 게시판, 블로그, 쇼핑몰처럼 로그인, 글쓰기, 데이터 저장이 필요한 웹사이트를 쉽게 만들 수 있어요. 마치 필수 도구가 다 갖춰진 웹 개발용 공구 세트처럼, 안정적이고 생산성 높은 백엔드 웹 개발을 가능하게 해주는 프레임워크예요.'),
                                                                                                          (49, 'Flask', 27, 'BE', 'N', 15, 'Flask란? 가볍고 유연하게 웹 애플리케이션을 만들 수 있는 Python 기반의 마이크로 웹 프레임워크예요! 필수 기능만 최소한으로 제공하고, 필요한 구성은 개발자가 자유롭게 선택해서 확장할 수 있어요. 예를 들면, 간단한 웹 페이지부터 API 서버, 데이터 시각화 도구까지 작고 빠르게 시작해서 점점 발전시켜 나갈 수 있어요. 마치 필요한 부품만 골라 조립할 수 있는 맞춤형 키트처럼, 단순하지만 강력하게 웹 서비스를 만들 수 있는 실용적인 프레임워크예요.'),
                                                                                                          (50, 'Spring Boot(Kotlin)', 28, 'BE', 'N', 16, 'Kotlin & Spring이란? 간결한 문법의 Kotlin 언어로, 강력한 Spring 프레임워크 기반의 백엔드 애플리케이션을 만드는 기술 조합이에요! Kotlin은 안정성과 생산성이 뛰어나고, Spring은 다양한 웹 기능을 체계적으로 제공해요. 두 기술이 만나면 더 짧고 명확한 코드로 효율적인 서버 개발이 가능해요. 예를 들면, API 서버 구축, 데이터베이스 연결, 인증 시스템 구현 등을 더 읽기 쉬운 코드로 빠르게 만들 수 있어요. 마치 스마트한 언어와 견고한 설계가 결합된 개발 환경처럼, 안정성과 개발 속도를 모두 잡고 싶은 백엔드 개발자에게 최적의 조합이에요.'),
                                                                                                          (51, 'Java + Spring Lib & Utils', 29, 'BE', 'N', 17, 'Spring 라이브러리 & 유틸이란? 복잡한 웹 애플리케이션을 더 쉽게 만들 수 있도록 도와주는 Spring의 구성 요소와 도구들이에요! 보안, 데이터 처리, 배치 작업 등 다양한 기능을 담당하는 라이브러리들이 Spring 생태계 안에 잘 정리되어 있고, 개발자가 필요한 기능만 선택해 사용할 수 있어요. 예를 들면, Spring Security로 로그인과 권한을 관리하고, Spring Data JPA로 복잡한 SQL 없이 DB를 다루며, Spring Batch로 대용량 데이터를 순차적으로 처리할 수 있어요. 마치 전문 공정별로 나뉜 자동화 도구 세트처럼, 웹 서비스의 복잡한 요구사항을 손쉽게 해결할 수 있도록 도와주는 실전 중심의 유틸 모음이에요.'),
                                                                                                          (52, 'Kotlin + Spring Lib & Utils', 30, 'BE', 'N', 18, 'Spring 라이브러리 & 유틸이란? 웹 애플리케이션을 더 강력하고 효율적으로 만들 수 있도록 도와주는 Spring의 확장 도구 모음이에요! 보안, 데이터 관리, 배치 처리, 메시지 큐 연동 등 복잡한 기능들을 쉽게 구현할 수 있는 다양한 라이브러리와 유틸리티가 포함돼 있어요. 예를 들면, Spring Security로 인증과 권한을 설정하고, Spring Data JPA로 데이터베이스와 편리하게 연결하며, Spring Batch로 정기적인 데이터 처리 작업을 자동화할 수 있어요. 마치 다양한 기능을 플러그처럼 추가할 수 있는 개발 키트처럼, 복잡한 웹 시스템을 간단하고 일관된 방식으로 개발할 수 있도록 도와주는 도구들이에요.'),
                                                                                                          (53, 'Java,Kotlin + Spring 운영 & 배포', 31, 'BE', 'N', 19, 'Java, Kotlin + Spring 운영 & 배포란? Spring으로 만든 웹 애플리케이션을 실제 서비스 환경에 올리고, 안정적으로 관리하는 방법이에요! 빌드, 설정, 서버 배포, 로깅, 모니터링 같은 운영 전반의 과정과 Java 또는 Kotlin 코드 기반에서 효율적인 실행 환경을 구성하는 내용을 다뤄요. 예를 들면, 애플리케이션을 Docker로 감싸서 배포하거나, 서버에서 환경변수 설정, 무중단 배포, 장애 대응 방법까지 실무 중심으로 관리할 수 있어요. 마치 완성된 제품을 고객에게 전달하고 유지 관리하는 전 과정처럼, 개발된 서비스를 실제로 운영하며 신뢰성 있게 제공하기 위한 핵심 실무 과정이에요.'),
                                                                                                          (54, 'Node.js Lib & Utils', 32, 'BE', 'N', 20, 'Node.js 라이브러리 & 유틸이란? 백엔드 개발을 더 빠르고 효율적으로 도와주는 Node.js의 필수 도구와 유틸리티 모음이에요! 서버 구축, 파일 처리, 인증, 데이터 검증, 로깅 등 반복되는 기능을 간단하게 구현할 수 있도록 도와주는 다양한 라이브러리를 활용할 수 있어요. 예를 들면, Express로 간단한 웹 서버를 만들고, Multer로 파일 업로드를 처리하거나, jsonwebtoken으로 로그인 인증을 구현할 수 있어요. 마치 자주 쓰는 부품을 모아둔 공구 세트처럼, Node.js 프로젝트를 더 간결하고 실용적으로 완성할 수 있게 해주는 핵심 도구들이에요.'),
                                                                                                          (55, 'Node.js 운영 & 배포', 32, 'BE', 'N', 21, 'Node.js 운영 & 배포란? Node.js로 만든 서버 애플리케이션을 실제 환경에서 실행하고 안정적으로 서비스하는 방법이에요! 프로세스 관리, 환경 설정, 배포 자동화, 로깅, 에러 대응 등 앱이 끊김 없이 잘 작동하도록 뒷단에서 돌보는 모든 운영 작업을 다뤄요. 예를 들면, PM2로 서버를 항상 켜두거나, Docker로 패키징해서 배포하고, CI/CD로 코드 변경을 자동 반영할 수 있어요. 마치 서비스를 매끄럽게 유지하는 무대 뒤 기술팀처럼, Node.js 앱을 실제 사용자에게 안정적으로 제공하기 위한 실무 중심의 기술이에요.'),
                                                                                                          (56, 'Django Lib & Utils', 33, 'BE', 'N', 22, 'Django 라이브러리 & 유틸이란? Django 개발을 더 빠르고 편리하게 만들어주는 확장 도구와 유용한 패키지들의 모음이에요! 인증, 권한 관리, 파일 업로드, API 구축, 시간 처리 등 웹 개발에서 자주 쓰이는 기능들을 쉽게 구현할 수 있도록 도와줘요. 예를 들면, Django REST framework로 API 서버를 만들고, django-allauth로 소셜 로그인 기능을 추가하거나, django-environ으로 환경변수를 깔끔하게 관리할 수 있어요. 마치 자주 쓰는 기능들을 미리 조립해둔 보조 키트처럼, Django 프로젝트를 더 강력하고 효율적으로 완성할 수 있도록 도와주는 도구들이에요.'),
                                                                                                          (57, 'Django 운영 & 배포', 33, 'BE', 'N', 23, 'Django 운영 & 배포란? Django로 만든 웹 애플리케이션을 실제 서버에 배포하고 안정적으로 운영하는 방법이에요! 서버 환경 구성, 보안 설정, 데이터베이스 연결, 로그 관리, 배포 자동화 등 서비스를 사용자에게 문제없이 제공하기 위한 실전 기술들을 다뤄요. 예를 들면, Gunicorn과 Nginx를 함께 사용해 앱을 배포하거나, 환경변수 설정, 정적 파일 처리, CI/CD 파이프라인 구성 등을 수행할 수 있어요. 마치 개발된 웹서비스를 무대 위에 올려 안전하게 공연하는 운영팀처럼, Django 프로젝트를 실서비스로 전환하고 안정적으로 유지하는 데 필요한 핵심 과정이에요.'),
                                                                                                          (58, 'Flask Lib & Utils', 34, 'BE', 'N', 24, 'Flask 라이브러리 & 유틸이란? Flask 개발을 더 빠르고 확장성 있게 만들어주는 다양한 도구와 확장 패키지들의 모음이에요! ORM, 인증, 폼 처리, REST API 구축, 환경 설정 등 기본 Flask 위에 필요한 기능을 유연하게 붙일 수 있어요. 예를 들면, Flask-SQLAlchemy로 데이터베이스를 다루고, Flask-Login으로 사용자 인증을 구현하거나, Flask-Migrate로 DB 변경 사항을 관리할 수 있어요. 마치 심플한 프레임워크를 확장 가능한 플랫폼으로 바꿔주는 조립 부품들처럼, 작고 유연한 Flask 프로젝트를 실전 서비스 수준으로 키워주는 실용적인 도구들이에요.'),
                                                                                                          (59, 'Flask 운영 & 배포', 34, 'BE', 'N', 25, 'Flask 운영 & 배포란? Flask로 만든 웹 애플리케이션을 실제 서버에 올리고 안정적으로 서비스하는 방법이에요! 서버 설정, 프로세스 관리, 정적 파일 처리, 환경변수 구성, 배포 자동화 등을 통해 Flask 앱을 실사용 환경에서 안전하게 운영할 수 있어요. 예를 들면, Gunicorn으로 애플리케이션을 실행하고, Nginx를 통해 외부 요청을 받아 전달하며, Docker나 CI/CD로 배포 작업을 자동화할 수 있어요. 마치 간단한 웹 앱을 실제 제품으로 포장하고 고객에게 전달하는 과정처럼, Flask 프로젝트를 실서비스 수준으로 끌어올리기 위한 핵심 운영 기술이에요.');

-- chapter(단원) 정보 주입
INSERT INTO chapter (chapter_id, chapter_nm, chapter_order, sub_id) VALUES
                                                                        (1, '기본 구조와 시맨틱 태그', 1, 1),
                                                                        (2, '텍스트 & 목록 요소', 2, 1),
                                                                        (3, '이미지·멀티미디어 & IFrame', 3, 1),
                                                                        (4, '폼 & 입력 요소', 4, 1),
                                                                        (5, '테이블·메타데이터 & 접근성', 5, 1),
                                                                        (6, '선택자 & 우선순위', 1, 2),
                                                                        (7, '박스 모델 & 배치', 2, 2),
                                                                        (8, 'Flexbox · Grid 레이아웃', 3, 2),
                                                                        (9, '색상·타이포그래피·배경', 4, 2),
                                                                        (10, '애니메이션·전환·반응형 디자인', 5, 2),
                                                                        (11, '기초 문법과 데이터 타입', 1, 3),
                                                                        (12, '조건문과 반복문', 2, 3),
                                                                        (13, '함수와 스코프', 3, 3),
                                                                        (14, '배열과 객체', 4, 3),
                                                                        (15, 'DOM 조작과 이벤트 처리', 5, 3),
                                                                        (16, '기본 타입 · 타입 단언 & 타입 추론', 1, 4),
                                                                        (17, '함수 · 제네릭 & 오버로드', 2, 4),
                                                                        (18, '인터페이스 · 타입 별칭 & 고급 타입', 3, 4),
                                                                        (19, '클래스 · 모듈 · 데코레이터 & 접근 제한자', 4, 4),
                                                                        (20, '고급 제네릭 · 조건부 타입 & 유틸리티 타입', 5, 4),
                                                                        (21, 'Virtual DOM 원리 & 역사', 1, 5),
                                                                        (22, 'Diff 알고리즘 & 키의 역할', 2, 5),
                                                                        (23, '리컨실리에이션(재조정) 사이클', 3, 5),
                                                                        (24, '실제 DOM 패치(Patching) 최적화', 4, 5),
                                                                        (25, '한계·대안 & 최신 동향', 5, 5),
                                                                        (26, 'Git 기본 개념과 설치', 1, 6),
                                                                        (27, '로컬 저장소 관리', 2, 6),
                                                                        (28, '브랜치와 병합 전략', 3, 6),
                                                                        (29, 'GitHub와 원격 저장소 활용', 4, 6),
                                                                        (30, '협업, PR, 이슈 및 고급 기능', 5, 6),
                                                                        (31, 'Git Hook 기본 개념', 1, 7),
                                                                        (32, 'Husky 소개와 설치', 2, 7),
                                                                        (33, 'Husky로 Git Hook 제어하기', 3, 7),
                                                                        (34, 'lint-staged 소개와 활용', 4, 7),
                                                                        (35, 'Husky + lint-staged 통합 자동화 실습', 5, 7),
                                                                        (36, 'Axios 인스턴스 기초 & 환경별 설정', 1, 8),
                                                                        (37, '전역 Request 인터셉터 구성', 2, 8),
                                                                        (38, '전역 Response 인터셉터 구성', 3, 8),
                                                                        (39, '토큰 자동 갱신 & 충돌 방지 패턴', 4, 8),
                                                                        (40, '고급 패턴·유틸리티화 & 테스트', 5, 8),
                                                                        (41, '에러 모델 설계 & 표준 HTTP 상태 코드', 1, 9),
                                                                        (42, '클라이언트-측 에러 분류 & 처리 전략', 2, 9),
                                                                        (43, '재시도 기본 전략 & 안전한 멱등성', 3, 9),
                                                                        (44, '고급 재시도 관리(회로 차단·폴리시)', 4, 9),
                                                                        (45, '관측·테스트 & 운영 베스트 프랙티스', 5, 9),
                                                                        (46, 'JSX 및 컴포넌트 기초', 1, 10),
                                                                        (47, 'Props와 State', 2, 10),
                                                                        (48, '이벤트 처리와 조건부 렌더링', 3, 10),
                                                                        (49, '리스트 렌더링과 키', 4, 10),
                                                                        (50, 'Hooks 및 고급 컴포넌트 구성', 5, 10),
                                                                        (51, 'Redux 기본 개념', 1, 11),
                                                                        (52, '액션과 리듀서', 2, 11),
                                                                        (53, '스토어와 상태 관리', 3, 11),
                                                                        (54, '미들웨어와 비동기 처리', 4, 11),
                                                                        (55, 'Redux Toolkit', 5, 11),
                                                                        (56, 'Zustand 기본 개념과 설치', 1, 12),
                                                                        (57, '상태 생성 및 구독 (get, set)', 2, 12),
                                                                        (58, 'store 분리 및 커스텀 훅 패턴', 3, 12),
                                                                        (59, '미들웨어 활용 (persist, devtools 등)', 4, 12),
                                                                        (60, 'Zustand 실전 예제 및 성능 최적화', 5, 12),
                                                                        (61, '템플릿 구문 & 인스턴스 기초', 1, 13),
                                                                        (62, '반응형 시스템', 2, 13),
                                                                        (63, '디렉티브 & 라이프사이클 훅', 3, 13),
                                                                        (64, '컴포넌트·Props·슬롯', 4, 13),
                                                                        (65, '라우팅·상태 관리 & Composition API', 5, 13),
                                                                        (66, 'Vuex 기본 개념', 1, 14),
                                                                        (67, 'State, Getters, Mutations', 2, 14),
                                                                        (68, 'Actions와 비동기 처리', 3, 14),
                                                                        (69, 'Pinia 기본 사용법', 4, 14),
                                                                        (70, 'Pinia와 Vue 생태계 통합', 5, 14),
                                                                        (71, '템플릿 구문 & 인스턴스 기초', 1, 15),
                                                                        (72, '반응형 시스템', 2, 15),
                                                                        (73, '디렉티브 & 라이프사이클 훅', 3, 15),
                                                                        (74, '컴포넌트·Props·슬롯', 4, 15),
                                                                        (75, '라우팅·상태 관리 & Composition API', 5, 15),
                                                                        (76, 'NgRx 기본 개념', 1, 16),
                                                                        (77, 'State, Actions, Reducers', 2, 16),
                                                                        (78, 'Effects와 비동기 처리', 3, 16),
                                                                        (79, 'Selectors와 Store 접근', 4, 16),
                                                                        (80, 'NgRx Entity와 고급 기능', 5, 16),
                                                                        (81, '디자인 시스템 기초와 Atomic Design', 1, 17),
                                                                        (82, 'Storybook 기본 설정과 사용법', 2, 17),
                                                                        (83, 'Args, Controls, Docs를 활용한 컴포넌트 문서화', 3, 17),
                                                                        (84, '컴포넌트 테스트 및 접근성 검증', 4, 17),
                                                                        (85, '디자인 시스템 확장 전략과 협업 방식', 5, 17),
                                                                        (86, 'Tailwind 기본 문법과 구성요소', 1, 18),
                                                                        (87, '레이아웃과 Flex/Grid 활용', 2, 18),
                                                                        (88, '반응형 디자인과 상태 기반 클래스', 3, 18),
                                                                        (89, 'Tailwind 구성 및 커스터마이징', 4, 18),
                                                                        (90, '프로젝트 설계 및 실전 적용 전략', 5, 18),
                                                                        (91, 'SCSS 기본 문법과 변수 사용', 1, 19),
                                                                        (92, 'Mixin, Function, Extend', 2, 19),
                                                                        (93, '조건문과 반복문', 3, 19),
                                                                        (94, 'SCSS 모듈화 및 import', 4, 19),
                                                                        (95, 'SCSS를 활용한 프로젝트 구조 설계', 5, 19),
                                                                        (96, '선택자 & 우선순위', 1, 20),
                                                                        (97, '박스 모델 & 레이아웃', 2, 20),
                                                                        (98, 'Flexbox & Grid', 3, 20),
                                                                        (99, '반응형 디자인 & 미디어 쿼리', 4, 20),
                                                                        (100, '애니메이션 & 트랜지션', 5, 20),
                                                                        (101, 'ESLint 기본 개념과 설치', 1, 21),
                                                                        (102, 'ESLint 규칙과 설정 파일', 2, 21),
                                                                        (103, 'Prettier 기본 개념과 포맷팅', 3, 21),
                                                                        (104, 'ESLint와 Prettier 통합 설정', 4, 21),
                                                                        (105, '실제 적용 및 커스텀 규칙 작성', 5, 21),
                                                                        (106, 'Next.js 기본 개념과 프로젝트 설정', 1, 22),
                                                                        (107, '라우팅과 네비게이션', 2, 22),
                                                                        (108, '데이터 페칭과 렌더링 방식', 3, 22),
                                                                        (109, 'API Routes와 서버 기능', 4, 22),
                                                                        (110, 'Next.js 고급 기능 및 최적화', 5, 22),
                                                                        (111, '렌더링 비용 이해 & 불필요한 리렌더 탐지', 1, 23),
                                                                        (112, 'React.memo 로 컴포넌트 메모이제이션', 2, 23),
                                                                        (113, '계산 값 캐싱 — useMemo', 3, 23),
                                                                        (114, '콜백 재생성 방지 — useCallback', 4, 23),
                                                                        (115, '실전 튜닝 & 측정', 5, 23),
                                                                        (116, 'Query Keys & 캐싱 기본', 1, 24),
                                                                        (117, 'Prefetch & 백그라운드 업데이트', 2, 24),
                                                                        (118, 'Mutations & 캐시 무효화', 3, 24),
                                                                        (119, '고급 Query Key 패턴', 4, 24),
                                                                        (120, '성능 튜닝 & 테스트', 5, 24),
                                                                        (121, 'Vue Test Utils 기본 개념', 1, 25),
                                                                        (122, 'Mount와 ShallowMount', 2, 25),
                                                                        (123, '컴포넌트 상호작용 테스트', 3, 25),
                                                                        (124, '비동기 및 이벤트 테스트', 4, 25),
                                                                        (125, 'Mock, Stub, 플러그인 테스트', 5, 25),
                                                                        (126, 'Nuxt.js 기본 구조 및 라우팅', 1, 26),
                                                                        (127, '페이지 및 레이아웃', 2, 26),
                                                                        (128, '상태 관리와 Vuex', 3, 26),
                                                                        (129, '비동기 데이터 처리와 API 연동', 4, 26),
                                                                        (130, 'Nuxt.js 고급 기능과 배포', 5, 26),
                                                                        (131, 'Angular Universal 기본 개념', 1, 27),
                                                                        (132, 'SSR 설정 및 빌드', 2, 27),
                                                                        (133, '서버 측 렌더링 흐름 이해', 3, 27),
                                                                        (134, '라우팅과 데이터 프리페칭', 4, 27),
                                                                        (135, '고급 최적화 및 배포 전략', 5, 27),
                                                                        (136, 'Jasmine 기본 개념', 1, 28),
                                                                        (137, 'Matchers와 테스트 구조', 2, 28),
                                                                        (138, '비동기 테스트', 3, 28),
                                                                        (139, '스파이(Spy)와 Mock', 4, 28),
                                                                        (140, 'Angular 테스트 통합', 5, 28),
                                                                        (141, 'Webpack의 동작 원리와 핵심 개념', 1, 29),
                                                                        (142, '기본 설정 파일 작성 (webpack.config.js)', 2, 29),
                                                                        (143, '로더(Loader) 개념과 적용', 3, 29),
                                                                        (144, '플러그인(Plugin) 개념과 활용', 4, 29),
                                                                        (145, '최적화와 개발 서버 설정', 5, 29),
                                                                        (146, 'GitHub Actions 기본 개념', 1, 30),
                                                                        (147, 'Workflow 트리거와 조건 설정', 2, 30),
                                                                        (148, 'Job & Step 구성 및 실행 환경', 3, 30),
                                                                        (149, 'CI/CD 구축 실전 - 빌드 & 테스트', 4, 30),
                                                                        (150, 'CD 실전 - 배포 자동화 & 시크릿 관리', 5, 30),
                                                                        (151, '프론트엔드 정적 빌드 이해', 1, 31),
                                                                        (152, 'Docker 기본 및 이미지 생성', 2, 31),
                                                                        (153, 'Nginx 설정 및 정적 파일 서빙', 3, 31),
                                                                        (154, 'Docker Compose 및 포트 연결', 4, 31),
                                                                        (155, '클라우드/서버 환경 배포 전략', 5, 31),
                                                                        (156, 'S3 버킷 생성 및 정적 웹사이트 호스팅', 1, 32),
                                                                        (157, 'CloudFront 배포 생성 및 연결', 2, 32),
                                                                        (158, '정적 자산 업로드 및 캐싱 전략', 3, 32),
                                                                        (159, '도메인 연결 및 HTTPS 설정', 4, 32),
                                                                        (160, '배포 자동화 및 CI/CD 연동', 5, 32),
                                                                        (161, '테스트 기본 개념 & 종류', 1, 33),
                                                                        (162, 'Unit Test 실전 – 로직 & 함수 테스트', 2, 33),
                                                                        (163, 'React 컴포넌트 테스트', 3, 33),
                                                                        (164, 'Snapshot Test & Mock 전략', 4, 33),
                                                                        (165, 'Integration Test & 실전 패턴', 5, 33),
                                                                        (166, 'E2E 테스트 개요 & 자동화 흐름 이해', 1, 34),
                                                                        (167, 'Cypress 실습 – 기본 명령어 & 흐름 구성', 2, 34),
                                                                        (168, '고급 E2E 전략 – 인증, 라우팅, 상태 검증', 3, 34),
                                                                        (169, 'Visual Regression Test 원리 & 도구', 4, 34),
                                                                        (170, 'E2E + VRT 통합 테스트 전략', 5, 34),
                                                                        (171, '기본 명령어와 파일 시스템', 1, 35),
                                                                        (172, '사용자와 권한 관리', 2, 35),
                                                                        (173, '프로세스와 작업 관리', 3, 35),
                                                                        (174, '패키지 및 소프트웨어 설치', 4, 35),
                                                                        (175, '시스템 관리와 로그 분석', 5, 35),
                                                                        (176, '네트워크 기본 개념', 1, 36),
                                                                        (177, 'IP 주소와 서브넷', 2, 36),
                                                                        (178, 'HTTP와 HTTPS', 3, 36),
                                                                        (179, 'DNS와 도메인', 4, 36),
                                                                        (180, '웹 보안 및 인증', 5, 36),
                                                                        (181, 'Git 기본 개념과 설치', 1, 37),
                                                                        (182, '로컬 저장소 관리', 2, 37),
                                                                        (183, '브랜치와 병합 전략', 3, 37),
                                                                        (184, 'GitHub와 원격 저장소 활용', 4, 37),
                                                                        (185, '협업, PR, 이슈 및 고급 기능', 5, 37),
                                                                        (186, 'Git Hook 기본 개념', 1, 38),
                                                                        (187, 'Husky 소개와 설치', 2, 38),
                                                                        (188, 'Husky로 Git Hook 제어하기', 3, 38),
                                                                        (189, 'lint-staged 소개와 활용', 4, 38),
                                                                        (190, 'Husky + lint-staged 통합 자동화 실습', 5, 38),
                                                                        (191, '기초 문법과 자료형', 1, 39),
                                                                        (192, '제어문과 반복문', 2, 39),
                                                                        (193, '객체 지향 프로그래밍', 3, 39),
                                                                        (194, '컬렉션과 제네릭', 4, 39),
                                                                        (195, '예외 처리와 파일 I/O', 5, 39),
                                                                        (196, '기초 문법과 자료형', 1, 40),
                                                                        (197, '조건문과 반복문', 2, 40),
                                                                        (198, '함수와 모듈', 3, 40),
                                                                        (199, '자료구조 (리스트, 튜플, 딕셔너리, 세트)', 4, 40),
                                                                        (200, '파일 입출력과 예외 처리', 5, 40),
                                                                        (201, '기초 문법과 데이터 타입', 1, 41),
                                                                        (202, '조건문과 반복문', 2, 41),
                                                                        (203, '함수와 스코프', 3, 41),
                                                                        (204, '배열과 객체', 4, 41),
                                                                        (205, 'DOM 조작과 이벤트 처리', 5, 41),
                                                                        (206, '기초 문법과 변수', 1, 42),
                                                                        (207, '조건문과 반복문', 2, 42),
                                                                        (208, '함수와 람다', 3, 42),
                                                                        (209, '클래스와 객체', 4, 42),
                                                                        (210, '컬렉션과 널 안정성', 5, 42),
                                                                        (211, '기본 SELECT 및 조건절', 1, 43),
                                                                        (212, '집계 함수 및 그룹핑', 2, 43),
                                                                        (213, 'JOIN 및 서브쿼리', 3, 43),
                                                                        (214, 'DDL/DML/제약 조건', 4, 43),
                                                                        (215, '트랜잭션 & 고급 기능', 5, 43),
                                                                        (216, 'RDB 기초 개념', 1, 44),
                                                                        (217, 'RDB 종류와 특징', 2, 44),
                                                                        (218, 'NoSQL 개요 및 분류', 3, 44),
                                                                        (219, 'NoSQL 대표 사례', 4, 44),
                                                                        (220, '상황에 맞는 DB 선택 전략', 5, 44),
                                                                        (221, 'SQL 성능 이해', 1, 45),
                                                                        (222, '인덱스와 데이터 접근 방식', 2, 45),
                                                                        (223, '쿼리 튜닝 전략', 3, 45),
                                                                        (224, '정규화와 비정규화', 4, 45),
                                                                        (225, '실무 성능 이슈 및 해결 사례', 5, 45),
                                                                        (226, 'Java & Spring 기초 개념 이해', 1, 46),
                                                                        (227, '계층 구조 및 실무 설계 패턴', 2, 46),
                                                                        (228, 'Spring Data JPA & 트랜잭션', 3, 46),
                                                                        (229, '인증, 보안 및 문서화 도구 활용', 4, 46),
                                                                        (230, '실전 고급 기술 & 배포 전략', 5, 46),
                                                                        (231, 'Node.js 기본 개념 및 실행 구조', 1, 47),
                                                                        (232, 'Express.js와 REST API 설계', 2, 47),
                                                                        (233, '인증, 환경 변수 및 에러 핸들링', 3, 47),
                                                                        (234, '데이터베이스 연동 및 테스트', 4, 47),
                                                                        (235, '아키텍처 설계, 확장성 및 배포 전략', 5, 47),
                                                                        (236, 'Django 기초 개념', 1, 48),
                                                                        (237, 'URL 및 뷰 처리', 2, 48),
                                                                        (238, '템플릿과 정적 파일', 3, 48),
                                                                        (239, '모델과 ORM', 4, 48),
                                                                        (240, 'DRF(REST API)', 5, 48),
                                                                        (241, 'Flask 기본 개념', 1, 49),
                                                                        (242, '라우팅과 뷰 함수', 2, 49),
                                                                        (243, '템플릿과 Jinja2', 3, 49),
                                                                        (244, 'Flask-SQLAlchemy 및 CRUD', 4, 49),
                                                                        (245, 'Flask 보안 및 배포', 5, 49),
                                                                        (246, 'Kotlin과 Spring Boot의 통합 기초', 1, 50),
                                                                        (247, 'Kotlin 스타일의 컨트롤러 & 라우팅 설계', 2, 50),
                                                                        (248, 'Kotlin 기반의 서비스 계층 설계 및 예외 처리', 3, 50),
                                                                        (249, '코틀린 JPA와 엔티티 설계 시 고려할 점', 4, 50),
                                                                        (250, '비동기 흐름과 코루틴을 활용한 API 처리', 5, 50),
                                                                        (251, 'ORM과 쿼리 매핑 도구', 1, 51),
                                                                        (252, '인증, 검증 및 시큐리티 유틸', 2, 51),
                                                                        (253, 'API 문서화 & 직렬화 도구', 3, 51),
                                                                        (254, '로깅, 캐시, 배치 처리 도구', 4, 51),
                                                                        (255, '테스트, 빌드, 개발 유틸 통합', 5, 51),
                                                                        (256, 'Kotlin 기반 ORM 및 쿼리 도구', 1, 52),
                                                                        (257, '인증, 보안 및 Validation 유틸', 2, 52),
                                                                        (258, '비동기 처리 및 웹 클라이언트 활용', 3, 52),
                                                                        (259, 'API 문서화, 로깅 및 캐시 유틸', 4, 52),
                                                                        (260, '테스트, 빌드, 배포 자동화 도구', 5, 52),
                                                                        (261, 'Spring 애플리케이션 실행 및 운영 (Jar 실행, 내장 톰캣, profile 등)', 1, 53),
                                                                        (262, '배포 환경 구성 (Docker, Nginx, Reverse Proxy, SSL 등)', 2, 53),
                                                                        (263, '환경 변수 및 설정 관리 (.env, application.yml, Spring Profile 등)', 3, 53),
                                                                        (264, 'CI/CD (GitHub Actions, DockerHub, Gradle 등)', 4, 53),
                                                                        (265, '모니터링 & 로깅 (Spring Boot Actuator, Micrometer, Prometheus, Grafana, ELK 등)', 5, 53),
                                                                        (266, 'Node.js Core Modules', 1, 54),
                                                                        (267, 'Express.js', 2, 54),
                                                                        (268, 'NPM과 모듈 시스템', 3, 54),
                                                                        (269, '비동기 처리와 이벤트 루프', 4, 54),
                                                                        (270, 'Node.js와 데이터베이스', 5, 54),
                                                                        (271, 'Node.js 프로세스 관리 (PM2 등)', 1, 55),
                                                                        (272, 'Node.js 배포 (Docker, Nginx, Reverse Proxy)', 2, 55),
                                                                        (273, '환경 변수 및 설정 관리 (.env, config 등)', 3, 55),
                                                                        (274, 'CI/CD (GitHub Actions, DockerHub 등)', 4, 55),
                                                                        (275, '모니터링 & 로깅 (Winston, Logrotate, Sentry 등)', 5, 55),
                                                                        (276, 'Django ORM과 모델 유틸', 1, 56),
                                                                        (277, '인증, 권한, 시리얼라이저 검증', 2, 56),
                                                                        (278, 'Django REST Framework 및 API 구축', 3, 56),
                                                                        (279, '캐시, 비동기 작업, 로깅 처리', 4, 56),
                                                                        (280, '테스트, 문서화 및 배포 도구 활용', 5, 56),
                                                                        (281, 'Django ORM (기본 내장)', 1, 57),
                                                                        (282, 'Django Auth, Simple JWT', 2, 57),
                                                                        (283, 'Django REST Framework (DRF)', 3, 57),
                                                                        (284, 'drf-yasg, drf-spectacular', 4, 57),
                                                                        (285, 'DRF Serializer Validation', 5, 57),
                                                                        (286, 'Flask 기본 구조 및 서버 프레임워크', 1, 58),
                                                                        (287, 'ORM 및 인증/인가 도구', 2, 58),
                                                                        (288, 'REST API 구축 및 유효성 검사', 3, 58),
                                                                        (289, '캐싱, 스케줄링, 로깅', 4, 58),
                                                                        (290, '테스트 및 배포 자동화 도구', 5, 58),
                                                                        (291, 'Flask 실행 및 운영 (Gunicorn, Waitress 등)', 1, 59),
                                                                        (292, 'Flask 배포 (Docker, Nginx)', 2, 59),
                                                                        (293, '환경 설정 (.env, Flask.config)', 3, 59),
                                                                        (294, 'CI/CD (GitHub Actions, DockerHub)', 4, 59),
                                                                        (295, '정적파일 & 모니터링 (S3, logging, Sentry, Prometheus)', 5, 59);

-- 로드맵 주입용 더미 user
INSERT INTO users(user_id, is_active, email, login_type, nickname) VALUES
    (1, 1, 'user@user.com', 'LOCAL', 'user');

-- 프론트엔드 기본 로드맵 주입
INSERT INTO roadmap_management(roadmap_management_id, roadmap_nm, user_id) VALUES
    (1, 'FE_DEFAULT_ROADMAP', 1);

INSERT INTO roadmap(roadmap_id, order_sub, sub_id, roadmap_management_id, is_complete, pre_submit_count, post_submit_count) VALUES
                                                                                                                                (1, 1, 1, 1, 0, 0, 0),
                                                                                                                                (2, 2, 2, 1, 0, 0, 0),
                                                                                                                                (3, 3, 3, 1, 0, 0, 0),
                                                                                                                                (4, 4, 4, 1, 0, 0, 0),
                                                                                                                                (5, 5, 5, 1, 0, 0, 0),
                                                                                                                                (6, 6, 6, 1, 0, 0, 0),
                                                                                                                                (7, 7, 7, 1, 0, 0, 0),
                                                                                                                                (8, 8, 8, 1, 0, 0, 0),
                                                                                                                                (9, 9, 9, 1, 0, 0, 0),
                                                                                                                                (10, 10, 10, 1, 0, 0, 0),
                                                                                                                                (11, 11, 11, 1, 0, 0, 0),
                                                                                                                                (12, 12, 12, 1, 0, 0, 0),
                                                                                                                                (13, 13, 17, 1, 0, 0, 0),
                                                                                                                                (14, 14, 18, 1, 0, 0, 0),
                                                                                                                                (15, 15, 19, 1, 0, 0, 0),
                                                                                                                                (16, 16, 20, 1, 0, 0, 0),
                                                                                                                                (17, 17, 21, 1, 0, 0, 0),
                                                                                                                                (18, 18, 22, 1, 0, 0, 0),
                                                                                                                                (19, 19, 23, 1, 0, 0, 0),
                                                                                                                                (20, 20, 24, 1, 0, 0, 0),
                                                                                                                                (21, 21, 29, 1, 0, 0, 0),
                                                                                                                                (22, 22, 30, 1, 0, 0, 0),
                                                                                                                                (23, 23, 31, 1, 0, 0, 0),
                                                                                                                                (24, 24, 32, 1, 0, 0, 0),
                                                                                                                                (25, 25, 33, 1, 0, 0, 0),
                                                                                                                                (26, 26, 34, 1, 0, 0, 0);


-- 백엔드 기본 로드맵 주입
INSERT INTO roadmap_management(roadmap_management_id, roadmap_nm, user_id) VALUES
    (2, 'BE_DEFAULT_ROADMAP', 1);

INSERT INTO roadmap(roadmap_id, order_sub, sub_id, roadmap_management_id, is_complete, pre_submit_count, post_submit_count) VALUES
                                                                                                                                (27, 1, 35, 2, 0, 0, 0),
                                                                                                                                (28, 2, 36, 2, 0, 0, 0),
                                                                                                                                (29, 3, 37, 2, 0, 0, 0),
                                                                                                                                (30, 4, 38, 2, 0, 0, 0),
                                                                                                                                (31, 5, 39, 2, 0, 0, 0),
                                                                                                                                (32, 6, 43, 2, 0, 0, 0),
                                                                                                                                (33, 7, 44, 2, 0, 0, 0),
                                                                                                                                (34, 8, 45, 2, 0, 0, 0),
                                                                                                                                (35, 9, 46, 2, 0, 0, 0),
                                                                                                                                (36, 10, 51, 2, 0, 0, 0),
                                                                                                                                (37, 11, 53, 2, 0, 0, 0);


CREATE TABLE total_content(
                              total_content_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                              content_title VARCHAR(255) NOT NULL,
                              content_url TEXT NOT NULL,
                              content_type VARCHAR(255) NOT NULL,
                              content_platform VARCHAR(255) NOT NULL,
                              content_duration VARCHAR(255) NOT NULL,
                              content_level VARCHAR(255) NOT NULL,
                              content_price VARCHAR(255) NOT NULL,
                              sub_id BIGINT NOT NULL,
                              CONSTRAINT fk_total_content_subject FOREIGN KEY (sub_id) REFERENCES subject(sub_id)
);

CREATE TABLE user_content(
                             user_content_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                             total_content_id BIGINT NOT NULL,
                             sub_id BIGINT NOT NULL,
                             user_id BIGINT NOT NULL,
                             is_ai_recommended boolean NOT NULL,
                             ai_recommend_reason TEXT NOT NULL,
                             CONSTRAINT fk_user_content_total_content FOREIGN KEY (total_content_id) REFERENCES total_content(total_content_id),
                             CONSTRAINT fk_user_content_subject FOREIGN KEY (sub_id) REFERENCES subject(sub_id),
                             CONSTRAINT fk_user_content_users FOREIGN KEY (user_id) REFERENCES users(user_id)
);

INSERT INTO total_content(total_content_id, content_title, content_url, content_type, content_platform, content_duration, content_level, content_price, sub_id) VALUES
                                                                                                                                                                    (1, '생활코딩-HTML', 'https://www.youtube.com/watch?v=tZooW6PritE&list=PLuHgQVnccGMDZP7FJ_ZsUrdCGH68ppvPb&ab_channel=%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 1),
                                                                                                                                                                    (2, 'HTML 태그 정리', 'https://www.youtube.com/watch?v=T7h8O7dpJIg&ab_channel=드림코딩', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 1),
                                                                                                                                                                    (3, 'HTML 중급 강의', 'https://m.blog.naver.com/mathesis_time/221906127872', '블로그', '블로그', 'HOUR_5', 'medium', 'FREE', 1),
                                                                                                                                                                    (4, '입문자를 위한 HTML 기초 강의', 'https://www.inflearn.com/course/%EC%9E%85%EB%AC%B8%EC%9E%90-html-%EA%B8%B0%EC%B4%88%EA%B0%95%EC%9D%98?srsltid=AfmBOooL9TdXvAkOj_uUnRnvHWUOAhYHM2jPiq_-aFslF5swlirjeGBx', '동영상', '인프런', 'HOUR_3', 'low', 'FREE', 1),
                                                                                                                                                                    (5, '코딩 자율학습 HTML + CSS + 자바스크립트', 'https://product.kyobobook.co.kr/detail/S000001834830', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 1),
                                                                                                                                                                    (6, '입문자를 위한 CSS 기초 강의', 'https://www.inflearn.com/course/입문자-css-기초강의?srsltid=AfmBOoqhLYWHIgSIuYN9L56c0YSqILc246vgsw8nGbi2y1MpHqUCoa0n', '동영상', '인프런', 'HOUR_5', 'low', 'FREE', 2),
                                                                                                                                                                    (7, 'CSS 프로그래밍 기초', 'https://dinfree.com/lecture/frontend/122_css_1.html', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 2),
                                                                                                                                                                    (8, 'WEB2 CSS - 1. 수업 소개', 'https://www.youtube.com/watch?v=Ok0bBJPtgJI&list=PLuHgQVnccGMAnWgUYiAW2cTzSBywFO75B&ab_channel=%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 2),
                                                                                                                                                                    (9, 'CSS Flexbox 완전 정리. 포트폴리오 만드는 날까지!', 'https://www.youtube.com/watch?v=7neASrWEFEM&ab_channel=드림코딩', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 2),
                                                                                                                                                                    (10, '코딩 자율학습 HTML + CSS + 자바스크립트', 'https://product.kyobobook.co.kr/detail/S000001834830', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 2),
                                                                                                                                                                    (11, '【한글자막】 CSS 완벽 가이드 (Flexbox, Grid & Sass 포함)', 'https://www.udemy.com/course/css-flexbox-grid-sass', '동영상', '유데미', 'OVER_10', 'low', 'BETWEEN_100K_200K', 2),
                                                                                                                                                                    (12, '코딩 자율학습 HTML + CSS + 자바스크립트', 'https://product.kyobobook.co.kr/detail/S000001834830', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 3),
                                                                                                                                                                    (13, '모던 자바스크립트 Deep Dive', 'https://product.kyobobook.co.kr/detail/S000001766445', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 3),
                                                                                                                                                                    (14, '바닐라 JS로 크롬 앱 만들기', 'https://nomadcoders.co/javascript-for-beginners', '동영상', '노마드코더', 'HOUR_10', 'low', 'FREE', 3),
                                                                                                                                                                    (15, 'ES6의 정석', 'https://nomadcoders.co/es6-once-and-for-all', '동영상', '노마드코더', 'HOUR_10', 'medium', 'UNDER_50K', 3),
                                                                                                                                                                    (16, 'JavaScript 입문 수업', 'https://www.youtube.com/playlist?list=PLuHgQVnccGMA4uSig3hCjl7wTDeyIeZVU', '동영상', '유튜브', 'HOUR_10', 'medium', 'FREE', 3),
                                                                                                                                                                    (17, 'JavaScript Course for Beginners – Your First Step to Web Development', 'https://www.youtube.com/watch?v=W6NZfCO5SIk&ab_channel=ProgrammingwithMosh', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 3),
                                                                                                                                                                    (18, '모던 JavaScript 튜토리얼', 'https://ko.javascript.info/', '블로그', '블로그', 'OVER_10', 'high', 'FREE', 3),
                                                                                                                                                                    (19, '견고한 JS 소프트웨어 만들기', 'https://www.inflearn.com/course/tdd-%EA%B2%AC%EA%B3%A0%ED%95%9C-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0', '동영상', '인프런', 'HOUR_3', 'medium', 'UNDER_50K', 3),
                                                                                                                                                                    (20, '타입스크립트로 블록체인 만들기', 'https://nomadcoders.co/typescript-for-beginners', '동영상', '노마드코더', 'HOUR_3', 'medium', 'FREE', 4),
                                                                                                                                                                    (21, '한 입 크기로 잘라먹는 타입스크립트', 'https://www.inflearn.com/course/한입-크기-타입스크립트', '동영상', '인프런', 'OVER_10', 'low', 'UNDER_50K', 4),
                                                                                                                                                                    (22, '타입스크립트 입문 - 기초부터 실전까지', 'https://www.inflearn.com/course/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9E%85%EB%AC%B8', '동영상', '인프런', 'HOUR_10', 'low', 'BETWEEN_50K_100K', 4),
                                                                                                                                                                    (23, '실전 프로젝트로 배우는 타입스크립트', 'https://www.inflearn.com/course/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%EC%A0%84', '동영상', '인프런', 'HOUR_10', 'high', 'BETWEEN_50K_100K', 4),
                                                                                                                                                                    (24, '[코드팩토리] [초급] 8시간만에 끝내는 코드팩토리의 Typescript 완전정복 풀코스', 'https://www.inflearn.com/course/%EC%BD%94%EB%93%9C%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%92%80%EC%BD%94%EC%8A%A4', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 4),
                                                                                                                                                                    (25, '[TypeScript 독학] #1 타입스크립트 개념 및 타입', 'https://velog.io/@bbaa3218/TypeScript-1-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%85%90-%EB%B0%8F-%ED%83%80%EC%9E%85', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 4),
                                                                                                                                                                    (26, '프로가 되기 위한 타입스크립트 프로그래밍 입문', 'https://yes24.com/product/goods/117963966', '책', 'Yes24', 'OVER_10', 'medium', 'UNDER_50K', 4),
                                                                                                                                                                    (27, 'Do it! 타입스크립트 프로그래밍', 'https://www.yes24.com/product/goods/89328106', '책', 'Yes24', 'OVER_10', 'medium', 'UNDER_50K', 4),
                                                                                                                                                                    (28, '타입스크립트로 블록체인 만들기', 'https://nomadcoders.co/typescript-for-beginners', '동영상', '노마드코더', 'HOUR_5', 'medium', 'FREE', 4),
                                                                                                                                                                    (29, '공식문서로 배우는 실전 타입스크립트', 'https://www.inflearn.com/course/%EA%B3%B5%EC%8B%9D%EB%AC%B8%EC%84%9C-%EC%8B%A4%EC%A0%84-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8', '동영상', '인프런', 'HOUR_3', 'low', 'UNDER_50K', 4),
                                                                                                                                                                    (30, '핵심만 골라 배우는 TypeScript', 'https://www.inflearn.com/course/%ED%95%B5%EC%8B%AC%EB%A7%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-tyescript', '동영상', '인프런', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 4),
                                                                                                                                                                    (31, '【한글자막】 Typescript :기초부터 실전형 프로젝트까지 with React + NodeJS', 'https://www.udemy.com/course/best-typescript-21/?srsltid=AfmBOoosvgmyQF-dC9cODGGQnG9LkhLTTC_rezgyPcbi9MIsTTZqjfyN&utm_source=chatgpt.com&couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'medium', 'BETWEEN_100K_200K', 4),
                                                                                                                                                                    (32, '【한글자막】 TypeScript 마스터 with Webpack & React', 'https://www.udemy.com/course/typescript-with-webpack-react/?srsltid=AfmBOopB0mJ8ppGCLk55jVUe1S73fwXfIk0KbxXmnIUTn_ltkUGgLzQj&utm_source=chatgpt.com&couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'medium', 'BETWEEN_100K_200K', 4),
                                                                                                                                                                    (33, 'JavaScript & TypeScript Essential', 'https://fastcampus.co.kr/dev_academy_kmt1?utm_source=chatgpt.com', '동영상', 'FASTCAMPUS', 'HOUR_5', 'low', 'UNKNOWN', 4),
                                                                                                                                                                    (34, '[리뉴얼] 타입스크립트 올인원 : Part1. 기본 문법편', 'https://www.inflearn.com/course/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%98%AC%EC%9D%B8%EC%9B%90-1', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 4),
                                                                                                                                                                    (35, '[리뉴얼] 타입스크립트 올인원 : Part2. 실전 분석편', 'https://www.inflearn.com/course/%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%98%AC%EC%9D%B8%EC%9B%90-2', '동영상', '인프런', 'HOUR_10', 'medium', 'UNDER_50K', 4),
                                                                                                                                                                    (36, 'TypeScript', 'https://edu.goorm.io/lecture/39523/생활코딩-typescript', '동영상', 'goormedu', 'HOUR_3', 'medium', 'FREE', 4),
                                                                                                                                                                    (37, '타입스크립트 핸드북', 'https://joshua1988.github.io/ts/', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 4),
                                                                                                                                                                    (38, '【한글자막】 TypeScript 마스터 with Webpack & React', 'https://www.udemy.com/course/typescript-with-webpack-react', '동영상', '유데미', 'OVER_10', 'high', 'BETWEEN_50K_100K', 4),
                                                                                                                                                                    (39, 'DOM 기본', 'https://www.inflearn.com/course/dom-%EA%B8%B0%EB%B3%B8', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 5),
                                                                                                                                                                    (40, 'React의 가상돔 (Virtual DOM)이 뭔가요? (짱 쉬움)', 'https://www.youtube.com/watch?v=gc-kXt0tjTM&ab_channel=별코딩', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 5),
                                                                                                                                                                    (41, 'DOM 인터랙션', 'https://www.inflearn.com/course/dom-%EC%99%84%EC%A0%84-%EB%81%9D%EB%82%B4%EA%B8%B0-%EC%9D%B8%ED%84%B0%EB%A0%89%EC%85%98', '동영상', '인프런', 'OVER_10', 'high', 'BETWEEN_50K_100K', 5),
                                                                                                                                                                    (42, 'Virtual DOM, 가상 돔 이란?', 'https://doqtqu.tistory.com/316#1.%20DOM(Document%20Object%20Model)', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 5),
                                                                                                                                                                    (43, 'What is the Virtual DOM in React?', 'https://www.freecodecamp.org/news/what-is-the-virtual-dom-in-react/', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 5),
                                                                                                                                                                    (44, 'DOM의 새로운 발견! Virtual DOM 동작 원리', 'https://velog.io/@sunhwa508/Virtual-DOM', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 5),
                                                                                                                                                                    (45, '제대로 파는 Git & GitHub', 'https://www.youtube.com/watch?v=1I3hMwQU6GU&ab_channel=%EC%96%84%ED%8C%8D%ED%95%9C%EC%BD%94%EB%94%A9%EC%82%AC%EC%A0%84', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 6),
                                                                                                                                                                    (46, '깃, 깃허브 제대로 배우기', 'https://www.youtube.com/watch?v=Z9dvM7qgN9s&ab_channel=%EB%93%9C%EB%A6%BC%EC%BD%94%EB%94%A9', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 6),
                                                                                                                                                                    (47, '깃 연습해보기', 'https://learngitbranching.js.org/?locale=ko', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 6),
                                                                                                                                                                    (48, '제대로 파고드는 Git & GitHub - by 얄코(Yalco)', 'https://www.inflearn.com/course/%EC%A0%9C%EB%8C%80%EB%A1%9C-%ED%8C%8C%EB%8A%94-%EA%B9%83', '동영상', '인프런', 'HOUR_10', 'medium', 'UNDER_50K', 6),
                                                                                                                                                                    (49, '【한글자막】 Git & Github 실무 활용 완벽 가이드', 'https://www.udemy.com/course/best-git-github', '동영상', '유데미', 'OVER_10', 'medium', 'BETWEEN_100K_200K', 6),
                                                                                                                                                                    (50, 'Git 팀 작업을 자동화하는 방법 [Hooks와 커스텀 스크립트]', 'https://coding-by-head.tistory.com/entry/git-hook', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 7),
                                                                                                                                                                    (51, 'Husky로 Git hooks 자동화하기(+ lint-staged, commitlint)', 'https://meoweundi.tistory.com/37', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 7),
                                                                                                                                                                    (52, 'Git Hooks', 'https://www.atlassian.com/ko/git/tutorials/git-hooks', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 7),
                                                                                                                                                                    (53, 'husky, lint-staged', 'https://deku.posstree.com/ko/react/husky-lint-staged/', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 7),
                                                                                                                                                                    (54, 'Configuring husky pre-commit git hooks', 'https://www.youtube.com/watch?v=jGEkiljxvxU', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 7),
                                                                                                                                                                    (55, 'Git Project Setup with Husky, Conventional Commits, and branching strategies.', 'https://www.youtube.com/watch?app=desktop&v=jNxDNoYEGVU&t=1169s', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 7),
                                                                                                                                                                    (56, 'Axios instance와 interceptors로 Axios 효율성 높이기', 'https://ramincoding.tistory.com/entry/React-Axios-instance-와-interceptors-로-Axios-효율성-높이기', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 8),
                                                                                                                                                                    (57, 'Axios Instance 만들어보기', 'https://velog.io/@posinity/%ED%95%AD%ED%95%B499-Axios-Instance-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 8),
                                                                                                                                                                    (58, 'Axios : instance와 interceptor', 'https://developer-haru.tistory.com/51', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 8),
                                                                                                                                                                    (59, 'Axios 공식 문서', 'https://axios-http.com/kr/docs/instance', '블로그', '블로그', 'HOUR_5', 'medium', 'FREE', 8),
                                                                                                                                                                    (60, 'How can you use axios interceptors?', 'https://stackoverflow.com/questions/52737078/how-can-you-use-axios-interceptors', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 8),
                                                                                                                                                                    (61, 'Axios Tutorial', 'https://www.youtube.com/playlist?list=PLnHJACx3NwAdSOK3BoQ7wjCDT1Iw7hs_u', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 8),
                                                                                                                                                                    (62, 'React | 공통 API 에러 처리 제작기(feat. React Query)', 'https://velog.io/@jun_n3/React-%EA%B3%B5%ED%86%B5-API-%EC%97%90%EB%9F%AC-%EC%B2%98%EB%A6%AC-%EC%A0%9C%EC%9E%91%EA%B8%B0feat.-React-Query', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 9),
                                                                                                                                                                    (63, 'Axios Retry로 API 요청 마스터하기: 종합 가이드', 'https://apidog.com/kr/blog/axios-retry-request-2/', '블로그', '블로그', 'HOUR_3', 'high', 'FREE', 9),
                                                                                                                                                                    (64, '[Web] API, REST API에 대해 공부해보자', 'https://five-sun.tistory.com/112', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 9),
                                                                                                                                                                    (65, 'Spring Boot 에서 API 재시도를 처리할수 있는 여러가지 방안들', 'https://velog.io/@garden6/API-%EC%9E%AC%EC%8B%9C%EB%8F%84%EB%A5%BC-%EC%B2%98%EB%A6%AC%ED%95%A0%EC%88%98-%EC%9E%88%EB%8A%94-%EC%97%AC%EB%9F%AC%EA%B0%80%EC%A7%80-%EB%B0%A9%EC%95%88%EB%93%A4', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 9),
                                                                                                                                                                    (66, 'API Fetch Retry 로직 작성해보기 (with Axios)', 'https://flyingsquirrel.medium.com/api-fetch-retry로직-작성해보기-with-axios-5cb81e6345ad', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 9),
                                                                                                                                                                    (67, 'Spring Retry for resilient database or REST API access with simple annotation in Spring Boot.', 'https://www.youtube.com/watch?v=Q0nh8ECG5rQ', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 9),
                                                                                                                                                                    (68, 'Unlock the Hidden Power of Spring Boot Retry', 'https://www.youtube.com/watch?v=Nj3wPmIJRy0', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 9),
                                                                                                                                                                    (69, 'Spring Retry & RestClient (Part 2): Custom HTTP Exceptions, Error Handlers, JDK/Apache HttpClients', 'https://www.youtube.com/watch?v=pezBoiaBvus', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 9),
                                                                                                                                                                    (70, '모던 리액트 Deep Dive', 'https://product.kyobobook.co.kr/detail/S000210725203', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 10),
                                                                                                                                                                    (71, 'React & Express 를 이용한 웹 어플리케이션 개발하기', 'https://www.inflearn.com/course/react-%EA%B0%95%EC%A2%8C-velopert', '동영상', '인프런', 'HOUR_10', 'medium', 'FREE', 10),
                                                                                                                                                                    (72, 'ReactJS로 영화 웹 서비스 만들기', 'https://nomadcoders.co/react-for-beginners', '동영상', '노마드코더', 'HOUR_10', 'low', 'FREE', 10),
                                                                                                                                                                    (73, '리액트의 Hooks 완벽 정복하기', 'https://velog.io/@velopert/react-hooks', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 10),
                                                                                                                                                                    (74, 'React JS 마스터클래스', 'https://nomadcoders.co/react-masterclass', '동영상', '노마드코더', 'OVER_10', 'high', 'BETWEEN_100K_200K', 10),
                                                                                                                                                                    (75, '벨로퍼트와 함께하는 모던 리액트', 'https://react.vlpt.us/', '블로그', '블로그', 'HOUR_5', 'medium', 'FREE', 10),
                                                                                                                                                                    (76, '프로젝트로 배우는 React.js', 'https://www.inflearn.com/course/프로젝트-배우는-리액트', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 10),
                                                                                                                                                                    (77, '웹 게임을 만들며 배우는 React에 TypeScript 적용하기', 'https://www.inflearn.com/course/react-typescript-webgame', '동영상', '인프런', 'HOUR_10', 'medium', 'UNDER_50K', 10),
                                                                                                                                                                    (78, '생활코딩 - Redux', 'https://www.inflearn.com/course/redux-%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9?srsltid=AfmBOoocwGw5aB_bSPaJTRNsjkGaO9h_KiH9OPZ6R78kJqNI1-PuzWne', '동영상', '인프런', 'HOUR_3', 'medium', 'FREE', 11),
                                                                                                                                                                    (79, '초보자를 위한 리덕스 101', 'https://nomadcoders.co/redux-for-beginners', '동영상', '노마드코더', 'HOUR_3', 'low', 'FREE', 11),
                                                                                                                                                                    (80, '(2025 최신 업데이트)리액트 : 프론트엔드 개발자로 가는 마지막 단계', 'https://www.inflearn.com/course/%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%A7%88%EC%A7%80%EB%A7%89#curriculum', '동영상', '인프런', 'HOUR_1', 'medium', 'BETWEEN_100K_200K', 11),
                                                                                                                                                                    (81, '[리액트] Redux와 사용법', 'https://medium.com/@heoh06/%EB%A6%AC%EC%95%A1%ED%8A%B8-redux%EC%99%80-%EC%82%AC%EC%9A%A9%EB%B2%95-731853fc3cd4', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 11),
                                                                                                                                                                    (82, '[Redux] Redux 사용법 기초 useState처럼 사용하기', 'https://velog.io/@chaerin00/Redux-%EC%82%AC%EC%9A%A9%EB%B2%95-%EA%B8%B0%EC%B4%88-useState%EC%B2%98%EB%9F%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 11),
                                                                                                                                                                    (83, 'React 입문 - react-redux 리덕스 사용법', 'https://olive-jam.tistory.com/47', '블로그', '블로그', 'HOUR_5', 'high', 'FREE', 11),
                                                                                                                                                                    (84, 'React Redux Tutorials', 'https://www.youtube.com/watch?v=9boMnm5X9ak&list=PLC3y8-rFHvwheJHvseC3I0HuYI2f46oAK', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 11),
                                                                                                                                                                    (85, 'Redux Toolkit Tutorial', 'https://www.youtube.com/watch?v=0awA5Uw6SJE&list=PLC3y8-rFHvwiaOAuTtVXittwybYIorRB3', '동영상', '유튜브', 'HOUR_3', 'high', 'FREE', 11),
                                                                                                                                                                    (86, '맛집 지도앱 만들기 (React Native + NestJS)', 'https://www.inflearn.com/course/%EB%A7%9B%EC%A7%91-%EC%A7%80%EB%8F%84%EC%95%B1-%EB%A7%8C%EB%93%A4%EA%B8%B0-reactnative-nestjs', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 12),
                                                                                                                                                                    (87, 'Zustand 가이드북(간단한 사용법부터 Pro Tips까지)', 'https://lambda-log.tistory.com/9', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 12),
                                                                                                                                                                    (88, '실무에 바로 쓰는 Next.js', 'https://spartacodingclub.kr/product/72', '동영상', 'spartacodingclub', 'OVER_10', 'medium', 'UNKNOWN', 12),
                                                                                                                                                                    (89, 'Zustand Tutorial for Beginners - The Only Course You Will Ever Need', 'https://www.youtube.com/watch?v=AYO4qHAnLQI', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 12),
                                                                                                                                                                    (90, 'react zustand in detail (2023)', 'https://www.youtube.com/playlist?list=PL1T-3Hf9FqXbH54aLLMWMpdn6OMa5TWOX', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 12),
                                                                                                                                                                    (91, 'Zustand React State Management Course (Simple Redux Alternative)', 'https://www.youtube.com/watch?v=fZPgBnL2x-Q', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 12),
                                                                                                                                                                    (92, 'Zustand', 'https://opentutorials.org/course/4671', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 12),
                                                                                                                                                                    (93, 'Zustand는 작고, 빠르고, 확장가능한 상태관리 솔루션입니다.', 'https://www.youtube.com/watch?v=L5ID-3r-U4w&list=PLeMeDIV7bypu08YTMGuKyjHgLnGN8VZ28&index=2', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 12),
                                                                                                                                                                    (94, 'Next + React Query로 SNS 서비스 만들기', 'https://www.inflearn.com/course/next-react-query-sns%EC%84%9C%EB%B9%84%EC%8A%A4', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 12),
                                                                                                                                                                    (95, '기초부터 배우는 Next YTMusic 클론 코딩 (with next.js 14, UI 마스터)', 'https://www.inflearn.com/course/%EA%B8%B0%EC%B4%88-next-ytmusic-%ED%81%B4%EB%A1%A0%EC%BD%94%EB%94%A9', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 12),
                                                                                                                                                                    (96, 'Vue.js 끝장내기 - 실무에 필요한 모든 것', 'https://www.inflearn.com/course/vue-js-끝내기-캡틴판교', '동영상', '인프런', 'HOUR_10', 'high', 'BETWEEN_100K_200K', 13),
                                                                                                                                                                    (97, '웹 게임을 만들며 배우는 Vue', 'https://www.inflearn.com/course/web-game-vue', '동영상', '인프런', 'HOUR_10', 'medium', 'FREE', 13),
                                                                                                                                                                    (98, 'Vue로 Nodebird SNS 만들기', 'https://www.inflearn.com/course/vue-nodebird-sns', '동영상', '인프런', 'OVER_10', 'high', 'BETWEEN_50K_100K', 13),
                                                                                                                                                                    (99, 'Vue3 강좌 한방에 몰아보기', 'https://www.youtube.com/watch?v=m2j_Y245xew', '동영상', '유튜브', 'HOUR_3', 'medium', 'FREE', 13),
                                                                                                                                                                    (100, '트렐로 개발로 배우는 Vue.js, Vuex, Vue-Router 프론트엔드 실전 기술', 'https://www.inflearn.com/course/vuejs', '동영상', '인프런', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 13),
                                                                                                                                                                    (101, 'Vue 3 시작하기', 'https://www.inflearn.com/course/vue-3-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0', '동영상', '인프런', 'HOUR_5', 'low', 'UNDER_50K', 13),
                                                                                                                                                                    (102, 'Vue.js + TypeScript 완벽 가이드', 'https://www.inflearn.com/course/vue-ts', '동영상', '인프런', 'HOUR_10', 'high', 'BETWEEN_50K_100K', 13),
                                                                                                                                                                    (103, 'Vue 3 중급 - Composition API', 'https://www.inflearn.com/course/vue-3-%EC%A4%91%EA%B8%89-composition-api', '동영상', '인프런', 'HOUR_3', 'medium', 'BETWEEN_50K_100K', 13),
                                                                                                                                                                    (104, 'Vue 3 & Firebase 10 커뮤니티 만들기 풀스택 - "활용편" (with Pinia, Quasar, Tiptap, VueUse)', 'https://www.inflearn.com/course/vue3-firebase10-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0%EB%A7%8C%EB%93%A4%EA%B8%B0', '동영상', '인프런', 'OVER_10', 'high', 'BETWEEN_100K_200K', 13),
                                                                                                                                                                    (105, 'Vue JS 맛보기 - 정말 쉬운지 아닌지 살펴보기?', 'https://www.youtube.com/watch?v=QtQ-xbLyaqI&ab_channel=%EB%8D%B0%EB%B8%8C%EB%A6%AC', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 13),
                                                                                                                                                                    (106, '뷰js 2 (Vue.js 2) 기초 익히기 기본 강좌!', 'https://www.youtube.com/playlist?list=PLB7CpjPWqHOtYP7P_0Ls9XNed0NLvmkAh', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 13),
                                                                                                                                                                    (107, '프로젝트로 배우는 Vue.js 3', 'https://www.inflearn.com/course/vue-%EA%B8%B0%EC%B4%88-%EC%9D%B5%ED%9E%88%EA%B8%B0', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 13),
                                                                                                                                                                    (108, 'Vue.js 중급 강좌 - 웹앱 제작으로 배워보는 Vue.js, ES6, Vuex', 'https://www.inflearn.com/course/vue-pwa-vue-js-%EC%A4%91%EA%B8%89', '동영상', '인프런', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 13),
                                                                                                                                                                    (109, 'Nuxt3 Pinia Full Course (feat. News API)', 'https://www.youtube.com/watch?v=5eA0V540hZs', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 14),
                                                                                                                                                                    (110, 'Vuex Tutorial', 'https://www.youtube.com/playlist?list=PLZzSdj89sCN292abcbI3utND8pA1T1OyB', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 14),
                                                                                                                                                                    (111, '공식문서로 알아보는 Pinia Full Tutorial', 'https://www.youtube.com/watch?v=_LPTZbzzc7g', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 14),
                                                                                                                                                                    (112, 'Pinia Crash Course', 'https://www.youtube.com/playlist?list=PL4cUxeGkcC9hp28dYyYBy3xoOdoeNw-hD', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 14),
                                                                                                                                                                    (113, 'Pinia Course 2022', 'https://www.youtube.com/watch?v=G4H6QOcGKbU', '동영상', '유튜브', 'HOUR_3', 'medium', 'FREE', 14),
                                                                                                                                                                    (114, 'Learn Pinia in 30 MINUTES! (Vue JS 3)', 'https://www.youtube.com/watch?v=JGC7aAC-3y8', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 14),
                                                                                                                                                                    (115, 'Angular, 앵귤러 100분 핵심강의', 'https://www.inflearn.com/course/angular-100min?srsltid=AfmBOorAE_wX-ioQ-_CODnNbvJXN9SLgrbvtmGxbq4CFN-Ua1lcdM6Fz', '동영상', '인프런', 'HOUR_3', 'medium', 'UNDER_50K', 15),
                                                                                                                                                                    (116, 'Angular 기본과 간단한 To-Do 어플리케이션 만들기', 'https://www.inflearn.com/course/angular-강좌-기본?srsltid=AfmBOorsGYu1eRLCu9OXAvzM-JSkb22oK-gG4A3qdwfYRAqVGresJ_IT', '동영상', '인프런', 'HOUR_3', 'low', 'FREE', 15),
                                                                                                                                                                    (117, 'Angular【한글자막】 Angular 완벽 가이드 : 기초 문법부터 TypeScript 기반 최신 문법까지', 'https://www.udemy.com/course/angular-2021/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'medium', 'UNDER_50K', 15),
                                                                                                                                                                    (118, 'Angular(2+) Front에서 Back까지 - Nest js를 알려면 Angular 모듈을 알아야한다!', 'https://www.inflearn.com/course/Angular', '동영상', '인프런', 'HOUR_10', 'medium', 'FREE', 15),
                                                                                                                                                                    (119, 'Angular Essentials', 'https://product.kyobobook.co.kr/detail/S000001891079', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 15),
                                                                                                                                                                    (120, '앵귤러 첫걸음', 'https://product.kyobobook.co.kr/detail/S000001057857', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 15),
                                                                                                                                                                    (121, 'Angular - The Complete Guide (2025 Edition)', 'https://www.udemy.com/course/the-complete-guide-to-angular-2', '동영상', '유데미', 'OVER_10', 'high', 'BETWEEN_100K_200K', 15),
                                                                                                                                                                    (122, 'Angular Deep Dive - Beginner to Advanced (Angular 19)', 'https://www.udemy.com/course/angular-course/', '동영상', '유데미', 'OVER_10', 'high', 'BETWEEN_50K_100K', 15),
                                                                                                                                                                    (123, 'Angular NGRX Complete Course Tutorial', 'https://www.youtube.com/playlist?list=PL_euSNU_eLbdg0gKbR8zmVJb4xLgHR7BX', '동영상', '유튜브', 'HOUR_10', 'low', 'FREE', 16),
                                                                                                                                                                    (124, '이 영상을 보시면 NgRx를 이해하실 수 있을 거라 장담합니다', 'https://www.youtube.com/watch?v=kx0VTgTtSBg', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 16),
                                                                                                                                                                    (125, 'Ngrx 도입', 'https://front-study.tistory.com/58', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 16),
                                                                                                                                                                    (126, '[Angular] NGRX 적용 - (1) ngrx 동작 과정 이해하기', 'https://dongurami0502.tistory.com/16', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 16),
                                                                                                                                                                    (127, 'ngrx architecture를 이용하여 angular 앱을 더 기분 좋게 만들기', 'https://medium.com/pplink/ngrx-architecture%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-angular-%EC%95%B1%EC%9D%84-%EB%8D%94-%EA%B8%B0%EB%B6%84-%EC%A2%8B%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0-9182c582a113', '블로그', '블로그', 'HOUR_3', 'high', 'FREE', 16),
                                                                                                                                                                    (128, 'NgRx (with NgRx Data) - The Complete Guide (Angular 19)', 'https://www.udemy.com/course/ngrx-course/?utm_medium=udemyads&utm_source=wj-krweb&utm_campaign=udemykorea_course&utm_content=ngrx-course&utm_term=230814&couponCode=KRLETSLEARNNOW', '동영상', '유데미', 'HOUR_10', 'high', 'BETWEEN_50K_100K', 16),
                                                                                                                                                                    (129, '실무에 바로 적용하는 스토리북과 UI 테스트', 'https://www.inflearn.com/course/%EC%8B%A4%EB%AC%B4%EC%A0%81%EC%9A%A9-%EC%8A%A4%ED%86%A0%EB%A6%AC%EB%B6%81-ui%ED%85%8C%EC%8A%A4%ED%8A%B8', '동영상', '인프런', 'HOUR_3', 'low', 'BETWEEN_50K_100K', 17),
                                                                                                                                                                    (130, '2시간으로 끝내는 프론트엔드 테스트 기본기', 'https://www.inflearn.com/course/%EC%A3%BC%EB%8B%88%EC%96%B4-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B8%B0%EB%B3%B8%EA%B8%B0', '동영상', '코드잇', 'HOUR_3', 'low', 'UNDER_50K', 17),
                                                                                                                                                                    (131, '스토리북 & 자동화 테스트와 함께 하는 컴포넌트 주도 프론트엔드 개발', 'https://www.inflearn.com/course/%ED%8C%90%EA%B5%90-%ED%87%B4%EA%B7%BC%EA%B8%B8%EB%B0%8B%EC%97%85-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C', '동영상', '인프런', 'HOUR_1', 'low', 'FREE', 17),
                                                                                                                                                                    (132, 'UI 컴포넌트 구축하기스토리북에서 디자인 시스템 컴포넌트를 구축하고 구조화하기', 'https://storybook.js.org/tutorials/design-systems-for-developers/react/ko/build/', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 17),
                                                                                                                                                                    (133, '현장에서 바로 써먹는 리액트 with 타입스크립트', 'https://product.kyobobook.co.kr/detail/S000202707764', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 17),
                                                                                                                                                                    (134, 'Storybook Official Tutorial Code Along - Web Development', 'https://www.udemy.com/course/storybook-official-tutorial-code-along-web-development', '동영상', '유데미', 'HOUR_10', 'low', 'UNDER_50K', 17),
                                                                                                                                                                    (135, 'Convert a Figma design to ReactJS components using Storybook', 'https://www.udemy.com/course/implement-a-design-system-with-reactjs-storybook-tailwind', '동영상', '유데미', 'HOUR_5', 'low', 'UNDER_50K', 17),
                                                                                                                                                                    (136, 'Advanced React & Storybook: From Components Library to CI/CD', 'https://www.udemy.com/course/build-react-v17-components-with-storybook', '동영상', '유데미', 'HOUR_5', 'medium', 'BETWEEN_50K_100K', 17),
                                                                                                                                                                    (137, 'Advanced React: Design System, Design Patterns, Performance', 'https://www.udemy.com/course/advanced-react', '동영상', '유데미', 'OVER_10', 'high', 'BETWEEN_50K_100K', 17),
                                                                                                                                                                    (138, 'React Storybook Tutorial', 'https://www.youtube.com/playlist?list=PLC3y8-rFHvwhC-j3x3t9la8-GQJGViDQk', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 17),
                                                                                                                                                                    (139, 'Modern Component Library with React & Storybook', 'https://www.youtube.com/playlist?list=PLKBvDYynKmlWa59k8pnw-EHac2_miPagh', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 17),
                                                                                                                                                                    (140, 'Storybook Crash Course: For React Devs And Storybook Beginners with Storybook Maintainer, Yann Braga', 'https://www.youtube.com/watch?v=x-x47qHq3nY', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 17),
                                                                                                                                                                    (141, '쉽고 빠른 스타일링 Tailwind CSS 기초 가이드', 'https://www.inflearn.com/course/tailwind-css-기초?srsltid=AfmBOoran6emeg4BdcdPHnUTYXV3h_ipF-U2bYisdK74Xyq7pDKrG1g5', '동영상', '인프런', 'HOUR_3', 'low', 'UNDER_50K', 17),
                                                                                                                                                                    (142, 'TailwindCSS 완벽 마스터: 포트폴리오부터 어드민까지!', 'https://www.inflearn.com/course/tailwindcss-완전정복-포트폴리오-어드민까지', '동영상', '인프런', 'HOUR_10', 'medium', 'UNDER_50K', 18),
                                                                                                                                                                    (143, '테일윈드 CSS', 'https://www.yes24.com/Product/Goods/126841796', '책', 'Yes24', 'OVER_10', 'medium', 'UNDER_50K', 18),
                                                                                                                                                                    (144, 'TailwindCSS 완전 정복 강의 EP01 ~ EP11', 'https://www.youtube.com/watch?v=sOiuZQo93cU&ab_channel=%EC%A7%90%EC%BD%94%EB%94%A9', '동영상', '유튜브', 'HOUR_3', 'medium', 'FREE', 18),
                                                                                                                                                                    (145, '[쉽고 빠른 스타일링 Tailwind CSS 기초 가이드] 설치/확장프로그램/기본속성', 'https://velog.io/@posinity/%EC%89%BD%EA%B3%A0-%EB%B9%A0%EB%A5%B8-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81-Tailwind-CSS-%EA%B8%B0%EC%B4%88-%EA%B0%80%EC%9D%B4%EB%93%9C', '블로그', '블로그', 'HOUR_5', 'medium', 'FREE', 18),
                                                                                                                                                                    (146, 'Tailwind CSS 사용기', 'https://fe-developers.kakaoent.com/2022/220303-tailwind-tips/', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 18),
                                                                                                                                                                    (147, '🚀Next.js + Tailwind.css 로 블로그 만들기 - 1. setting / config + data fetching', 'https://velog.io/@holicholicpop/Next.js-Tailwind.css-로-블로그-만들기-1.-setting-config-data-fetching', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 18),
                                                                                                                                                                    (148, 'Tailwind CSS Tutorial #1 - Intro & Setup', 'https://www.youtube.com/watch?v=bxmDnn7lrnk&list=PL4cUxeGkcC9gpXORlEHjc5bgnIi5HEGhw&ab_channel=NetNinja', '동영상', '유튜브', 'HOUR_3', 'medium', 'FREE', 18),
                                                                                                                                                                    (149, '[초급] 40분만에 훑어보는 Sass', 'https://www.inflearn.com/course/%EC%B4%88%EA%B8%89-30%EB%B6%84-sass', '동영상', '인프런', 'HOUR_1', 'low', 'UNDER_50K', 19),
                                                                                                                                                                    (150, 'CSS에 날개를 달아주는 Sass (SCSS)', 'https://www.inflearn.com/course/css%EC%97%90-%EB%82%A0%EA%B0%9C%EB%A5%BC-%EB%8B%AC%EC%95%84%EC%A3%BC%EB%8A%94-sass-scss', '동영상', '인프런', 'OVER_10', 'medium', 'UNDER_50K', 19),
                                                                                                                                                                    (151, 'The Complete Sass & SCSS Course: From Beginner to Advanced', 'https://www.udemy.com/course/sasscourse/?couponCode=ST8MT220425G1', '동영상', '유데미', 'HOUR_5', 'low', 'BETWEEN_50K_100K', 19),
                                                                                                                                                                    (152, '실무자를 위한 Sass (CSS 프리프로세서)', 'https://www.udemy.com/course/css-preprocessor/?couponCode=ST8MT220425G1', '동영상', '유데미', 'HOUR_3', 'low', 'UNDER_50K', 19),
                                                                                                                                                                    (153, 'SASS(SCSS) 기초 개념 및 사용법', 'https://www.youtube.com/watch?v=C4g036Ioo3o&list=PLmAWMAo-opQzz95sYuW5Bj9mcmx0NG-ey', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 19),
                                                                                                                                                                    (154, '초보자를 위한 Sass 기초 강의 & 자몽톡 클론코딩', 'https://www.inflearn.com/course/%EC%B4%88%EB%B3%B4%EC%9E%90-%EC%82%AC%EC%8A%A4-%EA%B8%B0%EC%B4%88%EA%B0%95%EC%9D%98-%ED%81%B4%EB%A1%A0#curriculum', '동영상', '인프런', 'HOUR_5', 'low', 'UNDER_50K', 19),
                                                                                                                                                                    (155, 'SCSS', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000008381180', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 19),
                                                                                                                                                                    (156, 'Sass Moderno (Lleva CSS al siguiente nivel)', 'https://www.udemy.com/course/sass-curso/?couponCode=ST8MT220425G1', '동영상', '유데미', 'HOUR_5', 'high', 'UNDER_50K', 19),
                                                                                                                                                                    (157, 'SCSS(SASS)+FLEX 실전 반응형 웹 프로젝트 with Figma', 'https://www.inflearn.com/course/scss-flex-실전반응형-웹프로젝트-figma', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_100K_200K', 19),
                                                                                                                                                                    (158, 'React Styled Components Course (V5)', 'https://www.udemy.com/course/styled-components-tutorial-and-project-course/?couponCode=ST7MT290425G1', '동영상', '유데미', 'HOUR_3', 'low', 'BETWEEN_50K_100K', 20),
                                                                                                                                                                    (159, 'Learn Styled Components in React', 'https://www.coursera.org/learn/learn-styled-components-in-react', '동영상', 'Coursera', 'HOUR_3', 'medium', 'FREE', 20),
                                                                                                                                                                    (160, 'Styled Components', 'https://www.codeit.kr/topics/styled-components', '동영상', '코드잇', 'HOUR_10', 'medium', 'FREE', 20),
                                                                                                                                                                    (161, 'CSS for the <Component> Age', 'https://styled-components.com/', '책', '공식문서', 'OVER_10', 'high', 'FREE', 20),
                                                                                                                                                                    (162, '[styled-component] 왕초보가 styled-component 배워보기', 'https://velog.io/@pakxe/series/styled-component', '블로그', '블로그', 'HOUR_5', 'low', 'FREE', 20),
                                                                                                                                                                    (163, 'React Styled Components', 'https://www.youtube.com/playlist?list=PLC3y8-rFHvwgu-G08-7ovbN9EyhF_cltM', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 20),
                                                                                                                                                                    (164, 'Prettier, ESLint 이해하고 사용하기', 'https://velog.io/@imkkuk/Prettier-ESLint-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 21),
                                                                                                                                                                    (165, '프론트엔드 개발환경의 이해와 실습 (webpack, babel, eslint..)', 'https://www.inflearn.com/course/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD/community?srsltid=AfmBOoqNJUk176njEl2FaVDoPUp19O7nleyenDXDRLlSBu4QzU5cIn11', '동영상', '인프런', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 21),
                                                                                                                                                                    (166, 'ESLint 설치 및 configuration 설정하는 방법', 'https://ablue-1.tistory.com/111', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 21),
                                                                                                                                                                    (167, '우리 팀을 위한 ESLint, Prettier 공유 컨피그 만들어보기', 'https://techblog.woowahan.com/15903/', '블로그', '블로그', 'HOUR_5', 'high', 'FREE', 21),
                                                                                                                                                                    (168, 'Prettier, ESLint 설치하기 [ 리액트 (React + Typescript) ]', 'https://www.youtube.com/watch?v=RDIKsxddlmg&ab_channel=어라운드허브스튜디오-AroundHubStudio', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 21),
                                                                                                                                                                    (169, 'Prettier', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000007628389', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 21),
                                                                                                                                                                    (170, 'ESLint', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000006806383', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 21),
                                                                                                                                                                    (171, 'Next.js 시작하기', 'https://www.inflearn.com/course/next-js-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0', '동영상', '인프런', 'HOUR_10', 'low', 'BETWEEN_50K_100K', 22),
                                                                                                                                                                    (172, 'NextJS 시작하기', 'https://nomadcoders.co/nextjs-for-beginners', '동영상', '노마드코더', 'HOUR_5', 'low', 'FREE', 22),
                                                                                                                                                                    (173, 'Next.js 완벽 마스터 (v15): Notion 기반 개발자 블로그 만들기 (with Cursor AI)', 'https://www.inflearn.com/course/next-%EC%99%84%EB%B2%BD%EB%A7%88%EC%8A%A4%ED%84%B0-notion-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%B8%94%EB%A1%9C%EA%B7%B8-cursorai', '동영상', '인프런', 'OVER_10', 'high', 'BETWEEN_100K_200K', 22),
                                                                                                                                                                    (174, 'Next.js 13', 'https://opentutorials.org/course/5098', '동영상', '생활코딩', 'HOUR_5', 'low', 'FREE', 22),
                                                                                                                                                                    (175, 'Next.js로 웹서비스 만들기', 'https://codingapple.com/course/next-js/', '동영상', '코딩애플', 'HOUR_10', 'medium', 'BETWEEN_100K_200K', 22),
                                                                                                                                                                    (176, 'Next.js로 웹사이트 최적화하기', 'https://www.codeit.kr/paths/nextjs-web-development', '동영상', '코드잇', 'HOUR_10', 'medium', 'FREE', 22),
                                                                                                                                                                    (177, 'Introduction to Next.js', 'https://www.coursera.org/learn/introduction-to-next-js', '동영상', 'Coursera', 'HOUR_3', 'low', 'FREE', 22),
                                                                                                                                                                    (178, 'Next.js 15 & React - The Complete Guide', 'https://www.udemy.com/course/nextjs-react-the-complete-guide/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'medium', 'BETWEEN_100K_200K', 22),
                                                                                                                                                                    (179, '쉽게 시작하는 Next.js', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000010731194', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 22),
                                                                                                                                                                    (180, '실전에서 바로 쓰는 Next.js', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000005120537', '책', '교보문고', 'OVER_10', 'high', 'UNDER_50K', 22),
                                                                                                                                                                    (181, 'Next + React Query로 SNS 서비스 만들기', 'https://www.inflearn.com/course/next-react-query-sns%EC%84%9C%EB%B9%84%EC%8A%A4', '동영상', '인프런', 'OVER_10', 'high', 'BETWEEN_50K_100K', 22),
                                                                                                                                                                    (182, '한 입 크기로 잘라먹는 Next.js(v15)', 'https://www.inflearn.com/course/%ED%95%9C%EC%9E%85-%ED%81%AC%EA%B8%B0-nextjs', '동영상', '인프런', 'OVER_10', 'low', 'UNDER_50K', 22),
                                                                                                                                                                    (183, 'NextJS 14 : quick start', 'https://www.youtube.com/watch?v=ogV4d6q-ykQ&list=PLeMeDIV7bypu08YTMGuKyjHgLnGN8VZ28&index=3', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 22),
                                                                                                                                                                    (184, '리액트 리렌더링 최적화 방법 조사', 'https://blog.teamelysium.kr/react-rerendering-optimization', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 23),
                                                                                                                                                                    (185, '부트캠프에서 알려주지 않는 것들 (리액트 렌더링 최적화 편) 2편', 'https://www.inflearn.com/course/%EB%B6%80%ED%8A%B8%EC%BA%A0%ED%94%84-%EC%95%8C%EB%A0%A4%EC%A3%BC%EC%A7%80%EC%95%8A%EB%8A%94%EA%B2%83%EB%93%A4-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%B5%9C%EC%A0%81%ED%99%94', '동영상', '인프런', 'HOUR_3', 'high', 'UNDER_50K', 23),
                                                                                                                                                                    (186, '모던 리액트 Deep Dive', 'https://product.kyobobook.co.kr/detail/S000210725203', '책', '교보문고', 'OVER_10', 'high', 'UNDER_50K', 23),
                                                                                                                                                                    (187, 'Learn useCallback in 8minutes', 'https://www.youtube.com/watch?v=_AyFP5s69N4&ab_channel=WebDevSimplified', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 23),
                                                                                                                                                                    (188, 'React.memo로 컴포넌트 최적화하기 (ft. useMemo, useCallback)', 'https://www.youtube.com/watch?v=oqUgcxwrnSY&ab_channel=별코딩', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 23),
                                                                                                                                                                    (189, 'React Advanced Concepts: Re-Rendering, Performance & More', 'https://www.udemy.com/course/react-advanced', '동영상', '유데미', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 23),
                                                                                                                                                                    (190, 'React Render Tutorial', 'https://www.youtube.com/playlist?list=PLC3y8-rFHvwg7czgqpQIBEAHn8D6l530t', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 23),
                                                                                                                                                                    (191, '8 React Js performance optimization techniques YOU HAVE TO KNOW!', 'https://www.youtube.com/watch?v=CaShN6mCJB0 ', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 23),
                                                                                                                                                                    (192, 'Learn React Query In 50 Minutes', 'https://www.youtube.com/watch?v=r8Dg0KVnfMA', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 24),
                                                                                                                                                                    (193, 'React Query Tutorial for Beginners', 'https://www.youtube.com/playlist?list=PLC3y8-rFHvwjTELCrPrcZlo6blLBUspd2', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 24),
                                                                                                                                                                    (194, 'React Query', 'https://www.codeit.kr/topics/react-query', '동영상', '코드잇', 'OVER_10', 'high', 'FREE', 24),
                                                                                                                                                                    (195, 'React Query |TanStack Query:Server State Management in React', 'https://www.udemy.com/course/react-query-tanstack-query-server-state-management-in-react/?couponCode=ST8MT220425G1', '동영상', '유데미', 'HOUR_5', 'low', 'UNDER_50K', 24),
                                                                                                                                                                    (196, '리액트 쿼리', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000006500261', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 24),
                                                                                                                                                                    (197, 'React Query / TanStack Query: React Server State Management', 'https://www.udemy.com/course/learn-react-query/?couponCode=ST8MT220425G1', '동영상', '유데미', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 24),
                                                                                                                                                                    (198, 'State Management with React Query', 'https://product.kyobobook.co.kr/detail/S000202678072', '책', '교보문고', 'OVER_10', 'high', 'UNDER_50K', 24),
                                                                                                                                                                    (199, 'React Query : quick start', 'https://www.youtube.com/watch?v=rQwJMmgx_bg', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 24),
                                                                                                                                                                    (200, 'Learn React Query In 50 Minutes', 'https://www.youtube.com/watch?v=r8Dg0KVnfMA', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 24),
                                                                                                                                                                    (201, 'React Query Tutorial', 'https://www.youtube.com/playlist?list=PLzYM-WGWIJDTMei3yRgQtiDGlUdP1ydw3', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 24),
                                                                                                                                                                    (202, 'Vue Test Utils', 'https://joshua1988.github.io/vue-camp/testing/vue-test-util.html#%E1%84%8E%E1%85%AC%E1%84%89%E1%85%B5%E1%86%AB-vue-cli-3-x-%E1%84%87%E1%85%A5%E1%84%8C%E1%85%A5%E1%86%AB-%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A1%E1%86%BC-%E1%84%8B%E1%85%A6%E1%84%89%E1%85%A5-%E1%84%89%E1%85%A5%E1%86%AF%E1%84%8E%E1%85%B5-%E1%84%87%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A5%E1%86%B8', '블로그', 'GitHub', 'HOUR_1', 'low', 'FREE', 25),
                                                                                                                                                                    (203, 'Vue Unit Testing', 'https://www.youtube.com/playlist?list=PLXDouhCU5r6oai6AB-WpDNPxEAqhvDfFt', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 25),
                                                                                                                                                                    (204, 'Testing Vue 3 apps with Vue Test Utils', 'https://www.youtube.com/playlist?list=PLC2LZCNWKL9ahK1IoODqYxKu5aA9T5IOA', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 25),
                                                                                                                                                                    (205, 'Vue Testing with Vue Test Utils', 'https://www.youtube.com/watch?v=QIDhzBg5eWY', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 25),
                                                                                                                                                                    (206, '[최신] Vue 강의 끝판왕 : Nuxt 3 완벽 마스터', 'https://www.inflearn.com/course/vue-%EB%81%9D%ED%8C%90%EC%99%95-nuxt3-%EC%99%84%EB%B2%BD%EB%A7%88%EC%8A%A4%ED%84%B0', '동영상', '인프런', 'OVER_10', 'high', 'BETWEEN_100K_200K', 26),
                                                                                                                                                                    (207, 'Nuxt.js 시작하기', 'https://www.inflearn.com/course/%EB%84%89%EC%8A%A4%ED%8A%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0', '동영상', '인프런', 'HOUR_10', 'high', 'BETWEEN_50K_100K', 26),
                                                                                                                                                                    (208, 'Nuxt 3 기반으로 AI Flatform 만들기', 'https://www.youtube.com/playlist?list=PLIZTLPwzS_qXH5YR-3ZxN5W5gqgDlxwQ1', '동영상', '유튜브', 'HOUR_3', 'medium', 'FREE', 26),
                                                                                                                                                                    (209, 'Nuxt.js 강좌', 'https://www.youtube.com/playlist?list=PLDE8MlAqcTnA9bJPt_aA-9A0YehTJ3FrC', '동영상', '유튜브', 'HOUR_3', 'medium', 'FREE', 26),
                                                                                                                                                                    (210, 'Nuxt3 Pinia Full Course (feat. News API)', 'https://www.youtube.com/watch?v=5eA0V540hZs', '동영상', '유튜브', 'HOUR_3', 'high', 'FREE', 26),
                                                                                                                                                                    (211, 'Nuxt 3 Tutorial', 'https://www.youtube.com/playlist?list=PL4cUxeGkcC9haQlqdCQyYmL_27TesCGPC', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 26),
                                                                                                                                                                    (212, 'Master Nuxt.js - A Vuejs framework by building projects', 'https://www.udemy.com/course/master-nuxtjs-a-vuejs-framework-by-building-projects-and-deploy/', '동영상', '유데미', 'HOUR_3', 'medium', 'UNDER_50K', 26),
                                                                                                                                                                    (213, 'Angular SSR In Depth (formerly Angular Universal)', 'https://www.udemy.com/course/angular-universal-course/?srsltid=AfmBOootMXpadDq_XUYQfVcQceOcvF08PJy6eLnaJ4_ofUw5TBfB8MAG', '동영상', '유데미', 'HOUR_5', 'medium', 'BETWEEN_50K_100K', 27),
                                                                                                                                                                    (214, 'Angular 16 Server Side Rendering and Client Side Rendering - Angular Universal', 'https://www.youtube.com/watch?v=lZoRAcoEFOw', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 27),
                                                                                                                                                                    (215, 'Angular SSR Deep Dive (With Client HYDRATION)', 'https://www.youtube.com/watch?v=U1MP4uCuUVI', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 27),
                                                                                                                                                                    (216, 'https://angular.io/guide/universal', 'https://v17.angular.io/guide/ssr', '책', '공식문서', 'OVER_10', 'medium', 'FREE', 27),
                                                                                                                                                                    (217, 'Angular 19 SSR Guide', 'https://www.youtube.com/playlist?list=PL_euSNU_eLbc91j2QvA_URGFwbHZsjS95', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 27),
                                                                                                                                                                    (218, '[Vanilla Javascript] Jasmine을 이용해 테스트 코드 작성해보기', 'https://datobi.tistory.com/55', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 28),
                                                                                                                                                                    (219, 'Jasmine JavaScript Testing Second Edition', 'https://product.kyobobook.co.kr/detail/S000035154674', '책', '교보문고', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 28),
                                                                                                                                                                    (220, '[10분 테코톡] 자스민, 병민의 웹팩 최적화 Part1', 'https://www.youtube.com/watch?v=QXYWlqK2eHI', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 28),
                                                                                                                                                                    (221, 'Jasmine Testing Framework Course', 'https://www.youtube.com/playlist?list=PL_euSNU_eLbcpJdoM-WWzUlNNVM4TwtMl', '동영상', '유튜브', 'HOUR_10', 'high', 'FREE', 28),
                                                                                                                                                                    (222, 'Jasmine JS: Start Testing From-Scratch', 'https://www.testim.io/blog/jasmine-js-a-from-scratch-tutorial-to-start-testing/', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 28),
                                                                                                                                                                    (223, 'JavaScript Testing with Jasmine', 'https://product.kyobobook.co.kr/detail/S000028165901', '책', '교보문고', 'OVER_10', 'high', 'UNDER_50K', 28),
                                                                                                                                                                    (224, 'Jasmine Testing Framework: A Complete Guide', 'https://www.lambdatest.com/learning-hub/jasmine-unit-testing', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 28),
                                                                                                                                                                    (225, 'Webpack 5: Optimizing For Production', 'https://www.udemy.com/course/webpack-optimizing-for-production/?couponCode=ST8MT220425G1', '동영상', '유데미', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 29),
                                                                                                                                                                    (226, 'Webpack', 'https://www.youtube.com/playlist?list=PLuHgQVnccGMChcT9IKopFDoAIoTA-03DA', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 29),
                                                                                                                                                                    (227, 'webpack', 'https://github.com/webpack/webpack', '책', 'GitHub', 'HOUR_1', 'low', 'FREE', 29),
                                                                                                                                                                    (228, 'webpack DOCS', 'https://webpack.kr/concepts/', '책', '공식문서', 'OVER_10', 'low', 'FREE', 29),
                                                                                                                                                                    (229, 'Webpack 5 Fundamentals', 'https://www.youtube.com/playlist?list=PLB67cosR0_lPUXIK35J8M7EQUbUJQMA0Q', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 29),
                                                                                                                                                                    (230, '프론트엔드 개발자를 위한 웹팩', 'https://www.inflearn.com/course/%ED%94%84%EB%9F%B0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9B%B9%ED%8C%A9#curriculum', '동영상', '인프런', 'HOUR_5', 'low', 'UNDER_50K', 29),
                                                                                                                                                                    (231, '프론트엔드 개발환경의 이해와 실습 (webpack, babel, eslint..)', 'https://www.inflearn.com/course/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD', '동영상', '인프런', 'HOUR_10', 'high', 'BETWEEN_50K_100K', 29),
                                                                                                                                                                    (232, 'Webpack 5 Up and Running', 'https://product.kyobobook.co.kr/detail/S000003531061', '책', '교보문고', 'OVER_10', 'high', 'UNDER_50K', 29),
                                                                                                                                                                    (233, 'Webpack 5: The Complete Guide For Beginners', 'https://www.udemy.com/course/webpack-from-beginner-to-advanced', '동영상', '유데미', 'HOUR_5', 'low', 'BETWEEN_50K_100K', 29),
                                                                                                                                                                    (234, '웹팩 핸드북', 'https://joshua1988.github.io/webpack-guide/guide.html', '책', 'GitHub', 'HOUR_1', 'low', 'FREE', 29),
                                                                                                                                                                    (235, 'Webpack 5 and Vite: A New Way to Learn - Active Thinking', 'https://www.udemy.com/course/webpack-5-vite/', '동영상', '유데미', 'HOUR_5', 'medium', 'UNDER_50K', 29),
                                                                                                                                                                    (236, 'Webpack 5 Ninja - Build Micro frontend and web apps', 'https://www.udemy.com/course/webpack-5-ninja-build-micro-frontend-and-web-apps', '동영상', '유데미', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 29),
                                                                                                                                                                    (237, 'Learn React Micro Frontend From Scratch Using Webpack', 'https://www.udemy.com/course/learn-react-micro-frontends-from-scratch-using-webpack', '동영상', '유데미', 'HOUR_5', 'high', 'BETWEEN_50K_100K', 29),
                                                                                                                                                                    (238, 'Webpack for React Applications', 'https://www.udemy.com/course/webpack-for-react-applications', '동영상', '유데미', 'HOUR_5', 'medium', 'UNDER_50K', 29),
                                                                                                                                                                    (239, 'webpack', 'https://www.youtube.com/playlist?list=PL-qMANrofLysX7hRV9BQymJFLD7Fasiv6', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 29),
                                                                                                                                                                    (240, 'CloudFront 총 정리', 'https://www.youtube.com/watch?v=-r_S_kweXlk&list=PLfth0bK2MgIazkNsXM59WNVCY_6kwSnxU', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 30),
                                                                                                                                                                    (241, 'CI/CD 5분 개념 정리 (현업에서 쓰는 개발 프로세스)', 'https://youtu.be/0Emq5FypiMM?si=xU4tZLVc5gsifqoI', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 30),
                                                                                                                                                                    (242, 'Amazon S3 및 CloudFront에 React 기반 단일 페이지 애플리케이션 배포', 'https://docs.aws.amazon.com/ko_kr/prescriptive-guidance/latest/patterns/deploy-a-react-based-single-page-application-to-amazon-s3-and-cloudfront.html', '블로그', '공식문서', 'HOUR_1', 'low', 'FREE', 30),
                                                                                                                                                                    (243, '제발 깃허브 액션🔥 모르는 개발자 없게해 주세요 🙏', 'https://youtu.be/iLqGzEkusIw?si=Nqg-hETnetlMqUTF', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 30),
                                                                                                                                                                    (244, '실무에 바로 적용하는 AWS 배포', 'https://www.inflearn.com/course/%EC%8B%A4%EB%AC%B4-%EB%B0%94%EB%A1%9C-%EC%A0%81%EC%9A%A9%ED%95%98%EB%8A%94-aws-%EB%B0%B0%ED%8F%AC', '동영상', '인프런', 'HOUR_5', 'medium', 'UNDER_50K', 30),
                                                                                                                                                                    (245, 'S3와 CloudFront를 이용하여 에러없이 SPA 배포하기', 'https://bigboss.dev/2022/11/cloudfront-functions-for-spa/', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 30),
                                                                                                                                                                    (246, '도대체 프론트엔드 빌드는 왜 하는거에요?', 'https://youtu.be/D-fqNyTV3b8?si=VC0kKgLUKmw-ddpF', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 30),
                                                                                                                                                                    (247, 'The cloud architects guide to CloudFront', 'https://www.udemy.com/course/the-cloud-architects-guide-to-cloudfront/?utm_source=adwords&utm_medium=udemyads&utm_campaign=Search_DSA_Beta_Prof_la.EN_cc.ROW-English&campaigntype=Search&portfolio=ROW-English&language=EN&product=Course&test=&audience=DSA&topic=&priority=Beta&utm_content=deal4584&utm_term=_._ag_162511579404_._ad_696197165421_._kw__._de_c_._dm__._pl__._ti_dsa-1677053911088_._li_9196622_._pd__._&matchtype=&gad_source=1&gbraid=0AAAAADROdO1LjJ0fto2rbz32I6LKCIy2j&gclid=CjwKCAjwn6LABhBSEiwAsNJrjujizbVpi1kgEdDANfpV0dR_vBKndtzVFeOVrHcYXsrn7BcdADmGyRoC9ncQAvD_BwE&couponCode=ST8MT220425G1', '동영상', '유데미', 'HOUR_3', 'medium', 'UNDER_50K', 30),
                                                                                                                                                                    (248, '[Front-End] CI/CD에 대해서 알아보고 배포 준비하기', 'https://velog.io/@hayoung474/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-Github-Action%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%B9%8C%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%8F%99%ED%99%94', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 30),
                                                                                                                                                                    (249, '프로트엔드 배포 일지', 'https://babble-dev.tistory.com/32', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 30),
                                                                                                                                                                    (250, 'AWS 배포 완벽가이드 (feat. Lightsail, Docker, ECS)', 'https://www.inflearn.com/course/aws-배포-완벽가이드', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 30),
                                                                                                                                                                    (251, '비전공자도 이해할 수 있는 Docker 입문/실전', 'https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-docker-%EC%9E%85%EB%AC%B8-%EC%8B%A4%EC%A0%84?srsltid=AfmBOoodrUu-ydxnuDiryh1SVY89-Pvz4y9YWzfdDsVKnhP5qaMmoeVP', '동영상', '인프런', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 30),
                                                                                                                                                                    (252, '【한글자막】 DevOps 학습: 파이프라인 및 Docker를 이용한 Jenkins 와의 CI/CD', 'https://www.udemy.com/course/best-devops-docker-jenkins-cicd/', '동영상', '유데미', 'HOUR_5', 'medium', 'BETWEEN_50K_100K', 30),
                                                                                                                                                                    (253, '【한글자막】 Docker & Kubernetes : 실전 가이드', 'https://www.udemy.com/course/docker-kubernetes-2022', '동영상', '유데미', 'OVER_10', 'high', 'BETWEEN_100K_200K', 30),
                                                                                                                                                                    (254, '배포자동화(CI/CD) - Github Actions/Nuxtjs/Docker/EC2', 'https://www.youtube.com/watch?v=E3i9qt0SS-I', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 30),
                                                                                                                                                                    (255, '프론트엔드 개발자를 위한 Docker로 React 개발 및 배포하기', 'https://velog.io/@oneook/Docker%EB%A1%9C-React-%EA%B0%9C%EB%B0%9C-%EB%B0%8F-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 30),
                                                                                                                                                                    (256, '개발자를 위한 쉬운 도커', 'https://www.inflearn.com/course/개발자를-위한-쉬운-도커', '동영상', '인프런', 'HOUR_10', 'low', 'BETWEEN_50K_100K', 30),
                                                                                                                                                                    (257, 'Frontend 효율적으로 배포하기 (React + Nginx + Docker)', 'https://ye0nn.tistory.com/67', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 30),
                                                                                                                                                                    (258, '[Docker] 프론트에서 도커로 배포 자동화하기', 'https://velog.io/@navyjeongs/Docker-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%90%EC%84%9C-%EB%8F%84%EC%BB%A4%EB%A1%9C-%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94%ED%95%98%EA%B8%B0', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 30),
                                                                                                                                                                    (259, '프론트엔드 배포 자동화(feat. Netlify, Github Actions)', 'https://velog.io/@j7papa/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94feat.-Netlify-Github-Actions', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 30),
                                                                                                                                                                    (260, '[실습] Docker 전체 흐름 느껴보기', 'https://www.youtube.com/watch?v=Rw1gRR7lZwQ', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 30),
                                                                                                                                                                    (261, 'Dockerize your React app and serve your build artifacts through Nginx', 'https://www.youtube.com/watch?v=gM2cWo1DWIk', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 30),
                                                                                                                                                                    (262, '실무에 바로 적용하는 프런트엔드 테스트 - 1부. 테스트 기초: 단위・통합 테스트', 'https://www.inflearn.com/course/%EC%8B%A4%EB%AC%B4%EC%A0%81%EC%9A%A9-%ED%94%84%EB%9F%B0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-1%EB%B6%80', '동영상', '인프런', 'HOUR_5', 'medium', 'BETWEEN_50K_100K', 33),
                                                                                                                                                                    (263, '근본있는 프론트엔드 유닛테스트', 'https://www.inflearn.com/course/%EA%B7%BC%EB%B3%B8%EC%9E%88%EB%8A%94-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9C%A0%EB%8B%9B%ED%85%8C%EC%8A%A4%ED%8A%B8', '동영상', '인프런', 'HOUR_5', 'low', 'UNDER_50K', 33),
                                                                                                                                                                    (264, 'React - 컴포넌트 테스팅 (React Testing Library)', 'https://velog.io/@goodjam92/React-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8C%85-React-Testing-Library', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 33),
                                                                                                                                                                    (265, 'Snapshot Testing', 'https://jestjs.io/docs/snapshot-testing', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 33),
                                                                                                                                                                    (266, 'react testing library와 jest로 React 유닛 테스트 구현하기', 'https://blog.pumpkin-raccoon.com/81', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 33),
                                                                                                                                                                    (267, 'React Testing Library and Jest: The Complete Guide', 'https://www.udemy.com/course/react-testing-library-and-jest/?couponCode=ST7MT290425G1', '동영상', '유데미', 'HOUR_10', 'high', 'BETWEEN_50K_100K', 33),
                                                                                                                                                                    (268, '실무에 바로 적용하는 프런트엔드 테스트 - 2부. 테스트 심화: 시각적 회귀・E2E 테스트', 'https://www.inflearn.com/course/%EC%8B%A4%EB%AC%B4%EC%A0%81%EC%9A%A9-%ED%94%84%EB%9F%B0%ED%8A%B8%EC%97%94%EB%93%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-2%EB%B6%80', '동영상', '인프런', 'HOUR_5', 'medium', 'BETWEEN_50K_100K', 34),
                                                                                                                                                                    (269, '따라하며 배우는 리액트 테스트 [2023.11 업데이트]', 'https://www.inflearn.com/course/%EB%94%B0%EB%9D%BC%ED%95%98%EB%8A%94-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%85%8C%EC%8A%A4%ED%8A%B8#curriculum', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 34),
                                                                                                                                                                    (270, '프런트엔드 개발을 위한 테스트 입문', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000008900593', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 34),
                                                                                                                                                                    (271, '실용적인 프론트엔드 테스트 전략 (2)', 'https://ui.toast.com/weekly-pick/ko_20190116#%EC%B6%94%EA%B0%80-%EC%8B%9C%EA%B0%81%EC%A0%81-%ED%9A%8C%EA%B7%80-%ED%85%8C%EC%8A%A4%ED%8A%B8', '블로그', '블로그', 'OVER_10', 'low', 'FREE', 34),
                                                                                                                                                                    (272, '1시간에 끝내는 Linux 기본 명령어', 'https://www.youtube.com/watch?v=ymwMfvzAOPg&list=PL8oUjFBfGVJxH_oJkYfRwSqM9Q5Fy5C1X', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 35),
                                                                                                                                                                    (273, '가장 쉬운 리눅스 강좌', 'https://www.youtube.com/watch?v=tPWBF13JIVk', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 35),
                                                                                                                                                                    (274, '[우분투 리눅스 기초 강의] 이것이 우분투 리눅스다(3판)', 'https://www.youtube.com/watch?v=wDGzJFmSwN8&list=PLVsNizTWUw7HAcyW6bma7trGJfiTSDA44', '동영상', '유튜브', 'OVER_10', 'medium', 'FREE', 35),
                                                                                                                                                                    (275, '리눅스 입문 - 개념으로 탄탄히!!', 'https://www.inflearn.com/course/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%9E%85%EB%AC%B8', '동영상', '인프런', 'OVER_10', 'low', 'BETWEEN_50K_100K', 35),
                                                                                                                                                                    (276, '리눅스 커맨드라인 툴 (Full ver.)', 'https://www.inflearn.com/course/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%BB%A4%EB%A7%A8%EB%93%9C%EB%9D%BC%EC%9D%B8-%ED%88%B4', '동영상', '인프런', 'OVER_10', 'low', 'BETWEEN_50K_100K', 35),
                                                                                                                                                                    (277, '시스템엔지니어가 알려주는 리눅스 실전편 Bash Shell Script', 'https://www.inflearn.com/course/%EB%A6%AC%EB%88%85%EC%8A%A4-bash-%EC%8B%A4%EC%A0%84%ED%8E%B8', '동영상', '인프런', 'HOUR_10', 'high', 'BETWEEN_50K_100K', 35),
                                                                                                                                                                    (278, 'Complete Linux Training Course to Get Your Dream IT Job 2025', 'https://www.udemy.com/course/complete-linux-training-course-to-get-your-dream-it-job/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'low', 'BETWEEN_100K_200K', 35),
                                                                                                                                                                    (279, 'Mastering Linux: The Comprehensive Guide', 'https://www.udemy.com/course/mastering-linux/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'low', 'UNDER_50K', 35),
                                                                                                                                                                    (280, 'Linux 초보자를 위한 기초 명령어와 텍스트 편집기 사용법', 'https://codingon.co.kr/lessonDetail', '동영상', '코딩온', 'HOUR_10', 'low', 'UNDER_50K', 35),
                                                                                                                                                                    (281, 'Linux 명령 및 셸 스크립팅 실습 소개', 'https://www.coursera.org/learn/hands-on-introduction-to-linux-commands-and-shell-scripting', '동영상', 'Coursera', 'OVER_10', 'low', 'FREE', 35),
                                                                                                                                                                    (282, 'Advanced Embedded Linux Development 특화 과정', 'https://www.coursera.org/specializations/advanced-embedded-linux-development', '동영상', 'Coursera', 'OVER_10', 'medium', 'FREE', 35),
                                                                                                                                                                    (283, '실용적 유닉스 커맨드', 'https://www.codeit.kr/topics/practical-unix-commands', '동영상', '코드잇', 'HOUR_5', 'low', 'FREE', 35),
                                                                                                                                                                    (284, '생활코딩 - 리눅스(Linux)', 'https://edu.goorm.io/lecture/12984/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9-%EB%A6%AC%EB%88%85%EC%8A%A4-linux', '동영상', 'goormedu', 'OVER_10', 'medium', 'FREE', 35),
                                                                                                                                                                    (285, '쉽게 배우는 리눅스: 우분투 실습을 통한 Linux 기초 다지기', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000010611227', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 35),
                                                                                                                                                                    (286, '시스템 관리자와 일반 사용자를 위한 Unix & Linux 입문', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000005522281', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 35),
                                                                                                                                                                    (287, 'Mastering Linux Device Driver Development', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000003560522', '책', '교보문고', 'OVER_10', 'high', 'UNDER_50K', 35),
                                                                                                                                                                    (288, '실무 초밀착 리눅스:클라우드 환경 운영부터 성능분석까지', 'https://fastcampus.co.kr/dev_online_linuxcloud', '동영상', 'FASTCAMPUS', 'OVER_10', 'high', 'UNKNOWN', 35),
                                                                                                                                                                    (289, '혼자 공부하는 네트워크', 'https://www.youtube.com/playlist?list=PLVsNizTWUw7HfOCgvlfHIDPPo3TE-2iQM', '동영상', '유튜브', 'OVER_10', 'low', 'FREE', 36),
                                                                                                                                                                    (290, '새내기 개발자들을 위한 필수 가이드', 'https://www.youtube.com/watch?app=desktop&v=dsoAkoxZ13o', '동영상', '유튜브', 'HOUR_5', 'low', 'FREE', 36),
                                                                                                                                                                    (291, '모두의 네트워크', 'https://m.yes24.com/Goods/Detail/61794014', '책', 'Yes24', 'OVER_10', 'low', 'UNDER_50K', 36),
                                                                                                                                                                    (292, '컴퓨터 네트워킹(하향식 접근)', 'https://product.kyobobook.co.kr/detail/S000061694627', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 36),
                                                                                                                                                                    (293, 'HTTP 완벽 가이드', 'https://www.yes24.com/product/goods/15381085', '책', 'Yes24', 'OVER_10', 'high', 'UNDER_50K', 36),
                                                                                                                                                                    (294, '[네트워크]네트워크 기초 지식 정리', 'https://noahlogs.tistory.com/47', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 36),
                                                                                                                                                                    (295, '왕초보를 위한 네트워크 기초', 'https://www.inflearn.com/course/%EC%99%95%EC%B4%88%EB%B3%B4-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B8%B0%EC%B4%88', '동영상', '인프런', 'HOUR_10', 'low', 'BETWEEN_50K_100K', 36),
                                                                                                                                                                    (296, '네트워크,그림으로 이해하자', 'https://www.inflearn.com/course/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B7%B8%EB%A6%BC-%EC%9D%B4%ED%95%B4', '동영상', '인프런', 'HOUR_3', 'low', 'BETWEEN_50K_100K', 36),
                                                                                                                                                                    (297, '개발자를 위한 컴퓨터공학 2: 혼자 공부하는 네트워크', 'https://www.inflearn.com/course/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99-%ED%98%BC%EC%9E%90%EA%B3%B5%EB%B6%80%ED%95%98%EB%8A%94-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC', '동영상', '인프런', 'OVER_10', 'low', 'FREE', 36),
                                                                                                                                                                    (298, '외워서 끝내느 네트워크 핵심이론 - 응용', 'https://www.inflearn.com/course/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%95%B5%EC%8B%AC%EC%9D%B4%EB%A1%A0-%EC%9D%91%EC%9A%A9', '동영상', '인프런', 'HOUR_5', 'medium', 'UNDER_50K', 36),
                                                                                                                                                                    (299, '생활코딩 - 네트워크 개념 잡기(도메인, 네임서버, HTTPS)', 'https://edu.goorm.io/lecture/12973/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B0%9C%EB%85%90-%EC%9E%A1%EA%B8%B0-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84%EC%84%9C%EB%B2%84-https', '동영상', 'goormedu', 'HOUR_3', 'low', 'FREE', 36),
                                                                                                                                                                    (300, '비전공자의 전공자 따라잡기 - 네트워크, HTTP', 'https://www.inflearn.com/course/%EC%A0%84%EA%B3%B5%EC%9E%90-%EB%94%B0%EB%9D%BC%EC%9E%A1%EA%B8%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-http', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 36),
                                                                                                                                                                    (301, '자바 무료 강의 2시간 완성 (1분 자바)', 'https://www.youtube.com/watch?v=DNCBaeCoMug', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 39),
                                                                                                                                                                    (302, 'Do it! 점프 투 자바', 'https://product.kyobobook.co.kr/detail/S000203246484', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 39),
                                                                                                                                                                    (303, '김영한의 자바 입문 - 코드로 시작하는 자바 첫걸음', 'https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%9E%90%EB%B0%94-%EC%9E%85%EB%AC%B8', '동영상', '인프런', 'OVER_10', 'low', 'FREE', 39),
                                                                                                                                                                    (304, '김영한의 실전 자바 - 기본편', 'https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B8%B0%EB%B3%B8%ED%8E%B8', '동영상', '인프런', 'OVER_10', 'low', 'UNDER_50K', 39),
                                                                                                                                                                    (305, '김영한의 실전 자바 - 중급 1편+김영한의 실전 자바 - 중급 2편', 'https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EC%A4%91%EA%B8%89-1', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_100K_200K', 39),
                                                                                                                                                                    (306, '김영한의 실전 자바 - 고급 1편, 멀티스레드와 동시성+김영한의 실전 자바 - 고급 2편, I/O, 네트워크, 리플렉션+김영한의 실전 자바 - 고급 3편, 람다, 스트림, 함수형 프로그래밍', 'https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1', '동영상', '인프런', 'OVER_10', 'high', 'UNKNOWN', 39),
                                                                                                                                                                    (307, 'Java의 정석', 'https://www.youtube.com/playlist?list=PLW2UjW795-f6xWA2_MUhEVgPauhGl3xIp', '동영상', '유튜브', 'OVER_10', 'high', 'FREE', 39),
                                                                                                                                                                    (308, 'java 소개', 'https://www.coursera.org/learn/java-introduction', '동영상', 'Coursera', 'OVER_10', 'low', 'FREE', 39),
                                                                                                                                                                    (309, '핵심 Java 특화 과정', 'https://www.coursera.org/specializations/core-java', '동영상', 'Coursera', 'OVER_10', 'medium', 'FREE', 39),
                                                                                                                                                                    (310, '최신 파이썬 코딩 무료 강의 | 2024 점프 투 파이썬 통합본', 'https://www.youtube.com/watch?v=ftQZo7XaTOA', '동영상', '유튜브', 'HOUR_10', 'low', 'FREE', 40),
                                                                                                                                                                    (311, '프로그래밍 시작하기 : 파이썬 입문 (Inflearn Original)+프로그래밍 시작하기 : 도전! 45가지 파이썬 기초 문법 실습 (Inflearn Original)', 'https://www.inflearn.com/course/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%9E%85%EB%AC%B8-%EC%9D%B8%ED%94%84%EB%9F%B0-%EC%98%A4%EB%A6%AC%EC%A7%80%EB%84%90?attributionToken=hwHwhgoMCJPhocAGEK79otcCEAEaJDY4MWIxNTdmLTAwMDAtMmY5NC1iNDJhLTg4M2QyNGY3Y2M3NCoHMTAzNjgyNzIso4CXIsXL8xfUsp0VwvCeFba3jC2o5aotmNa3LZruxjCQ97Iw9-jDMJvWty06DmRlZmF1bHRfc2VhcmNoSAFYAWgBegJzaQ', '동영상', '인프런', 'OVER_10', 'low', 'BETWEEN_50K_100K', 40),
                                                                                                                                                                    (312, '우리를 위한 프로그래밍 : 파이썬 중급 (Inflearn Original)', 'https://www.inflearn.com/course/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%A4%91%EA%B8%89-%EC%9D%B8%ED%94%84%EB%9F%B0-%EC%98%A4%EB%A6%AC%EC%A7%80%EB%84%90', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 40),
                                                                                                                                                                    (313, '모두를 위한 파이썬 : 필수 문법 배우기 Feat. 오픈소스 패키지 배포 (Inflearn Original)+고수가 되는 파이썬 : 동시성과 병렬성 문법 배우기 Feat. 멀티스레딩 vs 멀티프로세싱 (Inflearn Original)', 'https://www.inflearn.com/course/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%A4%91%EA%B3%A0%EA%B8%89', '동영상', '인프런', 'OVER_10', 'high', 'BETWEEN_100K_200K', 40),
                                                                                                                                                                    (314, '프로그래밍의 문을 열다: Python 입문', 'https://codingon.co.kr/lessonDetail', '동영상', '코딩온', 'OVER_10', 'low', 'UNDER_50K', 40),
                                                                                                                                                                    (315, 'Python 마스터로 가는 길: 고급 문법과 응용', 'https://codingon.co.kr/lessonDetail', '동영상', '코딩온', 'OVER_10', 'high', 'UNDER_50K', 40),
                                                                                                                                                                    (316, 'Python 활용 중급 과정', 'https://www.codeit.kr/paths/practical-python', '동영상', '코드잇', 'OVER_10', 'low', 'FREE', 40),
                                                                                                                                                                    (317, '생활코딩 - Python 입문', 'https://edu.goorm.io/lecture/28708/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9-python-%EC%9E%85%EB%AC%B8', '동영상', 'goormedu', 'HOUR_10', 'low', 'FREE', 40),
                                                                                                                                                                    (318, '점프 투 파이썬', 'https://wikidocs.net/book/1', '책', '위키독스', 'OVER_10', 'low', 'FREE', 40),
                                                                                                                                                                    (319, 'Kotlin 문법 총 정리 - 1시간', 'https://www.youtube.com/watch?v=OtHkb6wAI5U', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 42),
                                                                                                                                                                    (320, '자바 개발자를 위한 코틀린 입문(Java to Kotlin Starter Guide)', 'https://www.inflearn.com/course/java-to-kotlin', '동영상', '인프런', 'HOUR_5', 'low', 'BETWEEN_50K_100K', 42),
                                                                                                                                                                    (321, '코틀린 고급편', 'https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B3%A0%EA%B8%89%ED%8E%B8', '동영상', '인프런', 'HOUR_10', 'high', 'BETWEEN_50K_100K', 42),
                                                                                                                                                                    (322, '[중급편] 친절한 JETPACK 개론 <상> (Android Kotlin)+[중급편] 친절한 JETPACK 개론 <하> (Android Kotlin)', 'https://www.inflearn.com/course/%EC%B9%9C%EC%A0%88%ED%95%9C-jetpack-1', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_100K_200K', 42),
                                                                                                                                                                    (323, 'Complete Kotlin development masterclass', 'https://www.udemy.com/course/kotlinmasterclass/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'low', 'BETWEEN_100K_200K', 42),
                                                                                                                                                                    (324, 'Java 개발자를 위한 Kotlin', 'https://www.coursera.org/learn/kotlin-for-java-developers', '동영상', 'Coursera', 'OVER_10', 'medium', 'FREE', 42),
                                                                                                                                                                    (325, 'Kotlin의 고급 프로그래밍', 'https://www.coursera.org/learn/advanced-programming-in-kotlin', '동영상', 'Coursera', 'OVER_10', 'high', 'FREE', 42),
                                                                                                                                                                    (326, 'Google 공식 언어 Kotlin 프로그래밍 시작하기', 'https://edu.goorm.io/lecture/20670/google-%EA%B3%B5%EC%8B%9D-%EC%96%B8%EC%96%B4-kotlin-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0', '동영상', 'goormedu', 'OVER_10', 'low', 'UNDER_50K', 42),
                                                                                                                                                                    (327, 'Kotlin으로 만드는 심플셀스타그램 app', 'https://edu.goorm.io/lecture/45804/kotlin%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EC%8B%AC%ED%94%8C%EC%85%80%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8-app', '동영상', 'goormedu', 'HOUR_5', 'low', 'BETWEEN_100K_200K', 42),
                                                                                                                                                                    (328, 'Do it! 깡샘의 안드로이드 앱 프로그래밍 with 코틀린 [개정 4판] : 친절한 문법 설명 + 19개 실습 예제로 배우는 모바일 앱 개발', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000011035564', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 42),
                                                                                                                                                                    (329, '안드로이드 with Kotlin 앱 프로그래밍 가이드', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000002949014', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 42),
                                                                                                                                                                    (330, '코틀린 고급편', 'https://www.inflearn.com/course/코틀린-고급편', '동영상', '인프런', 'HOUR_10', 'high', 'UNDER_50K', 42),
                                                                                                                                                                    (331, '누구나 SQL - 기초', 'https://www.youtube.com/watch?v=60I72X_aKC4&list=PLb_vgczBBiSRwP4qEA4fvJyAqBWSSrNfq', '동영상', '유튜브', 'HOUR_10', 'low', 'FREE', 43),
                                                                                                                                                                    (332, 'SQL 마스터클래스', 'https://nomadcoders.co/sql-masterclass', '동영상', '노마드코더', 'OVER_10', 'low', 'UNDER_50K', 43),
                                                                                                                                                                    (333, '[SQL 기초 강의] 혼자 공부하는 SQL', 'https://www.youtube.com/watch?v=0cRhit1EJM0&list=PLVsNizTWUw7GCfy5RH27cQL5MeKYnl8Pm', '동영상', '유튜브', 'HOUR_10', 'low', 'FREE', 43),
                                                                                                                                                                    (334, '비전공자의 전공자 따라잡기 - 데이터베이스,SQL', 'https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%A0%84%EA%B3%B5%EC%9E%90-%EB%94%B0%EB%9D%BC%EC%9E%A1%EA%B8%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-sql', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 43),
                                                                                                                                                                    (335, '기초탄탄, SQL 톺아보기 (입문과정)', 'https://edu.goorm.io/lecture/45796/%EA%B8%B0%EC%B4%88%ED%83%84%ED%83%84-sql-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0-%EC%9E%85%EB%AC%B8%EA%B3%BC%EC%A0%95', '동영상', 'goormedu', 'HOUR_10', 'low', 'BETWEEN_100K_200K', 43),
                                                                                                                                                                    (336, '2025 이기적 SQL 개발자 이론서+기출문제', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000010603338', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 43),
                                                                                                                                                                    (337, 'Do it! SQL 입문', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000002945454', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 43),
                                                                                                                                                                    (338, '혼자 공부하는 SQL', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000002942571', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 43),
                                                                                                                                                                    (339, '[백문이불여일타] 데이터 분석을 위한 고급 SQL', 'https://www.inflearn.com/course/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D-%EA%B3%A0%EA%B8%89-sql#curriculum', '동영상', '인프런', 'HOUR_5', 'high', 'BETWEEN_50K_100K', 43),
                                                                                                                                                                    (340, 'The Ultimate MySQL Bootcamp: Go from SQL Beginner to Expert', 'https://www.udemy.com/course/the-ultimate-mysql-bootcamp-go-from-sql-beginner-to-expert/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'low', 'BETWEEN_100K_200K', 43),
                                                                                                                                                                    (341, 'Udacity Nanodegree: SQL', 'https://fastcampus.co.kr/dev_online_udacitysql', '동영상', '유데미', 'OVER_10', 'low', 'UNKNOWN', 43),
                                                                                                                                                                    (342, '[백문이불여일타] 데이터 분석을 위한 기초 SQL', 'https://www.inflearn.com/course/%EB%B0%B1%EB%AC%B8%EC%9D%B4%EB%B6%88%EC%97%AC%EC%9D%BC%ED%83%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D-%EA%B8%B0%EC%B4%88-sql', '동영상', '인프런', 'HOUR_3', 'low', 'UNDER_50K', 43),
                                                                                                                                                                    (343, '[백문이불여일타] 데이터 분석을 위한 중급 SQL', 'https://www.inflearn.com/course/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D-%EC%A4%91%EA%B8%89-sql', '동영상', '인프런', 'HOUR_5', 'medium', 'UNDER_50K', 43),
                                                                                                                                                                    (344, '처음 시작하는 MySQL DataBase', 'https://edu.goorm.io/lecture/13353/%EC%B2%98%EC%9D%8C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-mysql-database', '동영상', 'goormedu', 'HOUR_5', 'low', 'UNDER_50K', 44),
                                                                                                                                                                    (345, '갖고노는 MySQL 데이터베이스 by 얄코', 'https://www.inflearn.com/course/%EC%96%84%EC%BD%94-%EB%A7%88%EC%9D%B4%EC%97%90%EC%8A%A4%ED%81%90%EC%97%98#curriculum', '동영상', '인프런', 'HOUR_5', 'low', 'UNDER_50K', 44),
                                                                                                                                                                    (346, '[개념 콕] RDB, RDBMS, NoSQL', 'https://nbcamp.spartacodingclub.kr/blog/%EA%B0%9C%EB%85%90-%EC%BD%95-%EC%9B%B9-%EA%B0%9C%EB%B0%9C-%EC%A7%80%EC%8B%9D-spring%ED%8E%B8-rdb-rdbms-nosql-20953', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 44),
                                                                                                                                                                    (347, 'NoSQL 설명!! RDB와는 어떤 차이가 있는지도 설명!! MongoDB, Redis 매우 간단한 예제 포함!!', 'https://www.youtube.com/watch?v=sqVByJ5tbNA&t=18s', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 44),
                                                                                                                                                                    (348, '처음하는 MongoDB(몽고DB) 와 NoSQL(빅데이터) 데이터베이스 부트캠프 [입문부터 활용까지]', 'https://www.inflearn.com/course/nosql-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%AA%BD%EA%B3%A0db-%EC%9E%94%EC%9E%AC%EB%AF%B8%EC%BD%94%EB%94%A9', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 44),
                                                                                                                                                                    (349, 'Javascript로 배우는 NoSQL DB', 'https://www.inflearn.com/course/mongodb_grammar_basics', '동영상', '인프런', 'HOUR_5', 'low', 'UNDER_50K', 44),
                                                                                                                                                                    (350, 'NoSQL 이해', 'https://www.fun-coding.org/post/mongodb_basic1.html#gsc.tab=0', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 44),
                                                                                                                                                                    (351, 'MongoDB를 활용하여, 200억건 이상의 데이터 파이프라인 작성법', 'https://www.inflearn.com/course/%EC%8B%A4%EB%AC%B4%EC%9E%90%EB%8F%84-%EB%AA%A8%EB%A5%B4%EB%8A%94-mongo-%ED%99%9C%EC%9A%A9%EB%B2%95', '동영상', '인프런', 'HOUR_3', 'low', 'UNDER_50K', 44),
                                                                                                                                                                    (352, 'Learn MongoDB in 2 hours | NoSql Database', 'https://www.udemy.com/course/getting-started-with-mongodb/?couponCode=KRLETSLEARNNOW', '동영상', '유데미', 'HOUR_3', 'low', 'UNDER_50K', 44),
                                                                                                                                                                    (353, 'Redis : 개발자를 위한 Redis 완벽 가이드', 'https://www.udemy.com/course/redis-the-complete-developers-guide-korean/?couponCode=KRLETSLEARNNOW', '동영상', '유데미', 'OVER_10', 'medium', 'UNDER_50K', 44),
                                                                                                                                                                    (354, '한 눈에 끝내는 SQL', 'https://edu.goorm.io/lecture/15413/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-sql', '동영상', 'goormedu', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 45),
                                                                                                                                                                    (355, 'SQL 데이터베이스: 기초부터 데이터 모델링까지', 'https://www.codeit.kr/paths/sql-database-for-developers', '동영상', '코드잇', 'OVER_10', 'medium', 'UNDER_50K', 45),
                                                                                                                                                                    (356, 'SW 개발자를 위한 성능 좋은 SQL 쿼리 작성법', 'https://www.inflearn.com/course/%EC%84%B1%EB%8A%A5%EC%A2%8B%EC%9D%80-%EC%BF%BC%EB%A6%AC%EC%9E%91%EC%84%B1%EB%B2%95?srsltid=AfmBOop4B6wVQpH_jz6hmnmQbW7c76FN66qCPpiR_MsRcxyOjZ7w3nod', '동영상', '인프런', 'HOUR_10', 'high', 'BETWEEN_100K_200K', 45),
                                                                                                                                                                    (357, '업무에 바로 쓰는 SQL 튜닝', 'https://www.inflearn.com/course/%EC%97%85%EB%AC%B4-sql-%ED%8A%9C%EB%8B%9D?srsltid=AfmBOor_2B3r1qc4Gc0VQ3Wcssas-gWyYgximCXJV9TRBxb_Y1rHAyDZ', '동영상', '인프런', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 45),
                                                                                                                                                                    (358, '비전공자도 이해할 수 있는 MySQL 성능 최적화 입문/실전 (SQL 튜닝편)', 'https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-mysql-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%95%ED%99%95-sql%ED%8A%9C%EB%8B%9D?srsltid=AfmBOoonqPu1uF2BxvwiyKUEHDcK51ynZXjzmhe_9LE5OLnAfuLjF428', '동영상', '인프런', 'HOUR_3', 'medium', 'BETWEEN_50K_100K', 45),
                                                                                                                                                                    (359, 'SQL Tuning', 'https://www.youtube.com/playlist?list=PLCkO8I_DSQ7ejSSRg0FjAC6Y9aiEWeO0a', '동영상', '유튜브', 'HOUR_5', 'medium', 'FREE', 45),
                                                                                                                                                                    (360, 'SQL SERVER 튜닝 가이드(이론편)', 'https://www.youtube.com/playlist?list=PLCkO8I_DSQ7dbWnsv0-DLsmjR_b2OguPU', '동영상', '유튜브', 'HOUR_5', 'high', 'FREE', 45),
                                                                                                                                                                    (361, 'SQL SERVER 튜닝 가이드(실습편)', 'https://www.youtube.com/playlist?list=PLCkO8I_DSQ7e8fRtslphWS9fGkClGkxfr', '동영상', '유튜브', 'HOUR_5', 'high', 'FREE', 45),
                                                                                                                                                                    (362, 'SQL Server 컨설턴트가 알려주는, 쿼리 능력 레벨업(고급 T-SQL 쿼리)', 'https://www.inflearn.com/course/sql-%EC%BF%BC%EB%A6%AC%EB%8A%A5%EB%A0%A5', '동영상', '인프런', 'HOUR_10', 'high', 'UNDER_50K', 45),
                                                                                                                                                                    (363, '스프링 부트 (Spring Boot) 강의', 'https://www.youtube.com/watch?v=rHJgMRimJ4Y&list=PLlTylS8uB2fBOi6uzvMpojFrNe7sRmlzU', '동영상', '유튜브', 'OVER_10', 'low', 'FREE', 46),
                                                                                                                                                                    (364, '스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8?srsltid=AfmBOorhf7FZ7EFxoVHw6EgjQh2J2Gwya9a2oGKIlkr7yyX5oXo46KzF', '동영상', '인프런', 'HOUR_10', 'low', 'FREE', 46),
                                                                                                                                                                    (365, '쉽게 배우는 Spring Boot & JPA', 'https://codingapple.com/course/spring-boot-jpa/', '동영상', '코딩애플', 'HOUR_5', 'low', 'BETWEEN_50K_100K', 46),
                                                                                                                                                                    (366, '자바 스프링 프레임워크(renew ver.) - 신입 프로그래머를 위한 강좌', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC_renew', '동영상', '인프런', 'OVER_10', 'low', 'UNDER_50K', 46),
                                                                                                                                                                    (367, 'Java 마이크로서비스(MSA) 프로젝트 실습', 'https://www.inflearn.com/course/java-msa-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%A4%EC%8A%B5', '동영상', '인프런', 'HOUR_10', 'high', 'BETWEEN_50K_100K', 46),
                                                                                                                                                                    (368, '스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-1', '동영상', '인프런', 'OVER_10', 'low', 'BETWEEN_50K_100K', 46),
                                                                                                                                                                    (369, '스프링 MVC 2편 - 백엔드 웹 개발 활용 기술', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2', '동영상', '인프런', 'OVER_10', 'low', 'UNDER_50K', 46),
                                                                                                                                                                    (370, '스프링 DB 1편 - 데이터 접근 핵심 원리', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-db-1', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 46),
                                                                                                                                                                    (371, '실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1', '동영상', '인프런', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 46),
                                                                                                                                                                    (372, '스프링 부트 - 핵심 원리와 활용', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%ED%95%B5%EC%8B%AC%EC%9B%90%EB%A6%AC-%ED%99%9C%EC%9A%A9', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 46),
                                                                                                                                                                    (373, '스프링 MVC 2편 - 백엔드 웹 개발 활용 기술', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-mvc-2', '동영상', '인프런', 'OVER_10', 'medium', 'UNDER_50K', 46),
                                                                                                                                                                    (374, '스프링 프레임워크는 내 손에 [스프1탄]', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84-spring-1', '동영상', '인프런', 'OVER_10', 'low', 'UNDER_50K', 46),
                                                                                                                                                                    (375, '스프링 마이크로서비스 코딩 공작소', 'https://product.kyobobook.co.kr/detail/S000061351987', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 46),
                                                                                                                                                                    (376, '[NarP Series] MVC 프레임워크는 내 손에 [나프2탄]', 'https://www.inflearn.com/course/%EB%82%98%ED%94%84-mvc-2', '동영상', '인프런', 'OVER_10', 'low', 'UNDER_50K', 46),
                                                                                                                                                                    (377, '스프링 핵심 원리 - 고급편', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8', '동영상', '인프런', 'OVER_10', 'high', 'UNDER_50K', 46),
                                                                                                                                                                    (378, '스프링부트 게시판 프로젝트', 'https://www.youtube.com/watch?v=YshcPPHClR4&list=PLV9zd3otBRt7jmXvwCkmvJ8dH5tR_20c0', '동영상', '유튜브', 'HOUR_5', 'medium', 'FREE', 46),
                                                                                                                                                                    (379, '스프링과 스프링부트(Spring Boot)ㅣ정의, 특징, 사용 이유, 생성 방법', 'https://www.codestates.com/blog/content/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 46),
                                                                                                                                                                    (380, '스프링 부트 3 핵심 가이드', 'https://product.kyobobook.co.kr/detail/S000216104276', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 46),
                                                                                                                                                                    (381, '스프링 부트 3 백엔드 개발자 되기: 자바 편', 'https://product.kyobobook.co.kr/detail/S000212798297', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 46),
                                                                                                                                                                    (382, '【한글자막】 Spring Boot 3 & Spring Framework 6 마스터하기! [최신판]', 'https://www.udemy.com/course/spring-boot-and-spring-framework-korean', '동영상', '유데미', 'OVER_10', 'high', 'BETWEEN_100K_200K', 46),
                                                                                                                                                                    (383, 'Do it! Node.js 프로그래밍 입문', 'https://www.youtube.com/playlist?list=PLG7te9eYUi7vxSvo6hvhOaht8oP0PoCwi', '동영상', '유튜브', 'HOUR_5', 'low', 'FREE', 47),
                                                                                                                                                                    (384, 'WEB2 - Node.js', 'https://opentutorials.org/course/3332', '동영상', '생활코딩', 'HOUR_3', 'medium', 'FREE', 47),
                                                                                                                                                                    (385, '얄코의 Node.js (Korean ver.)', 'https://www.inflearn.com/course/%EC%96%84%EC%BD%94-node-js', '동영상', '인프런', 'HOUR_5', 'low', 'UNDER_50K', 47),
                                                                                                                                                                    (386, 'NodeJS - The Complete Guide (MVC, REST APIs, GraphQL, Deno)', 'https://www.udemy.com/course/nodejs-the-complete-guide/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'low', 'BETWEEN_100K_200K', 47),
                                                                                                                                                                    (387, 'Node.js로 백엔드 서버 개발하기', 'https://www.codeit.kr/paths/nodejs-backend-development', '동영상', '코드잇', 'OVER_10', 'medium', 'FREE', 47),
                                                                                                                                                                    (388, 'Node.js 서버 프로그래밍 과정', 'https://edu.goorm.io/lecture/13564/node-js-%EC%84%9C%EB%B2%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B3%BC%EC%A0%95', '동영상', 'goormedu', 'OVER_10', 'medium', 'UNDER_50K', 47),
                                                                                                                                                                    (389, '[저자 직강] Do it! Node.js 프로그래밍', 'https://edu.goorm.io/lecture/12534/%EC%A0%80%EC%9E%90-%EC%A7%81%EA%B0%95-do-it-node-js-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D', '동영상', 'goormedu', 'OVER_10', 'medium', 'FREE', 47),
                                                                                                                                                                    (390, '한시간만에 Node.js 백엔드 기초 끝내기 (ft. API 구축)', 'https://www.youtube.com/watch?v=Tt_tKhhhJqY', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 47),
                                                                                                                                                                    (391, 'Do it! Node.js 프로그래밍 입문', 'https://www.youtube.com/watch?v=4inLYlZOKAU&list=PLG7te9eYUi7vxSvo6hvhOaht8oP0PoCwi', '동영상', '유튜브', 'HOUR_10', 'low', 'FREE', 47),
                                                                                                                                                                    (392, 'Do it! Node.js 프로그래밍 입문 : 쉽고 빠르게 달리는 백엔드 개발', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000005463761', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 47),
                                                                                                                                                                    (393, 'Node.js 프로젝트 투입 일주일 전', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000002955356', '책', '교보문고', 'OVER_10', 'high', 'UNDER_50K', 47),
                                                                                                                                                                    (394, '생활코딩! Node.js 노드제이에스 프로그래밍', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000002928538', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 47),
                                                                                                                                                                    (395, '테스트주도개발(TDD)로 만드는 NodeJS API 서버', 'https://www.inflearn.com/course/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C-tdd-nodejs-api', '동영상', '인프런', 'HOUR_5', 'medium', 'UNDER_50K', 47),
                                                                                                                                                                    (396, '【한글자막】 NodeJS 완벽 가이드 : MVC, REST APIs, GraphQL, Deno', 'https://www.udemy.com/course/nodejs-mvc-rest-apis-graphql-deno/', '동영상', '유데미', 'OVER_10', 'high', 'BETWEEN_100K_200K', 47),
                                                                                                                                                                    (397, 'Vue.js - Django Web Programming (Blog CRUD and Auth)', 'https://www.udemy.com/course/vuejs-django-web-programming-blog-crud-and-auth/?couponCode=ST8MT220425G1', '동영상', '유데미', 'HOUR_5', 'medium', 'BETWEEN_50K_100K', 48),
                                                                                                                                                                    (398, 'python django tutorial 강좌', 'https://www.youtube.com/watch?v=alrLd9T96aA&list=PLi4xPOplIq7d1vDdLBAvS5PmQR-p6KwUz', '동영상', '유튜브', 'HOUR_5', 'low', 'FREE', 48),
                                                                                                                                                                    (399, '작정하고 장고! Django REST Framework 편', 'https://www.youtube.com/watch?v=1qiQkKshMUs&list=PLQFurmxCuZ2Qmcl0TJame_N79kP2o7VzG', '동영상', '유튜브', 'HOUR_5', 'low', 'FREE', 48),
                                                                                                                                                                    (400, '【한글자막】 Django 4 및 Python 풀스택 개발자 마스터 클래스', 'https://www.udemy.com/course/django-4-python/?couponCode=ST8MT220425G1', '동영상', '유데미', 'HOUR_5', 'medium', 'BETWEEN_100K_200K', 48),
                                                                                                                                                                    (401, '실전! Django 활용', 'https://www.inflearn.com/course/%EC%8B%A4%EC%A0%84-django-%ED%99%9C%EC%9A%A9#curriculum', '동영상', '인프런', 'HOUR_5', 'medium', 'BETWEEN_50K_100K', 48),
                                                                                                                                                                    (402, '모두를 위한 장고 특화 과정', 'https://www.coursera.org/specializations/django', '동영상', 'Coursera', 'OVER_10', 'medium', 'FREE', 48),
                                                                                                                                                                    (403, 'Django로 하나로 완성하는 MVP 개발', 'https://www.codeit.kr/paths/django-web-development', '동영상', '코드잇', 'OVER_10', 'medium', 'FREE', 48),
                                                                                                                                                                    (404, 'Django 한 그릇 뚝딱', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000002986653', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 48),
                                                                                                                                                                    (405, '이한영의 Django(장고) 입문', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000005171331', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 48),
                                                                                                                                                                    (406, '장고 기초 끝내기(django Framework)', 'https://www.youtube.com/playlist?list=PLpzDq-W37heQVO-5JnVMp1blZH3M0lo5Z', '동영상', '유튜브', 'HOUR_10', 'low', 'UNDER_50K', 48),
                                                                                                                                                                    (407, 'Python Flask Web Framework', 'https://www.youtube.com/playlist?list=PLuHgQVnccGMClNOIuT3b3M4YZjxmult2y', '동영상', '생활코딩', 'HOUR_1', 'low', 'FREE', 49),
                                                                                                                                                                    (408, '점프 투 플라스크', 'https://wikidocs.net/book/4542', '책', '위키독스', 'OVER_10', 'low', 'FREE', 49),
                                                                                                                                                                    (409, '【한글자막】 Python FLASK로 웹사이트 만들기', 'https://www.udemy.com/course/python-flask-jose/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 49),
                                                                                                                                                                    (410, 'flask/플라스크와 백엔드 기본', 'https://www.inflearn.com/course/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%92%80%EC%8A%A4%ED%83%9D-1', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 49),
                                                                                                                                                                    (411, '파이썬 플라스크(Flask) 기반 웹 개발 및 업무 자동화 서비스 활용', 'https://www.inflearn.com/course/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%94%8C%EB%9D%BC%EC%8A%A4%ED%81%AC-%EC%9B%B9%EC%84%9C%EB%B9%84%EC%8A%A4', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 49),
                                                                                                                                                                    (412, 'Python용 Flask 알아보기 - 전체 튜토리얼', 'https://www.youtube.com/watch?v=Z1RJmh_OqeA', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 49),
                                                                                                                                                                    (413, 'REST APIs with Flask and Python in 2025', 'https://www.udemy.com/course/rest-api-flask-and-python/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'medium', 'BETWEEN_100K_200K', 49),
                                                                                                                                                                    (414, 'Flask 기반의 파이썬 웹 프로그래밍', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000002970916', '책', '교보문고', 'OVER_10', 'high', 'UNDER_50K', 49),
                                                                                                                                                                    (415, 'Flask for Beginners: Creating an Application', 'https://www.coursera.org/projects/flask-for-beginners-creating-an-application', '동영상', 'Coursera', 'HOUR_3', 'low', 'FREE', 49),
                                                                                                                                                                    (416, 'Python Flask', 'https://www.youtube.com/playlist?list=PLEOnZ6GeucBWvOGSbIKNMp6RMQL9LYRc3', '동영상', '유튜브', 'HOUR_10', 'low', 'FREE', 49),
                                                                                                                                                                    (417, 'Flask Tutorial Note Web App', 'https://wikidocs.net/book/8078', '책', '위키독스', 'HOUR_3', 'low', 'FREE', 49),
                                                                                                                                                                    (418, '파이썬과 파이어베이스로 커뮤니티 사이트 만들기', 'https://www.youtube.com/playlist?list=PLqIc89sXpwUCjwzRImFjO2UL8lBopRajj', '동영상', '유튜브', 'HOUR_3', 'nan', 'FREE', 49),
                                                                                                                                                                    (419, '실전! 코틀린과 스프링 부트로 도서관리 애플리케이션 개발하기', 'https://www.inflearn.com/course/java-to-kotlin-2?srsltid=AfmBOorwYhOYGDjLQCkG__yqs__NHBpONEGNDTt7xNCGRKkYhpRvFNEA', '동영상', '인프런', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 50),
                                                                                                                                                                    (420, '자바 개발자를 위한 코틀린 입문', 'https://www.inflearn.com/course/java-to-kotlin', '동영상', '인프런', 'HOUR_10', 'low', 'BETWEEN_50K_100K', 50),
                                                                                                                                                                    (421, '은행 서버 프로젝트 실습을 통해 배우는 코틀린 마스터 클래스', 'https://www.inflearn.com/course/%EC%9D%80%ED%96%89%EC%84%9C%EB%B2%84-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%8B%A4%EC%8A%B5-%EC%BD%94%ED%8B%80%EB%A6%B0-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%81%B4%EB%9E%98%EC%8A%A4', '동영상', '인프런', 'HOUR_10', 'medium', 'UNDER_50K', 50),
                                                                                                                                                                    (422, '스프링부트+코틀린 - 블로그 프로젝트', 'https://www.youtube.com/watch?v=Fjf5_NQnDVw&list=PLiLLi47PCMPjdezfGUnayz5PwEfwAQCBi', '동영상', '유튜브', 'HOUR_10', 'medium', 'FREE', 50),
                                                                                                                                                                    (423, '코틀린 문법부터 실무까지 (실전 자바->코틀린 변환)', 'https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EB%AC%B8%EB%B2%95-%EC%8B%A4%EB%AC%B4-%EC%9E%90%EB%B0%94to%EC%BD%94%ED%8B%80%EB%A6%B0', '동영상', '인프런', 'OVER_10', 'high', 'UNDER_50K', 50),
                                                                                                                                                                    (424, 'Spring Boot & JPA에서 Java와 Kotlin을 함께 사용하기', 'https://tech.inflab.com/20240110-java-and-kotlin/', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 50),
                                                                                                                                                                    (425, '[입문] 누구나 배울 수 있는 코틀린(Kotlin)', 'https://www.inflearn.com/course/kotlin-%EC%9E%85%EB%AC%B8', '동영상', '인프런', 'HOUR_5', 'low', 'UNDER_50K', 50),
                                                                                                                                                                    (426, 'Kotlin 및 Spring Boot 를 사용하여 RESTFUL API 구축하기', 'https://www.udemy.com/course/build-restful-apis-using-kotlin-and-spring-boot-korean/?couponCode=ST8MT220425G1', '동영상', '유데미', 'HOUR_10', 'medium', 'UNDER_50K', 50),
                                                                                                                                                                    (427, '[고급] Kotlin(코틀린) 개발자를 위한 마스터클래스', 'https://www.udemy.com/course/kotlin-part1/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'high', 'UNDER_50K', 50),
                                                                                                                                                                    (428, '[초급] 맛보자! 코틀린과 스프링으로 API 호출하기', 'https://www.inflearn.com/course/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%8A%A4%ED%94%84%EB%A7%81-api%ED%98%B8%EC%B6%9C-%EC%9E%85%EB%AC%B8?srsltid=AfmBOooOAx44LNVHnS2jyUEBhEWH7kue1OV6yWhDmrlq3ECLKeBpGGXd', '동영상', '인프런', 'HOUR_3', 'low', 'FREE', 50),
                                                                                                                                                                    (429, '코틀린 쿡북', 'https://www.yes24.com/product/goods/90452827', '책', 'Yes24', 'HOUR_10', 'medium', 'UNDER_50K', 50),
                                                                                                                                                                    (430, '코틀린 마이크로서비스 개발', 'https://www.yes24.com/product/goods/68796734', '책', 'Yes24', 'OVER_10', 'high', 'UNDER_50K', 50),
                                                                                                                                                                    (431, '자바 ORM 표준 JPA 프로그래밍 - 기본편', 'https://www.inflearn.com/course/ORM-JPA-Basic', '동영상', '인프런', 'OVER_10', 'low', 'BETWEEN_50K_100K', 51),
                                                                                                                                                                    (432, '실전! 스프링 데이터 JPA', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA-%EC%8B%A4%EC%A0%84', '동영상', '인프런', 'HOUR_10', 'medium', 'BETWEEN_50K_100K', 51),
                                                                                                                                                                    (433, '실전! Querydsl', 'https://www.inflearn.com/course/Querydsl-%EC%8B%A4%EC%A0%84', '동영상', '인프런', 'HOUR_10', 'high', 'BETWEEN_50K_100K', 51),
                                                                                                                                                                    (434, 'ORM, JPA, Spring Data JPA 적용하기 [ 스프링 부트 (Spring Boot) ]', 'https://www.youtube.com/watch?v=OiAYmtq4Av8', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 51),
                                                                                                                                                                    (435, '자바 ORM 표준 JPA 프로그래밍', 'https://product.kyobobook.co.kr/detail/S000000935744', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 51),
                                                                                                                                                                    (436, '[Spring] ORM (Object Relational Mapping) 이란?', 'https://velog.io/@matcha_/Spring-ORM-Object-Relational-Mapping-%EC%9D%B4%EB%9E%80', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 51),
                                                                                                                                                                    (437, '스프링 배치', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B0%B0%EC%B9%98', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 51),
                                                                                                                                                                    (438, 'Spring Batch란? 간단한 개념과 코드 살펴보기', 'https://dkswnkk.tistory.com/707', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 51),
                                                                                                                                                                    (439, '스프링 시큐리티 완전 정복 [6.x 개정판]', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B5', '동영상', '인프런', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 51),
                                                                                                                                                                    (440, '스프링 시큐리티 OAuth2', 'https://www.inflearn.com/course/%EC%A0%95%EC%88%98%EC%9B%90-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8B%9C%ED%81%90%EB%A6%AC%ED%8B%B0', '동영상', '인프런', 'OVER_10', 'high', 'UNDER_50K', 51),
                                                                                                                                                                    (441, '스프링 시큐리티', 'https://www.youtube.com/watch?v=y0PXQgrkb90&list=PLJkjrxxiBSFCKD9TRKDYn7IE96K2u3C3U', '동영상', '유튜브', 'HOUR_3', 'medium', 'FREE', 51),
                                                                                                                                                                    (442, 'Spring Security', 'https://spring.io/projects/spring-security', '블로그', '공식문서', 'HOUR_3', 'low', 'FREE', 51),
                                                                                                                                                                    (443, '【한글자막】 Spring Security 6 초보에서 마스터 되기 최신강의! (JWT , OAUTH2 포함)', 'https://www.udemy.com/course/spring-security-6-jwt-oauth2-korean/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'medium', 'UNDER_50K', 51),
                                                                                                                                                                    (444, 'Logback vs SLF4J vs Log4J2 - 차이점은 무엇입니까? 자바 두뇌 두뇌 바이트', 'https://www.youtube.com/watch?v=SWHYrCXIL38&t=90s', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 51),
                                                                                                                                                                    (445, '개발자에게 필요한 로그 관리', 'https://www.inflearn.com/course/%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%97%90%EA%B2%8C-%ED%95%84%EC%9A%94%ED%95%9C-%EB%A1%9C%EA%B7%B8%EA%B4%80%EB%A6%AC#curriculum', '동영상', '인프런', 'HOUR_3', 'medium', 'UNDER_50K', 51),
                                                                                                                                                                    (446, '[Spring Boot] 테스트 코드', 'https://sjh9708.tistory.com/195', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 51),
                                                                                                                                                                    (447, 'Java/Spring 테스트를 추가하고 싶은 개발자들의 오답노트', 'https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%98%A4%EB%8B%B5%EB%85%B8%ED%8A%B8', '동영상', '인프런', 'HOUR_10', 'medium', 'UNDER_50K', 51),
                                                                                                                                                                    (448, '스프링부트 JUnit 테스트 - 시큐리티를 활용한 Bank 애플리케이션', 'https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-junit-%ED%85%8C%EC%8A%A4%ED%8A%B8', '동영상', '인프런', 'OVER_10', 'medium', 'UNDER_50K', 51),
                                                                                                                                                                    (449, 'Springboot Test(종합)', 'https://www.youtube.com/playlist?list=PLeMeDIV7bypssYJ4ezUDEru-39G1gwXvr', '동영상', '유튜브', 'HOUR_5', 'high', 'FREE', 51),
                                                                                                                                                                    (450, 'Node.js - Express', 'https://www.inflearn.com/course/node-js-express#curriculum', '동영상', '인프런', 'HOUR_10', 'medium', 'FREE', 54),
                                                                                                                                                                    (451, 'Node.js, Express, MongoDB & More: The Complete Bootcamp', 'https://www.udemy.com/course/nodejs-express-mongodb-bootcamp/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'high', 'BETWEEN_100K_200K', 54),
                                                                                                                                                                    (452, 'Node.js 및 Express로 백엔드 앱 개발하기', 'https://www.coursera.org/learn/developing-backend-apps-with-nodejs-and-express', '동영상', 'Coursera', 'OVER_10', 'medium', 'FREE', 54),
                                                                                                                                                                    (453, 'Node.js 및 Express를 사용한 RESTful 마이크로서비스 특화 과정', 'https://www.coursera.org/specializations/restful-microservices-using-node-js-and-express', '동영상', 'Coursera', 'OVER_10', 'high', 'FREE', 54),
                                                                                                                                                                    (454, 'Node.js 백엔드 개발자 되기', 'https://ebook-product.kyobobook.co.kr/dig/epd/ebook/E000005200379', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 54),
                                                                                                                                                                    (455, 'Node.js에 TypeScript 적용하기(feat. NodeBird)', 'https://www.inflearn.com/course/nodejs-typescript-%EC%A0%81%EC%9A%A9', '동영상', '인프런', 'HOUR_10', 'medium', 'UNDER_50K', 54),
                                                                                                                                                                    (456, 'Node.js 백엔드 서버 개발 소개(Fastify + Prisma + Typescript와 함께하는)', 'https://www.youtube.com/playlist?list=PLEU9vwKdoCqR9yTVGnfq1tIu5wPraKDV-', '동영상', '유튜브', 'HOUR_3', 'medium', 'FREE', 54),
                                                                                                                                                                    (457, 'WEB5 - Express Passport.js', 'https://www.inflearn.com/course/WEB5-Express-Passport-js', '동영상', '인프런', 'HOUR_3', 'low', 'FREE', 54),
                                                                                                                                                                    (458, 'EXPRESS.JS: Learn Node! Node js & Express js - Master Nodejs', 'https://www.udemy.com/course/expressjs-learn-node-node-js-express-js-master-nodejs/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'high', 'BETWEEN_50K_100K', 54),
                                                                                                                                                                    (459, 'Express JS #15 - Passport.js Authentication', 'https://www.youtube.com/watch?v=_lZUq39FGv0', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 54),
                                                                                                                                                                    (460, 'Unit Testing for Typescript & NodeJs Developers with Jest', 'https://www.udemy.com/course/unit-testing-typescript-nodejs', '동영상', '유데미', 'OVER_10', 'medium', 'BETWEEN_50K_100K', 54),
                                                                                                                                                                    (461, 'APTRS DOCS', 'https://aptrs.com/latest/custom-report/pdf/pdf/', '책', '공식문서', 'OVER_10', 'medium', 'FREE', 56),
                                                                                                                                                                    (462, 'Python Django CRM - Course', 'https://www.youtube.com/playlist?list=PLpyspNLjzwBka94O3ABYcRYk8IaBR8hXZ', '동영상', '유튜브', 'HOUR_10', 'medium', 'FREE', 56),
                                                                                                                                                                    (463, '작정하고 장고! Django REST Framework 편', 'https://www.youtube.com/playlist?list=PLQFurmxCuZ2Qmcl0TJame_N79kP2o7VzG', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 56),
                                                                                                                                                                    (464, 'django REST framework', 'https://www.django-rest-framework.org/', '책', '공식문서', 'OVER_10', 'low', 'FREE', 56),
                                                                                                                                                                    (465, 'DjangoCRM', 'https://github.com/DjangoCRM/django-crm?tab=readme-ov-file', '책', 'GitHub', 'OVER_10', 'low', 'FREE', 56),
                                                                                                                                                                    (466, 'Django REST Framework 핵심사항', 'https://www.inflearn.com/course/%EC%9E%A5%EA%B3%A0-drf', '동영상', '인프런', 'HOUR_5', 'low', 'UNDER_50K', 56),
                                                                                                                                                                    (467, 'REST APIs with Flask and Python in 2025', 'https://www.udemy.com/course/rest-api-flask-and-python/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'low', 'BETWEEN_100K_200K', 58),
                                                                                                                                                                    (468, 'marshmallow flask python', 'https://www.youtube.com/playlist?list=PLwbVI2LKRNRysiK1pLESNU6kNBSRxSj3I', '동영상', '유튜브', 'HOUR_5', 'low', 'FREE', 58),
                                                                                                                                                                    (469, 'Python Web | Introduction To Flask SQLAlchemy | CRUD Operations', 'https://www.youtube.com/watch?v=wmIoQaLzhA4', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 58),
                                                                                                                                                                    (470, 'Flask SQLAlchemy', 'https://www.youtube.com/playlist?list=PLXmMXHVSvS-BlLA5beNJojJLlpE0PJgCW', '동영상', '유튜브', 'HOUR_10', 'medium', 'FREE', 58),
                                                                                                                                                                    (471, '[Flask] Flask-WTF을 이용한 form 사용하기', 'https://velog.io/@___pepper/Flask-Flask-WTF%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-form-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 58),
                                                                                                                                                                    (472, 'flask-marshmallow', 'https://github.com/marshmallow-code/flask-marshmallow', '책', 'GitHub', 'HOUR_1', 'low', 'FREE', 58),
                                                                                                                                                                    (473, 'Flask-SQLAlchemy Docs', 'https://flask-sqlalchemy.readthedocs.io/en/stable/', '책', '공식문서', 'OVER_10', 'low', 'FREE', 58),
                                                                                                                                                                    (474, 'Flask-Migrate', 'https://flask-migrate.readthedocs.io/en/latest/', '책', '공식문서', 'OVER_10', 'low', 'FREE', 58),
                                                                                                                                                                    (475, 'Jenkins를 이용한 CI/CD Pipeline 구축', 'https://www.inflearn.com/course/%EC%A0%A0%ED%82%A8%EC%8A%A4-ci-cd-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%9D%BC%EC%9D%B8', '동영상', '인프런', 'OVER_10', 'low', 'BETWEEN_50K_100K', 53),
                                                                                                                                                                    (476, 'DevOps를 위한 Docker 가상화 기술(Private Harbor Registry)', 'https://www.inflearn.com/course/devops-docker-%EA%B0%80%EC%83%81%ED%99%94-%EA%B8%B0%EC%88%A0', '동영상', '인프런', 'OVER_10', 'low', 'BETWEEN_50K_100K', 53),
                                                                                                                                                                    (477, '1시간만에 치킨 콤보값으로 배우는 서버 배포', 'https://www.inflearn.com/course/1%EC%8B%9C%EA%B0%84%EB%A7%8C%EC%97%90-%EC%B9%98%ED%82%A8%EC%BD%A4%EB%B3%B4%EA%B0%92-%EC%84%9C%EB%B2%84-%EB%B0%B0%ED%8F%AC', '동영상', '인프런', 'HOUR_1', 'low', 'UNDER_50K', 53),
                                                                                                                                                                    (478, '그래서 웹서비스는 하나 만들었는데 배포는 어떻게 함?(AWS)', 'https://www.youtube.com/watch?v=cOUhREAWJNw', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 53),
                                                                                                                                                                    (479, 'AWS EC2 + Nginx + Docker + SpringBoot + GitHub Action 무중단 배포(Deploy)', 'https://www.youtube.com/playlist?list=PLcyPfaKZ8Ykg4OkqAhFgwLvASs5T_-UjE', '동영상', '유튜브', 'HOUR_5', 'medium', 'FREE', 53),
                                                                                                                                                                    (480, '스프링 부트로 만든 백엔드 서버 처음으로 AWS EC2에 배포해보기!', 'https://www.youtube.com/watch?v=-imYJdLJAU4', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 53),
                                                                                                                                                                    (481, '실전 대비! DevOps 인터뷰 완벽 정복 - 고급편', 'https://www.inflearn.com/course/%EB%8D%B0%EB%B8%8C%EC%98%B5%EC%8A%A4-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%99%84%EB%B2%BD-%EC%A0%95%EB%B3%B5', '동영상', '인프런', 'HOUR_3', 'high', 'UNDER_50K', 53),
                                                                                                                                                                    (482, '처음 시작하는 Infrastructure as Code : AWS & 테라폼', 'https://www.inflearn.com/course/%EB%8D%B0%EB%B8%8C%EC%98%B5%EC%8A%A4-%ED%85%8C%EB%9D%BC%ED%8F%BC-aws', '동영상', '인프런', 'HOUR_5', 'medium', 'UNDER_50K', 53),
                                                                                                                                                                    (483, '비전공자도 이해할 수 있는 CI/CD 입문 실전', 'https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-ci-cd-%EC%9E%85%EB%AC%B8-%EC%8B%A4%EC%A0%84', '동영상', '인프런', 'HOUR_10', 'low', 'BETWEEN_50K_100K', 53),
                                                                                                                                                                    (484, '하루만에 배우는 express with AWS', 'https://www.inflearn.com/course/%ED%95%98%EB%A3%A8%EB%A7%8C%EC%97%90-%EB%A7%8C%EB%93%9C%EB%8A%94-express-aws', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 55),
                                                                                                                                                                    (485, 'Node.js로 웹 서버 만들기 : Heroku로 배포하기', 'https://www.youtube.com/watch?v=igFgJ5KENy0', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 55),
                                                                                                                                                                    (486, '지금 당장 데브옵스 AWS', 'https://www.inflearn.com/course/지금-당장-데브옵스-aws', '책', '인프런', 'OVER_10', 'low', 'UNDER_50K', 55),
                                                                                                                                                                    (487, 'AWS EC2 접속하기 | Node.js 서버 클라우드에 띄우기', 'https://www.youtube.com/watch?v=lzZ9KSGh6eI', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 55),
                                                                                                                                                                    (488, 'Serverless Framework Guide: API Gateway, AWS & Node.js', 'https://www.udemy.com/course/aws-lambda-serverless-framework-build-ecommerce-apis/?kw=node.js+server&src=sac&couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'low', 'BETWEEN_50K_100K', 55),
                                                                                                                                                                    (489, '백엔드 서버 클릭 몇번으로 무료 배포하는 방법', 'https://www.youtube.com/watch?v=SGGebq48h3Y&t=77s', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 55),
                                                                                                                                                                    (490, 'Build and Deploy a NodeJS API', 'https://www.udemy.com/course/build-and-deploy-a-nodejs-api/?srsltid=AfmBOorHLtFnIM-wjvPYeKPWMEldz8PjHdnKktV-e8xf51ooPnsPGoWu&utm_source=chatgpt.com', '동영상', '유데미', 'HOUR_1', 'high', 'FREE', 55),
                                                                                                                                                                    (491, 'Full Node.js Deployment to AWS - FREE SSL, NGINX | Node js HTTPS Server', 'https://www.youtube.com/watch?v=yhiuV6cqkNs', '동영상', '유튜브', 'HOUR_1', 'high', 'FREE', 55),
                                                                                                                                                                    (492, 'Deploy NodeJS app with PM2 on AWS EC2 instance | Deploying NodeJS in AWS by AWS Avinash Reddy', 'https://www.youtube.com/watch?v=rI6Cr4QqUm4', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 55),
                                                                                                                                                                    (493, 'Deploying Node.js App With PM2', 'https://www.youtube.com/watch?v=RF6Dzwwpduo', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 55),
                                                                                                                                                                    (494, 'Vercel로 Flask 배포하기', 'https://velog.io/@seondal/Vercel-Flask-무료로-배포하기', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 59),
                                                                                                                                                                    (495, '[Python] Flask + uWSGI + Nginx를 연결 및 배포', 'https://soyoung-new-challenge.tistory.com/118', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 59),
                                                                                                                                                                    (496, 'Flask 또는 Django를 Production 서버로 배포(Deploy)하기', 'https://jay-flow.medium.com/flask-%EB%98%90%EB%8A%94-django%EB%A5%BC-production-%EC%84%9C%EB%B2%84%EB%A1%9C-%EB%B0%B0%ED%8F%AC-deploy-%ED%95%98%EA%B8%B0-1abadb0b941a', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 59),
                                                                                                                                                                    (497, 'The Ultimate Flask Course', 'https://www.udemy.com/course/the-ultimate-flask-course/?couponCode=ST8MT220425G1', '동영상', '유데미', 'OVER_10', 'medium', 'UNDER_50K', 59),
                                                                                                                                                                    (498, 'How to Deploy a Python Flask App with Google Cloud Platform (GCP) on a Virtual Machine', 'https://youtu.be/NlO84jRTwPU?si=fwoBwPNSaXUYoOdw', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 59),
                                                                                                                                                                    (499, 'AWS 안쓰고 파이썬 플라스크 프로그램, 백엔드 서버 10분만에 http://fly.io 이용해서 배포하는 방법', 'https://youtu.be/9ZYB_bFRW8A?si=6iFrwUBB3rxTQp8J', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 59),
                                                                                                                                                                    (500, 'Flask 앱 CI/CD 파이프라인 만들고, 배포 5분만에 하기 | Azure Web App', 'https://youtu.be/huNRWtL-GF8?si=VnDjL0NDiHGFiCjS', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 59),
                                                                                                                                                                    (501, 'Azure 무료 VM으로 flask앱 배포하기 | 서버리스 flask 앱 배포와 비교', 'https://youtu.be/2ORb2g_dpCU?si=7XE9IBG836HcsPSz', '동영상', '유튜브', 'HOUR_1', 'medium', 'UNDER_50K', 59),
                                                                                                                                                                    (502, '[Azure] WebApp 생성 및 Flask 배포하기', 'https://dev-astra.tistory.com/384', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 59),
                                                                                                                                                                    (503, 'Terraform을 사용하여 기본 Flask 웹 서버 배포', 'https://cloud.google.com/docs/terraform/get-started-with-terraform?hl=ko', '블로그', '블로그', 'HOUR_1', 'high', 'FREE', 59),
                                                                                                                                                                    (504, 'Django 프로젝트 AWS EC2에 배포하기 - 터미널을 꺼도 서버 돌아가게 하자! (프리 티어)', 'https://woojin.tistory.com/36', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 57),
                                                                                                                                                                    (505, 'Django 빠르게 배포하기', 'https://www.codeit.kr/topics/getting-started-with-django/lessons/3620', '동영상', '코드잇', 'HOUR_1', 'low', 'BETWEEN_50K_100K', 57),
                                                                                                                                                                    (506, '10분만에 Django 프로젝트 Heroku에 배포하기 - [1시간만에 플러터/장고로 풀스택 퀴즈앱 만들기]', 'https://www.youtube.com/watch?v=9NnjMHxhqkI&list=PL3ilpnPyonYfztoBliWzrS6pzV8C5jxdR&index=6', '동영상', '유튜브', 'HOUR_1', 'low', 'UNDER_50K', 57),
                                                                                                                                                                    (507, '파이썬 웹 프로그래밍 : FlyIO를 사용해 Django를 인터넷에 배포하기', 'https://www.youtube.com/watch?v=CkBIU6nvF2U', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 57),
                                                                                                                                                                    (508, 'Django EC2 배포하기', 'https://www.youtube.com/playlist?list=PLOemN3LiCpznbiEeM_XH9Lfzi6TM4cm_9', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 57),
                                                                                                                                                                    (509, '파이썬으로 장고(Django) 공략하기 : 입문', 'https://www.inflearn.com/course/django-course', '동영상', '인프런', 'HOUR_10', 'low', 'UNDER_50K', 57),
                                                                                                                                                                    (510, '작정하고 장고! Django로 Pinterest 따라만들기 : 바닥부터 배포까지', 'https://www.inflearn.com/course/%EC%9E%A5%EA%B3%A0-%ED%95%80%ED%84%B0%EB%A0%88%EC%8A%A4%ED%8A%B8', '동영상', '인프런', 'OVER_10', 'low', 'BETWEEN_50K_100K', 57),
                                                                                                                                                                    (511, 'Django 서비스 AWS로 배포하기', 'https://nerogarret.tistory.com/45', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 57),
                                                                                                                                                                    (512, '[Django] Django 서비스 Azure로 배포하기(제일 빠르고 쉬운 방법)', 'https://medium.com/@heeee/django-django-%EC%84%9C%EB%B9%84%EC%8A%A4-azure%EB%A1%9C-%EB%B0%B0%ED%8F%AC%ED%95%98%EA%B8%B0-%EC%A0%9C%EC%9D%BC-%EB%B9%A0%EB%A5%B4%EA%B3%A0-%EC%89%AC%EC%9A%B4-%EB%B0%A9%EB%B2%95-7e7d2e005ed7', '블로그', '블로그', 'HOUR_3', 'low', 'FREE', 57),
                                                                                                                                                                    (513, '제대로 파는 Git & GitHub', 'https://www.youtube.com/watch?v=1I3hMwQU6GU&ab_channel=%EC%96%84%ED%8C%8D%ED%95%9C%EC%BD%94%EB%94%A9%EC%82%AC%EC%A0%84', '동영상', '유튜브', 'HOUR_3', 'low', 'FREE', 37),
                                                                                                                                                                    (514, '깃, 깃허브 제대로 배우기', 'https://www.youtube.com/watch?v=Z9dvM7qgN9s&ab_channel=%EB%93%9C%EB%A6%BC%EC%BD%94%EB%94%A9', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 37),
                                                                                                                                                                    (515, '깃 연습해보기', 'https://learngitbranching.js.org/?locale=ko', '블로그', '블로그', 'HOUR_1', 'low', 'FREE', 37),
                                                                                                                                                                    (516, '제대로 파고드는 Git & GitHub - by 얄코(Yalco)', 'https://www.inflearn.com/course/%EC%A0%9C%EB%8C%80%EB%A1%9C-%ED%8C%8C%EB%8A%94-%EA%B9%83', '동영상', '인프런', 'HOUR_10', 'medium', 'UNDER_50K', 37),
                                                                                                                                                                    (517, '【한글자막】 Git & Github 실무 활용 완벽 가이드', 'https://www.udemy.com/course/best-git-github', '동영상', '유데미', 'OVER_10', 'medium', 'BETWEEN_100K_200K', 37),
                                                                                                                                                                    (518, 'Git 팀 작업을 자동화하는 방법 [Hooks와 커스텀 스크립트]', 'https://coding-by-head.tistory.com/entry/git-hook', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 38),
                                                                                                                                                                    (519, 'Husky로 Git hooks 자동화하기(+ lint-staged, commitlint)', 'https://meoweundi.tistory.com/37', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 38),
                                                                                                                                                                    (520, 'Git Hooks', 'https://www.atlassian.com/ko/git/tutorials/git-hooks', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 38),
                                                                                                                                                                    (521, 'husky, lint-staged', 'https://deku.posstree.com/ko/react/husky-lint-staged/', '블로그', '블로그', 'HOUR_1', 'medium', 'FREE', 38),
                                                                                                                                                                    (522, 'Configuring husky pre-commit git hooks', 'https://www.youtube.com/watch?v=jGEkiljxvxU', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 38),
                                                                                                                                                                    (523, 'Git Project Setup with Husky, Conventional Commits, and branching strategies.', 'https://www.youtube.com/watch?app=desktop&v=jNxDNoYEGVU&t=1169s', '동영상', '유튜브', 'HOUR_1', 'medium', 'FREE', 38),
                                                                                                                                                                    (524, '코딩 자율학습 HTML + CSS + 자바스크립트', 'https://product.kyobobook.co.kr/detail/S000001834830', '책', '교보문고', 'OVER_10', 'medium', 'UNDER_50K', 41),
                                                                                                                                                                    (525, '모던 자바스크립트 Deep Dive', 'https://product.kyobobook.co.kr/detail/S000001766445', '책', '교보문고', 'OVER_10', 'low', 'UNDER_50K', 41),
                                                                                                                                                                    (526, '바닐라 JS로 크롬 앱 만들기', 'https://nomadcoders.co/javascript-for-beginners', '동영상', '노마드코더', 'HOUR_10', 'low', 'FREE', 41),
                                                                                                                                                                    (527, 'ES6의 정석', 'https://nomadcoders.co/es6-once-and-for-all', '동영상', '노마드코더', 'HOUR_10', 'medium', 'UNDER_50K', 41),
                                                                                                                                                                    (528, 'JavaScript 입문 수업', 'https://www.youtube.com/playlist?list=PLuHgQVnccGMA4uSig3hCjl7wTDeyIeZVU', '동영상', '유튜브', 'HOUR_10', 'medium', 'FREE', 41),
                                                                                                                                                                    (529, 'JavaScript Course for Beginners – Your First Step to Web Development', 'https://www.youtube.com/watch?v=W6NZfCO5SIk&ab_channel=ProgrammingwithMosh', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 41),
                                                                                                                                                                    (530, '모던 JavaScript 튜토리얼', 'https://ko.javascript.info/', '블로그', '블로그', 'OVER_10', 'high', 'FREE', 41),
                                                                                                                                                                    (531, '견고한 JS 소프트웨어 만들기', 'https://www.inflearn.com/course/tdd-%EA%B2%AC%EA%B3%A0%ED%95%9C-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0', '동영상', '인프런', 'HOUR_3', 'medium', 'UNDER_50K', 41),
                                                                                                                                                                    (532, '실무에 바로 적용하는 AWS 배포', 'https://www.inflearn.com/course/%EC%8B%A4%EB%AC%B4-%EB%B0%94%EB%A1%9C-%EC%A0%81%EC%9A%A9%ED%95%98%EB%8A%94-aws-%EB%B0%B0%ED%8F%AC', '동영상', '인프런', 'HOUR_5', 'high', 'BETWEEN_50K_100K', 31),
                                                                                                                                                                    (533, 'MERN STACK 커뮤니티 : 시작부터 배포까지 알려주는 React', 'https://www.inflearn.com/course/%ED%92%80%EC%8A%A4%ED%83%9D-%EC%BB%A4%EB%AE%A4%EB%8B%88%ED%8B%B0-mern', '동영상', '인프런', 'HOUR_10', 'medium', 'UNDER_50K', 31),
                                                                                                                                                                    (534, '애플리케이션 배포 자동화와 CI/CD', 'https://www.inflearn.com/course/%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94-ci-cd', '동영상', '인프런', 'HOUR_3', 'low', 'UNDER_50K', 31),
                                                                                                                                                                    (535, '【한글자막】 Docker & Kubernetes : 실전 가이드', 'https://www.udemy.com/course/docker-kubernetes-2022/?couponCode=CP130525', '동영상', '유데미', 'OVER_10', 'medium', 'BETWEEN_100K_200K', 31),
                                                                                                                                                                    (536, '그래서 웹서비스 하나 만들었는데 배포는 어떻게함? (AWS)', 'https://www.youtube.com/watch?v=cOUhREAWJNw', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 31),
                                                                                                                                                                    (537, '프론트 배포를 위한 잡다한 사전 지식', 'https://iborymagic.tistory.com/94', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 31),
                                                                                                                                                                    (538, '단 한 번의 커밋으로 배포까지! 프론트엔드 자동화 전략', 'https://notforme.kr/%EB%8B%A8-%ED%95%9C-%EB%B2%88%EC%9D%98-%EC%BB%A4%EB%B0%8B%EC%9C%BC%EB%A1%9C-%EB%B0%B0%ED%8F%AC%EA%B9%8C%EC%A7%80-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%9E%90%EB%8F%99%ED%99%94-%EC%A0%84/', '블로고', '블로그', 'HOUR_3', 'medium', 'FREE', 31),
                                                                                                                                                                    (539, 'AWS(Amazon Web Service) 입문자를 위한 강의', 'https://www.udemy.com/course/aws-beginner-sk/?couponCode=CP130525', '동영상', '유데미', 'HOUR_10', 'low', 'BETWEEN_50K_100K', 32),
                                                                                                                                                                    (540, 'AWS S3 Basics', 'https://www.coursera.org/projects/aws-s3-basics', '동영상', 'Coursera', 'HOUR_3', 'low', 'FREE', 32),
                                                                                                                                                                    (541, 'Hosting a Static Website (HTML/CSS/Javascript) in AWS S3', 'https://www.coursera.org/projects/hosting-static-web-site-aws', '동영상', 'Coursera', 'HOUR_1', 'low', 'FREE', 32),
                                                                                                                                                                    (542, 'AWS 기본기', 'https://www.codeit.kr/topics/aws-basic', '동영상', '코드잇', 'HOUR_5', 'medium', 'FREE', 32),
                                                                                                                                                                    (543, '(LV.100)AWS의 파일 저장/관리의 필수서비스 : Amazon S3를 소개합니다!', 'https://www.youtube.com/watch?v=6sL80G4Pn7Y', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 32),
                                                                                                                                                                    (544, '[AWS] S3란 무엇인가', 'https://velog.io/@ghldjfldj/AWS-S3%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 32),
                                                                                                                                                                    (545, 'AWS Cloudfront: Serve content from multiple S3 buckets', 'https://www.coursera.org/projects/aws-cloudfront-s3', '동영상', 'Coursera', 'HOUR_3', 'medium', 'FREE', 32),
                                                                                                                                                                    (546, 'Create an Amazon CloudFront Distribution and Website | Step-by-Step AWS CDN Tutorial for Beginners', 'https://www.youtube.com/watch?v=GUfAQUjA3a0', '동영상', '유튜브', 'HOUR_1', 'low', 'FREE', 32),
                                                                                                                                                                    (547, 'Amazon CloudFront Developer Guide', 'https://product.kyobobook.co.kr/detail/S000045921004', '책', '교보문고', 'OVER_10', 'high', 'BETWEEN_50K_100K', 32),
                                                                                                                                                                    (548, 'AWS S3와 CloudFront 연동 끝까지 가보기', 'https://akku-dev.tistory.com/153', '블로그', '블로그', 'HOUR_3', 'medium', 'FREE', 32);


CREATE TABLE exam(
                     exam_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                     exam_content TEXT NOT NULL,
                     exam_answer INT NOT NULL,
                     exam_level VARCHAR(255) NOT NULL,
                     option1 VARCHAR(255) NOT NULL,
                     option2 VARCHAR(255) NOT NULL,
                     option3 VARCHAR(255) NOT NULL,
                     option4 VARCHAR(255) NOT NULL,
                     solution TEXT NOT NULL,
                     sub_id BIGINT NOT NULL,
                     CONSTRAINT fk_exam_subject FOREIGN KEY (sub_id) REFERENCES subject(sub_id)
);

CREATE TABLE user_exam_answer(
                                 exam_answer_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                                 user_answer INT NOT NULL,
                                 is_pre BOOLEAN NOT NULL,
                                 nth INT NOT NULL,
                                 exam_id BIGINT NOT NULL,
                                 sub_id BIGINT NOT NULL,
                                 user_id BIGINT NOT NULL,
                                 CONSTRAINT fk_user_exam_answer_subject FOREIGN KEY (sub_id) REFERENCES subject(sub_id),
                                 CONSTRAINT fk_user_exam_answer_exam FOREIGN KEY (exam_id) REFERENCES exam(exam_id),
                                 CONSTRAINT fk_user_exam_answer_user FOREIGN KEY (user_id) REFERENCES users(user_id)
);

INSERT INTO exam(exam_id, exam_content, exam_answer, exam_level, option1, option2, option3, option4, sub_id, solution) VALUES
                                                                                                                           (1, 'HTML 문서의 최상위 루트 요소는 무엇인가?', 1, 'low', '<html>', '<head>', '<body>', '<doctype>', 1, '<html> 요소는 HTML 문서의 최상위 루트 요소이기 때문에 정답이다.'),
                                                                                                                           (2, 'head 요소 안에 넣을 수 없는 태그는?', 4, 'low', '<title>', '<link>', '<meta>', '<section>', 1, '<section>은 시맨틱 콘텐츠 구역으로, head 요소 내에는 포함될 수 없다.'),
                                                                                                                           (3, '한 페이지에서 필수이며 한 번만 사용해야 하는 요소는?', 1, 'low', '<main>', '<header>', '<aside>', '<nav>', 1, '<main>은 페이지에서 한 번만 등장해야 하는 시맨틱 핵심 콘텐츠 영역이다.'),
                                                                                                                           (4, '시맨틱 태그와 용도 짝짓기가 올바른 것은?', 1, 'medium', '<nav> — 주요 내비게이션 링크', '<footer> — 본문 주요 콘텐츠', '<aside> — 문서 제목 영역', '<header> — 독립 기사 콘텐츠', 1, '<nav>는 주요 내비게이션 링크를 나타내는 시맨틱 태그이다.'),
                                                                                                                           (5, '<article> 요소를 사용하기에 가장 적합한 예시는?', 1, 'medium', '블로그 글 한 편', '페이지 상단 로고 영역', '사이트 전역 검색 폼', '레이아웃 용 빈 div', 1, '블로그 글 한 편은 독립적인 콘텐츠로 <article>에 적합하다.'),
                                                                                                                           (6, '시맨틱 태그 사용의 주요 장점이 아닌 것은?', 4, 'medium', 'SEO 개선', '보조 기술 접근성 향상', '코드 가독성 향상', '무조건 더 빠른 렌더링 보장', 1, '"무조건 더 빠른 렌더링 보장"은 시맨틱 태그 사용의 주요 장점이 아닌 것은?의 정답이 되는 이유이다.'),
                                                                                                                           (7, '다음 코드 중 문법적으로 유효한 것은?', 1, 'high', '<header><h1>T</h1></header><main><section>…</section></main>', '<main><header>…</header></main>', '<nav><main>…</main></nav>', '<footer><header>…</header></footer>', 1, '<header><h1>T</h1></header><main><section>…</section></main>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (8, '올바르지 않은 요소 중첩은?', 4, 'high', '<article><section></section></article>', '<nav><ul><li></li></ul></nav>', '<header><h1></h1><p></p></header>', '<footer><main></main></footer>', 1, '<footer><main></main></footer>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (9, 'HTML5 아웃라인 알고리즘을 고려할 때 <section> 내부에서 첫 제목으로 가장 적절한 헤딩 수준은?', 1, 'high', '<h1>', '<h2>', '<h3>', '<h4>', 1, '<h1>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (10, '<main> 요소에 대한 설명으로 옳은 것은?', 2, 'high', '문서에 여러 개 포함될 수 있다', '페이지 핵심 콘텐츠를 담으며 유일해야 한다', 'section 요소 안에 중첩될 수 있다', '검색 엔진이 무시하도록 하는 주석 용도이다', 1, '페이지 핵심 콘텐츠를 담으며 유일해야 한다는 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (11, '단락(문단)을 나타내는 대표적인 블록 요소는?', 1, 'low', '<p>', '<span>', '<li>', '<br>', 1, '<p>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (12, '한 줄 내에서 별도 의미 없이 인라인 컨테이너 역할을 하는 태그는?', 1, 'low', '<span>', '<div>', '<p>', '<pre>', 1, '<span>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (13, '순서가 없는 목록을 생성하는 요소는?', 1, 'low', '<ul>', '<ol>', '<dl>', '<list>', 1, '<ul>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (14, '<ol start="5">로 설정했을 때 첫 번째 목록 항목 번호는?', 1, 'medium', '5', '0', '1', 'A', 1, '5는 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (15, '의미론적 “강조”를 전달하며 스크린 리더가 음성 톤 변화를 줄 수 있는 인라인 요소는?', 1, 'medium', '<em>', '<i>', '<span>', '<b>', 1, '<em>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (16, '다음 중 정의 목록의 올바른 기본 구조는?', 1, 'medium', '<dl><dt>용어</dt><dd>정의</dd></dl>', '<dt><dl>용어</dl><dd>정의</dd>', '<dl><dd>정의</dd><dt>용어</dt></dl>', '<ul><li>용어 - 정의</li></ul>', 1, '<dl><dt>용어</dt><dd>정의</dd></dl>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (17, '다음 중 유효하지 않은 중첩 목록 구조는?', 2, 'high', '<ul><li>Item<ol><li>Sub</li></ol></li></ul>', '<ul><ol><li>Sub</li></ol></ul>', '<ol><li>Item<ul><li>Sub</li></ul></li></ol>', '<ul><li>Item<ul><li>Sub</li></ul></li></ul>', 1, '<ul><ol><li>Sub</li></ol></ul>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (18, '<strong> 요소와 동일한 의미론적 중요도를 제공하지 않는 태그는?', 1, 'high', '<b>', '<em>', '<mark>', '<i>', 1, '<b>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (19, '<pre> 요소에 대한 설명으로 옳은 것은?', 1, 'high', '공백과 줄바꿈을 그대로 유지한다', '모든 브라우저에서 인라인 요소로 렌더된다', '텍스트를 자동 줄바꿈해 공간을 최소화한다', 'HTML 태그를 자동 이스케이프한다', 1, '공백과 줄바꿈을 그대로 유지한다는 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (20, 'reversed 속성이 설정된 <ol> 요소의 기능은?', 1, 'high', '목록 번호를 역순으로 표시한다', '번호 대신 라틴 문자(A, B, C)로 표시한다', '목록을 가로로 배치한다', '짝수 번호만 출력한다', 1, '목록 번호를 역순으로 표시한다는 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (21, '이미지를 삽입할 때 사용하는 대표 인라인 요소는?', 1, 'low', '<img>', '<picture>', '<figure>', '<video>', 1, '<img>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (22, 'img 요소의 alt 속성 주 목적은?', 1, 'low', '시각 장애인 접근성 대체 텍스트 제공', '이미지 자동 크롭 지정', 'SEO 제외 요청', 'CSS 클래스 지정', 1, '시각 장애인 접근성 대체 텍스트 제공은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (23, 'video 태그에 사용자 재생 버튼을 표시하려면 필수인 속성은?', 1, 'low', 'controls', 'autoplay', 'loop', 'muted', 1, 'controls은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (24, 'picture 요소 내부에서 뷰포트 너비별로 다른 소스를 명시하는 태그는?', 1, 'medium', '<source>', '<img>', '<link>', '<meta>', 1, '<source>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (25, 'audio preload="none"으로 설정 시 브라우저 동작은?', 1, 'medium', '오디오 데이터 선로드 안 함', '전체 파일 즉시 다운로드', '메타데이터와 일부 버퍼 선로드', '자동 재생 준비', 1, '오디오 데이터 선로드 안 함은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (26, 'iframe 요소에서 외부 페이지가 현재 문서를 조작하지 못하도록 제한하는 속성은?', 1, 'medium', 'sandbox', 'allow', 'referrerpolicy', 'loading', 1, 'sandbox는 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (27, '모바일에서 무음 자동 재생을 보장하려면 video 태그에 일반적으로 필요한 속성 조합은?', 1, 'high', 'autoplay + muted', 'autoplay + loop', 'muted + controls', 'loop + poster', 1, 'autoplay + muted는 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (28, 'track 요소 kind="subtitles"가 제공하는 정보는?', 1, 'high', '사용자 언어 번역 자막', '비디오 썸네일', '광고 삽입 지점', 'DRM 키', 1, '사용자 언어 번역 자막은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (29, '외부 3rd-party 콘텐츠(예: YouTube) 삽입 시 Living Standard가 권장하는 기본 요소는?', 1, 'high', '<iframe>', '<embed>', '<object>', '<param>', 1, '<iframe>은 질문에서 요구한 조건을 가장 정확히 충족한다.'),
                                                                                                                           (30, 'srcset과 sizes를 사용한 img 동작 설명 중 옳지 않은 것은?', 2, 'high', 'DPR·뷰포트에 따라 가장 적합한 소스를 선택한다', '모든 소스를 미리 다운로드해 캐시에 저장한다', 'sizes는 레이아웃 너비 힌트를 제공한다', 'srcset은 해상도/너비 조건별 URL 목록을 제공한다', 1, '모든 소스를 미리 다운로드해 캐시에 저장한다는 srcset의 동작 설명으로 옳지 않다.'),
                                                                                                                           (31, 'form 요소에서 action 속성을 생략하면 기본으로 사용되는 전송 대상은?', 1, 'low', '현재 문서의 URL', '브라우저 홈 페이지', '/index.html', '전송이 차단되고 오류가 난다', 1, 'form의 action 속성을 생략하면 기본적으로 현재 문서의 URL로 데이터를 전송한다.'),
                                                                                                                           (32, '사용자 입력이 이메일 형식(예: user@example.com)인지 자동 검증하려면 어떤 input 타입을 사용해야 하는가?', 1, 'low', 'email', 'text', 'url', 'search', 1, 'input의 type이 email이면 브라우저가 이메일 형식인지 자동으로 검증해준다.'),
                                                                                                                           (33, '서로 배타적인 여러 Radio 버튼을 그룹화하려면 반드시 일치해야 하는 속성은?', 1, 'low', 'name', 'id', 'value', 'for', 1, 'radio 버튼은 name 속성이 같아야 하나의 그룹으로 인식되어 배타적 선택이 가능하다.'),
                                                                                                                           (34, '브라우저 기본 제출 버튼 역할을 하는 요소/속성 조합으로 올바른 것은?', 1, 'medium', '<button type="submit">', '<input type="button">', '<a href="/submit">', '<div role="submit">', 1, 'type="submit" 속성을 가진 button은 form 제출 버튼으로 동작한다.'),
                                                                                                                           (35, 'label 요소와 폼 컨트롤을 연계할 때 필수로 동일해야 하는 속성 쌍은?', 1, 'medium', 'label의 for ↔ 컨트롤의 id', 'label의 id ↔ 컨트롤의 name', 'label의 name ↔ 컨트롤의 value', 'label의 for ↔ 컨트롤의 name', 1, 'label의 for 속성과 연계할 input 등의 id 속성이 같아야 연결된다.'),
                                                                                                                           (36, '폼 자동 완성 기능을 명시적으로 비활성화하려면 어떤 속성 값을 사용해야 하는가?', 1, 'medium', 'autocomplete="off"', 'autofill="false"', 'complete="none"', 'disable="autocomplete"', 1, 'autocomplete="off"를 사용하면 브라우저의 자동완성 기능이 비활성화된다.'),
                                                                                                                           (37, '사용자가 하나 이상의 항목을 체크할 수 있으며 값은 on/off로 전송되는 컨트롤은?', 1, 'high', '<input type="checkbox">', '<input type="radio">', '<select>', '<input type="range">', 1, 'checkbox는 다중 선택이 가능하며 선택되면 "on" 값이 전송된다.'),
                                                                                                                           (38, '다중 선택이 가능한 <select> 요소를 만들기 위해 추가해야 할 필수 속성은?', 1, 'high', 'multiple', 'size="1"', 'data-multi="true"', 'selection="many"', 1, 'select 요소에 multiple 속성을 추가하면 다중 선택이 가능해진다.'),
                                                                                                                           (39, 'input 요소의 pattern 속성에 정규식을 지정했을 때, 사용자가 패턴에 맞지 않는 값을 입력하고 제출하면 발생하는 기본 동작은?', 1, 'high', '브라우저가 제출을 막고 오류 메시지를 표시한다', '서버로 전송되지만 “pattern” 문자열이 함께 포함된다', '브라우저가 값을 빈 문자열로 바꾼 뒤 전송한다', 'pattern 속성은 단순 주석이므로 아무 효과가 없다', 1, 'pattern 속성과 일치하지 않으면 HTML5가 제출을 막고 경고 메시지를 출력한다.'),
                                                                                                                           (40, 'form 요소에 novalidate 속성을 설정하면 어떤 결과가 발생하는가?', 1, 'high', 'HTML5 내장 검증을 건너뛰고 즉시 제출한다', '모든 required 속성이 자동으로 제거된다', '서버가 클라이언트 검증 스크립트를 주입한다', '브라우저가 파일 업로드를 차단한다', 1, 'novalidate 속성은 브라우저의 내장 유효성 검사를 건너뛰게 한다.'),
                                                                                                                           (41, 'HTML 테이블에서 한 행을 나타내는 요소는?', 1, 'low', '<tr>', '<th>', '<td>', '<tbody>', 1, 'tr은 table row의 약자로 하나의 행을 나타내는 요소이다.'),
                                                                                                                           (42, '표의 열 제목(헤더 셀)을 표현하는 시맨틱 태그는?', 1, 'low', '<th>', '<td>', '<caption>', '<colgroup>', 1, 'th는 table header의 약자로 열 제목을 의미하는 셀에 사용된다.'),
                                                                                                                           (43, 'HTML5에서 문서의 문자 인코딩을 선언하기 위한 표준 태그는?', 1, 'low', '<meta charset="UTF-8">', '<meta http-equiv="content-type" content="text/html;charset=utf-8">', '<charset>', '<meta encoding="utf-8">', 1, 'HTML5에서는 간단히 <meta charset="UTF-8">로 문자 인코딩을 설정한다.'),
                                                                                                                           (44, '표 머리글 행들을 의미론적으로 그룹화할 때 사용하는 요소는?', 1, 'medium', '<thead>', '<head>', '<tablehead>', '<caption>', 1, 'thead는 표의 머리글 부분을 의미론적으로 묶는 데 사용된다.'),
                                                                                                                           (45, '다음 meta 태그는 어떤 역할을 하는가? <meta name="viewport" content="width=device-width, initial-scale=1">', 1, 'medium', '모바일 화면에서 레이아웃 스케일·줌 동작 제어', '문서 문자 인코딩 설정', '검색 엔진 색인 방지', '쿠키 보안 속성 지정', 1, 'viewport 메타태그는 모바일 환경에서 반응형 레이아웃 설정에 필수다.'),
                                                                                                                           (46, '테이블과 논리적으로 연결된 제목을 제공하기 위한 요소는?', 1, 'medium', '<caption>', '<title>', '<header>', '<summary>', 1, 'caption은 테이블과 연결된 제목 또는 설명을 붙일 때 사용된다.'),
                                                                                                                           (47, '복잡한 표에서 특정 열의 모든 셀에 적용되는 헤더 셀의 scope 값으로 적절한 것은?', 1, 'high', 'col', 'row', 'rowgroup', 'auto', 1, 'scope="col"은 헤더 셀이 열 전체에 적용됨을 나타낸다.'),
                                                                                                                           (48, '여러 헤더 셀과 관계를 맺는 데이터 셀(td)을 명시적으로 연결할 때 사용하는 속성은?', 1, 'high', 'headers', 'scope', 'aria-label', 'colspan', 1, 'headers 속성은 td가 참조할 th의 id를 지정해 의미를 명확히 한다.'),
                                                                                                                           (49, 'HTML5에서 <summary> 속성이 더 이상 허용되지 않으므로, 복합 표 요약 정보를 제공하려면 권장되는 방법은?', 1, 'high', 'table 요소에 aria-describedby 속성으로 숨은 요약 요소의 id 연결', 'summary="요약" 속성을 계속 사용', '헤더 셀에 data-summary 속성 추가', 'tfoot 내부에 요약 문자열 삽입', 1, '접근성을 고려해 aria-describedby 속성으로 요약 정보 요소를 연결하는 것이 권장된다.'),
                                                                                                                           (50, '다음 중 테이블의 내부 섹션을 사양 순서대로 올바르게 배치한 것은?', 1, 'high', '<caption> → <colgroup> → <thead> → <tbody> → <tfoot>', '<thead> → <caption> → <colgroup> → <tbody> → <tfoot>', '<caption> → <thead> → <colgroup> → <tfoot> → <tbody>', '<caption> → <colgroup> → <tbody> → <thead> → <tfoot>', 1, 'HTML5 명세에 따르면 테이블의 내부 구성 요소는 <caption>, <colgroup>, <thead>, <tbody>, <tfoot> 순서로 배치하는 것이 올바르며, 이는 접근성과 구조적 의미 전달을 위함이다.'),
                                                                                                                           (51, '모든 요소에 스타일을 적용하려면 어떤 CSS 선택자를 사용해야 하는가?', 1, 'low', '*', '.', '#', '%', 2, 'CSS에서 * 선택자는 모든 요소를 대상으로 하는 범용 선택자로, 전역 스타일을 적용할 때 사용된다.'),
                                                                                                                           (52, '클래스 선택자를 선언할 때 사용하는 접두사는?', 1, 'low', '.', '#', '@', '&', 2, 'CSS에서 클래스 선택자는 .(점)을 접두사로 사용하여 정의하며, 여러 요소에 동일한 스타일을 적용할 수 있다.'),
                                                                                                                           (53, 'p 요소의 직접 자식 span만 선택하려면 올바른 선택자는?', 1, 'low', 'p > span', 'p span', 'p + span', 'p ~ span', 2, 'CSS에서 > 선택자는 부모의 **직접 자식**만을 선택하므로, p > span은 p 요소의 바로 아래 있는 span만 선택한다.'),
                                                                                                                           (54, '다음 중 href 속성이 "https://"로 시작하는 a 요소를 선택하는 올바른 방법은?', 1, 'medium', 'a[href^="https://"]', 'a[href$="https://"]', 'a[href*="https://"]', 'a[href]', 2, '^= 연산자는 속성 값이 특정 문자열로 시작하는 요소를 선택하므로, "https://"로 시작하는 href 속성을 가진 a 요소를 정확히 선택한다.'),
                                                                                                                           (55, '다음 셀렉터 중 가장 높은 우선순위(specificity)를 가지는 것은?', 1, 'medium', '#header .nav li a', '.header-nav > a', 'div#header', 'a.btn-primary', 2, 'CSS 우선순위는 ID > 클래스 > 요소 순이며, #header .nav li a는 ID, 클래스, 태그를 모두 포함하여 specificity가 가장 높다.'),
                                                                                                                           (56, '첫 줄에만 스타일을 적용할 때 사용하는 시맨틱 선택자는?', 1, 'medium', '::first-line', ':first-letter', ':first-of-type', '::before', 2, '::first-line은 요소의 첫 번째 줄에만 스타일을 적용하는 시맨틱 선택자로, 주로 문단의 서두 스타일링에 사용된다.'),
                                                                                                                           (57, 'button 요소 중 data-role="primary" 이 아니면서 disabled 속성이 없는 경우를 선택하는 올바른 선택자는?', 1, 'high', 'button[data-role="primary"]:not([disabled])', 'button:not([data-role="primary"]):disabled', 'button[data-role!="primary"]:disabled', 'button!:primary:not(disabled)', 2, '조건을 정확히 해석하면 "primary 역할을 가지며 비활성화되지 않은 버튼"이므로, 첫 번째 선택자만이 올바르게 이를 표현한다.'),
                                                                                                                           (58, 'li:nth-child(2n+1) 선택자가 선택하는 항목은?', 1, 'high', '홀수 번째 li (1,3,5 …)', '짝수 번째 li (2,4,6 …)', '3의 배수 li', '첫 번째 li 하나만', 2, '2n+1은 수학적으로 홀수 항목을 의미하므로, 이 선택자는 1번째, 3번째, 5번째 등 홀수 li 요소를 선택한다.'),
                                                                                                                           (59, ':not(.hidden) 선택자의 우선순위는 다음 중 무엇과 동일한가?', 1, 'high', '클래스 선택자 하나', '아이디 선택자 하나', '요소(태그) 선택자 하나', '인라인 스타일', 2, ':not() 안의 선택자에 따라 우선순위가 결정되며, .hidden은 클래스 선택자이므로 전체 선택자의 우선순위도 클래스 하나와 동일하다.'),
                                                                                                                           (60, '[lang|="en"] 속성 선택자가 선택하는 요소는?', 1, 'high', 'lang 값이 "en"이거나 "en-"으로 시작하는 요소', 'lang 값에 "en" 문자열이 포함된 모든 요소', 'lang 값이 "-en"으로 끝나는 요소', 'lang 값이 정확히 "en-US"인 요소만', 2, '|= 연산자는 정확히 "en" 또는 "en-"으로 시작하는 값을 가진 속성을 선택하므로, lang="en" 또는 lang="en-US" 등이 이에 해당된다.'),
                                                                                                                           (61, '박스 모델에서 콘텐츠(content) 영역 바로 바깥에 위치한 영역은?', 1, 'low', 'padding', 'margin', 'border', 'outline', 2, '박스 모델에서 콘텐츠 영역 바로 다음에 오는 것은 padding 영역이다.'),
                                                                                                                           (62, '요소에 width: 200px; padding: 10px; border: 5px solid; box-sizing: border-box; 를 지정했다. 요소의 총 렌더링 너비는?', 2, 'low', '230px', '200px', '210px', '220px', 2, 'box-sizing: border-box를 사용하면 padding과 border를 포함한 전체 너비가 width 값(200px)으로 제한된다.'),
                                                                                                                           (63, '연속된 두 p 요소가 있을 때, 첫 번째 요소의 margin-bottom이 20px이고 두 번째 요소의 margin-top이 30px이다. 실제 두 요소 사이의 간격은?', 2, 'low', '50px', '30px', '20px', '0px', 2, '수직 마진은 상쇄(margin collapsing)되어 더 큰 값인 30px만 적용된다.'),
                                                                                                                           (64, 'position: absolute; 가 지정된 요소의 좌표 기준은 기본적으로 어디인가?', 1, 'medium', '가장 가까운 position 값이 static이 아닌 조상 요소', '브라우저 뷰포트', 'body 요소', '가장 가까운 flex 컨테이너', 2, 'absolute 요소는 가장 가까운 relative, absolute, fixed, sticky 등의 position을 가진 조상 요소를 기준으로 위치가 정해진다.'),
                                                                                                                           (65, '다음 중 Block Formatting Context(BFC)를 생성하지 않는 선언은?', 4, 'medium', 'overflow: hidden;', 'float: left;', 'display: inline-block;', 'position: relative;', 2, 'position: relative는 BFC를 생성하지 않지만 나머지는 BFC를 생성한다.'),
                                                                                                                           (66, 'z-index 속성을 사용해 레이어 순서를 제어하려면, 일반적으로 요소가 어떤 상태여야 하는가?', 2, 'medium', 'position이 static이어야 한다', 'position이 relative/absolute/fixed/sticky 중 하나여야 한다', 'display가 inline-block이어야 한다', 'opacity가 1보다 작아야 한다', 2, 'z-index가 동작하려면 요소는 relative, absolute, fixed, sticky 중 하나의 position 값을 가져야 한다.'),
                                                                                                                           (67, '왼쪽(float:left)으로 부유한 이미지 아래의 문단이 이미지 주위를 감싸지 않도록 하려면 문단에 어떤 clear 값을 적용해야 하는가?', 1, 'high', 'clear:left;', 'clear:right;', 'clear:both;', 'clear:none;', 2, 'float:left로 띄운 요소 아래에 겹치지 않으려면 clear:left를 적용해야 한다.'),
                                                                                                                           (68, 'outline 속성에 대한 설명으로 옳은 것은?', 1, 'high', 'outline은 요소의 박스 모델 크기에 포함되지 않는다', 'outline은 각 면마다 두께를 다르게 설정할 수 있다', 'outline은 border-radius 값을 따른다', 'outline 속성은 상속된다', 2, 'outline은 요소의 외곽선이지만 레이아웃에 영향을 주지 않기 때문에 박스 모델 크기에는 포함되지 않는다.'),
                                                                                                                           (69, 'overflow 속성 값 중 내용이 넘칠 때만 스크롤바를 표시하고 평소에는 숨기는 값은?', 1, 'high', 'auto', 'scroll', 'hidden', 'visible', 2, 'overflow: auto는 내용이 넘칠 경우에만 스크롤을 보여준다.'),
                                                                                                                           (70, '다음 중 새로운 stacking context를 만들지 않는 선언은?', 4, 'high', 'transform: translateX(10px);', 'opacity: 0.8;', 'position: fixed;', 'overflow: auto;', 2, 'overflow: auto는 stacking context를 생성하지 않지만 나머지는 생성한다.'),
                                                                                                                           (71, '요소를 Flexbox 컨테이너로 만들기 위한 필수 선언은?', 1, 'low', 'display: flex;', 'flex-direction: row;', 'display: grid;', 'position: flex;', 2, 'display: flex;는 요소를 Flex 컨테이너로 정의하는 필수 선언이다.'),
                                                                                                                           (72, 'Flexbox에서 주축(main axis) 방향 정렬을 제어하는 속성은?', 1, 'low', 'justify-content', 'align-items', 'align-content', 'order', 2, 'justify-content는 주축(main axis) 방향의 정렬을 설정하는 속성이다.'),
                                                                                                                           (73, 'flex-direction: column;을 설정하면 메인 축(main axis)은 기본적으로 어떤 방향으로 흐르는가?', 1, 'low', '위 → 아래', '왼쪽 → 오른쪽', '오른쪽 → 왼쪽', '아래 → 위', 2, 'flex-direction: column은 주축을 수직 방향(위→아래)으로 설정한다.'),
                                                                                                                           (74, 'Flex 항목이 한 줄을 넘을 때 줄바꿈을 허용하려면 올바른 선언은?', 1, 'medium', 'flex-wrap: wrap;', 'white-space: nowrap;', 'overflow-wrap: break-word;', 'flex-flow: nowrap;', 2, 'flex-wrap: wrap;은 Flex 항목이 한 줄을 초과할 때 줄바꿈을 가능하게 한다.'),
                                                                                                                           (75, 'flex 항목의 시각적 순서를 제어하는 order 속성의 기본값은?', 1, 'medium', '0', '1', '-1', 'auto', 2, 'order 속성의 기본값은 0이며, 숫자가 낮을수록 앞쪽에 배치된다.'),
                                                                                                                           (76, '개별 Flex 항목이 컨테이너의 align-items 값을 무시하고 자체 교차축 정렬을 지정하려면 어떤 속성을 사용해야 하는가?', 1, 'medium', 'align-self', 'justify-self', 'flex-basis', 'place-items', 2, 'align-self는 개별 항목이 교차축 방향 정렬을 따로 지정할 때 사용된다.'),
                                                                                                                           (77, '세 개의 동일 너비 Grid 열을 생성하는 올바른 선언은?', 1, 'medium', 'grid-template-columns: repeat(3, 1fr);', 'grid-columns: 1fr 1fr 1fr;', 'grid: auto / 1fr 1fr 1fr;', 'grid-template-rows: repeat(3, 1fr);', 2, 'repeat(3, 1fr)은 동일한 너비의 3개 열을 설정하는 간결한 문법이다.'),
                                                                                                                           (78, 'Grid·Flex 컨테이너 모두에서 행과 열 간 간격을 동시에 설정할 수 있는 단일 속성은?', 1, 'high', 'gap', 'row-gap', 'column-gap', 'spacing', 2, 'gap 속성은 row-gap과 column-gap을 한꺼번에 설정할 수 있는 속성이다.'),
                                                                                                                           (79, 'grid-auto-flow 속성 값 중 아이템을 열 단위로 자동 배치하도록 지시하는 값은?', 1, 'high', 'column', 'row', 'dense', 'auto', 2, 'grid-auto-flow: column은 아이템을 열 방향으로 자동 배치한다.'),
                                                                                                                           (80, 'Inline-level Grid 컨테이너를 생성하려면 어떤 display 값을 사용해야 하는가?', 1, 'high', 'inline-grid', 'grid-inline', 'inline-flex', 'inline-block', 2, 'inline-grid는 인라인 레벨의 Grid 컨테이너를 정의할 수 있는 display 속성이다.'),
                                                                                                                           (81, '글자 색상을 빨간색으로 지정하는 올바른 CSS 선언은?', 1, 'low', 'color: red;', 'background-color: red;', 'font-color: red;', 'text-color: #red;', 2, 'color 속성은 텍스트 색상을 지정할 때 사용된다.'),
                                                                                                                           (82, '다음 중 3자리 HEX 색상으로 올바르게 표현한 것은?', 1, 'low', '#0af', '#00aaFF', '#0aFf', '#ggg', 2, '#0af는 3자리 HEX 색상으로 올바르게 표현된 형식이다.'),
                                                                                                                           (83, '50% 투명 빨간색을 나타내는 올바른 rgba() 표기는?', 1, 'low', 'rgba(255, 0, 0, 0.5)', 'rgba(255, 0, 0, 50)', 'rgba(255, 0, 0, .05)', 'rgb(255, 0, 0, 0.5)', 2, 'rgba 함수는 마지막 인자로 투명도를 0~1 사이 값으로 받는다.'),
                                                                                                                           (84, '굵기(bold)가 시각적으로 표준인 700에 해당하는 font-weight 값은?', 1, 'medium', '700', '500', '600', '1000', 2, '700은 브라우저에서 굵은 글씨로 인식되는 표준 font-weight 값이다.'),
                                                                                                                           (85, '문단의 줄 간격을 조절할 때 사용하는 CSS 속성은?', 1, 'medium', 'line-height', 'letter-spacing', 'word-spacing', 'text-indent', 2, 'line-height는 줄 간격(행간)을 조절하는 데 사용된다.'),
                                                                                                                           (86, '다음 중 background 속성의 shorthand 문법으로 유효한 예시는?', 2, 'medium', 'background: center / cover url("hero.jpg") repeat;', 'background: url("hero.jpg") center / cover no-repeat fixed;', 'background: cover center url("hero.jpg") no-repeat;', 'background: fixed no-repeat url("hero.jpg") / contain center;', 2, 'shorthand 형식은 올바른 순서와 구성으로 선언되어야 유효하다.'),
                                                                                                                           (87, 'CSS 사용자 정의 속성(변수)을 요소에 적용할 때 올바른 표기는?', 1, 'high', 'color: var(--primary);', 'color: $primary;', 'color: var(primary);', 'color: --primary;', 2, 'CSS 변수는 var(--이름) 형식으로 참조된다.'),
                                                                                                                           (88, '선형 그라디언트에서 좌측 상단 → 우측 하단 방향을 지정하는 올바른 값은?', 1, 'high', 'linear-gradient(to bottom right, red, blue)', 'linear-gradient(45deg, red, blue)', 'linear-gradient(to top left, red, blue)', 'linear-gradient(right bottom, red, blue)', 2, 'to bottom right는 좌측 상단에서 우측 하단 방향을 의미한다.'),
                                                                                                                           (89, '여러 개의 background 이미지를 지정할 때, 시각적으로 맨 위에 표시되는 것은?', 1, 'high', 'background 속성에 나열된 첫 번째 이미지', 'background 속성에 나열된 마지막 이미지', '가장 해상도가 높은 이미지', '가장 작은 파일 크기의 이미지', 2, 'CSS에서는 먼저 나열된 이미지가 맨 위에 표시된다.'),
                                                                                                                           (90, 'em 단위와 rem 단위 차이에 대한 설명으로 옳은 것은?', 1, 'high', 'rem은 항상 root(html) 요소의 글꼴 크기를 기준으로 한다', 'em은 언제나 1rem과 동일하다', 'rem은 상속된 부모 요소의 폰트 크기를 기준으로 한다', 'em은 root 요소의 폰트 크기를 무시한다', 2, 'rem은 항상 root 요소를 기준으로, em은 부모 요소를 기준으로 한다.'),
                                                                                                                           (91, 'transition 속성에서 애니메이션 가속 곡선을 지정하는 데 사용하는 하위 속성은?', 1, 'low', 'transition-timing-function', 'transition-delay', 'transition-property', 'transition-duration', 2, 'transition-timing-function은 가속도 곡선을 제어하는 속성이다.'),
                                                                                                                           (92, '다음 애니메이션 선언에서 animation-iteration-count 값을 무한 반복으로 설정하려면 올바른 값은? animation: spin 1s linear _____;', 1, 'low', 'infinite', 'forever', 'loop', '0', 2, '"infinite"는 애니메이션을 무한 반복하도록 지정하는 값이다.'),
                                                                                                                           (93, '@keyframes 규칙에서 from 과 to 키워드는 각각 어떤 백분율에 해당하는가?', 1, 'low', '0%와 100%', '25%와 75%', '50%와 100%', '100%와 0%', 2, 'from은 0%, to는 100%를 의미한다.'),
                                                                                                                           (94, '다음 선언 중 애니메이션이 끝난 후 마지막 프레임 상태를 유지하려면 어떤 속성을 추가해야 하는가? animation: fade 2s ease;', 1, 'medium', 'animation-fill-mode: forwards;', 'animation-direction: reverse;', 'animation-play-state: paused;', 'animation-delay: 2s;', 2, 'animation-fill-mode: forwards는 애니메이션 종료 후 마지막 상태를 유지한다.'),
                                                                                                                           (95, 'transition: opacity 200ms ease-in-out 50ms; 선언에서 50ms는 어떤 의미인가?', 1, 'medium', '지연(delay)', '총 지속 시간(duration)', '가속 곡선(timing-function)', '전환 대상 속성(property)', 2, '마지막 값은 transition-delay로, 전환 시작 전 지연 시간을 의미한다.'),
                                                                                                                           (96, '사용자가 페이지에 마우스를 올렸을 때 애니메이션을 일시 정지하려면 버튼:hover { _____: paused; } 빈칸에 들어갈 속성은?', 1, 'medium', 'animation-play-state', 'animation-status', 'animation-mode', 'animation-state', 2, 'animation-play-state는 애니메이션의 재생 상태를 제어한다.'),
                                                                                                                           (97, '다음 중 GPU 가속을 활용하여 부드러운 애니메이션을 만들기 위해 흔히 권장되는 속성은?', 1, 'high', 'transform', 'top', 'margin-left', 'width', 2, 'transform은 GPU 가속을 사용하므로 애니메이션에 적합하다.'),
                                                                                                                           (98, '미디어쿼리 prefer-reduced-motion 에 대한 설명으로 옳은 것은?', 1, 'high', '사용자가 움직임 감소를 선호하면 true가 된다', '브라우저 창 크기를 줄였을 때 트리거된다', '고해상도 화면에서만 동작한다', '모바일 기기에서만 지원된다', 2, 'prefer-reduced-motion은 사용자의 설정을 반영해 애니메이션을 줄이는 용도로 사용된다.'),
                                                                                                                           (99, '@media only screen and (max-width: 600px) { … } 규칙은 어떤 상황에서 적용되는가?', 1, 'high', '뷰포트 너비가 600px 이하일 때', '뷰포트 너비가 600px 이상일 때', '고대비 모드일 때', '사용자가 다크 모드를 켰을 때', 2, 'max-width는 지정된 너비 이하일 때 CSS를 적용하는 조건이다.'),
                                                                                                                           (100, 'vh 단위 50vh는 무엇을 의미하는가?', 1, 'high', '뷰포트 높이의 50%', '부모 요소 높이의 50%', '문서 전체 높이의 50%', '뷰포트 너비의 50%', 2, 'vh는 뷰포트 높이의 백분율로, 50vh는 화면 높이의 절반이다.'),
                                                                                                                           (101, 'JavaScript에서 변수를 선언할 수 없는 키워드는?', 4, 'low', 'let', 'const', 'var', 'define', 3, 'define은 JavaScript에서 예약어나 변수 선언 키워드로 사용되지 않는다.'),
                                                                                                                           (102, '다음 중 JavaScript의 숫자형 타입은?', 1, 'low', 'Number', 'Int', 'Float', 'Decimal', 3, 'Number는 JavaScript의 기본 숫자형 타입으로 정수 및 실수를 모두 표현할 수 있다.'),
                                                                                                                           (103, '문자열을 나타내는 방법으로 올바르지 않은 것은?', 4, 'low', "'Hello'", '"Hello"', '`Hello`', '<Hello>', 3, '<Hello>는 문자열이 아닌 HTML 태그 형태로 간주되어 JavaScript 문자열 리터럴로 유효하지 않다.'),
                                                                                                                           (104, 'undefined와 null의 차이에 대한 설명으로 옳은 것은?', 2, 'medium', '둘 다 같은 의미이다', 'undefined는 값이 할당되지 않음', 'null은 정의되지 않음', 'undefined는 명시적 초기화', 3, 'undefined는 변수가 선언되었지만 아직 값이 할당되지 않은 상태를 나타낸다.'),
                                                                                                                           (105, 'typeof null의 결과는?', 1, 'medium', 'object', 'null', 'undefined', 'string', 3, 'typeof null은 "object"를 반환하는데, 이는 JavaScript의 오래된 버그로 알려져 있다.'),
                                                                                                                           (106, 'JavaScript에서 템플릿 리터럴은 무엇으로 묶는가?', 3, 'medium', "'", '"', '`', '~', 3, '`는 템플릿 리터럴을 작성할 때 사용하는 backtick(백틱) 기호이다.'),
                                                                                                                           (107, 'NaN은 어떤 상황에서 발생하는가?', 1, 'high', '숫자 나누기 문자', '0 나누기 0', '문자 더하기 숫자', 'undefined와 연산', 3, '숫자를 문자와 나누는 등 수치 계산이 불가능한 연산에서 NaN이 발생한다.'),
                                                                                                                           (108, 'const로 선언된 변수는 어떤 특징이 있는가?', 3, 'high', '재선언 가능', '값 변경 가능', '블록 스코프', '자동 초기화', 3, 'const는 블록 스코프를 가지며, 선언 시 반드시 초기화가 필요하고 재할당이 불가능하다.'),
                                                                                                                           (109, '다음 중 falsy 값이 아닌 것은?', 4, 'high', '0', "''", 'false', "'false'", 3, "'false'는 문자열이므로 truthy 값으로 평가된다."),
                                                                                                                           (110, 'JavaScript에서 세미콜론(;)은 언제 필수인가?', 3, 'high', '항상', '절대로 필요 없음', '문장 끝', '객체 안에서', 3, 'JavaScript는 자동 세미콜론 삽입 기능이 있지만, 문장 끝에 명확하게 종료하기 위해 세미콜론을 사용하는 것이 안전하다.'),
                                                                                                                           (111, 'JavaScript에서 조건문 if를 작성할 때 사용하는 키워드는?', 2, 'low', 'when', 'if', 'cond', 'case', 3, 'if는 JavaScript에서 조건문을 정의할 때 사용하는 기본 키워드이다.'),
                                                                                                                           (112, '조건문에서 여러 조건을 연결하는 연산자는?', 3, 'low', '&', '|', '&&', '==', 3, '&&는 여러 조건을 AND로 연결하는 논리 연산자이다.'),
                                                                                                                           (113, 'switch 문에서 각 조건을 나타내는 키워드는?', 1, 'low', 'case', 'when', 'option', 'check', 3, 'case는 switch 문에서 각 조건 분기를 정의할 때 사용된다.'),
                                                                                                                           (114, 'for 루프를 종료하는 키워드는?', 4, 'medium', 'skip', 'stop', 'continue', 'break', 3, 'break는 반복문을 완전히 종료하는 데 사용하는 키워드이다.'),
                                                                                                                           (115, '반복문의 조건을 건너뛰고 다음 반복으로 이동하는 키워드는?', 3, 'medium', 'skip', 'next', 'continue', 'redo', 3, 'continue는 현재 반복을 건너뛰고 다음 반복으로 넘어가게 한다.'),
                                                                                                                           (116, 'while 반복문의 조건이 false이면?', 3, 'medium', '무한 반복', '한 번 실행', '실행 안 됨', '오류 발생', 3, '실행 안 됨이므로 조건이 false이면 while 반복문은 실행되지 않는다.'),
                                                                                                                           (117, 'do...while 루프의 특징으로 옳은 것은?', 3, 'high', '조건을 먼저 검사', '조건이 true면 반복 안 함', '무조건 한 번 실행', '사용 불가', 3, '"무조건 한 번 실행"은 do...while 반복문의 특징으로, 조건과 무관하게 최소 1회 실행된다.'),
                                                                                                                           (118, 'switch 문에서 break를 생략하면?', 3, 'high', '에러 발생', '기본값 실행', '다음 case까지 실행', '루프 종료', 3, 'switch 문에서 break를 생략하면 이후의 case 구문들이 연달아 실행된다.'),
                                                                                                                           (119, '다음 중 삼항 연산자의 형식으로 올바른 것은?', 1, 'high', '조건 ? 참 : 거짓', '조건 : 참 ? 거짓', '조건 ? 거짓 : 참', 'if ? then : else', 3, '조건 ? 참 : 거짓는 삼항 조건 연산자의 기본 구문이다.'),
                                                                                                                           (120, 'for (let i = 0; i < 5; i++)에서 i++의 의미는?', 2, 'high', 'i를 1로 설정', 'i를 1씩 증가', 'i를 출력', 'i를 감소', 3, 'i++는 반복 변수 i의 값을 한 번씩 증가시키는 역할을 한다.'),
                                                                                                                           (121, 'JavaScript에서 함수를 선언하는 키워드는?', 2, 'low', 'method', 'function', 'define', 'func', 3, 'function는 JavaScript에서 함수 선언 시 사용하는 표준 키워드이다.'),
                                                                                                                           (122, '함수를 실행하려면 어떻게 해야 하는가?', 3, 'low', 'call()', 'invoke()', '함수명()', 'do()', 3, '함수명()는 정의된 함수를 호출하는 기본적인 방법이다.'),
                                                                                                                           (123, '함수 내에서 사용된 변수는 기본적으로 어떤 스코프를 가지는가?', 2, 'low', '전역', '지역', '블록', '클래스', 3, '지역은 함수 내에서 선언된 변수의 기본 스코프이다.'),
                                                                                                                           (124, '화살표 함수의 기본 형태로 올바른 것은?', 2, 'medium', 'function => {}', '() => {}', '-> {}', '{} => ()', 3, '() => {}는 JavaScript의 화살표 함수 기본 문법이다.'),
                                                                                                                           (125, '함수 표현식은 어떤 변수 키워드와 함께 자주 사용되는가?', 4, 'medium', 'let', 'const', 'var', '모두 해당', 3, '함수 표현식은 const, let, var 모두와 함께 사용 가능하지만 var의 경우, 호이스팅(hoisting)과 함수 스코프 문제로 인해 예측하기 어려운 동작이 발생할 수 있어 지양된다.'),
                                                                                                                           (126, 'return 키워드의 기능은?', 2, 'medium', '함수를 종료', '값을 반환', '다음 반복으로 이동', '코드를 건너뜀', 3, 'return 기능은 함수를 종료하고 값을 반환하는 키워드이다.'),
                                                                                                                           (127, '화살표 함수에서 this는 무엇을 참조하는가?', 4, 'high', '전역 객체', '함수 자신', '호출 컨텍스트', '화살표 함수는 this를 가지지 않음', 3, '화살표 함수는 일반 함수와 달리 this를 가지지 않고 상위 스코프의 this를 사용한다.'),
                                                                                                                           (128, '즉시 실행 함수(IIFE)의 형식으로 맞는 것은?', 3, 'high', 'function(){}', '() => {}', '(function() {})()', '{}();', 3, '(function() {})()는 즉시 실행 함수(IIFE)의 올바른 문법이다.'),
                                                                                                                           (129, '함수에서 매개변수를 생략하면?', 2, 'high', '에러 발생', 'undefined로 처리', '0으로 초기화', 'null로 초기화', 3, '함수 호출 시 전달하지 않은 인자는 자동으로 undefined가 된다.'),
                                                                                                                           (130, '함수 내부에서 정의된 함수는 어떤 범위를 가지는가?', 3, 'high', '전역', '함수 외부', '지역', 'DOM', 3, '함수 내에서 정의된 함수는 해당 함수의 지역 범위에서만 유효하다.'),
                                                                                                                           (131, 'JavaScript에서 배열을 생성하는 방법으로 옳은 것은?', 1, 'low', 'var a = [];', 'var a = {};', 'var a = ()', 'var a = <>;', 3, 'var a = [];는 JavaScript 배열 생성 문법이다.'),
                                                                                                                           (132, '객체에서 속성에 접근하는 방법은?', 2, 'low', 'obj->key', 'obj.key', 'obj-key', 'obj:key', 3, 'obj.key는 객체의 속성에 접근하는 표준 점 표기법이다.'),
                                                                                                                           (133, '다음 중 배열에 요소를 추가하는 메서드는?', 1, 'low', 'push()', 'pop()', 'shift()', 'splice()', 3, 'push()는 배열의 끝에 요소를 추가하는 메서드이다.'),
                                                                                                                           (134, '객체의 속성 값을 삭제하는 키워드는?', 2, 'medium', 'remove', 'delete', 'clear', 'drop', 3, 'delete는 객체의 속성을 삭제하는 데 사용하는 키워드이다.'),
                                                                                                                           (135, '배열의 모든 요소에 대해 반복 실행하는 메서드는?', 2, 'medium', 'map()', 'forEach()', 'filter()', 'reduce()', 3, 'forEach()는 배열의 각 요소에 대해 콜백 함수를 실행하는 메서드이다.'),
                                                                                                                           (136, '객체의 모든 키를 배열로 반환하는 메서드는?', 2, 'medium', 'Object.values()', 'Object.keys()', 'Object.entries()', 'Object.map()', 3, 'Object.keys()는 객체의 key 목록을 배열로 반환하는 메서드이다.'),
                                                                                                                           (137, '배열에서 요소를 제거하는 pop()은 어느 쪽 요소를 제거하는가?', 3, 'high', '처음', '중간', '마지막', '랜덤', 3, 'pop()은 배열의 마지막 요소를 제거하는 메서드이다.'),
                                                                                                                           (138, '배열의 길이를 반환하는 속성은?', 3, 'high', 'size', 'count', 'length', 'items', 3, 'length는 배열의 길이를 반환하는 속성이다.'),
                                                                                                                           (139, '객체의 속성과 값을 모두 배열 형태로 반환하는 메서드는?', 3, 'high', 'Object.keys()', 'Object.values()', 'Object.entries()', 'Object.toArray()', 3, 'Object.entries()는 객체의 key-value 쌍을 배열 형태로 반환한다.'),
                                                                                                                           (140, '배열의 복사를 위한 메서드로 적절한 것은?', 1, 'high', 'slice()', 'splice()', 'pop()', 'map()', 3, 'slice()는 배열을 복사할 때 사용하는 메서드로, 원본 배열을 변경하지 않는다.'),
                                                                                                                           (141, 'HTML 요소를 JavaScript로 가져올 때 사용하는 메서드는?', 3, 'low', 'getElement()', 'query()', 'getElementById()', 'fetchElement()', 3, 'getElementById()는 특정 id 값을 가진 요소를 선택하는 메서드이다.'),
                                                                                                                           (142, '다음 중 이벤트 리스너 등록 메서드는?', 3, 'low', 'addEvent()', 'setEvent()', 'addEventListener()', 'eventListen()', 3, 'addEventListener()는 이벤트 리스너를 요소에 등록하는 표준 메서드이다.'),
                                                                                                                           (143, '버튼 클릭 시 실행되는 이벤트 타입은?', 3, 'low', 'hover', 'mousedown', 'click', 'submit', 3, 'click은 사용자가 버튼을 클릭했을 때 발생하는 이벤트 타입이다.'),
                                                                                                                           (144, '다음 중 innerText와 유사한 속성은?', 3, 'medium', 'textValue', 'htmlText', 'textContent', 'innerHTML', 3, 'textContent는 요소의 텍스트 콘텐츠를 가져오거나 설정할 수 있는 속성이다.'),
                                                                                                                           (145, '이벤트 객체에서 발생한 요소를 참조하는 속성은?', 1, 'medium', 'target', 'source', 'caller', 'element', 3, 'target은 이벤트가 발생한 요소를 참조하는 이벤트 객체의 속성이다.'),
                                                                                                                           (146, '이벤트 전파를 막는 메서드는?', 2, 'medium', 'preventDefault()', 'stopPropagation()', 'cancelEvent()', 'blockEvent()', 3, 'stopPropagation()는 이벤트의 버블링(전파)을 중지시킨다.'),
                                                                                                                           (147, 'DOMContentLoaded 이벤트는 언제 발생하는가?', 3, 'high', '페이지 로딩 시작 시', '스크립트 로딩 완료 시', 'DOM 트리 완성 시', '이미지 로딩 완료 시', 3, 'DOMContentLoaded는 문서의 DOM이 완전히 로드되었을 때 발생하는 이벤트이다.'),
                                                                                                                           (148, 'innerHTML 속성의 특징으로 옳은 것은?', 3, 'high', '보안에 강함', '텍스트만 출력', 'HTML 태그 포함 출력', '읽기 전용', 3, 'innerHTML은 HTML 태그가 포함된 콘텐츠를 설정하거나 가져올 수 있다.'),
                                                                                                                           (149, 'HTML 요소 클래스 추가 시 사용하는 메서드는?', 4, 'high', 'addClass()', 'appendClass()', 'classAdd()', 'classList.add()', 3, 'classList.add()는 HTML 요소에 클래스를 추가하는 메서드이다.'),
                                                                                                                           (150, '폼 제출 시 기본 동작을 막으려면?', 2, 'high', 'event.stopPropagation()', 'event.preventDefault()', 'return false', 'event.block()', 3, 'event.preventDefault()는 form 제출 시 기본 동작을 막기 위한 이벤트 메서드이다.'),
                                                                                                                           (151, '다음 선언에서 변수 greeting 의 타입은? let greeting: string = "hello";', 1, 'low', 'string', 'any', 'String (래퍼 객체)', 'never', 4, 'string는 TypeScript에서 명시적으로 문자열 타입을 선언하는 방식이다.'),
                                                                                                                           (152, 'number[] 타입과 완전히 같은 의미를 갖는 배열 선언은?', 1, 'low', 'Array<number>', 'ReadonlyArray<number>', 'Array<any>', 'boolean[]', 4, 'Array<number>는 number[]와 동일한 의미의 제네릭 배열 타입 표현이다.'),
                                                                                                                           (153, '타입 단언(as)을 올바르게 사용한 예시는?', 1, 'low', 'const el = document.getElementById("app") as HTMLDivElement;', 'const num = "3" as number[];', 'const flag = (true) as never;', 'let v = 1; v as;', 4, 'DOM 요소에 대한 구체적인 타입 단언은 as 키워드를 사용하여 정확히 명시할 수 있다.'),
                                                                                                                           (154, 'unknown 과 any 의 차이에 대한 설명 중 옳은 것은?', 1, 'medium', 'unknown 값은 사용 전 타입 좁히기(narrowing)가 필요하다', 'any 값은 컴파일 단계에서 아무 연산도 허용되지 않는다', 'unknown 은 런타임에만 존재하는 타입이다', 'any 로 선언된 변수는 자동으로 never 로 업캐스트된다', 4, 'unknown은 타입 안정성을 위해 사용 전에 타입 확인이 필요하다.'),
                                                                                                                           (155, '다음 함수의 반환 타입으로 가장 적절한 것은? function fail(msg: string) { throw new Error(msg); }', 1, 'medium', 'never', 'void', 'undefined', 'unknown', 4, 'throw만 하는 함수는 절대 값을 반환하지 않으므로 never가 적절하다.'),
                                                                                                                           (156, 'enum Color { Red, Green, Blue } 선언에서 Color.Green 의 값은?', 1, 'medium', '1', '0', '"Green"', 'undefined', 4, 'enum은 기본적으로 0부터 시작하며 Green은 1이다.'),
                                                                                                                           (157, '다음 중 튜플 타입을 올바르게 선언한 것은?', 1, 'high', 'let point: [number, number] = [1, 2];', 'let point: (number, number) = 1, 2;', 'let point = [number, number];', 'let point: number[] = [1, "2"];', 4, '튜플은 정확한 타입과 개수의 배열을 표현할 수 있다.'),
                                                                                                                           (158, 'const assertion을 활용해 모든 프로퍼티를 읽기 전용 리터럴로 만드는 예시는? const cfg = _____;', 1, 'high', '{ mode: "dark" } as const', 'as const { mode: "dark" }', '{ mode: "dark" } as readonly', 'const { mode: "dark" }', 4, 'as const는 전체 객체를 리터럴 타입 및 readonly로 만든다.'),
                                                                                                                           (159, '다음 코드에서 Keys 타입은 무엇이 되는가? enum E { A, B, C } type Keys = keyof typeof E;', 1, 'high', '"A" | "B" | "C"', '0 | 1 | 2', 'E', 'keyof E (컴파일 오류)', 4, 'typeof E를 사용하면 열거형의 키 값을 유니언 타입으로 추출할 수 있다.'),
                                                                                                                           (160, 'const str = "hello"; 변수 str 의 타입 추론 결과는?', 1, 'high', '"hello" (리터럴 타입)', 'string', 'any', 'never', 4, 'const 변수는 리터럴 값으로 타입이 추론된다.'),
                                                                                                                           (161, '다음 화살표 함수에서 TypeScript가 추론한 반환 타입은? const add = (a: number, b: number) => a + b;', 1, 'low', 'number', 'void', 'any', 'never', 4, '두 숫자의 덧셈 결과는 number이므로 타입 추론도 number이다.'),
                                                                                                                           (162, '‘나머지 매개변수’(rest parameter)를 올바르게 선언한 예시는?', 1, 'low', 'function sum(...nums: number[]): number { /*...*/ }', 'function sum(nums...: number): number { /*...*/ }', 'function sum(..nums: number[]): number { /*...*/ }', 'function sum(nums:number) ...rest { /*...*/ }', 4, '...nums는 여러 인수를 배열 형태로 받는 문법이다.'),
                                                                                                                           (163, '다음 함수 호출 시 컴파일 오류가 발생하지 않도록 하려면 f에 필요한 오버로드 시그니처는? f("hi"); f(1, 2);', 1, 'low', 'function f(str: string): void; function f(a: number, b: number): void;', 'function f(arg: string | number): void;', 'function f(...args: any[]): void;', 'function f(str: string, num: number): void;', 4, '다양한 시그니처를 허용하려면 오버로드 선언이 필요하다.'),
                                                                                                                           (164, '제네릭 함수 identity<T>(value: T): T 를 호출한 결과의 타입은? const x = identity<string>("abc");', 1, 'medium', 'string', 'T', 'any', 'void', 4, 'T는 string으로 지정되었기 때문에 반환 타입도 string이다.'),
                                                                                                                           (165, '제네릭 제약(Constraint)을 올바르게 사용한 예시는?', 1, 'medium', 'function logLength<T extends { length: number }>(arg: T): number { return arg.length; }', 'function logLength<T = { length: number }>(arg: T): number { return arg.length; }', 'function logLength<T super { length: number }>(arg: T): number { return arg.length; }', 'function logLength<T implements Lengthable>(arg: T): number { return arg.length; }', 4, 'T extends { length: number }를 통해 길이를 가진 타입만 허용할 수 있다.'),
                                                                                                                           (166, '`this` 매개변수 타입을 명시해 오류를 방지한 올바른 선언은?', 1, 'medium', 'function handler(this: void, e: Event): void { /*...*/ }', 'function handler(e: Event, this): void { /*...*/ }', 'function handler(this Event, e): void { /*...*/ }', 'function handler(e: Event): this { /*...*/ }', 4, 'this: void를 명시하면 함수 내부에서 this 사용을 방지할 수 있다.'),
                                                                                                                           (167, '다음 코드에서 T의 기본 타입 매개변수가 string이 되도록 올바른 선언은?', 1, 'medium', 'function wrap<T = string>(value?: T): T[] { return [value as T]; }', 'function wrap<T extends string>(value: T = ""): T[] { return [value]; }', 'function wrap<T defaults string>(value?: T): T[] { return [value]; }', 'function wrap<T string>(value?: T): T[] { return [value]; }', 4, '기본 제네릭 타입은 = 을 통해 지정할 수 있다.'),
                                                                                                                           (168, 'TypeScript 함수 오버로드에서 ‘구현부(implementation)’에 대해 옳은 설명은?', 1, 'high', '선언된 여러 시그니처 뒤에 단 하나만 존재해야 한다', '오버로드마다 구현을 따로 작성해야 한다', '구현부의 매개변수는 반드시 any 타입이어야 한다', '구현부는 export 되어서는 안 된다', 4, '오버로드 시 실제 구현은 단 한 개여야 하며 마지막에 위치한다.'),
                                                                                                                           (169, '다음 함수는 왜 컴파일 오류가 나는가? function foo(a?: number, b: number) {}', 1, 'high', '선택 매개변수는 필수 매개변수 뒤에 올 수 없다', 'number 타입에는 선택 여부를 지정할 수 없다', 'void 반환형을 명시하지 않았다', '매개변수가 두 개 이상이면 반드시 rest 사용', 4, '선택 매개변수는 항상 마지막에 위치해야 한다.'),
                                                                                                                           (170, '다음 제네릭 함수에서 T가 string | number 일 때 반환 타입은? function toArray<T>(value: T): T[] { return [value]; }', 1, 'high', '(string | number)[]', 'string[] | number[]', 'never[]', 'any[]', 4, 'T가 유니언이면 결과 배열도 유니언 타입의 요소를 갖는다.'),
                                                                                                                           (171, '다음 중 인터페이스 선언으로 올바른 것은?', 1, 'low', 'interface User { id: number; name?: string }', 'interface = User { id number; }', 'type interface User = { id: number }', 'interface User: { id; number }', 4, 'interface 문법에서 키워드와 블록 구성에 맞는 정확한 문법이다.'),
                                                                                                                           (172, '타입 별칭으로 제네릭을 선언할 때 올바른 문법은?', 1, 'low', 'type Box<T> = { value: T };', 'alias Box<T> { value: T }', 'type<T> Box = { value: T }', 'typedef Box<T> = { value: T };', 4, 'type 키워드와 함께 <T>를 선언부에서 지정하여 사용한다.'),
                                                                                                                           (173, '`type Keys = keyof { a: string; b: number }` 의 결과는?', 1, 'low', '"a" | "b"', 'string | number', '"a" & "b"', 'any', 4, 'keyof 연산자는 객체의 key들을 유니언 문자열 타입으로 반환한다.'),
                                                                                                                           (174, '인터섹션 타입 A & B 에 대한 설명으로 옳은 것은?', 1, 'medium', 'A 와 B 모두의 프로퍼티를 가진 타입이다', 'A 와 B 중 하나를 선택한 유니언이다', '런타임에 자동으로 객체를 병합한다', '중복 프로퍼티가 있으면 never 타입이 된다', 4, '& 연산자는 두 타입의 조합을 나타내며 모든 프로퍼티를 포함한다.'),
                                                                                                                           (175, '다음 유니언 타입을 차별화(discriminated) 하기 위한 공통 프로퍼티는?', 1, 'medium', 'kind', 'length', 'value', 'type', 4, '유니언 타입을 구분하려면 공통 literal 프로퍼티를 사용해야 하며, 보통 kind 또는 type을 사용한다.'),
                                                                                                                           (176, '다음 매핑된 타입 선언의 효과는? type Readonly<T> = { readonly [K in keyof T]: T[K] };', 1, 'medium', '모든 프로퍼티를 readonly 로 만든다', '모든 프로퍼티를 선택적(optional)으로 만든다', '프로퍼티를 제거한다', '함수 타입으로 변환한다', 4, 'Mapped type에서 readonly를 명시하면 모든 키가 읽기 전용이 된다.'),
                                                                                                                           (177, '조건부 타입 T extends string ? string : number 에서 T가 boolean일 때 평가 결과는?', 1, 'high', 'number', 'string', 'boolean', 'never', 4, 'boolean은 string을 상속하지 않으므로 조건식의 false 분기인 number가 선택된다.'),
                                                                                                                           (178, '분배 조건부 타입에서 never가 결과로 나오지 않도록 하려면 사용하는 래퍼(Wrapper) 기법은?', 1, 'high', '튜플로 감싸기 `[T]`', 'Partial<T> 적용', 'keyof T 사용', 'as const 단언', 4, '조건부 타입 분배를 방지하려면 분배되는 타입을 튜플로 감싼다.'),
                                                                                                                           (179, '다음 인터페이스가 있을 때 Optional<T> 의 역할은? interface User { id: number; name: string } type Optional<T> = { [K in keyof T]?: T[K] };', 1, 'high', '모든 프로퍼티를 선택적으로 만든다', '모든 프로퍼티를 필수로 만든다', '프로퍼티 key를 union 으로 반환', 'T 타입을 조건부 타입으로 변환', 4, 'Mapped type에 ?를 추가하면 모든 속성이 optional이 된다.'),
                                                                                                                           (180, '다음 인덱스 시그니처 선언의 의미는? interface StringMap { [key: string]: string }', 1, 'high', '임의의 문자열 키에 대해 값은 string 이어야 한다', '키와 값이 항상 같은 문자열이다', '숫자 인덱스 전용 객체이다', '키는 리터럴 타입만 허용한다', 4, '인덱스 시그니처는 임의의 key를 허용하고 해당 타입의 값을 가진다.'),
                                                                                                                           (181, '다음 클래스 선언에서 명시적으로 접근 제한자를 생략한 name 필드의 기본 접근 수준은?', 1, 'low', 'public', 'private', 'protected', 'readonly', 4, '접근 제한자를 명시하지 않으면 기본적으로 public으로 간주된다.'),
                                                                                                                           (182, 'readonly 프로퍼티는 어디에서만 값을 할당(변경)할 수 있는가?', 1, 'low', '선언과 동시에 또는 생성자 내부', '어디서든 한 번만', '클래스 외부 아무 곳', '정적 메서드 내부', 4, 'readonly 속성은 선언과 생성자 내부에서만 초기화할 수 있다.'),
                                                                                                                           (183, '다음 코드가 컴파일 오류를 일으키는 이유는? abstract class Base {} const b = new Base();', 1, 'low', 'abstract 클래스는 직접 인스턴스화할 수 없다', 'Base 클래스에 constructor가 없다', 'extends 키워드가 필요하다', '타입 매개변수가 누락됐다', 4, 'abstract 클래스는 인스턴스를 만들 수 없고 반드시 상속해서 사용해야 한다.'),
                                                                                                                           (184, '클래스 멤버 데코레이터를 사용하려면 tsconfig에 설정해야 하는 Compiler 옵션은?', 1, 'medium', '"experimentalDecorators": true', '"emitDecoratorMetadata": false', '"useDecorators": true', '"strict": false', 4, '데코레이터를 사용하려면 experimentalDecorators를 true로 설정해야 한다.'),
                                                                                                                           (185, '다음 코드 중 매개변수 프로퍼티(Parameter Property)를 이용한 예시는?', 1, 'medium', 'constructor(private id: number, public name: string)', 'id!: number;', 'public getId() { return this.id }', 'static from(obj: any) { ... }', 4, '생성자 매개변수에 접근 제한자를 붙이면 자동으로 프로퍼티가 생성된다.'),
                                                                                                                           (186, 'protected 멤버에 대한 설명으로 틀린 것은?', 3, 'medium', '동일 클래스 내부에서 접근 가능하다', '파생(하위) 클래스 내부에서 접근 가능하다', '클래스 인스턴스 외부에서 접근 가능하다', '인스턴스 외부에서는 접근 불가하다', 4, 'protected는 외부에서 접근할 수 없으며 하위 클래스에서만 접근 가능하다.'),
                                                                                                                           (187, '모듈 시스템에서 모든 내보내기를 객체 하나로 가져오는 올바른 구문은?', 1, 'medium', 'import * as utils from "./utils";', 'import utils.* from "./utils";', 'import { * } from "utils";', 'require("./utils") as *', 4, 'import * as 식별자 from 경로; 형식이 모든 내보내기를 가져오는 방식이다.'),
                                                                                                                           (188, 'static 멤버에 대한 올바른 접근 방법은? class Counter { static total = 0; }', 1, 'high', 'Counter.total', 'new Counter().total', 'Counter.prototype.total', 'this.total', 4, 'static 속성은 클래스 이름으로 직접 접근해야 한다.'),
                                                                                                                           (189, '클래스 데코레이터 함수의 첫 번째 매개변수 타입은?', 1, 'high', '생성자 함수를 나타내는 (new (...args: any[]) => any)', '인스턴스 타입', 'string', 'PropertyDescriptor', 4, '클래스 데코레이터는 생성자 함수(constructor)를 첫 인자로 받는다.'),
                                                                                                                           (190, '다음 import 구문이 기본값과 이름 내보내기를 동시에 가져오는 정확한 형태는?', 1, 'high', 'import def, { named } from "./mod";', 'import { default as def, named } from "./mod";', 'import * as def, named from "./mod";', 'import def, named from "mod";', 4, '기본값은 def로, 이름 내보내기는 {} 안에 명시하여 가져온다.'),
                                                                                                                           (191, '다음 조건부 타입에서 T가 string | number 일 때 Inferred 타입은? type Inferred<T> = T extends string ? 1 : 0;', 1, 'low', '1 | 0', 'never', '1', '0', 4, '조건부 타입은 유니언 분배로 인해 각 타입에 대해 평가되어 결과가 유니언 타입이 된다.'),
                                                                                                                           (192, '유틸리티 타입 Partial<T> 의 효과는?', 1, 'low', 'T의 모든 프로퍼티를 선택적(optional)으로 만든다', 'T의 모든 프로퍼티를 읽기 전용으로 만든다', 'T의 프로퍼티를 제거한다', 'T를 never 로 변환한다', 4, '유틸리티 타입 Partial<T>는 T의 모든 프로퍼티를 선택적(optional)으로 만든다'),
                                                                                                                           (193, '다음 제네릭에서 infer U 로 추론되는 타입 U는? type ElementType<T> = T extends (infer U)[] ? U : T;', 1, 'low', '배열의 요소 타입', '배열 자체 타입', 'never', 'unknown', 4, 'infer 키워드는 조건부 타입에서 일부 타입을 추론할 수 있도록 해준다.'),
                                                                                                                           (194, '`NonNullable<T>` 유틸리티 타입은 어떤 멤버를 제거하는가?', 1, 'medium', 'null 과 undefined', 'void', 'never', '0 과 ""', 4, 'NonNullable은 null과 undefined를 제거한 타입을 반환한다.'),
                                                                                                                           (195, '다음 매핑된 타입에서 `-?` 기호의 의미는? type Req<T> = { [K in keyof T]-?: T[K] };', 1, 'medium', '선택적(?) 속성 한정자를 제거해 필수로 만든다', 'readonly 한정자를 제거한다', '프로퍼티 키를 제거한다', 'Union 타입을 분배한다', 4, '-?는 선택적 속성을 강제로 필수 속성으로 전환한다.'),
                                                                                                                           (196, 'Exclude<"a" | "b", "a"> 의 결과 타입은?', 1, 'medium', '"b"', '"a"', '"a" | "b"', 'never', 4, 'Exclude는 첫 번째 유니언 타입에서 두 번째를 제거한다.'),
                                                                                                                           (197, '다음 타입에서 infer R 은 무엇을 추론하는가? type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;', 1, 'high', '함수 반환 타입', '함수 매개변수 타입', '함수 this 타입', '함수 호출 시그니처 개수', 4, 'infer R은 함수 반환 타입을 추론하기 위한 키워드이다.'),
                                                                                                                           (198, '`Pick<T, K>` 유틸리티 타입 사용 시 K 의 제약은?', 1, 'high', 'keyof T 에 속하는 프로퍼티 key union 이어야 한다', '아무 Union 타입 가능', 'number 만 가능', 'T 의 값 타입이 포함되어야 한다', 4, 'K는 반드시 T의 key 중 일부여야 한다.'),
                                                                                                                           (199, '다음 조건부 타입에서 infer 키워드가 필요한 이유는? type First<T extends any[]> = T extends [infer F, ...any] ? F : never;', 1, 'high', '배열의 첫 요소 타입을 추론하기 위해', '배열 길이를 체크하기 위해', '프로미스 결과를 기다리기 위해', '제네릭 제약을 제거하기 위해', 4, 'infer는 조건부 타입에서 내부 타입을 추론할 수 있게 한다.'),
                                                                                                                           (200, '다음 타입 정의에서 readonly와 optional을 동시에 제거하려면 어떤 유틸리티 조합이 필요한가? type Clean<T> = ____<____<T>>;', 1, 'high', 'Required & Mutable (커스텀 Mutable 구현 필요)', 'NonNullable & Exclude', 'Pick & Omit', 'Partial & Readonly', 4, 'Required는 선택 속성을 제거하고, Mutable은 readonly를 제거하는 커스텀 유틸리티로 구현할 수 있다.'),
                                                                                                                           (201, 'Virtual DOM의 ‘가상’이 의미하는 것은?', 1, 'low', '메모리에 존재하는 DOM 트리의 추상화 객체', '웹 GL로 그린 3D DOM', '브라우저 외부에서 렌더링된 서버 DOM', 'CSS OM의 별칭', 5, 'Virtual DOM은 실제 DOM의 가벼운 추상화로, 메모리 상에서 구조를 모사한 객체이다.'),
                                                                                                                           (202, 'Virtual DOM을 가장 널리 보급한 라이브러리로 평가되는 것은?', 1, 'low', 'React', 'AngularJS 1.x', 'jQuery', 'Backbone.js', 5, 'React는 Virtual DOM 개념을 대중화한 대표적인 라이브러리이다.'),
                                                                                                                           (203, 'Virtual DOM이 브라우저 DOM 직접 조작 대비 성능 이점을 주는 주된 이유는?', 1, 'low', '여러 변경을 메모리상에서 모아 최소 패치로 적용하기 때문', 'JS 파싱 시간을 없애기 때문', 'CSS 계산을 스레드오프로드하기 때문', '네이티브 코드로 DOM API를 대체하기 때문', 5, 'Virtual DOM은 변경사항을 메모리에서 모아 실제 DOM에 최소한만 반영한다.'),
                                                                                                                           (204, '초기의 React(0.14 이전) 렌더 파이프라인 단계 순서는?', 1, 'medium', 'Render→Diff→Patch', 'Commit→Render→Diff', 'Diff→Render→Mount', 'Reflow→Paint→Diff', 5, 'Render 후 메모리 비교(Diff)를 거쳐 DOM에 Patch하는 순서였다.'),
                                                                                                                           (205, '2014년 페이스북 논문 ‘Efficient Virtual DOM and Incremental DOM’에서 강조한 핵심 최적화 중 하나는?', 1, 'medium', 'O(n) 키 기반 Diff', 'CSS-in-JS 캐싱', 'WebAssembly DOM 패치', 'Service Worker 프리패치', 5, '키 기반 O(n) 비교로 효율적인 리스트 diff 처리를 가능하게 한다.'),
                                                                                                                           (206, 'Virtual DOM 개념이 React 외에도 채택된 경량 라이브러리로 유명한 것은?', 1, 'medium', 'Snabbdom', 'Ember.js', 'Ext JS', 'GWT', 5, 'Snabbdom은 Virtual DOM 기반의 가볍고 성능 좋은 라이브러리이다.'),
                                                                                                                           (207, '‘Virtual DOM은 무조건 실제 DOM 조작보다 빠르다’는 주장에 대한 올바른 반박은?', 1, 'high', '계산·Diff 비용이 변경량보다 크면 실제 DOM이 더 빠를 수 있다', '브라우저가 Virtual DOM을 네이티브로 최적화하므로 항상 빠르다', 'JS 엔진이 JIT 컴파일을 못하면 Virtual DOM이 강제된다', 'HTML 문서 크기가 1 KB 미만이면 Virtual DOM이 필요 없다', 5, '변경이 많지 않을 경우 diff 비용이 더 클 수 있다.'),
                                                                                                                           (208, 'React 16 이상에서 Virtual DOM Fiber 아키텍처로 교체된 주된 목표는?', 1, 'high', '작업을 잘게 쪼개 스케줄링해 인터랙션 응답성을 높이기 위해', 'DOM API를 완전히 제거하기 위해', 'JS Bundle 크기를 절반으로 줄이기 위해', 'IE9 지원 유지 비용을 줄이기 위해', 5, 'Fiber는 타임 슬라이스 처리로 렌더링을 나눠 처리할 수 있게 한다.'),
                                                                                                                           (209, 'Virtual DOM 노드를 일반적으로 ‘VNode’라 부른다. 이 VNode가 직렬화·역직렬화에 적합한 이유는?', 1, 'high', '순수 JS 객체로 사이드이펙트 없이 표현돼 JSON 변환이 쉽다', 'DOM Node 인스턴스를 그대로 담기 때문이다', 'HTML 문자열과 1:1 매핑되기 때문이다', '브라우저 IndexedDB에 자동 캐싱되기 때문이다', 5, 'VNode는 순수 객체로 이루어져 있어 쉽게 JSON화할 수 있다.'),
                                                                                                                           (210, 'Virtual DOM 탄생 이전 퍼포먼스 병목 개선 전통 기법은?', 1, 'high', 'DOM Batching(문서 조각·프래그먼트에 변경 누적 후 일괄 삽입)', 'Web GPU 렌더링', 'HTTP/3 PUSH', 'SSR Streaming', 5, '기존에는 DOMFragment로 DOM 조작을 모아서 일괄 처리하는 방식이 사용됐다.'),
                                                                                                                           (211, 'React의 기본 Diff 전략이 O(n) 복잡도를 달성하는 핵심 전제는?', 1, 'low', '같은 레벨(Depth)에서만 노드를 비교한다', '모든 형제 노드를 완전 탐색(DFS)한다', 'HTML 태그 이름이 바뀌면 서브트리를 재귀 비교한다', '키가 중복될 때만 비교를 건너뛴다', 5, 'DOM 구조의 깊이를 유지하며 효율적으로 비교한다.'),
                                                                                                                           (212, '리스트 요소에 안정적 Key를 지정하지 않으면 발생할 수 있는 UI 문제는?', 1, 'low', '입력‧포커스 상태가 잘못된 항목으로 이동한다', 'DOM 노드가 절대로 재사용되지 않는다', 'CSS 클래스가 적용되지 않는다', '브라우저 스크롤 위치가 고정된다', 5, 'Key가 없으면 동일 요소로 인식되지 않아 상태가 꼬일 수 있다.'),
                                                                                                                           (213, '아래 중 Key로 사용하기에 가장 안전한 값은?', 1, 'low', '데이터베이스에서 보장된 고유 id', '배열 index', 'Date.now() 호출 결과', 'Math.random() 결과', 5, '고유 식별 가능한 값이 key로 가장 적합하다.'),
                                                                                                                           (214, 'Diff 과정에서 태그 이름이 다른 두 노드가 만나면 React는 어떻게 처리하는가?', 1, 'medium', '이전 노드를 언마운트하고 새 노드를 마운트한다', '텍스트 콘텐츠만 비교해 바꾼다', '속성을 깊이 비교해 바꾼다', '두 노드를 교환(Swap)한다', 5, '다른 태그는 다른 노드로 간주되어 완전히 교체된다.'),
                                                                                                                           (215, '형제 노드 순서 변경에 가장 큰 비용을 초래하는 Key 사용 패턴은?', 1, 'medium', 'index를 Key로 사용', '고유 id를 Key로 사용', '문자열 해시를 Key로 사용', '숫자형 Primary Key 사용', 5, 'index 사용은 삽입/삭제에 따른 위치 혼란을 초래할 수 있다.'),
                                                                                                                           (216, 'React Diff에서 ‘삽입·삭제·이동’ 3연산을 줄이기 위해 적용되는 리스트 최적화는?', 1, 'medium', 'Longest Increasing Subsequence(LIS) 탐색', 'Binary Search Tree 재구성', 'KMP 알고리즘', 'Dijkstra', 5, 'LIS 알고리즘은 최소 이동만으로 정렬을 유지할 수 있게 돕는다.'),
                                                                                                                           (217, 'key=index 사용 시 버그 위험이 가장 높은 경우는?', 1, 'high', '사용자가 Todo 항목을 드래그해 순서를 변경할 때', '초기 로딩 시 항목을 한 번만 표시할 때', 'Todo가 읽기 전용일 때', 'Todo 항목 수가 1개일 때', 5, '순서가 바뀔 수 있는 항목은 index key 사용 시 문제가 발생한다.'),
                                                                                                                           (218, 'Diff 알고리즘 성능을 정성적으로 측정하기에 가장 적합한 지표는?', 1, 'high', '렌더(Commit)당 DOM Mutation 개수', 'JS Heap 스냅샷 크기', '네트워크 Bandwidth 사용량', '브라우저 FPS(Max)', 5, '실제 DOM 변경 횟수는 성능 분석에 매우 중요한 지표이다.'),
                                                                                                                           (219, 'React 18 Fiber 스케줄러가 Diff 작업을 중단할 수 있는 이유는?', 1, 'high', 'Fiber 노드를 작업 단위로 쪼개 cooperative scheduling 이 가능해서', 'Virtual DOM을 Worker에서 실행하기 때문에', 'Diff를 WASM으로', 'Strict Mode 때문', 5, 'Fiber 구조는 렌더링 작업을 잘게 나누어 유휴 시간에 처리할 수 있게 한다.'),
                                                                                                                           (220, 'Vue 3 PatchFlag 활용 목적은?', 1, 'high', '변경 가능성 있는 부분만 빠르게 식별해 불필요한 비교를 줄이기 위해', '모든 노드를 깊이 비교하기 위해', 'HTML 문자열 파싱 속도를 높이기 위해', '브라우저 GC 트리거 회피', 5, 'PatchFlag는 VDOM diff 과정에서 필요한 노드만 빠르게 필터링하는 용도이다.'),
                                                                                                                           (221, 'React 18 렌더링 파이프라인의 기본 3단계 순서는?', 1, 'low', 'Render → Diff → Commit', 'Commit → Render → Diff', 'Diff → Commit → Render', 'Prepare → Paint → Commit', 5, '렌더링 중 계산(Render), 비교(Diff), 반영(Commit) 순서로 동작한다.'),
                                                                                                                           (222, 'Scheduler가 중단·재개할 수 있는 단계는?', 1, 'low', 'Render(Diff) 단계', 'Commit 단계', '브라우저 Paint 단계', 'Layout 단계', 5, 'Commit 단계는 중단 불가능하며 Render(Diff) 단계만 중단·재개가 가능하다.'),
                                                                                                                           (223, 'Batching은 여러 setState 호출을 어떻게 처리하는가?', 1, 'low', '하나의 렌더 사이클로 합친다', '각 호출마다 즉시 렌더', '첫 호출만 실행', 'setTimeout 지연', 5, 'setState가 여러 번 호출되어도 React는 이를 하나의 렌더링으로 묶는다.'),
                                                                                                                           (224, 'Fiber 노드의 우선순위 필드는?', 1, 'medium', 'lanes', 'tag', 'return', 'index', 5, 'lanes는 작업의 우선순위를 관리하는 핵심 개념이다.'),
                                                                                                                           (225, 'Concurrent Mode에서 긴 리스트 응답성 향상 API 조합은?', 1, 'medium', 'startTransition / useTransition', 'useLayoutEffect / flushSync', 'useImperativeHandle / forwardRef', 'unstable_batchedUpdates / act', 5, 'startTransition은 낮은 우선순위 작업으로 분리하여 UI 응답성을 높일 수 있게 한다.'),
                                                                                                                           (226, 'Commit 단계 직후 DOM 변경 확정 후 호출 훅은?', 1, 'medium', 'useLayoutEffect / componentDidMount', 'useEffect / componentDidUpdate', 'getSnapshotBeforeUpdate', 'shouldComponentUpdate', 5, 'DOM 반영 직후 useLayoutEffect가 먼저 호출되고 useEffect는 비동기로 호출된다.'),
                                                                                                                           (227, 'Fiber 트리 alternate 포인터가 가리키는 것은?', 1, 'high', '현재 트리와 작업 중 트리의 다른 하나', '부모 노드 sibling', 'DevTools 메타', 'Suspense fallback', 5, 'alternate는 현재 작업 중인 Fiber와 이전 상태를 연결한다.'),
                                                                                                                           (228, 'Suspense fallback 표시 시 Commit 단계 실제 동작은?', 1, 'high', '기존 UI 유지, fallback 부분만 커밋', '전체 DOM 언마운트', '레이아웃 강제', 'Fiber 루트 재생성', 5, 'Suspense는 로딩 중인 부분만 대체하고 나머지 UI는 그대로 유지한다.'),
                                                                                                                           (229, '우선순위 동등 업데이트 합치기 정책은?', 1, 'high', '가장 최근 업데이트만 남기고 합친다', 'FIFO 렌더', '무작위 처리', 'Deferred Value 생성', 5, '동일 우선순위의 업데이트는 마지막 것만 적용될 수 있다.'),
                                                                                                                           (230, 'Offscreen 컴포넌트 렌더 시 Render 비용 줄이는 기술은?', 1, 'high', 'display locking 대신 메모리 트리만 유지', 'Unmount', 'Server Components', 'lanes를 Idle', 5, 'Offscreen은 화면에 표시되지 않더라도 컴포넌트를 비활성 상태로 유지해 리렌더 비용을 최소화한다.'),
                                                                                                                           (231, 'DOM 패치 단계의 1차 목표는?', 1, 'low', '실제 DOM 변경을 최소 집합으로 적용해 레이아웃·페인트 비용을 줄인다', '가상 DOM 트리를 재귀적으로 깊이 비교한다', 'JS 엔진 GC 주기를 단축한다', 'HTTP 요청을 병렬화한다', 5, 'DOM 패치 단계에서는 실제 DOM 변경을 최소화하여 렌더링 비용을 줄이는 것이 목적이다.'),
                                                                                                                           (232, 'Layout 발생 트리거가 아닌 것은?', 1, 'low', '읽기만 수행하는 element.getBoundingClientRect()', 'style 변경', '노드 삭제', 'innerHTML 교체', 5, 'getBoundingClientRect()는 레이아웃을 트리거하지 않고 단순히 값을 읽어오는 메서드이다.'),
                                                                                                                           (233, 'React style 속성 diff 전략은?', 1, 'low', '바뀐 개별 CSS 프로퍼티만 set', 'cssText 전체 재할당', '모두 null 후 재적용', 'CSSOM 캐시 비움', 5, 'React는 성능을 위해 변경된 스타일 속성만 골라서 업데이트한다.'),
                                                                                                                           (234, 'Layout Thrashing 방지 일반 방법은?', 1, 'medium', 'read와 write 작업을 일괄 모아 순서대로 실행', '모든 DOM 작업 setTimeout', 'CSS will-change 남용', 'MutationObserver 감시', 5, 'read와 write를 섞지 않고 순차적으로 실행하면 Layout Thrashing을 방지할 수 있다.'),
                                                                                                                           (235, 'innerHTML 교체가 효율적일 수 있는 시나리오는?', 1, 'medium', '컨텐츠 전체가 한 번에 완전히 교체되고 작을 때', '리스트 일부 텍스트 변경', '대규모 테이블 셀 일부 업데이트', 'form value 변경', 5, '작고 완전히 교체되는 콘텐츠의 경우 innerHTML이 더 빠를 수 있다.'),
                                                                                                                           (236, '경량 VDOM class 속성 패치 전략은?', 1, 'medium', '이전·다음 클래스 토큰 비교해 add/remove', 'className 전체 재지정', 'classList.value 할당', 'rAF 내 하나씩', 5, '불필요한 재지정을 방지하기 위해 변경된 클래스만 add/remove 방식으로 처리한다.'),
                                                                                                                           (237, 'React flushSync 이점은?', 1, 'high', '동기 커밋으로 글리치 없이 연속 업데이트 묶는다', 'Diff 건너뜀', '서버 컴포넌트 제외', 'Worker 오프로드', 5, 'flushSync는 동기적으로 렌더링하여 화면 깜빡임(glitch)을 방지한다.'),
                                                                                                                           (238, '배치되지 않은 setState 깜빡임 원리는?', 1, 'high', '여러 Commit 분리로 Layout/Paint 각각', 'GC 발생', 'GPU 레이어 분리', 'idleCallback', 5, 'setState가 batching되지 않으면 중복 commit으로 인해 깜빡임이 발생할 수 있다.'),
                                                                                                                           (239, 'CSS contain 속성 활용 성능 개선 상황은?', 1, 'high', '하위 레이아웃이 외부 영향 없을 때 contain 설정', '상위 Grid 퍼센트폭', 'position fixed 요소', 'z-index 충돌', 5, '하위 요소가 외부 레이아웃에 영향을 주지 않는다면 contain을 사용해 레이아웃 계산 최적화가 가능하다.'),
                                                                                                                           (240, 'SVG/Canvas 반복 갱신 시 대안은?', 1, 'high', 'WebGL/Canvas 직접 렌더', 'innerHTML', 'Shadow DOM', 'Service Worker', 5, 'WebGL이나 Canvas의 직접 렌더링은 반복 갱신 시 성능을 높여준다.'),
                                                                                                                           (241, 'Virtual DOM이 fine-grained 변경에 비효율적 이유는?', 1, 'low', '전체 서브트리를 재평가·diff해야 해서', 'GPU 가속 꺼짐', 'HTML5 위배', 'WASM 호환x', 5, '작은 변경이라도 전체 서브트리를 탐색하므로 fine-grained 변경에 비효율적이다.'),
                                                                                                                           (242, 'Svelte가 빠른 이유는?', 1, 'low', '컴파일 단계 분석 후 직접 DOM 코드 생성', '모든 상태를 Proxy', 'Service Worker 캐시', 'WebGL 렌더', 5, 'Svelte는 컴파일 단계에서 직접 DOM 조작 코드로 변환하므로 빠르다.'),
                                                                                                                           (243, 'Incremental DOM 핵심 차이점은?', 1, 'low', 'Diff 없이 템플릿 실행 중 직접 DOM 명령 스트림', '키 불필요', '모든 노드 제거 후 삽입', '서버 전용', 5, 'Incremental DOM은 diff 없이 명령 스트림 방식으로 DOM을 갱신한다.'),
                                                                                                                           (244, 'SolidJS 신호 패러다임 이점은?', 1, 'medium', '변경 DOM 바인딩만 다시 실행', 'JSX 미사용', 'Worker 렌더', 'LocalStorage 캐싱', 5, '신호(Signals)는 변경된 부분만 다시 평가하므로 성능에 유리하다.'),
                                                                                                                           (245, 'React Server Components가 줄여 주는 비용은?', 1, 'medium', '클라이언트 JS 번들 크기', 'HTML 크기', 'TLS 왕복', '브라우저 레이아웃', 5, '서버 컴포넌트는 클라이언트로 전달할 JS 양을 줄여 초기 로딩 성능을 개선한다.'),
                                                                                                                           (246, 'Resumability 목표는?', 1, 'medium', 'Hydration 없이 서버 상태 이어받아 즉시 상호작용', 'WebGL 모든 컴포넌트', 'Worker 분산', 'gRPC', 5, 'Resumability는 클라이언트에서 Hydration 없이 즉시 작동하게 해 성능을 높이는 기법이다.'),
                                                                                                                           (247, 'Virtual DOM 필요 없는 이유(정적 콘텐츠 페이지)?', 1, 'high', '변경 빈도 낮아 Diff 오버헤드 낭비', '브라우저가 VDOM 차단', 'SSR HTML5 충돌', 'SEO 스크립트 문제', 5, '정적 페이지는 변경이 거의 없기 때문에 diff 과정의 오버헤드가 낭비된다.'),
                                                                                                                           (248, 'React Forget 목표는?', 1, 'high', '컴파일러로 fine-grained reactivity 자동 도입', '모든 useEffect 제거', 'JSX 포팅', 'webpack 제거', 5, 'React Forget은 자동으로 상태 변경 추적 코드를 삽입하여 세밀한 반응성 구현을 목표로 한다.'),
                                                                                                                           (249, 'Astro Islands 아키텍처 방식은?', 1, 'high', '필요 인터랙티브 부분만 CSR 하이드레이션', '페이지 전체 Shadow DOM', 'defer 스크립트', 'CSS inline', 5, 'Astro Islands는 정적 페이지에서 필요한 부분만 클라이언트 사이드 렌더링을 적용한다.'),
                                                                                                                           (250, '저사양 기기에서 VDOM 메모리 문제 이유는?', 1, 'high', 'VNode 트리가 추가 메모리 상주', 'GPU 캐시 없음', 'HTTP2 push', 'Intl polyfill', 5, 'VNode는 실제 DOM과 별도로 메모리를 사용하기 때문에 저사양 기기에서는 부담이 될 수 있다.'),
                                                                                                                           (251, 'Git은 어떤 형식의 시스템인가?', 2, 'low', '클라우드 스토리지', '버전 관리 시스템', '파일 서버', 'DBMS', 6, 'Git은 소스 코드의 변경 이력을 추적할 수 있는 버전 관리 시스템이다.'),
                                                                                                                           (252, 'Git을 설치한 후 버전을 확인하는 명령어는?', 2, 'low', 'git check', 'git version', 'git install', 'git info', 6, 'git version 명령어는 설치된 Git의 버전을 확인하는 데 사용된다.'),
                                                                                                                           (253, 'Git 저장소를 초기화하는 명령어는?', 3, 'low', 'git start', 'git new', 'git init', 'git create', 6, 'git init은 현재 디렉토리를 Git 저장소로 초기화한다.'),
                                                                                                                           (254, 'Git은 어떤 모델을 기반으로 동작하는가?', 2, 'medium', '파일 차이 추적 모델', '파일 전체 스냅샷 모델', 'SQL 데이터 모델', 'REST API 모델', 6, 'Git은 파일 전체의 상태를 스냅샷으로 저장하는 구조를 사용한다.'),
                                                                                                                           (255, 'Git의 핵심 구조가 아닌 것은?', 3, 'medium', 'Commit', 'Branch', 'Pull Request', 'Repository', 6, 'Pull Request는 Git의 기능이 아닌 GitHub 등 플랫폼의 기능이다.'),
                                                                                                                           (256, 'Git이 다른 버전 관리 시스템과 구별되는 가장 큰 특징은?', 2, 'medium', '클라우드 기반', '분산 버전 관리', '서버 의존성', 'GUI 필수', 6, 'Git은 로컬에서도 전체 이력을 관리할 수 있는 분산 버전 관리 시스템이다.'),
                                                                                                                           (257, 'Git 저장소 내 숨겨진 디렉토리는?', 2, 'high', '.gitconfig', '.git', '.repository', '.version', 6, '.git 디렉토리는 Git 저장소의 내부 데이터를 저장하는 핵심 디렉토리다.'),
                                                                                                                           (258, 'Git 기본 사용자 이름 설정 명령어는?', 2, 'high', 'git user set', 'git config user.name', 'git set username', 'git setup name', 6, 'git config user.name은 Git 사용자 이름을 설정하는 명령어다.'),
                                                                                                                           (259, 'Git 저장소에서 ''working directory''란 무엇인가?', 2, 'high', '원격 저장소 경로', '현재 작업 중인 로컬 폴더', '서버 경로', '커밋된 파일 저장소', 6, 'working directory는 실제로 작업하고 있는 로컬 폴더를 의미한다.'),
                                                                                                                           (260, 'Git 저장소에서 ''staging area''란?', 3, 'high', '커밋된 파일 공간', '수정 대기 중 공간', '커밋 준비 중인 공간', '삭제 대기 공간', 6, 'staging area는 커밋될 파일들을 임시로 보관하는 영역이다.'),
                                                                                                                           (261, 'Git에서 변경 사항을 스테이징 영역에 추가하는 명령어는?', 2, 'low', 'git commit', 'git add', 'git push', 'git status', 6, 'git add 명령어는 변경된 파일을 스테이징 영역에 추가한다.'),
                                                                                                                           (262, '스테이징 영역에 추가된 파일을 저장소에 기록하는 명령어는?', 3, 'low', 'git save', 'git push', 'git commit', 'git merge', 6, 'git commit 명령어는 스테이징 영역의 내용을 저장소에 커밋한다.'),
                                                                                                                           (263, '현재 작업 디렉토리의 변경 상태를 확인하는 명령어는?', 1, 'low', 'git status', 'git show', 'git commit', 'git log', 6, 'git status는 현재 작업 디렉토리와 스테이징 영역의 상태를 확인한다.'),
                                                                                                                           (264, '마지막 커밋 메시지를 수정하는 명령어는?', 2, 'medium', 'git amend', 'git commit --amend', 'git edit', 'git rebase', 6, 'git commit --amend는 마지막 커밋 메시지나 내용을 수정할 때 사용된다.'),
                                                                                                                           (265, '수정한 파일을 이전 상태로 되돌리는 명령어는?', 3, 'medium', 'git undo', 'git reset file', 'git restore file', 'git rollback', 6, 'git restore file 명령어는 작업 중인 파일을 이전 커밋 상태로 되돌린다.'),
                                                                                                                           (266, 'git log 명령어는 무엇을 보여주는가?', 2, 'medium', '브랜치 목록', '커밋 기록', '변경된 파일 목록', '서버 상태', 6, 'git log는 커밋 히스토리, 작성자, 메시지 등을 보여준다.'),
                                                                                                                           (267, '스테이징 영역에서 파일을 제거하는 명령어는?', 3, 'high', 'git remove', 'git unstage', 'git reset HEAD <file>', 'git restore', 6, 'git reset HEAD <file>은 해당 파일을 스테이징 영역에서 제거한다.'),
                                                                                                                           (268, '로컬 저장소에 새 파일을 생성하고 Git이 추적하도록 하려면 필요한 명령어는?', 2, 'high', 'git create', 'git add', 'git push', 'git commit', 6, 'git add 명령어로 Git은 새 파일을 추적하도록 설정한다.'),
                                                                                                                           (269, '파일이 staging 되었는지 아닌지 구분하는 명령어는?', 1, 'high', 'git diff', 'git compare', 'git check', 'git log', 6, 'git diff 명령어는 스테이징 여부에 따라 다른 출력 결과를 보여준다.'),
                                                                                                                           (270, '작업 트리와 스테이징 영역의 차이를 보는 명령어는?', 2, 'high', 'git status', 'git diff', 'git branch', 'git show', 6, 'git diff는 작업 트리와 스테이징 영역의 차이점을 확인하는 데 사용된다.'),
                                                                                                                           (271, 'Git에서 브랜치를 생성하는 명령어는?', 1, 'low', 'git branch <branch-name>', 'git create branch', 'git new branch', 'git make branch', 6, 'git branch <branch-name> 명령어로 새로운 브랜치를 생성한다.'),
                                                                                                                           (272, '현재 브랜치를 확인하는 명령어는?', 2, 'low', 'git show-branch', 'git branch', 'git current', 'git check', 6, 'git branch는 현재 브랜치를 포함한 브랜치 목록을 보여준다.'),
                                                                                                                           (273, '다른 브랜치로 이동하는 명령어는?', 1, 'low', 'git switch', 'git change branch', 'git move branch', 'git jump', 6, 'git switch 명령어는 다른 브랜치로 전환할 때 사용된다.'),
                                                                                                                           (274, '브랜치를 삭제하는 명령어는?', 3, 'medium', 'git remove branch', 'git delete branch', 'git branch -d <branch-name>', 'git clear branch', 6, 'git branch -d 명령어는 로컬 브랜치를 삭제한다.'),
                                                                                                                           (275, '브랜치를 병합할 때 사용하는 명령어는?', 1, 'medium', 'git merge', 'git attach', 'git connect', 'git combine', 6, 'git merge는 브랜치의 변경사항을 병합하는 데 사용된다.'),
                                                                                                                           (276, '병합 충돌이 발생했을 때 가장 먼저 해야 할 일은?', 2, 'medium', 'push 하기', '충돌 해결', 'commit 하기', 'reset 하기', 6, '충돌이 발생하면 먼저 코드를 수정하여 충돌을 해결해야 한다.'),
                                                                                                                           (277, 'Fast-forward 병합이 가능한 상황은?', 1, 'high', '브랜치가 동일 선상일 때', '병렬 작업이 많을 때', '리베이스 후일 때', '충돌 발생 시', 6, 'Fast-forward는 브랜치가 병합 대상보다 뒤처지지 않을 때 가능하다.'),
                                                                                                                           (278, 'Git에서 리베이스(rebase)의 주요 목적은?', 2, 'high', '브랜치 삭제', '커밋 기록을 정리', '브랜치 연결 끊기', '브랜치 복제', 6, 'rebase는 커밋 히스토리를 직선화하여 보기 쉽게 만든다.'),
                                                                                                                           (279, 'rebase 중 충돌이 발생했을 때 해결 방법은?', 3, 'high', 'git abort', 'git reset', '충돌 해결 후 git rebase --continue', 'git merge', 6, '충돌 해결 후 git rebase --continue 명령어로 rebase를 계속 진행할 수 있다.'),
                                                                                                                           (280, 'Git 병합 전략 중, 커밋 히스토리를 깔끔하게 유지하는 방법은?', 3, 'high', 'merge', 'fast-forward', 'rebase', 'squash', 6, 'rebase는 분기 없는 히스토리를 만들어 커밋 기록이 깔끔하다.'),
                                                                                                                           (281, 'GitHub에서 원격 저장소를 복제하는 명령어는?', 2, 'low', 'git pull', 'git clone', 'git fetch', 'git copy', 6, 'git clone은 원격 저장소를 로컬로 복제한다.'),
                                                                                                                           (282, '로컬 저장소를 원격 저장소에 연결하는 명령어는?', 3, 'low', 'git connect', 'git link', 'git remote add', 'git sync', 6, 'git remote add 명령어로 로컬 저장소에 원격 저장소 주소를 등록할 수 있다.'),
                                                                                                                           (283, '원격 저장소의 정보를 확인하는 명령어는?', 2, 'low', 'git info remote', 'git remote -v', 'git remote info', 'git check remote', 6, 'git remote -v 명령어는 원격 저장소의 URL과 이름을 보여준다.'),
                                                                                                                           (284, 'GitHub에 변경 사항을 업로드하는 명령어는?', 1, 'medium', 'git push', 'git upload', 'git send', 'git deploy', 6, 'git push 명령어는 로컬 변경 사항을 원격 저장소로 업로드한다.'),
                                                                                                                           (285, '원격 저장소의 최신 변경 사항을 가져오는 명령어는?', 3, 'medium', 'git update', 'git fetch', 'git pull', 'git clone', 6, 'git pull은 fetch 후 자동으로 merge까지 수행해 최신 상태를 가져온다.'),
                                                                                                                           (286, 'git fetch 후 로컬 브랜치에 적용하려면 어떤 명령어를 사용해야 하는가?', 3, 'medium', 'git rebase', 'git checkout', 'git merge', 'git switch', 6, 'git fetch로 가져온 변경 사항을 로컬 브랜치에 적용하려면 merge를 사용한다.'),
                                                                                                                           (287, '원격 저장소를 삭제하는 명령어는?', 3, 'high', 'git remove remote', 'git remote delete', 'git remote rm', 'git delete origin', 6, 'git remote rm 명령어는 등록된 원격 저장소를 제거한다.'),
                                                                                                                           (288, 'git push origin main 명령어의 의미는?', 2, 'high', 'main 브랜치를 로컬에 복제', 'main 브랜치를 원격 저장소에 업로드', 'main 브랜치를 삭제', 'main 브랜치 이름 변경', 6, '해당 명령어는 로컬 main 브랜치를 원격 저장소에 업로드한다.'),
                                                                                                                           (289, 'GitHub에서 포크(fork) 기능은 어떤 역할을 하는가?', 2, 'high', '프로젝트를 클론하는 것', '자신의 계정으로 프로젝트를 복사', '서버를 복제', '브랜치를 새로 만드는 것', 6, 'fork는 원본 프로젝트를 복사하여 독립적으로 개발할 수 있게 한다.'),
                                                                                                                           (290, 'GitHub에서 저장소를 복제(clone)한 후 바로 개발할 수 있는 브랜치는?', 1, 'high', 'master/main', 'feature', 'develop', 'hotfix', 6, '기본 브랜치인 master 또는 main이 초기 개발 시작점이다.'),
                                                                                                                           (291, 'GitHub에서 협업 시 일반적으로 사용하는 요청 방식은?', 2, 'low', 'Push Request', 'Pull Request', 'Merge Request', 'Commit Request', 6, 'Pull Request는 다른 사람의 저장소에 변경 사항을 제안하는 방식으로 협업의 핵심이다.'),
                                                                                                                           (292, 'Pull Request를 생성할 때 필수적으로 지정해야 하는 것은?', 2, 'low', '리포지토리 이름', '베이스 브랜치와 비교 브랜치', '커밋 ID', '패치 URL', 6, 'Pull Request는 어떤 브랜치에서 어떤 브랜치로 병합할지를 명시해야 하므로 비교 대상 브랜치 지정이 필수다.'),
                                                                                                                           (293, 'GitHub 이슈(Issue)의 주요 목적은?', 2, 'low', '코드 수정', '버그 관리 및 기능 요청', '커밋 관리', '프로젝트 복제', 6, 'Issue는 버그 리포트, 기능 제안 등을 통해 개발 프로세스를 관리하는 데 사용된다.'),
                                                                                                                           (294, 'Pull Request에 리뷰어를 지정하는 목적은?', 2, 'medium', '자동 병합', '코드 검토 요청', '버그 수정', '브랜치 삭제', 6, '리뷰어를 지정하면 코드 변경 사항에 대해 검토를 요청할 수 있어 협업 품질이 향상된다.'),
                                                                                                                           (295, 'GitHub Actions는 무엇을 자동화하는 기능인가?', 2, 'medium', '이슈 생성', 'CI/CD 파이프라인', '브랜치 복제', '저장소 삭제', 6, 'GitHub Actions는 코드 빌드, 테스트, 배포 등의 자동화된 작업을 지원하는 CI/CD 도구다.'),
                                                                                                                           (296, 'Fork 후 Pull Request를 보내려면 먼저 해야 할 일은?', 2, 'medium', 'origin으로 직접 push', '포크한 저장소에 push', 'GitHub에서 Fork 취소', '새 브랜치 만들기', 6, 'Fork한 저장소에 push한 뒤 Pull Request를 보내야 GitHub에서 변경 사항을 비교할 수 있다.'),
                                                                                                                           (297, 'GitHub에서 커밋을 다른 사람과 연동할 때 필요한 것은?', 3, 'high', 'Email 등록', 'SSH 키 설정', 'GPG 서명 설정', 'Fork 설정', 6, 'GPG 서명은 커밋의 작성자가 신뢰 가능한 사람임을 검증할 수 있도록 돕는다.'),
                                                                                                                           (298, 'GitHub 저장소를 비공개로 변경하려면 필요한 권한은?', 2, 'high', 'Contributor', 'Owner', 'Collaborator', 'Reviewer', 6, '비공개 여부는 저장소의 소유자(Owner)만이 변경할 수 있는 권한이다.'),
                                                                                                                           (299, 'GitHub 이슈 템플릿을 설정하는 파일 위치는?', 1, 'high', '.github/ISSUE_TEMPLATE/', 'docs/ISSUE/', 'src/issue_template/', 'config/issues/', 6, 'GitHub는 .github/ISSUE_TEMPLATE 경로에 있는 템플릿을 자동으로 인식한다.'),
                                                                                                                           (300, 'GitHub에서 squash merge를 선택하는 주요 이유는?', 1, 'high', '히스토리를 깔끔하게 유지하기 위해', '모든 브랜치를 삭제하기 위해', '병합 충돌을 강제 발생시키기 위해', '코드를 롤백하기 위해', 6, 'Squash merge는 여러 커밋을 하나로 합쳐 기록을 깔끔하게 만든다.'),
                                                                                                                           (301, 'Git Hook은 언제 실행되는 스크립트인가?', 1, 'low', '커밋, 푸시 등의 이벤트 시점', 'Git 설치 시점', '브랜치 삭제 시점', '저장소 복제 시점', 7, 'Git Hook은 특정 Git 이벤트에 맞춰 실행되는 자동화 스크립트이다.'),
                                                                                                                           (302, 'Git Hook 스크립트는 기본적으로 어떤 언어로 작성되는가?', 2, 'low', 'Python', 'Shell Script', 'JavaScript', 'Ruby', 7, 'Git Hook은 기본적으로 Shell Script 형식으로 작성되며 실행 가능해야 한다.'),
                                                                                                                           (303, 'Git 기본 Hook 파일들이 위치하는 디렉토리는?', 1, 'low', '.git/hooks', '.hooks', 'hooks/', 'src/hooks', 7, 'Git은 .git/hooks 디렉토리에서 Hook 스크립트를 관리한다.'),
                                                                                                                           (304, '커밋 전에 코드 검사를 자동으로 실행하기 위해 사용하는 Hook은?', 2, 'medium', 'post-commit', 'pre-commit', 'pre-push', 'commit-msg', 7, 'pre-commit은 커밋 직전에 실행되어 코드 검사, 테스트 등을 자동화할 수 있다.'),
                                                                                                                           (305, '커밋 메시지를 검증하는 데 사용되는 Git Hook은?', 3, 'medium', 'pre-push', 'pre-commit', 'commit-msg', 'post-merge', 7, 'commit-msg는 커밋 메시지를 검사하고 규칙에 맞지 않으면 커밋을 차단할 수 있다.'),
                                                                                                                           (306, 'Git Hook은 기본적으로 어떤 파일 형태로 제공되는가?', 2, 'medium', '활성화된 스크립트 파일', '비활성화된 샘플 파일', 'JSON 설정 파일', 'Markdown 문서', 7, 'Git Hook은 처음에는 샘플로 제공되며 사용자가 이름을 변경해 활성화해야 한다.'),
                                                                                                                           (307, 'Git Hook을 전역(global)으로 설정할 수 있는 방법은?', 2, 'high', 'global-hooks 디렉토리 지정', 'git config --global core.hooksPath', 'git global hook', 'hooksPath 설정파일 추가', 7, 'Git의 전역 설정에서 core.hooksPath를 지정하면 모든 프로젝트에 공통 적용할 수 있다.'),
                                                                                                                           (308, 'Git Hook 중 push가 되기 전에 마지막으로 실행되는 Hook은?', 2, 'high', 'post-commit', 'pre-push', 'commit-msg', 'post-merge', 7, 'pre-push는 push 직전에 실행되는 Hook으로, 마지막 방어선 역할을 한다.'),
                                                                                                                           (309, 'Git Hook을 이용해 push를 차단할 수 있는 방법은?', 3, 'high', 'pre-commit 실패', 'commit-msg 실패', 'pre-push 실패', 'merge-fail', 7, 'pre-push가 실패하면 Git은 push를 중단하므로 유효성 검사에 유용하다.'),
                                                                                                                           (310, 'Git Hook을 통해 코드 품질 관리를 하는 이유는?', 2, 'high', '개발 속도 향상', '코드 일관성 유지', '브랜치 보호', '리포지토리 용량 감소', 7, '코드 포맷, 린트 등의 검사를 Hook으로 자동화하면 일관된 품질을 유지할 수 있다.'),
                                                                                                                           (311, 'Husky의 주요 목적은 무엇인가?', 1, 'low', 'Git Hook 관리 자동화', 'Git 리포지토리 복제', '브랜치 자동 생성', '코드 리뷰 자동화', 7, 'Husky는 Git Hook 스크립트를 쉽고 편리하게 설정, 실행할 수 있도록 도와준다.'),
                                                                                                                           (312, 'Husky를 설치하는 기본 명령어는?', 1, 'low', 'npm install husky', 'npm add git-hooks', 'npm install hooker', 'npm husky-setup', 7, 'npm install husky 명령어로 Husky를 프로젝트에 설치할 수 있다.'),
                                                                                                                           (313, 'Husky를 활성화하기 위해 필요한 명령어는?', 1, 'low', 'npx husky install', 'npx husky start', 'npx git-hook', 'npm init husky', 7, '설치된 Husky를 활성화하려면 npx husky install 명령어를 실행해야 한다.'),
                                                                                                                           (314, 'Husky 설치 후 설정을 추가하는 파일은?', 2, 'low', '.huskyrc', '.husky/', '.git/hooks', '.huskyconfig', 7, 'Husky 설정은 .husky/ 디렉토리에 Hook 별로 구성된다.'),
                                                                                                                           (315, 'Husky를 통해 pre-commit Hook을 추가할 때 사용하는 명령어는?', 1, 'medium', 'npx husky add .husky/pre-commit ''npm test''', 'husky create pre-commit', 'git add pre-commit', 'npm run hook-add', 7, 'npx husky add 명령어로 특정 Hook에 실행할 스크립트를 추가할 수 있다.'),
                                                                                                                           (316, 'Husky 설치 시 .gitignore에 추가되지 않는 디렉토리는?', 1, 'medium', '.husky', 'node_modules', 'hooks', 'build', 7, '.husky 디렉토리는 Git에서 추적이 필요하므로 기본적으로 .gitignore에 포함되지 않는다.'),
                                                                                                                           (317, 'Husky를 package.json scripts에 등록하는 이유는?', 2, 'medium', '테스트 실행', '자동 설치 보장', '버전 업데이트', 'gitignore 무시', 7, 'scripts에 등록해두면 프로젝트 설치 시 Husky 설치도 자동으로 실행된다.'),
                                                                                                                           (318, 'Husky를 설치 후 Git Hook이 정상 동작하지 않는 경우 우선 확인할 사항은?', 1, 'high', '.git/hooks 디렉토리 존재 여부', 'npm 버전', 'Prettier 설치 여부', '프로젝트 크기', 7, 'Git Hook이 정상 작동하려면 .git/hooks 디렉토리 및 링크가 존재해야 한다.'),
                                                                                                                           (319, 'Husky를 제거할 때 사용해야 하는 명령어는?', 1, 'high', 'npm uninstall husky', 'npm remove git-hook', 'npm husky-remove', 'npx husky delete', 7, 'npm uninstall husky 명령어로 패키지를 제거하고 Hook도 수동 제거해야 한다.'),
                                                                                                                           (320, 'Husky 설치 시 Git Hook을 적용하기 위해 반드시 필요한 것은?', 2, 'high', 'package-lock.json', 'git 초기화 (.git 존재)', 'node_modules 재설치', '브랜치 생성', 7, 'Git Hook은 .git 디렉토리 내부에 적용되므로 Git 저장소로 초기화되어 있어야 한다.'),
                                                                                                                           (321, 'Husky로 pre-commit Hook을 추가하려면 필요한 명령어는?', 2, 'low', 'husky create pre-commit', 'npx husky add .husky/pre-commit', 'git init hook', 'npm install hooker', 7, 'npx husky add 명령어로 원하는 Hook에 스크립트를 추가할 수 있다.'),
                                                                                                                           (322, 'Husky를 사용하여 pre-push Hook을 설정할 때 경로는?', 1, 'low', '.husky/pre-push', '.git/pre-push', 'hooks/pre-push', '.husky/hooks/pre-push', 7, '.husky/pre-push는 Husky가 Hook을 관리하는 기본 디렉토리와 파일 경로다.'),
                                                                                                                           (323, 'Husky Hook 파일에서 실행할 명령어를 작성하는 파일은?', 2, 'low', 'package.json', 'Hook script 파일', '.huskyrc', 'hooks-config.js', 7, 'Hook script 파일 내에 실행할 명령어를 직접 작성한다.'),
                                                                                                                           (324, 'Husky로 생성된 Hook 스크립트의 첫 번째 줄은 무엇이어야 하는가?', 2, 'medium', '#!/usr/bin/env husky', '#!/bin/bash', '#!node', '#!/usr/bin/env node', 7, 'Shell Script로 실행되기 때문에 첫 줄에는 #!/bin/bash가 와야 한다.'),
                                                                                                                           (325, 'Husky의 pre-commit Hook에서 실패할 경우 결과는?', 2, 'medium', '커밋이 진행된다', '커밋이 차단된다', '푸시가 진행된다', '브랜치가 변경된다', 7, 'pre-commit Hook이 실패하면 커밋 자체가 차단되어 품질 문제가 반영되지 않도록 한다.'),
                                                                                                                           (326, 'Husky pre-push Hook에서 실패하면 어떤 일이 발생하는가?', 2, 'medium', 'push가 정상적으로 완료된다', 'push가 차단된다', 'pull이 시작된다', 'merge conflict 발생', 7, 'pre-push Hook이 실패하면 원격 저장소로의 push는 중단된다.'),
                                                                                                                           (327, 'Husky로 여러 명령어를 pre-commit에 실행할 때 사용하는 방법은?', 2, 'high', '쉼표로 구분', '&& 연산자 사용', '파이프(|) 사용', 'AND 명령어 사용', 7, '쉘에서 여러 명령어를 순차 실행하려면 && 연산자를 사용한다.'),
                                                                                                                           (328, 'Husky 설정 후 git commit 시 pre-commit이 동작하지 않는 경우 우선 확인할 것은?', 2, 'high', 'node_modules 삭제 여부', '.husky 디렉토리 여부', 'npm 버전', 'yarn.lock 존재 여부', 7, '.husky 디렉토리가 없으면 Hook이 실행되지 않으므로 반드시 존재해야 한다.'),
                                                                                                                           (329, 'Husky hook 파일에 명령어를 추가하는 기본 방법은?', 2, 'high', 'scripts 항목 수정', '직접 shell script 수정', 'npm script 작성', 'git config 수정', 7, 'Hook 파일 자체가 shell script이므로 직접 수정하여 명령어를 추가한다.'),
                                                                                                                           (330, 'Husky를 통해 pre-commit에서 lint 검사를 실행할 때 가장 일반적인 방법은?', 2, 'high', 'npm test', 'npm run lint', 'npm run build', 'npm install lint', 7, 'npm run lint는 프로젝트 내 lint 설정을 기반으로 코드를 검사한다.'),
                                                                                                                           (331, 'lint-staged의 주요 목적은 무엇인가?', 2, 'low', '전체 코드 linting', '스테이징된 파일만 linting', '빌드 최적화', '버전 관리', 7, 'lint-staged는 스테이지된 파일만 검사하여 빠르고 효율적인 린팅을 지원한다.'),
                                                                                                                           (332, 'lint-staged를 설치하는 명령어는?', 1, 'low', 'npm install lint-staged', 'npm install lint-stage', 'npm add staged-lint', 'npm install pre-lint', 7, 'lint-staged는 npm install lint-staged 명령어로 설치할 수 있다.'),
                                                                                                                           (333, 'lint-staged 설정을 추가할 수 있는 파일은?', 2, 'low', '.lintstagedrc', 'package.json', '.lintstage', '.stagedlint', 7, 'lint-staged 설정은 package.json 또는 별도 파일로 추가할 수 있다.'),
                                                                                                                           (334, 'lint-staged를 사용할 때 파일 패턴을 설정하는 이유는?', 2, 'medium', '전체 파일 적용', '변경된 파일만 지정 작업 적용', 'Git 히스토리 추적', '버전 롤백', 7, '변경된 파일만 대상으로 지정 작업을 수행하여 효율성과 속도를 높인다.'),
                                                                                                                           (335, 'lint-staged 설정에서 JavaScript 파일에 ESLint를 적용하려면 어떻게 작성하는가?', 1, 'medium', '"*.js": "eslint"', '"*.js": "prettier"', '"*.js": "node"', '"*.js": "test"', 7, '"*.js": "eslint" 형식으로 파일 패턴과 실행 명령어를 설정한다.'),
                                                                                                                           (336, 'lint-staged가 적용되는 파일 범위는?', 2, 'medium', 'Git에 커밋된 모든 파일', '스테이지된 파일', '로컬 디렉토리 전체', '리포지토리 전체', 7, 'lint-staged는 Git에 스테이징된 파일에만 적용된다.'),
                                                                                                                           (337, 'lint-staged에서 여러 명령어를 실행하려면 어떻게 설정하는가?', 2, 'high', '쉼표로 구분', '배열로 설정', '공백으로 구분', '세미콜론으로 구분', 7, '여러 명령어를 배열로 설정하면 각 명령어가 순서대로 실행된다.'),
                                                                                                                           (338, 'lint-staged를 통해 commit 전에 파일 포맷팅을 적용하려면 사용하는 명령어는?', 1, 'high', 'prettier --write', 'eslint --fix', 'lint --stage', 'node --format', 7, 'prettier --write 명령어로 코드를 포맷팅할 수 있다.'),
                                                                                                                           (339, 'lint-staged 설정을 .lintstagedrc로 분리하는 이유는?', 1, 'high', '설정 관리 편의성', 'CI/CD 통합', '성능 향상', 'Git Hook 자동화', 7, '별도 파일로 설정하면 관리가 용이하고 프로젝트 구조가 깔끔해진다.'),
                                                                                                                           (340, 'lint-staged를 사용할 때 실패한 파일이 있을 경우 커밋은 어떻게 되는가?', 2, 'high', '커밋 진행', '커밋 차단', '푸시 차단', '브랜치 변경', 7, '명령어가 실패하면 Git은 커밋을 차단하여 품질 문제 반영을 막는다.'),
                                                                                                                           (341, 'Husky와 lint-staged를 함께 사용하는 주된 이유는?', 2, 'low', '전체 파일에 lint 적용', '스테이징된 파일에만 lint 및 포맷 적용', '브랜치 보호', '리포지토리 삭제', 7, '두 도구를 함께 쓰면 필요한 파일만 검사하고 Hook으로 자동화할 수 있다.'),
                                                                                                                           (342, 'lint-staged를 실행하는 위치로 가장 적합한 Git Hook은?', 3, 'low', 'post-merge', 'pre-push', 'pre-commit', 'post-commit', 7, 'pre-commit 단계에서 코드를 검사해야 품질 문제를 사전에 방지할 수 있다.'),
                                                                                                                           (343, 'Husky로 lint-staged를 pre-commit에 연결하는 방법은?', 2, 'low', 'npm script 등록', 'npx husky add .husky/pre-commit ''npx lint-staged''', 'git push 설정', 'prettier 설정', 7, 'Hook 파일에 npx lint-staged 명령어를 추가하여 연결할 수 있다.'),
                                                                                                                           (344, 'lint-staged 실행 실패 시 커밋은 어떻게 되는가?', 2, 'medium', '커밋 진행', '커밋 차단', '브랜치 변경', 'push 진행', 7, '명령어가 실패하면 커밋은 차단되어 품질이 유지된다.'),
                                                                                                                           (345, 'lint-staged 설정 파일에 여러 명령어를 적용할 때 사용하는 자료형은?', 2, 'medium', 'Object', 'Array', 'String', 'Number', 7, '여러 명령어를 실행하려면 배열(Array)로 작성해야 한다.'),
                                                                                                                           (346, 'Husky 설정 없이 lint-staged만 설치했을 경우 발생하는 문제는?', 1, 'medium', 'Hook이 작동하지 않음', '빌드 실패', '버전 충돌', '리포지토리 삭제', 7, 'Hook이 실행되려면 Husky와 같이 연결되어 있어야 한다.'),
                                                                                                                           (347, 'lint-staged의 실행 명령어를 npx를 통해 바로 실행하려면 필요한 것은?', 2, 'high', 'package.json scripts', 'npx lint-staged', 'git lint', 'npm run lint-stage', 7, 'npx lint-staged 명령어로 바로 실행할 수 있다.'),
                                                                                                                           (348, 'Husky의 pre-commit Hook 스크립트에서 lint-staged를 호출할 때 기본 사용 방법은?', 2, 'high', 'npm run lint', 'npx lint-staged', 'eslint staged', 'prettier staged', 7, 'pre-commit 스크립트에서 npx lint-staged를 실행하면 설정대로 동작한다.'),
                                                                                                                           (349, 'lint-staged가 처리하는 파일은 기본적으로 어떤 상태인가?', 2, 'high', 'untracked', 'staged', 'committed', 'ignored', 7, 'lint-staged는 Git에 스테이징된 파일만을 대상으로 한다.'),
                                                                                                                           (350, 'Husky + lint-staged 통합 설정이 잘 작동하면 어떤 이점이 있는가?', 2, 'high', '커밋 속도 향상', '코드 품질 유지와 일관성 확보', '브랜치 삭제 자동화', '파일 무결성 검사', 7, '커밋 전 코드 검사와 포맷을 자동화하여 품질을 일관되게 유지할 수 있다.'),
                                                                                                                           (351, '다음 중 **Axios 인스턴스**를 생성할 때 사용하는 함수는?', 1, 'low', 'axios.create()', 'axios.init()', 'Axios.new()', 'axios.config()', 8, 'axios.create()는 커스텀 Axios 인스턴스를 생성할 때 사용하는 공식 메서드이다.'),
                                                                                                                           (352, '인스턴스 생성 시 공통 **기본 경로**를 지정하려면 어떤 옵션을 설정해야 하는가?', 1, 'low', 'baseURL', 'rootPath', 'basePath', 'prefix', 8, 'baseURL은 모든 요청 URL 앞에 자동으로 붙는 기본 경로를 지정하는 옵션이다.'),
                                                                                                                           (353, 'Axios 전역 옵션 중 **요청이 일정 시간 안에 완료되지 않으면** 자동으로 거절되는 한계 시간 옵션은?', 1, 'low', 'timeout', 'maxDuration', 'requestLimit', 'delay', 8, 'timeout은 요청이 지정된 시간 안에 완료되지 않으면 자동으로 실패하게 만드는 옵션이다.'),
                                                                                                                           (354, '환경변수로 baseURL 설정 목적은?', 1, 'medium', '빌드/배포 환경별 API 엔드포인트 분기', '쿠키 첨부', '서버 컴포넌트 리다이렉트', 'HTTP/3', 8, '환경변수를 통해 baseURL을 설정하면 개발/운영 환경에 따라 동적으로 엔드포인트를 구분할 수 있다.'),
                                                                                                                           (355, '인스턴스 레벨 공통 헤더 설정 코드 동등 효과는?', 1, 'medium', 'axios.create({ headers: { common: { ''X-Custom'': ''foo'' } } })', 'axios.setHeader', 'axios.config.headers', 'axios.defaults.set', 8, 'axios.create의 headers.common 옵션은 모든 요청에 공통 헤더를 포함하도록 설정하는 공식 방법이다.'),
                                                                                                                           (356, 'withCredentials:true 사용 대표 상황은?', 1, 'medium', '쿠키·세션 포함 CORS 요청', 'POST 강제', '타임아웃 무시 스트리밍', 'multipart', 8, 'withCredentials:true는 CORS 요청 시 쿠키나 세션 정보를 포함시킬 때 필요하다.'),
                                                                                                                           (357, '환경별 구성을 런타임 코드 없이 분기 권장 방법은?', 1, 'medium', '.env 환경 변수 + 인스턴스 옵션 분기', 'if/else URL', 'localStorage URL', 'setInterval 재설정', 8, '런타임 코드 없이 환경에 따라 설정을 자동 분기하려면 .env 환경 변수 사용이 가장 효율적이다.'),
                                                                                                                           (358, 'transformResponse 역할은?', 1, 'high', '응답 데이터 가공 후 전달', '요청 본문 직렬화', '헤더 토큰 추가', 'HTTP 오류 무시', 8, 'transformResponse는 서버로부터 받은 응답 데이터를 가공해 클라이언트에 전달할 수 있게 한다.'),
                                                                                                                           (359, '브라우저 미지원 프로토콜 요청하려면 커스텀할 옵션은?', 1, 'high', 'adapter', 'proxy', 'xsrfCookieName', 'decompress', 8, 'adapter 옵션은 브라우저가 지원하지 않는 방식으로 요청을 보내기 위한 커스터마이징 포인트다.'),
                                                                                                                           (360, '다수 API 서버 통신 권장 인스턴스 관리 방법은?', 1, 'high', '서버 종류별 전용 인스턴스 모듈 분리', '전역 axios 하나', '매 요청마다 create', 'XHR 직접 구현', 8, '서버별로 인스턴스를 나눠 관리하면 설정 충돌 없이 모듈화된 구조를 유지할 수 있다.'),
                                                                                                                           (361, '전역 Request 인터셉터 메서드는?', 1, 'low', 'axiosInstance.interceptors.request.use()', 'axiosInstance.onRequest()', 'axios.requestInterceptor()', 'axiosInstance.useRequest()', 8, 'interceptors.request.use()는 모든 요청 전에 가로채서 로직을 실행할 수 있는 공식 메서드이다.'),
                                                                                                                           (362, 'config 객체 전달 시점은?', 1, 'low', 'HTTP 전송 직전', '응답 직후', 'create 직후', '체인 끝', 8, 'Axios는 요청을 전송하기 직전에 config 객체를 최종 적용한다.'),
                                                                                                                           (363, '토큰 첨부 헤더는?', 1, 'low', 'Authorization: Bearer <token>', 'Auth-Token', 'Set-Cookie', 'X-Access', 8, '토큰 기반 인증에서 가장 일반적인 Authorization 헤더 형식은 Bearer 토큰이다.'),
                                                                                                                           (364, '요청 중복 방지 기본 전략은?', 1, 'medium', 'Pending Map 큐 관리', 'withCredentials false', 'timeout 0', 'validateStatus null', 8, '요청 중복 방지를 위해 요청 키를 기준으로 Pending Map에서 상태를 관리하는 것이 일반적이다.'),
                                                                                                                           (365, '요청 단계 에러 처리 콜백은?', 1, 'medium', '.use() 두번째 인자', '없음', 'Promise.reject', 'async keyword', 8, 'interceptor의 .use() 두 번째 인자는 요청 중 예외가 발생했을 때 처리하는 콜백이다.'),
                                                                                                                           (366, '쿼리 파라미터 변환 수정 프로퍼티는?', 1, 'medium', 'params', 'data', 'headers', 'timeout', 8, 'params 속성은 URL 쿼리 문자열에 붙는 파라미터 데이터를 수정할 때 사용된다.'),
                                                                                                                           (367, 'eject 호출 효과는?', 1, 'high', '이후 요청부터 제거', '현재 진행 중 요청도 제거', '새로고침 후', 'GC 시', 8, 'eject는 등록된 인터셉터를 제거하며 이후 요청부터 해당 인터셉터는 작동하지 않는다.'),
                                                                                                                           (368, '멀티탭 토큰 변경 감지 Web API는?', 1, 'high', 'storage 이벤트', 'visibilitychange', 'sendBeacon', 'BroadcastChannel', 8, 'storage 이벤트는 다른 탭에서 localStorage 값이 변경됐을 때 발생하여 멀티탭 통신에 유용하다.'),
                                                                                                                           (369, 'Request 인터셉터 비동기 시 문제는?', 1, 'high', 'Promise 반환 안하면 체인 멈춤', 'Axios 자동 취소', 'CORS 무시', 'timeout 리셋', 8, '비동기 인터셉터는 Promise를 반환해야 체인이 유지된다. 그렇지 않으면 다음 요청이 진행되지 않는다.'),
                                                                                                                           (370, '로깅 권장 출력 타이밍은?', 1, 'high', 'config 수정 전에', 'then 마지막', '응답 인터셉터', 'catch', 8, '요청 정보를 정확히 기록하려면 config가 수정되기 전, 인터셉터의 시작 시점에서 로깅하는 것이 좋다.'),
                                                                                                                           (371, 'Response 인터셉터 메서드는?', 1, 'low', 'axiosInstance.interceptors.response.use()', 'axiosInstance.onResponse()', 'axios.responseInterceptor()', 'axiosInstance.after()', 8, 'axiosInstance.interceptors.response.use()는 응답을 가로채어 후처리할 때 사용하는 공식 메서드이다.'),
                                                                                                                           (372, 'data 전달 시점은?', 1, 'low', 'HTTP 응답 수신 직후', '요청 직전', '체인 종료 후', '타임아웃', 8, '응답 데이터는 서버로부터 수신한 직후 response.data에 전달된다.'),
                                                                                                                           (373, 'validateStatus false 결과 처리?', 1, 'low', 'Promise reject', '재시도', 'undefined', '리로드', 8, 'validateStatus 조건을 만족하지 않으면 Axios는 Promise를 reject 상태로 반환한다.'),
                                                                                                                           (374, '응답 camelCase 통일 변환 대상은?', 1, 'medium', 'response.data', 'response.config', 'statusText', 'headers.common', 8, 'API 응답 본문(response.data)의 키를 camelCase로 변환하여 클라이언트 측 일관성을 맞춘다.'),
                                                                                                                           (375, '스피너 제어 일반 흐름은?', 1, 'medium', '요청 전 ON → 응답 후 OFF', '응답 후 ON', '요청 전 OFF', '항상 OFF', 8, 'UX 향상을 위해 요청 전 로딩 표시 → 응답 수신 후 제거하는 방식이 일반적이다.'),
                                                                                                                           (376, '파일 다운로드 응답 처리 누락 설정은?', 1, 'medium', 'responseType:\'blob\'', 'withCredentials true', 'maxContentLength 0', 'decompress false', 8, '파일 응답은 blob 형태로 처리해야 하므로 responseType을 ''blob''으로 설정해야 한다.'),
                                                                                                                           (377, 'HTTP 200 내부 오류 승격 방법은?', 1, 'high', 'return Promise.reject(customError)', 'status=500 재할당', 'throw 불가', 'validateStatus false', 8, 'HTTP 200이지만 내부적으로 오류인 경우 customError로 reject해 오류로 처리할 수 있다.'),
                                                                                                                           (378, '에러 로깅 후 체인 유지?', 1, 'high', '에러 콜백 로깅 후 reject', '반환 없음', '성공 콜백', 'data 덮어쓰기', 8, '에러 핸들러에서 로깅 후 Promise.reject로 다시 넘기면 체인이 유지된다.'),
                                                                                                                           (379, '1회만 실행 플래그 시 확인점?', 1, 'high', '충돌 없는 고유 키 사용', 'delete 필수', 'boolean 필수', 'headers만', 8, '동일 요청 중복 방지를 위해 고유 키를 사용해 요청 식별이 가능해야 한다.'),
                                                                                                                           (380, 'SSR 환경 메모리 릭 없이 인터셉터 사용?', 1, 'high', '응답 후 eject', '매 요청 create', 'async 사용 금지', 'validateStatus 200', 8, 'SSR 환경에서는 인터셉터를 응답 후 eject하여 메모리 누수를 방지해야 한다.'),
                                                                                                                           (381, '만료 Access Token 실패시 첫 단계?', 1, 'low', 'Refresh Token으로 새 토큰 요청', '로그아웃', '토큰 삭제', '리로드', 8, 'Access Token이 만료되면 Refresh Token을 사용하여 새 토큰을 받아오는 것이 표준 처리 방식이다.'),
                                                                                                                           (382, '동시 401 1회 갱신 패턴은?', 1, 'low', '요청 큐잉 패턴', 'withCredentials false', 'HTTP 429', 'CancelToken 제거', 8, '401 응답이 동시에 여러 개 발생할 경우 하나만 Refresh하고 나머지는 큐에 넣어 기다리는 패턴이 안정적이다.'),
                                                                                                                           (383, 'Refresh Token 안전 저장 방식?', 1, 'low', 'HttpOnly Secure 쿠키', 'localStorage', 'sessionStorage', 'IndexedDB', 8, 'Refresh Token은 XSS로부터 보호되기 위해 HttpOnly Secure 쿠키에 저장하는 것이 가장 안전하다.'),
                                                                                                                           (384, '멀티 탭 오래된 토큰 문제는?', 1, 'medium', '연쇄 갱신 무한 루프 위험', '쿠키 사라짐', 'CSP 위반', '자동 리로드', 8, '여러 탭이 동시에 갱신하면 무한 루프에 빠질 수 있으므로 이를 막는 처리 로직이 필요하다.'),
                                                                                                                           (385, '큐에 넣어둘 객체는?', 1, 'medium', 'Promise resolver', 'axios 인스턴스', 'XHR', 'AbortSignal', 8, '토큰 갱신 중 대기 중인 요청은 Promise의 resolver를 큐에 넣어 순차적으로 처리한다.'),
                                                                                                                           (386, '__retry 플래그 목적은?', 1, 'medium', '무한 재귀 방지', '타임아웃 두배', 'validateStatus 우회', 'CORS 건너뜀', 8, '__retry 같은 사용자 정의 플래그로 동일 요청이 반복되지 않도록 제어할 수 있다.'),
                                                                                                                           (387, 'Refresh 실패 시 후속 조치?', 1, 'high', '로그아웃 후 인증 페이지', '무한 재시도', '기존 토큰 요청', '페이지 새로고침', 8, 'Refresh가 실패하면 사용자의 인증 상태가 만료된 것이므로 로그아웃 후 로그인 페이지로 유도해야 한다.'),
                                                                                                                           (388, '원본 메서드·바디 보존 재시도 방법?', 1, 'high', 'return api(originalConfig)', 'get(url)', '바디 headers', 'method 삭제', 8, '실패한 요청의 config를 그대로 넘겨 재요청하면 메서드와 바디가 유지된다.'),
                                                                                                                           (389, 'Safari ITP 토큰 쿠키 완화는?', 1, 'high', 'SameSite=None; Secure + 짧은 만료', 'localStorage', 'Path 제한', 'Domain 생략', 8, 'Safari는 보안 강화를 위해 ITP를 적용하며, 이를 완화하려면 Secure + SameSite=None 쿠키를 짧게 설정해야 한다.'),
                                                                                                                           (390, 'MSW 사용 이점?', 1, 'high', '백엔드 없이 401/refresh 시나리오 테스트', 'JWT 암호화', 'CSP 우회', 'HTTP2 우선', 8, 'MSW(Mock Service Worker)는 API 없이 네트워크 요청을 가로채 테스트할 수 있어 인증 시나리오 검증에 유리하다.'),
                                                                                                                           (391, '자동 재시도 유틸리티는?', 1, 'low', 'axios-retry', 'axios-cache-adapter', 'axios-mock-adapter', 'axios-progress-bar', 8, 'axios-retry는 실패한 요청을 자동으로 재시도할 수 있게 해주는 유틸리티 라이브러리다.'),
                                                                                                                           (392, '지수 백오프 500→1000 올바른가?', 1, 'low', '500→1000', '250→500', '500→750', '1000→1500', 8, '지수 백오프는 이전 대기 시간의 배수를 적용하므로 500→1000이 올바른 증가 방식이다.'),
                                                                                                                           (393, '취소 토큰 대체 API는?', 1, 'low', 'AbortController / AbortSignal', 'BroadcastChannel', 'SharedWorker', 'ReadableStream.cancel', 8, 'Axios는 최신 브라우저에서 AbortController와 AbortSignal을 사용해 요청을 취소할 수 있다.'),
                                                                                                                           (394, '도메인별 모듈화 권장 패턴은?', 1, 'medium', '전용 인스턴스 + CRUD export', '전역 axios', '직접 호출', 'Fetch 혼용', 8, '도메인별 인스턴스 분리와 기능별 CRUD 함수 export로 구조화하는 것이 유지보수에 유리하다.'),
                                                                                                                           (395, 'mock replyOnce 시나리오 목적은?', 1, 'medium', '1회 실패 후 재시도 성공', '캐싱 검증', '웹소켓', '업로드', 8, 'replyOnce는 첫 요청에만 특정 응답을 주고 다음 요청부터는 다르게 처리할 수 있어 재시도 테스트에 적합하다.'),
                                                                                                                           (396, 'Circuit Breaker Open 전환 기준은?', 1, 'medium', '연속 실패 임계초과', '모든 요청 성공', 'AbortSignal', 'HTTP 3xx', 8, 'Circuit Breaker는 일정 횟수 이상 연속 실패 시 Open 상태로 전환되어 요청을 차단한다.'),
                                                                                                                           (397, '동일 요청 합치기 원리는?', 1, 'high', '같은 URL 프라미스 공유', '모든 요청 취소', 'GET→HEAD', '로컬 캐시', 8, '동일 요청 중복을 방지하려면 동일한 요청 URL에 대해 동일한 Promise를 공유하면 된다.'),
                                                                                                                           (398, 'Adapter 커스텀 이점 아닌 것은?', 3, 'high', 'CORS 무시 (아님)', 'WebSocket/gRPC', '네트워크 우회', 'React Native 네이티브 모듈', 8, 'Adapter 커스텀은 다양한 네트워크 인터페이스를 가능하게 하지만 CORS 정책은 클라이언트 제약이므로 우회할 수 없다.'),
                                                                                                                           (399, '성능 메트릭 측정 간단 방법은?', 1, 'high', '요청 직전 Date.now 저장, 응답 후 경과 계산', 'hrtime만', 'Network 스크래핑', '패킷 스니핑', 8, '간단한 성능 측정은 요청 전 timestamp와 응답 후 timestamp를 비교해 계산할 수 있다.'),
                                                                                                                           (400, 'jest.mock axios 단점은?', 1, 'high', '인터셉터/어댑터 로직 스킵', '테스트 느림', '2xx 재현 불가', 'TS 타입 실패', 8, 'jest.mock으로 axios를 모킹하면 실제 인터셉터나 어댑터 로직이 빠져 테스트 정확도가 떨어질 수 있다.'),
                                                                                                                           (401, '클라이언트 잘못된 요청(예: JSON 스키마 위반)에 대한 권장 HTTP 상태 코드는?', 1, 'low', '400 Bad Request', '401 Unauthorized', '500 Internal Server Error', '409 Conflict', 9, '400 Bad Request는 요청 자체에 문제가 있을 때 사용하는 표준 응답 코드이다.'),
                                                                                                                           (402, '인증 헤더가 누락된 요청에 서버가 반환해야 할 표준 상태 코드는?', 1, 'low', '401 Unauthorized', '403 Forbidden', '412 Precondition Failed', '502 Bad Gateway', 9, '401 Unauthorized는 인증 정보가 없거나 잘못되었을 때 반환되는 상태 코드이다.'),
                                                                                                                           (403, 'REST API에서 존재하지 않는 리소스에 대한 GET 요청 시 적절한 응답 코드는?', 1, 'low', '404 Not Found', '410 Gone', '204 No Content', '422 Unprocessable Entity', 9, '404 Not Found는 요청한 리소스가 존재하지 않을 때 사용하는 표준 응답 코드이다.'),
                                                                                                                           (404, 'RFC 7807 ‘Problem Details for HTTP APIs’가 권장하는 기본 Content-Type은?', 1, 'medium', 'application/problem+json', 'application/json; problem', 'text/problem', 'application/vnd.error+json', 9, 'RFC 7807은 오류 응답 본문을 JSON으로 표현할 때 application/problem+json을 권장한다.'),
                                                                                                                           (405, 'RFC 7807 JSON 응답 예시에서 반드시 포함해야 하는 필드는?', 1, 'medium', 'title', 'instance', 'detail', 'errors', 9, 'title은 오류 유형을 간결하게 설명하는 필드로 필수 항목이다.'),
                                                                                                                           (406, '다음 중 4xx와 5xx 상태 코드 차이에 대한 설명으로 옳지 않은 것은?', 4, 'medium', '4xx는 클라이언트 오류, 5xx는 서버 오류를 나타낸다', '5xx는 재시도 가능성이 4xx보다 높다', '4xx 오류라도 Problem Details 바디를 포함할 수 있다', '4xx는 절대 재시도해서는 안 된다', 9, '4xx라도 일시적 오류일 수 있어 무조건 재시도 불가한 것은 아니다.'),
                                                                                                                           (407, '동일 자원 중복 생성 시 서버가 반환해도 멱등성 규칙을 깨지지 않는 상태 코드는?', 1, 'high', '409 Conflict', '201 Created', '202 Accepted', '302 Found', 9, '409 Conflict는 요청이 중복되었을 때 반환 가능하며, 멱등성을 보장할 수 있다.'),
                                                                                                                           (408, 'Problem Details 바디에 커스텀 ‘code’ 정수 필드를 두는 주된 이점은?', 1, 'high', '클라이언트가 로컬라이징 메시지를 매핑하기 쉽다', 'HTTP 상태 코드 전송을 생략할 수 있다', 'JSON 패싱을 건너뛸 수 있다', 'CORS 프리플라이트를 우회한다', 9, '커스텀 code 필드를 사용하면 클라이언트에서 메시지를 매핑하기 용이해진다.'),
                                                                                                                           (409, '다음 중 idempotent 메서드가 아닌 것은?', 1, 'high', 'POST', 'PUT', 'DELETE', 'HEAD', 9, 'POST는 요청을 여러 번 수행하면 결과가 달라질 수 있어 멱등하지 않다.'),
                                                                                                                           (410, '클라이언트가 429 Too Many Requests 응답을 받을 때 재시도 시점을 알기 위해 확인해야 하는 헤더는?', 1, 'high', 'Retry-After', 'Warning', 'WWW-Authenticate', 'Content-Encoding', 9, 'Retry-After 헤더는 클라이언트에게 재시도 가능한 시점을 알려주는 공식적인 방법이다.'),
                                                                                                                           (411, '브라우저 네트워크 오류 vs HTTP 오류 구분 방법은?', 1, 'low', '응답 없음 & error.request 존재 → 네트워크 오류', 'status 0이면 HTTP 오류', 'message에 Network Error 포함 시 HTTP 오류', 'https로 시작시 네트워크 오류 없음', 9, 'Axios에서 네트워크 오류는 error.request가 존재하고 응답이 없을 때 발생하며, 이는 서버에 도달하지 못한 경우다.'),
                                                                                                                           (412, '422 오류 UX 비추천 패턴은?', 1, 'low', '모달 전체 가리고 중앙만 오류', '필드 인라인 표시', '폼 상단 요약', '스낵바 알림', 9, '422는 필드 단위의 오류이므로 전체 모달보다는 인라인 또는 요약 표시가 바람직하다.'),
                                                                                                                           (413, '전역 오류 핸들러 역할은?', 1, 'low', '로그인 만료 등 공통 처리', '레이아웃 교체', 'CSS 초기화', 'History 재설정', 9, '전역 오류 핸들러는 인증 만료, 네트워크 장애 등 앱 전역의 예외를 처리한다.'),
                                                                                                                           (414, '오프라인 GET 요청 전략은?', 1, 'medium', '대기열 저장 후 복구 시 재시도', '캐시 비우고 에러', '503 구성', '무한 로딩', 9, '오프라인일 경우 요청을 큐에 저장해 두었다가 연결 복구 후 재시도하는 전략이 적절하다.'),
                                                                                                                           (415, 'Error Boundary 해결 문제는?', 1, 'medium', '렌더 예외로 인한 흰 화면', 'API 500 재시도', 'CORS 차단', 'WebSocket', 9, 'Error Boundary는 렌더링 중 발생한 예외를 감지해 UI 전체 마비를 막는다.'),
                                                                                                                           (416, '중복 POST 방지 클라이언트 조치?', 1, 'medium', '이전 요청 취소 AbortController', 'Cache-Control no-store', 'POST→GET', '로그 제거', 9, 'AbortController를 사용하면 동일한 요청이 중복 실행되는 것을 방지할 수 있다.'),
                                                                                                                           (417, 'axios 취소 vs 네트워크 오류 구분 프로퍼티?', 1, 'high', 'error.code === ''ERR_CANCELED''', 'message 포함 Network', 'status -1', 'timeout 0', 9, 'Axios는 요청 취소 시 error.code가 ERR_CANCELED로 설정되어 구분이 가능하다.'),
                                                                                                                           (418, '국제화 오류 메시지 비추천 방법은?', 1, 'high', '서버가 완제품 문구 제공', '클라이언트 코드 매핑', 'title/detail 키 사용', '템플릿 변수 치환', 9, '서버가 직접 완성된 메시지를 제공하면 다국어 처리 및 UX 제어가 어렵다.'),
                                                                                                                           (419, '모바일 에러/재요청 데이터 최소화 우선 고려는?', 1, 'high', '오프라인 감지 후 백오프', '해상도 다운', '캐시 삭제', 'UDP 강제', 9, '모바일 환경에서는 네트워크 상태를 감지하고, 불필요한 재요청을 피하기 위해 백오프 전략이 중요하다.'),
                                                                                                                           (420, '사용자 메시지+디버그 정보 구조 권장?', 1, 'high', 'UI 요약 & 콘솔 raw trace', 'alert 모두', '서버 HTML 오류 페이지', '쿠키 저장', 9, '사용자에겐 간단한 메시지, 개발자에겐 콘솔 로그로 raw trace를 분리 제공하는 방식이 이상적이다.'),
                                                                                                                           (421, '멱등 메서드는?', 1, 'low', 'PUT', 'POST', 'PATCH', 'CONNECT', 9, 'PUT은 동일한 요청을 여러 번 수행해도 같은 결과를 보장하므로 멱등하다.'),
                                                                                                                           (422, '고정 3초 4번 총 지연?', 1, 'low', '12초', '9초', '6초', '3초', 9, '고정 3초씩 4번이면 총 지연은 3 x 4 = 12초가 된다.'),
                                                                                                                           (423, '지수 1s 배수2 3회 누적?', 1, 'medium', '7 s', '6 s', '5 s', '4 s', 9, '1 + 2 + 4 = 7초로 누적 지연이 계산된다.'),
                                                                                                                           (424, 'Retry-After 120 권장 재시도?', 1, 'medium', '120초 이상 후', '60초', '즉시', '무시', 9, 'Retry-After는 서버가 지정한 대기 시간으로, 이를 존중하여 120초 이상 대기 후 재시도해야 한다.'),
                                                                                                                           (425, 'POST 안전 재시도 보완책?', 1, 'medium', 'Idempotency-Key 헤더', 'HTTP/2 업그레이드', '빈 바디', 'PUT 사용', 9, 'Idempotency-Key를 사용하면 POST 요청이라도 중복 실행 방지가 가능하다.'),
                                                                                                                           (426, '재시도 고려 가능한 408/409?', 1, 'medium', '408 Request Timeout', '409 Conflict', '400', '401', 9, '408은 일시적인 타임아웃으로 재시도 여지가 있는 상태 코드이다.'),
                                                                                                                           (427, 'Full Jitter 목적은?', 1, 'high', '서버 폭주 완화', '총 지연 줄임', 'TCP 우회', 'TLS 감소', 9, 'Full Jitter는 무작위 지연을 추가하여 동시에 많은 요청이 몰리는 것을 방지한다.'),
                                                                                                                           (428, '재시도 불가 오류 유형?', 1, 'high', '400 필드 검증', '502', '408', '429', 9, '400 오류는 요청 자체에 문제가 있어 재시도해도 해결되지 않는다.'),
                                                                                                                           (429, '조건부 PUT 재시도 안전 이유?', 1, 'high', 'ETag 버전 동일 시만 수행', 'PUT 캐싱', 'HTTP/3 전용', '브라우저 보장', 9, 'ETag로 리소스 버전을 확인하면 중복 PUT 요청도 안전하게 수행할 수 있다.'),
                                                                                                                           (430, '모바일 TCP 끊김 POST 문제 감소?', 1, 'high', '짧은 타임아웃 + 멱등 키', 'HTTP 1.0', '재시도 끔', '인증 제거', 9, '모바일 환경에서는 멱등 키를 통해 동일 요청의 중복 전송을 방지하고, 타임아웃을 짧게 설정해 끊김 문제를 줄인다.'),
                                                                                                                           (431, 'Circuit Closed→Open 조건?', 1, 'low', '연속 실패 임계', '성공 200', '301', '쿠키 만료', 9, 'Circuit Breaker는 설정된 횟수만큼 연속 실패 시 Open 상태로 전환되어 요청을 차단한다.'),
                                                                                                                           (432, 'Half-Open 성공 전이?', 1, 'low', 'Closed', 'Open', 'Forced-Open', 'Isolated', 9, 'Half-Open 상태에서 테스트 요청이 성공하면 다시 Closed 상태로 복귀한다.'),
                                                                                                                           (433, 'Open 상태 바로 실패 목적?', 1, 'low', '백엔드 부하 차단', '캐시 무효', 'TLS 시간 줄임', 'DNS 재해석', 9, 'Open 상태에서는 요청을 막아 서버에 더 이상 부하가 가지 않도록 설계된다.'),
                                                                                                                           (434, '재시도+CB 충돌 위험?', 1, 'medium', '과도 재시도→즉시 Open', 'Jitter 제거', 'Retry-After 무시', 'HTTP/2 끊김', 9, '재시도가 많아지면 Circuit Breaker가 빠르게 Open되어 정상 흐름이 차단될 수 있다.'),
                                                                                                                           (435, 'Coalescing 효과 시나리오?', 1, 'medium', '같은 리소스 다수 GET', '다른 POST', 'WebSocket', 'SSE', 9, 'Coalescing은 동일한 GET 요청이 있을 때 하나의 요청으로 묶어 서버 요청을 줄이는 기술이다.'),
                                                                                                                           (436, 'Equal Jitter 이점 아닌 것?', 2, 'medium', '스파이크 완화', '최대/최소 지연 예측', 'Full Jitter보다 대기 줄임', '서버 완화', 9, 'Equal Jitter는 예측 가능성은 높지만 Full Jitter보다 대기 시간이 줄어들진 않는다.'),
                                                                                                                           (437, 'Fallback 전략 사례?', 1, 'high', '캐시된 데이터로 표시', '재시도 0', 'CB 강제 Close', 'Retry-After 무시', 9, 'Fallback 전략은 요청이 실패했을 때 캐시된 데이터를 보여주는 등 대체 로직을 제공한다.'),
                                                                                                                           (438, 'Hedged Request 주의점?', 1, 'high', '멱등 보장 필요', 'DNS TTL 0', 'KEEP-ALIVE 끊기', 'TLS 1.3', 9, 'Hedged Request는 같은 요청을 여러 번 보내기 때문에 멱등성 보장이 필요하다.'),
                                                                                                                           (439, 'Max-Retry-TTL 목적?', 1, 'high', '무제한 지연 방지', 'TCP FIN 감소', '브라우저 버그 회피', 'Keep-Alive 증가', 9, 'Max-Retry-TTL은 총 재시도 지연 시간의 상한을 설정하여 무한 대기 상태를 방지한다.'),
                                                                                                                           (440, 'CB 실시간 튜닝 기법?', 1, 'high', 'Feature Flag 기반 임계 조정', '콘솔 변수', '헤더 하드코드', '빌드 상수', 9, 'Feature Flag를 활용하면 운영 중에도 Circuit Breaker 설정을 유연하게 조정할 수 있다.'),
                                                                                                                           (441, '자주 쓰는 SLO 쌍은?', 1, 'low', '가용성·오류율', 'CPU·메모리', '빌드시간·커버리지', 'PR 리뷰', 9, 'SLO(Service Level Objective)는 일반적으로 사용자 중심의 품질 지표로 가용성과 오류율이 자주 사용된다. 이는 사용자가 서비스를 얼마나 안정적으로 이용할 수 있는지를 나타내는 중요한 지표이기 때문이다.'),
                                                                                                                           (442, 'P99 증가 의심 원인?', 1, 'low', '소수 요청 재시도 지연', '평균 느려짐', '404 급증', '로깅 오류', 9, 'P99는 상위 1%의 응답 시간이기 때문에 소수의 느린 요청(예: 재시도로 인한 지연)이 전체 P99 값을 높일 수 있다.'),
                                                                                                                           (443, '분산 추적 유용 이유?', 1, 'medium', 'Trace로 재시도 체인 시각화', '헤더 암호화', '로그 제거', '패킷 캡처', 9, '분산 추적은 요청 흐름을 시각화하여 문제를 추적하는 데 도움을 준다. 특히 재시도나 체인의 병목 현상을 쉽게 파악할 수 있다.'),
                                                                                                                           (444, 'Chaos 테스트 간단 도구?', 1, 'medium', 'MSW random error', 'CSS Lint', 'Bundle Analyzer', 'Lighthouse', 9, 'MSW(Mock Service Worker)는 네트워크 에러를 시뮬레이션할 수 있어 간단한 Chaos 테스트에 활용 가능하다.'),
                                                                                                                           (445, '포스트모템 포함 아님?', 1, 'medium', '담당자 인적 정보', '타임라인', 'RCA', '재발 방지', 9, '포스트모템에는 보통 사고 타임라인, 원인 분석(RCA), 재발 방지 대책이 포함되며, 개인의 인적 정보는 포함하지 않는다.'),
                                                                                                                           (446, '알림 임계 낮음 문제?', 1, 'high', 'Alert Fatigue', 'MTTR 증가', 'Slack→Email', 'Grafana 꺼짐', 9, '알림 임계값이 너무 낮으면 과도한 알림으로 인해 경고 무시 현상(Alert Fatigue)이 발생한다.'),
                                                                                                                           (447, '롤아웃 안전 배포 전략?', 1, 'high', 'Feature Flag Gradual', 'Big-bang', 'Force-push', 'CI 캐시 무효', 9, 'Feature Flag를 사용해 점진적으로 기능을 릴리스하면 오류 발생 시 롤백이 용이하고 안정적인 배포가 가능하다.'),
                                                                                                                           (448, '로그 레벨 매핑?', 1, 'high', '시작 debug, 재시도 info, 실패 error', '모두 warn', '재시도 fatal', '성공 error', 9, '일반적으로 시작 단계는 debug, 재시도는 info, 실패는 error로 구분하여 로그 레벨을 설정한다.'),
                                                                                                                           (449, '슬라이딩 윈도우 오류율 이유?', 1, 'high', '즉시값 대신 경향 파악', '메트릭 안 삭제', '테스트 속도', '다크 테마', 9, '슬라이딩 윈도우는 일정 시간 동안의 데이터를 분석하여 즉각적인 수치보다 전반적인 경향을 파악하기 위해 사용된다.'),
                                                                                                                           (450, '오류율 상승 자동 롤백 기능은?', 1, 'high', 'Canary 분석 → rollback', 'Merge Queue', 'multi-stage build', 'npm postinstall', 9, 'Canary 배포는 점진적 배포 후 오류율을 분석해 문제가 있으면 자동으로 롤백하는 전략이다.'),
                                                                                                                           (451, 'JSX에서 하나의 컴포넌트가 반환할 수 있는 요소는?', 1, 'low', '하나의 부모 요소만 반환해야 한다', '여러 개의 형제 요소를 반환할 수 있다', '모든 요소를 <script> 태그로 감싸야 한다', 'JSX에서는 요소 반환이 필요 없다', 10, 'JSX는 하나의 컴포넌트에서 하나의 부모 요소만 반환해야 React가 가상 DOM을 올바르게 렌더링할 수 있다.'),
                                                                                                                           (452, '다음 중 JSX 문법으로 올바른 것은?', 2, 'low', '<div class=\'\'container\'\'>', '<div className=\'\'container\'\'>', '<div classname=\'\'container\'\'>', '<div ClassName=\'\'container\'\'>', 10, 'JSX에서는 HTML의 class 대신 JavaScript 예약어인 className을 속성으로 사용해야 한다.'),
                                                                                                                           (453, 'React 컴포넌트 이름은 어떤 규칙을 따라야 하는가?', 3, 'low', '소문자로 시작해야 한다', '중괄호로 감싸야 한다', '대문자로 시작해야 한다', '파일 이름과 동일해야 한다', 10, 'React는 사용자 정의 컴포넌트를 대문자로 시작하는 이름으로 구분하기 때문에 컴포넌트는 대문자로 시작해야 한다.'),
                                                                                                                           (454, 'JSX에서 JavaScript 표현식을 사용할 때 어떤 기호를 사용하는가?', 2, 'medium', '[]', '{}', '()', '<>', 10, 'JSX 내에서 JavaScript 표현식을 삽입할 때는 중괄호({})를 사용한다.'),
                                                                                                                           (455, 'JSX에서 주석을 다는 올바른 방법은?', 3, 'medium', '// 주석', '<!-- 주석 -->', '{/* 주석 */}', '# 주석', 10, 'JSX에서 주석은 중괄호와 /* */를 함께 사용해야 유효하다.'),
                                                                                                                           (456, '다음 중 JSX에서 유효한 self-closing 태그는?', 3, 'medium', '<br>', '<img>', '<input/>', '<div></div>', 10, 'JSX에서는 self-closing 태그는 반드시 슬래시(/)와 함께 사용해야 하므로 <input/>이 올바른 표현이다.'),
                                                                                                                           (457, '컴포넌트의 기본 구조로 올바른 것은?', 1, 'high', 'function App() { return <h1>Hello</h1>; }', 'let App = () => (<h1>Hello</h1>)', 'component App() => <h1>Hello</h1>', 'function App: return (<h1>Hello</h1>)', 10, 'React의 함수형 컴포넌트는 function 키워드와 return 문을 포함하는 기본 형태로 작성된다.'),
                                                                                                                           (458, 'JSX 내에서 조건부 렌더링을 위해 주로 사용하는 연산자는?', 3, 'high', '??', '==', '&&', '!=', 10, '조건부 렌더링에서는 && 연산자를 사용해 조건이 true일 때만 JSX를 반환하도록 작성한다.'),
                                                                                                                           (459, '컴포넌트를 export 하는 기본 방법은?', 2, 'high', 'module.export = ComponentName;', 'export default ComponentName;', 'require(ComponentName);', 'ComponentName.export();', 10, 'ES6 문법에서 기본적으로 export default 문법을 사용해 컴포넌트를 내보낸다.'),
                                                                                                                           (460, 'JSX에서 style 속성을 사용할 때 올바른 형식은?', 2, 'medium', 'style=\'\'color: red;\'\'', 'style={{color: \'\'red\'\'}}', 'style=\'\'{{color: red}}\'\'', 'style=(color: red)', 10, 'JSX에서는 style 속성에 객체 형태로 스타일을 넘기며, 이때 중괄호를 두 번 사용해야 한다.'),
                                                                                                                           (461, 'React에서 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달할 때 사용하는 것은?', 1, 'low', 'props', 'state', 'context', 'ref', 10, '부모 컴포넌트는 props를 통해 자식에게 데이터를 전달할 수 있다. 이는 컴포넌트 간 데이터 흐름의 기본이다.'),
                                                                                                                           (462, '다음 중 props의 특징으로 올바른 것은?', 2, 'low', '변경 가능한 값이다', '부모 → 자식 방향의 데이터 전달이다', '컴포넌트 내부에서만 사용된다', 'setProps로 값을 변경한다', 10, 'props는 변경 불가능한 읽기 전용 값이며, 부모 컴포넌트에서 자식으로 전달되는 데이터이다.'),
                                                                                                                           (463, '컴포넌트 내부에서 값의 변경에 따라 다시 렌더링되도록 하는 데이터는?', 2, 'low', 'props', 'state', 'context', 'variable', 10, 'state는 컴포넌트 내부의 변경 가능한 상태로, 값이 바뀌면 컴포넌트가 다시 렌더링된다.'),
                                                                                                                           (464, 'React에서 state를 변경할 수 있는 올바른 방법은?', 3, 'medium', 'state = newValue', 'this.state.update(newValue)', 'setState(newValue)', 'state.set(newValue)', 10, 'React에서는 state를 직접 수정하지 않고 setState 함수를 통해 상태를 변경해야 한다.'),
                                                                                                                           (465, '함수형 컴포넌트에서 state를 사용하기 위해 import해야 할 Hook은?', 2, 'medium', 'useEffect', 'useState', 'useReducer', 'useMemo', 10, '함수형 컴포넌트에서 state를 사용하려면 React의 useState Hook을 import해서 사용한다.'),
                                                                                                                           (466, '다음 중 useState의 기본 사용법으로 옳은 것은?', 3, 'medium', 'const state = useState(0)', 'let [state] = useState(0)', 'const [count, setCount] = useState(0)', 'state, setState = useState(0)', 10, 'useState는 배열 구조 분해 할당을 통해 [상태, 설정함수] 형태로 값을 사용한다.'),
                                                                                                                           (467, 'props를 통해 전달된 값을 변경하려고 할 때의 올바른 대응은?', 1, 'high', 'setState로 복사본을 변경한다', 'props 값을 직접 변경한다', 'ref를 사용해 수정한다', 'forceUpdate로 무시하고 렌더링한다', 10, 'props는 불변이므로 직접 변경할 수 없으며, 복사본을 만들어 state로 관리하는 것이 적절하다.'),
                                                                                                                           (468, 'state는 다음 중 어느 시점에 React가 컴포넌트를 다시 렌더링하도록 만드는가?', 1, 'high', 'state 변경 시', 'props 선언 시', '컴포넌트 mount 시', 'CSS 클래스가 바뀔 때', 10, 'state 값이 변경되면 React는 해당 변경을 감지하고 컴포넌트를 자동으로 다시 렌더링한다.'),
                                                                                                                           (469, '다음 중 props와 state의 공통점은?', 2, 'high', '컴포넌트 간 공유 가능', '변경 시 UI 자동 업데이트', '함수형 컴포넌트에서만 사용', '직접 수정 가능', 10, 'props와 state 모두 값이 변경되면 자동으로 UI가 업데이트된다.'),
                                                                                                                           (470, 'props의 타입을 미리 지정하여 유효성 검사를 하고 싶을 때 사용하는 것은?', 2, 'high', 'TypeGuard', 'PropTypes', 'TypeScript', 'validateProps', 10, 'React에서는 PropTypes를 사용해 props의 타입을 정의하고, 전달된 값이 올바른지 유효성 검사를 수행할 수 있다.'),
                                                                                                                           (471, 'React에서 클릭 이벤트를 등록할 때 사용하는 속성은?', 1, 'low', 'onClick', 'onclick', 'click', 'addEventListener', 10, 'React에서는 camelCase로 작성된 onClick 속성을 사용하여 클릭 이벤트를 등록한다. 이는 JSX가 JavaScript 문법을 따르기 때문이다.'),
                                                                                                                           (472, 'SyntheticEvent의 기본 동작을 취소하려면 이벤트 객체에서 어떤 메서드를 호출해야 하는가?', 1, 'low', 'preventDefault()', 'stopPropagation()', 'cancelBubble()', 'halt()', 10, 'preventDefault() 메서드는 기본 동작을 막는 표준적인 방식으로, SyntheticEvent에서도 동일하게 작동한다.'),
                                                                                                                           (473, '다음 중 && 연산자를 이용한 조건부 렌더링으로 올바른 것은?', 1, 'low', '{isLoggedIn && <Dashboard />}', '{isLoggedIn ? <Dashboard />}', '{isLoggedIn || <Dashboard />}', 'isLoggedIn && <Dashboard />', 10, 'JSX 내에서 조건부 렌더링 시, isLoggedIn이 true일 경우에만 <Dashboard />를 렌더링하는 표현은 && 연산자를 사용한 형태가 올바르다.'),
                                                                                                                           (474, '이벤트 핸들러에 인자를 전달하기 위한 가장 일반적인 방법은?', 1, 'medium', 'onClick={() => handleClick(id)}', 'onClick={handleClick(id)}', 'onClick={handleClick.bind(this, id)()}', 'onClick="handleClick(id)"', 10, '익명 함수를 사용하는 방식인 onClick={() => handleClick(id)}는 클릭 시점에 함수가 실행되도록 보장하는 가장 일반적인 패턴이다.'),
                                                                                                                           (475, '삼항 연산자를 사용한 조건부 렌더링 예시로 적절한 것은?', 1, 'medium', '{isLoggedIn ? <Logout /> : <Login />}', '{isLoggedIn && <Login /> : <Logout />}', '{isLoggedIn ? <Login />}', '{<Login /> ? isLoggedIn : <Logout />}', 10, '삼항 연산자(?:)는 조건에 따라 두 개의 컴포넌트를 선택적으로 렌더링할 수 있으며, 가장 기본적인 패턴이다.'),
                                                                                                                           (476, '컴포넌트가 특정 조건에서 아무것도 렌더링하지 않도록 하려면 일반적으로 무엇을 반환하는가?', 1, 'medium', 'null', 'undefined', ''''' (빈 문자열)', 'false', 10, 'null을 반환하면 React는 아무것도 렌더링하지 않기 때문에 조건부 렌더링에서 효과적으로 사용된다.'),
                                                                                                                           (477, '이벤트 버블링을 중단하려면 SyntheticEvent에서 어떤 메서드를 호출해야 하는가?', 1, 'high', 'stopPropagation()', 'preventDefault()', 'stopBubble()', 'halt()', 10, 'stopPropagation()은 이벤트가 부모 요소로 전파되는 것을 막기 위한 메서드이며, SyntheticEvent에서도 동일하게 작동한다.'),
                                                                                                                           (478, '다음 중 조건에 따라 클래스 이름을 동적으로 지정한 올바른 JSX 구문은?', 1, 'high', '<div className={isActive ? ''active'' : ''''}></div>', '<div class=''isActive && active''></div>', '<div className=''isActive ? active''></div>', '<div className={isActive && ''active''}></div>', 10, '삼항 연산자를 사용한 className 지정 방식은 JSX에서 조건에 따라 클래스를 명확히 설정할 수 있는 안전한 방법이다.'),
                                                                                                                           (479, 'React에서 SyntheticEvent 객체는 이벤트 핸들러 종료 후 값을 재사용할 수 없는데, 이를 예외적으로 보존하려면 호출해야 하는 메서드는?', 1, 'high', 'persist()', 'keep()', 'save()', 'cache()', 10, 'React는 성능을 위해 이벤트 객체를 재사용하며, persist()를 호출하면 해당 이벤트 객체를 비동기적으로도 사용할 수 있도록 보존한다.'),
                                                                                                                           (480, '다음 코드가 0을 렌더링하는 문제를 방지하기 위한 권장 방법은? {messages.length && <Badge count={messages.length} />}', 1, 'high', 'messages.length > 0 && <Badge count={messages.length} />', 'messages.length || <Badge count={messages.length} />', '{messages.length !== 0 && <Badge count={messages.length} />}', 'messages.length && Badge(count={messages.length})', 10, '0은 falsy 값이지만 JSX로 출력되면 그대로 보이기 때문에, 명시적으로 0보다 큰 경우에만 렌더링하도록 조건을 작성해야 한다.'),
                                                                                                                           (481, '배열을 JSX로 변환할 때 가장 흔히 사용하는 배열 메서드는?', 1, 'low', 'map()', 'forEach()', 'filter()', 'reduce()', 10, 'map()은 각 요소를 변형하여 반환하는 함수로 JSX 엘리먼트를 생성하는 데 가장 적합하다.'),
                                                                                                                           (482, 'key prop은 일반적으로 어디에 지정해야 하는가?', 1, 'low', 'map()이 반환하는 각 형제 요소의 최상위 태그', 'ul·ol 같은 부모 컨테이너', '리스트 내부 모든 하위 요소', 'key prop은 필수가 아니다', 10, 'React는 key를 통해 각 요소의 변경 여부를 추적하므로, 반복된 형제 요소의 최상위 태그에 key를 지정해야 한다.'),
                                                                                                                           (483, 'React key에 대한 기본 규칙으로 올바른 것은?', 1, 'low', '형제 사이에서 고유해야 한다', '페이지 전체에서 절대 고유해야 한다', '숫자만 사용할 수 있다', '렌더마다 새로운 값을 부여해야 한다', 10, 'key는 리스트 내에서 형제 요소들 사이에서만 고유하면 충분하다. 전역적으로 고유할 필요는 없다.'),
                                                                                                                           (484, '다음 중 인덱스를 key로 사용해도 비교적 안전한 경우는?', 1, 'medium', '항목이 절대 추가·삭제·재정렬되지 않는 정적 목록', '사용자가 드래그로 순서를 바꾸는 목록', '동적으로 삽입·삭제되는 Todo 리스트', '컨트롤된 input 필드를 가진 양방향 폼', 10, '정적인 목록은 요소의 순서나 수가 바뀌지 않기 때문에 인덱스를 key로 사용해도 문제가 없다.'),
                                                                                                                           (485, 'key를 생략하면 React가 주로 어떤 반응을 보이는가?', 1, 'medium', '개발자 콘솔에 경고를 출력한다', '컴파일 오류가 발생한다', '렌더링이 완전히 중단된다', '성능이 자동으로 최적화된다', 10, 'key가 없으면 React는 경고 메시지를 출력하며, 이는 성능 및 상태 관리의 문제로 이어질 수 있다.'),
                                                                                                                           (486, '다음 중 Fragment에 key를 부여하는 올바른 문법은?', 1, 'medium', '<React.Fragment key={item.id}>...</React.Fragment>', '<Fragment key>{...}</Fragment>', '<></> key={item.id}', '<Fragment id={item.id}>...</Fragment>', 10, 'Fragment에 key를 부여할 때는 <React.Fragment key={...}>와 같이 명시적으로 작성해야 한다.'),
                                                                                                                           (487, '렌더마다 Math.random() 값을 key로 사용하면 주로 발생하는 문제는?', 1, 'high', '모든 자식이 매번 언마운트·리마운트되어 상태가 초기화된다', '컴파일 타임 타입 오류가 발생한다', '브라우저 캐시가 비활성화된다', 'React가 diff 과정을 건너뛴다', 10, 'key가 매번 바뀌면 React는 해당 요소를 새 요소로 인식하고 재마운트하게 되어 성능 저하와 상태 초기화 문제가 발생한다.'),
                                                                                                                           (488, '리스트가 자주 재정렬될 때 가장 바람직한 key 선택은?', 1, 'high', '데이터베이스에서 받은 고유 id', '배열 길이', 'Date.now()로 만든 타임스탬프', '요소의 화면 좌표값', 10, 'id와 같이 변경되지 않는 고유 식별자는 React가 요소를 정확히 추적할 수 있게 해주므로 가장 안전한 key로 사용된다.'),
                                                                                                                           (489, '중첩(map 안의 map) 리스트를 렌더링할 때 key를 꼭 부여해야 하는 위치는?', 1, 'high', '각 map이 반환하는 최상위 형제 요소', '가장 바깥 컨테이너 한 곳만', '가장 안쪽 요소 한 곳만', 'key는 한 레벨에서만 허용된다', 10, 'React에서는 각 반복(map)에서 반환되는 요소마다 key를 부여해야 하므로, 중첩된 경우 각각의 map에서 key를 부여해야 한다.'),
                                                                                                                           (490, '다음 중 key prop에 대한 설명으로 옳지 않은 것은?', 4, 'high', '문자열 또는 숫자처럼 직렬화 가능한 값이어야 한다', '컴포넌트가 재사용되는 동안 변하지 않아야 한다', 'React diff 알고리즘이 요소 정체성을 추적할 때 사용한다', '렌더링 간 변경하면 DOM 최적화가 강화된다', 10, 'key는 변하지 않아야 React가 최적화를 할 수 있으며, 자주 바뀌면 오히려 DOM 변경이 많아져 비효율적이다.'),
                                                                                                                           (491, '함수형 컴포넌트에서 전역 컨텍스트 값을 읽어올 때 사용하는 Hook은?', 1, 'low', 'useContext', 'useState', 'useReducer', 'useMemo', 10, 'useContext는 Context API를 사용하여 전역 데이터를 컴포넌트 내부에서 접근할 수 있게 해주는 Hook이다.'),
                                                                                                                           (492, '사용자 정의 Hook을 만들 때 반드시 지켜야 하는 명명 규칙은?', 1, 'low', 'use로 시작해야 한다', '대문자로 시작해야 한다', 'with로 시작해야 한다', 'Hook 접미사를 붙여야 한다', 10, 'React는 Hook의 실행 순서를 추적하기 위해 use로 시작하는 네이밍 규칙을 필수로 요구한다.'),
                                                                                                                           (493, 'useEffect의 두 번째 인수에 빈 배열([])을 전달하면 언제 실행되는가?', 1, 'low', '컴포넌트가 처음 마운트될 때만', '모든 렌더링마다', '의존성 값이 변경될 때마다', '언마운트될 때만', 10, '두 번째 인수에 빈 배열을 넘기면 해당 useEffect는 마운트 시 한 번만 실행된다.'),
                                                                                                                           (494, 'useRef로 생성한 ref.current 값의 핵심 특징은?', 1, 'medium', '렌더 사이에 값이 바뀌어도 재렌더링을 일으키지 않는다', '값이 변경되면 자동으로 상태 업데이트가 발생한다', 'DOM 엘리먼트에만 사용할 수 있다', '매 렌더링마다 새로운 객체가 생성된다', 10, 'ref.current는 컴포넌트가 다시 렌더링되어도 값이 유지되며, 값 변경 시에도 리렌더링을 유발하지 않는다.'),
                                                                                                                           (495, '복잡한 상태 전이를 깔끔하게 관리하기 위해 useState 대신 권장되는 Hook은?', 1, 'medium', 'useReducer', 'useCallback', 'useMemo', 'useRef', 10, 'useReducer는 상태가 여러 경우로 분기되는 상황에서 상태 전이 로직을 명확히 정의하기에 적합하다.'),
                                                                                                                           (496, '계산 비용이 큰 값을 메모이제이션하여 렌더링 성능을 최적화할 때 사용하는 Hook은?', 1, 'medium', 'useMemo', 'useEffect', 'useLayoutEffect', 'useCallback', 10, 'useMemo는 복잡한 계산 결과를 저장하고 의존성이 바뀔 때만 재계산하여 렌더링 성능을 높이는 데 사용된다.'),
                                                                                                                           (497, '다음 코드에서 handleClick 함수가 매 렌더링마다 새로 생성되는 문제를 방지하려면?', 1, 'high', 'const handleClick = useCallback(() => setCount(c => c + 1), []);', 'const handleClick = useMemo(() => () => setCount(c => c + 1), []);', 'const handleClick = useEffect(() => setCount(c => c + 1), []);', 'const handleClick = useRef(() => setCount(c => c + 1));', 10, 'useCallback은 함수 참조를 메모이제이션하여 매 렌더링 시 동일한 함수를 재사용할 수 있게 해준다.'),
                                                                                                                           (498, 'useEffect 콜백이 반환하는 함수의 주 용도는?', 1, 'high', '이전 effect를 정리(clean-up)하는 데 사용된다', '의존성 배열을 강제로 재계산한다', '렌더링 결과를 직접 DOM에 삽입한다', '상태 업데이트를 배치(batching)한다', 10, 'useEffect의 반환 함수는 컴포넌트가 언마운트되거나 의존성이 변경되기 전 실행되어 리소스를 정리한다.'),
                                                                                                                           (499, '자식 컴포넌트의 DOM 혹은 인스턴스에 부모가 접근할 수 있도록 만드는 고급 기술은?', 1, 'high', 'forwardRef', 'memo', 'lazy', 'StrictMode', 10, 'forwardRef는 부모 컴포넌트가 자식의 DOM 요소나 ref 객체에 접근할 수 있게 하는 고급 기능이다.'),
                                                                                                                           (500, 'Hooks의 핵심 규칙으로 옳지 않은 것은?', 2, 'high', 'Hook은 함수형 컴포넌트 최상위에서만 호출해야 한다', 'Hook은 조건문·반복문 안에서 자유롭게 호출할 수 있다', '커스텀 Hook 내부에서도 다른 Hook을 호출할 수 있다', 'Class 컴포넌트에서는 Hook을 사용할 수 없다', 10, 'Hook은 항상 동일한 순서로 호출되어야 하므로 조건문이나 반복문 내부에서는 사용할 수 없다.'),
                                                                                                                           (501, 'Redux의 핵심 개념은?', 2, 'low', '컴포넌트 상태 공유', '단일 상태 트리', '다중 스토어 구조', '컴파일 시간 상태', 11, 'Redux는 하나의 단일 상태 트리(single state tree)를 통해 전체 애플리케이션의 상태를 중앙에서 관리하는 것이 핵심 개념이다.'),
                                                                                                                           (502, 'Redux에서 상태를 변경할 수 있는 유일한 방법은?', 3, 'low', 'Reducer 호출', 'Store 직접 수정', 'Action dispatch', 'State mutation', 11, 'Redux에서 상태는 dispatch를 통해 액션을 전달하고, 리듀서가 이를 처리하여 변경된다. 이는 단방향 데이터 흐름을 유지하기 위함이다.'),
                                                                                                                           (503, 'Redux에서 상태를 저장하는 객체는?', 1, 'low', 'store', 'reducer', 'action', 'component', 11, 'Redux에서 상태는 store 객체에 저장되며, 이는 애플리케이션의 상태 트리를 관리하는 핵심 객체이다.'),
                                                                                                                           (504, 'Redux의 세 가지 핵심 원칙 중 아닌 것은?', 2, 'medium', '상태는 단일 객체로 저장된다', '상태는 직접 수정할 수 있다', '상태 변경은 순수 함수로 수행된다', '상태는 읽기 전용이다', 11, 'Redux에서는 상태는 직접 수정할 수 없고, 반드시 액션과 리듀서를 통해서만 변경되어야 한다.'),
                                                                                                                           (505, 'Redux를 사용하는 주요 이유는?', 2, 'medium', '성능 향상', '상태 공유와 예측 가능한 흐름', '렌더링 속도 증가', '자동 라우팅', 11, 'Redux는 복잡한 컴포넌트 계층 구조에서도 상태를 중앙 집중화하여 관리하고 흐름을 예측 가능하게 만들어준다.'),
                                                                                                                           (506, 'Redux의 상태는 어떤 성격을 가진다?', 3, 'medium', '비순차적', '비동기적', '불변(immutable)', '동적 변경 가능', 11, 'Redux 상태는 직접 수정하지 않고 항상 새로운 상태 객체를 반환해야 하므로 불변성을 유지한다.'),
                                                                                                                           (507, 'React에서 Redux를 연결하는 가장 일반적인 라이브러리는?', 1, 'high', 'react-redux', 'redux-connect', 'react-context', 'redux-react', 11, 'react-redux는 Redux 상태를 React 컴포넌트와 연결하기 위한 공식 바인딩 라이브러리다.'),
                                                                                                                           (508, 'Redux의 동작 방식에 가장 가까운 비유는?', 1, 'high', '게시판에 메모 남기기', '직접 수정', '데이터베이스 삽입', '로컬스토리지 저장', 11, 'Redux는 상태를 직접 수정하지 않고 액션을 통해 상태를 업데이트하는 방식으로, 게시판에 메모를 남기는 것처럼 간접적이다.'),
                                                                                                                           (509, 'Redux 상태 트리에서 상태를 변경하는 순수 함수는?', 3, 'high', 'action', 'dispatcher', 'reducer', 'store', 11, 'reducer는 액션을 받아서 새로운 상태를 반환하는 순수 함수이며 상태 변경 로직의 핵심이다.'),
                                                                                                                           (510, 'Redux는 어떤 디자인 패턴에 기반하고 있는가?', 3, 'high', 'MVC', 'Observer', 'Flux', 'Factory', 11, 'Redux는 Facebook에서 만든 Flux 아키텍처에서 영감을 받은 단방향 데이터 흐름을 따르는 상태 관리 패턴이다.'),
                                                                                                                           (511, 'Redux에서 액션 객체는 어떤 필드를 반드시 포함해야 하는가?', 2, 'low', 'payload', 'type', 'value', 'dispatch', 11, '액션 객체는 최소한 어떤 동작인지 구분할 수 있도록 type 속성을 반드시 포함해야 한다.'),
                                                                                                                           (512, 'Reducer 함수의 주요 특징은?', 3, 'low', '비결정적 함수', '부작용을 가진 함수', '순수 함수', '비동기 함수', 11, 'Reducer는 동일한 입력에 대해 항상 동일한 출력을 반환하고 외부 상태를 변경하지 않는 순수 함수여야 한다.'),
                                                                                                                           (513, '리듀서는 어떤 값을 반환해야 하는가?', 2, 'low', 'dispatch 함수', '변경된 상태', '액션 객체', '이벤트 객체', 11, '리듀서는 전달된 현재 상태와 액션을 기반으로 새로운 상태를 계산하여 반환한다.'),
                                                                                                                           (514, '다음 중 올바른 액션 생성자 함수는?', 4, 'medium', 'create(type)', 'generateAction()', 'dispatchAction()', 'function that returns a type and optional payload', 11, '액션 생성자 함수는 type과 payload를 포함한 액션 객체를 반환하는 함수여야 한다.'),
                                                                                                                           (515, '액션 생성자(action creator)는 무엇을 반환하는가?', 3, 'medium', 'dispatch', 'reducer', '액션 객체', '상태 트리', 11, '액션 생성자는 액션 객체를 반환하는 함수로, 이 객체는 dispatch 함수에 의해 리듀서로 전달된다.'),
                                                                                                                           (516, '리듀서가 상태를 변경할 수 있는 조건은?', 2, 'medium', '외부 상태 참조', '새로운 상태 객체 반환', '상태 직접 수정', 'DOM 접근', 11, 'Redux에서는 상태를 직접 수정하지 않고 항상 새로운 상태 객체를 반환해야 하며, 이는 불변성을 유지하기 위함이다.'),
                                                                                                                           (517, '여러 개의 리듀서를 하나로 합치기 위해 사용하는 함수는?', 3, 'high', 'combine()', 'mergeReducers()', 'combineReducers()', 'createReducers()', 11, 'combineReducers는 여러 리듀서를 하나로 합쳐서 store에 전달할 수 있게 해주는 Redux의 유틸 함수이다.'),
                                                                                                                           (518, '리듀서 내부에서 상태를 변경할 때 가장 중요한 규칙은?', 3, 'high', '기존 상태를 직접 수정', 'payload에 따라 조건 분기', '새 상태를 복사 후 반환', 'state를 삭제 후 생성', 11, '기존 상태를 직접 변경하지 않고 새로운 객체를 만들어 반환함으로써 불변성을 유지해야 한다.'),
                                                                                                                           (519, 'dispatch는 어떤 역할을 하는가?', 1, 'high', '리듀서 실행', '상태 조회', '스토어 생성', '미들웨어 실행', 11, 'dispatch는 액션을 스토어에 전달하여 리듀서가 해당 액션을 처리하게 하는 역할을 한다.'),
                                                                                                                           (520, 'type 값이 없는 액션을 dispatch하면?', 2, 'high', '에러 발생', '무시됨', '무작위 처리', 'store 초기화', 11, 'Redux는 액션 객체의 type 값을 기준으로 리듀서를 실행하므로, type이 없으면 해당 액션은 무시된다.'),
                                                                                                                           (521, 'Redux에서 상태를 저장하는 핵심 객체는?', 2, 'low', 'provider', 'store', 'context', 'reducer', 11, 'store는 상태를 보관하고 액션을 디스패치하며 구독 기능을 제공하는 Redux의 핵심 객체이다.'),
                                                                                                                           (522, '스토어를 생성할 때 사용하는 함수는?', 1, 'low', 'createStore()', 'makeStore()', 'initStore()', 'buildStore()', 11, 'createStore는 Redux에서 스토어를 생성할 때 사용하는 함수이다. 단, 최신 Redux Toolkit에서는 configureStore를 권장한다.'),
                                                                                                                           (523, 'Redux에서 상태를 조회하는 함수는?', 1, 'low', 'getState()', 'useState()', 'state()', 'readState()', 11, 'getState는 현재 store에 저장된 상태를 반환하는 Redux 함수이다.'),
                                                                                                                           (524, '스토어에 리듀서를 연결하는 역할은?', 3, 'medium', 'dispatch()', 'subscribe()', 'combineReducers()', 'reducer()', 11, 'combineReducers는 여러 리듀서를 하나로 결합하여 루트 리듀서를 만들고 스토어에 연결하는 데 사용된다.'),
                                                                                                                           (525, 'React와 Redux를 연결하는 최상위 컴포넌트는?', 1, 'medium', 'Provider', 'Connect', 'ReduxWrapper', 'StoreBridge', 11, 'Provider는 React 컴포넌트 트리에 Redux store를 주입하여 하위 컴포넌트들이 store에 접근할 수 있게 한다.'),
                                                                                                                           (526, '스토어에서 구독을 해제하는 방법은?', 1, 'medium', 'unsubscribe()', 'remove()', 'detach()', 'off()', 11, 'store.subscribe로 등록된 콜백은 반환된 unsubscribe 함수를 호출함으로써 해제할 수 있다.'),
                                                                                                                           (527, '상태 변경 시마다 실행되는 함수를 등록하려면?', 1, 'high', 'subscribe()', 'watch()', 'track()', 'observer()', 11, 'subscribe 함수는 상태가 변경될 때마다 실행되는 콜백을 등록할 수 있는 Redux의 기본 메서드이다.'),
                                                                                                                           (528, 'Redux에서 상태 변경이 일어나면 어떤 방식으로 UI가 갱신되는가?', 3, 'high', '자동 갱신', 'store에서 직접 렌더링', '구독 함수 호출', 'action에서 직접 수정', 11, 'Redux는 상태가 변경되면 등록된 구독 함수가 호출되어 UI가 갱신되도록 트리거한다.'),
                                                                                                                           (529, 'store.dispatch()는 어떤 역할을 수행하는가?', 2, 'high', '리듀서 초기화', '액션 전달 및 상태 변경', '상태 초기화', 'UI 리렌더링', 11, 'dispatch는 액션을 스토어에 전달하고, 리듀서를 통해 상태 변경을 트리거하는 역할을 한다.'),
                                                                                                                           (530, 'Redux에서 상태는 어떤 구조로 저장되는가?', 3, 'high', '클래스 객체', 'Map', '단일 JSON 객체', '배열 트리', 11, 'Redux의 상태는 하나의 단일 JSON 객체 구조로 관리되어 트리 형태로 중첩된 데이터를 표현한다.'),
                                                                                                                           (531, 'Redux 미들웨어의 주된 목적은?', 2, 'low', '스토어 생성', '비동기 로직 처리', 'UI 렌더링', '액션 강제 취소', 11, 'Redux 미들웨어는 액션과 리듀서 사이에서 비동기 작업이나 로깅 같은 부가 로직을 처리하는 데 사용된다.'),
                                                                                                                           (532, 'Redux에서 미들웨어를 적용할 때 사용하는 함수는?', 1, 'low', 'applyMiddleware()', 'useMiddleware()', 'createMiddleware()', 'bindMiddleware()', 11, 'applyMiddleware는 Redux에서 미들웨어를 스토어에 연결하기 위해 사용하는 함수이다.'),
                                                                                                                           (533, 'Redux에서 비동기 액션을 처리하기 위해 사용하는 대표적 미들웨어는?', 1, 'low', 'redux-thunk', 'redux-loop', 'redux-saga', 'redux-promise', 11, 'redux-thunk는 가장 널리 사용되는 Redux 비동기 미들웨어로, 액션 생성자에서 함수를 반환할 수 있게 해준다.'),
                                                                                                                           (534, 'redux-thunk 미들웨어를 사용하면 액션 생성자가 반환할 수 있는 것은?', 3, 'medium', '객체만 가능', '문자열', '함수', '숫자', 11, 'redux-thunk는 액션 생성자가 함수를 반환할 수 있게 하여, 비동기 로직을 처리한 후 dispatch를 호출할 수 있게 한다.'),
                                                                                                                           (535, 'redux-saga는 어떤 문법을 활용하는가?', 3, 'medium', 'callback', 'async/await', 'generator', 'observable', 11, 'redux-saga는 ES6 generator 문법을 기반으로 비동기 로직을 명령형으로 정의할 수 있게 해준다.'),
                                                                                                                           (536, '비동기 요청 중 상태를 관리하기 위한 일반적인 상태 값은?', 1, 'medium', 'loading, success, error', 'fetch, render, complete', 'start, wait, end', 'idle, go, stop', 11, '비동기 처리 시 요청 중, 성공, 실패 상태를 구분하기 위해 loading, success, error 상태를 자주 사용한다.'),
                                                                                                                           (537, 'redux-logger의 역할은?', 3, 'high', '에러 처리', '비동기 요청', '상태 변경 기록 출력', '로딩 스피너 표시', 11, 'redux-logger는 상태 변화 및 액션 디스패치를 콘솔에 출력하여 디버깅을 돕는 미들웨어이다.'),
                                                                                                                           (538, 'thunk 함수 내부에서 dispatch를 호출하는 이유는?', 3, 'high', '에러를 던지기 위해', '상태를 초기화하기 위해', '비동기 완료 후 상태 변경하기 위해', '스토어 삭제하기 위해', 11, 'thunk 내부에서 dispatch를 호출함으로써, 비동기 작업이 끝난 후 상태를 변경하는 액션을 실행할 수 있다.'),
                                                                                                                           (539, '미들웨어는 액션과 리듀서 사이에서 어떤 역할을 하는가?', 2, 'high', '액션 필터링', '액션 로깅 및 비동기 처리', '컴포넌트 렌더링', 'HTML 반환', 11, '미들웨어는 액션이 리듀서에 도달하기 전에 로깅, 비동기 처리 등 중간 작업을 수행할 수 있다.'),
                                                                                                                           (540, '비동기 요청 시 공통된 처리 로직을 중앙화하려면 어떻게 해야 하는가?', 3, 'high', '리듀서에 작성', '컴포넌트 내부 처리', '미들웨어에서 처리', '스토어에서 처리', 11, '공통된 비동기 처리 로직은 미들웨어에 두어 코드 중복을 줄이고 관리하기 쉽게 한다.'),
                                                                                                                           (541, 'Redux Toolkit에서 스토어를 생성하는 함수는?', 3, 'low', 'createStore()', 'initStore()', 'configureStore()', 'setupStore()', 11, 'configureStore는 Redux Toolkit에서 제공하는 함수로, 기본 미들웨어와 DevTools를 자동 설정해준다.'),
                                                                                                                           (542, 'Redux Toolkit은 어떤 목적을 가지고 설계되었는가?', 2, 'low', '성능 향상', '코드 간결성 및 표준화', '미들웨어 제거', '상태 공유 방지', 11, 'Redux Toolkit은 복잡하고 장황했던 Redux 코드 작성을 간결하고 표준화된 방식으로 개선하기 위해 만들어졌다.'),
                                                                                                                           (543, 'Redux Toolkit에서 액션 생성과 리듀서를 동시에 정의할 수 있는 함수는?', 2, 'low', 'createReducer()', 'createSlice()', 'combineReducer()', 'createAction()', 11, 'createSlice는 액션 생성자와 리듀서를 동시에 생성할 수 있어 코드 양을 줄이고 구조를 명확히 한다.'),
                                                                                                                           (544, 'createSlice로 생성한 리듀서의 액션은 어디에 정의되는가?', 1, 'medium', 'slice.actions', 'slice.reducers', 'slice.dispatch', 'slice.state', 11, 'createSlice로 생성된 액션은 slice.actions 속성에 포함되어 다른 컴포넌트에서 불러와 사용할 수 있다.'),
                                                                                                                           (545, 'Redux Toolkit에서 상태 불변성 유지를 위해 사용하는 라이브러리는?', 2, 'medium', 'Immutable.js', 'Immer', 'ProxyState', 'DraftState', 11, 'Redux Toolkit은 내부적으로 Immer를 사용하여 개발자가 불변성을 신경 쓰지 않고도 상태를 안전하게 변경할 수 있도록 한다.'),
                                                                                                                           (546, 'Redux Toolkit에서 비동기 처리를 위해 사용하는 함수는?', 1, 'medium', 'createAsyncThunk()', 'useEffect()', 'thunkReducer()', 'createThunk()', 11, 'createAsyncThunk는 비동기 요청 로직을 정의하고, 자동으로 pending, fulfilled, rejected 액션을 생성해주는 함수이다.'),
                                                                                                                           (547, 'Redux Toolkit에서 slice를 사용할 때 필요한 속성이 아닌 것은?', 4, 'high', 'name', 'initialState', 'reducers', 'selectors', 11, 'slice를 정의할 때 selectors는 필수가 아니며, name, initialState, reducers가 필수 속성이다.'),
                                                                                                                           (548, 'Redux Toolkit에서 extraReducers의 주요 용도는?', 2, 'high', '미들웨어 등록', '비동기 액션 처리', '스토어 설정', '로컬 상태 저장', 11, 'extraReducers는 외부 액션(예: createAsyncThunk에서 생성된 액션 등)에 대한 상태 처리를 정의할 때 사용된다.'),
                                                                                                                           (549, 'Redux Toolkit은 어떤 미들웨어를 기본 포함하는가?', 1, 'high', 'redux-thunk', 'redux-logger', 'redux-saga', 'redux-observable', 11, 'Redux Toolkit은 기본적으로 redux-thunk 미들웨어를 포함하여 비동기 작업을 지원한다.'),
                                                                                                                           (550, 'Redux Toolkit에서 slice로부터 리듀서를 가져올 때 사용하는 속성은?', 2, 'high', 'slice.state', 'slice.reducer', 'slice.actions', 'slice.dispatch', 11, 'createSlice로부터 생성된 리듀서는 slice.reducer 속성을 통해 가져올 수 있다.'),
                                                                                                                           (551, '클라이언트 잘못된 요청(예: JSON 스키마 위반)에 대한 권장 HTTP 상태 코드는?', 1, 'low', '400 Bad Request', '401 Unauthorized', '500 Internal Server Error', '409 Conflict', 12, '요청의 형식이나 데이터가 잘못되었을 경우 서버는 400 Bad Request 상태 코드를 반환한다.'),
                                                                                                                           (552, '인증 헤더가 누락된 요청에 서버가 반환해야 할 표준 상태 코드는?', 1, 'low', '401 Unauthorized', '403 Forbidden', '412 Precondition Failed', '502 Bad Gateway', 12, '401 Unauthorized는 인증 정보가 없거나 올바르지 않은 경우 클라이언트에게 인증을 요구하는 응답이다.'),
                                                                                                                           (553, 'REST API에서 존재하지 않는 리소스에 대한 GET 요청 시 적절한 응답 코드는?', 1, 'low', '404 Not Found', '410 Gone', '204 No Content', '422 Unprocessable Entity', 12, '서버에 요청한 리소스가 존재하지 않을 경우, 404 Not Found 응답을 반환해야 한다.'),
                                                                                                                           (554, 'RFC 7807 ‘Problem Details for HTTP APIs’가 권장하는 기본 Content-Type은?', 1, 'medium', 'application/problem+json', 'application/json; problem', 'text/problem', 'application/vnd.error+json', 12, 'RFC 7807은 오류 응답을 표준화하기 위해 application/problem+json Content-Type을 사용하도록 권장한다.'),
                                                                                                                           (555, 'RFC 7807 JSON 응답 예시에서 반드시 포함해야 하는 필드는?', 1, 'medium', 'title', 'instance', 'detail', 'errors', 12, 'title은 문제의 짧고 간단한 설명으로, RFC 7807에서 필수 필드로 정의되어 있다.'),
                                                                                                                           (556, '다음 중 4xx와 5xx 상태 코드 차이에 대한 설명으로 옳지 않은 것은?', 4, 'medium', '4xx는 클라이언트 오류, 5xx는 서버 오류를 나타낸다', '5xx는 재시도 가능성이 4xx보다 높다', '4xx 오류라도 Problem Details 바디를 포함할 수 있다', '4xx는 절대 재시도해서는 안 된다', 12, '일부 4xx 오류(예: 429 Too Many Requests)는 재시도 가능하므로 "절대 재시도 불가"는 잘못된 설명이다.'),
                                                                                                                           (557, '동일 자원 중복 생성 시 서버가 반환해도 멱등성 규칙을 깨지지 않는 상태 코드는?', 1, 'high', '409 Conflict', '201 Created', '202 Accepted', '302 Found', 12, '409 Conflict는 중복된 리소스 생성 요청에 대해 충돌을 알리는 응답이며, 동일 요청을 반복해도 결과가 같아 멱등성을 유지한다.'),
                                                                                                                           (558, 'Problem Details 바디에 커스텀 ‘code’ 정수 필드를 두는 주된 이점은?', 1, 'high', '클라이언트가 로컬라이징 메시지를 매핑하기 쉽다', 'HTTP 상태 코드 전송을 생략할 수 있다', 'JSON 패싱을 건너뛸 수 있다', 'CORS 프리플라이트를 우회한다', 12, '정수형 code를 포함하면 클라이언트 측에서 응답을 빠르게 매핑하거나 번역 메시지와 연결하기가 쉬워진다.'),
                                                                                                                           (559, '다음 중 idempotent 메서드가 아닌 것은?', 1, 'high', 'POST', 'PUT', 'DELETE', 'HEAD', 12, 'POST는 요청이 여러 번 반복되면 리소스가 중복 생성될 수 있으므로 멱등하지 않다.'),
                                                                                                                           (560, '클라이언트가 429 Too Many Requests 응답을 받을 때 재시도 시점을 알기 위해 확인해야 하는 헤더는?', 1, 'high', 'Retry-After', 'Warning', 'WWW-Authenticate', 'Content-Encoding', 12, 'Retry-After 헤더는 클라이언트가 언제 다시 요청할 수 있는지를 알려주는 표준 헤더이다.'),
                                                                                                                           (561, '브라우저 네트워크 오류 vs HTTP 오류 구분 방법은?', 1, 'low', '응답 없음 & error.request 존재 → 네트워크 오류', 'status 0이면 HTTP 오류', 'message에 Network Error 포함 시 HTTP 오류', 'https로 시작시 네트워크 오류 없음', 12, '네트워크 오류는 서버 응답 자체가 없을 때 발생하며, error.request가 존재하되 error.response가 없는 경우로 구분할 수 있다.'),
                                                                                                                           (562, '422 오류 UX 비추천 패턴은?', 1, 'low', '모달 전체 가리고 중앙만 오류', '필드 인라인 표시', '폼 상단 요약', '스낵바 알림', 12, '모달로 전체를 가리는 방식은 사용자에게 필요한 정보 접근을 막아 UX를 저해하므로 지양해야 한다.'),
                                                                                                                           (563, '전역 오류 핸들러 역할은?', 1, 'low', '로그인 만료 등 공통 처리', '레이아웃 교체', 'CSS 초기화', 'History 재설정', 12, '전역 오류 핸들러는 인증 만료, 네트워크 실패 등 전역에서 발생하는 예외를 일관되게 처리하는 역할을 한다.'),
                                                                                                                           (564, '오프라인 GET 요청 전략은?', 1, 'medium', '대기열 저장 후 복구 시 재시도', '캐시 비우고 에러', '503 구성', '무한 로딩', 12, '오프라인 상태에서는 요청을 대기열에 저장했다가 온라인이 되었을 때 재전송하는 전략이 바람직하다.'),
                                                                                                                           (565, 'Error Boundary 해결 문제는?', 1, 'medium', '렌더 예외로 인한 흰 화면', 'API 500 재시도', 'CORS 차단', 'WebSocket', 12, 'Error Boundary는 컴포넌트 렌더링 중 예외로 인해 발생하는 화면 전체 마비(흰 화면)를 방지한다.'),
                                                                                                                           (566, '중복 POST 방지 클라이언트 조치?', 1, 'medium', '이전 요청 취소 AbortController', 'Cache-Control no-store', 'POST→GET', '로그 제거', 12, 'AbortController를 사용해 이전 요청을 명시적으로 취소하면 불필요한 POST 중복 처리를 줄일 수 있다.'),
                                                                                                                           (567, 'axios 취소 vs 네트워크 오류 구분 프로퍼티?', 1, 'high', 'error.code === ''ERR_CANCELED''', 'message 포함 Network', 'status -1', 'timeout 0', 12, 'Axios는 요청 취소 시 error.code 값에 ''ERR_CANCELED''를 할당하여 다른 네트워크 오류와 구분할 수 있게 한다.'),
                                                                                                                           (568, '국제화 오류 메시지 비추천 방법은?', 1, 'high', '서버가 완제품 문구 제공', '클라이언트 코드 매핑', 'title/detail 키 사용', '템플릿 변수 치환', 12, '완성된 문구를 서버에서 직접 제공하면 언어나 플랫폼별 표현 유연성이 떨어지므로 국제화에 부적절하다.'),
                                                                                                                           (569, '모바일 에러/재요청 데이터 최소화 우선 고려는?', 1, 'high', '오프라인 감지 후 백오프', '해상도 다운', '캐시 삭제', 'UDP 강제', 12, '모바일 환경에서는 네트워크 품질을 감지하고 자동 재시도를 제한하는 백오프 전략이 데이터 절약에 효과적이다.'),
                                                                                                                           (570, '사용자 메시지+디버그 정보 구조 권장?', 1, 'high', 'UI 요약 & 콘솔 raw trace', 'alert 모두', '서버 HTML 오류 페이지', '쿠키 저장', 12, '사용자에게는 간결한 메시지를, 개발자에게는 콘솔 로그를 통해 상세한 디버그 정보를 분리 제공하는 것이 바람직하다.'),
                                                                                                                           (571, '멱등 메서드는?', 1, 'low', 'PUT', 'POST', 'PATCH', 'CONNECT', 12, 'PUT은 동일 요청을 여러 번 보내더라도 동일한 결과를 보장하는 멱등성(Idempotent)을 가진다.'),
                                                                                                                           (572, '고정 3초 4번 총 지연?', 1, 'low', '12초', '9초', '6초', '3초', 12, '고정 간격 3초를 4회 수행하면 총 지연 시간은 3초 × 4 = 12초가 된다.'),
                                                                                                                           (573, '지수 1s 배수2 3회 누적?', 1, 'medium', '7 s', '6 s', '5 s', '4 s', 12, '지수 백오프는 1 + 2 + 4 = 7초로 누적되며, 배수 2를 기준으로 증가한다.'),
                                                                                                                           (574, 'Retry-After 120 권장 재시도?', 1, 'medium', '120초 이상 후', '60초', '즉시', '무시', 12, 'Retry-After는 클라이언트가 요청을 재시도할 수 있는 시점을 지정하며, 명시된 시간 이후에만 재요청하는 것이 올바르다.'),
                                                                                                                           (575, 'POST 안전 재시도 보완책?', 1, 'medium', 'Idempotency-Key 헤더', 'HTTP/2 업그레이드', '빈 바디', 'PUT 사용', 12, 'Idempotency-Key를 사용하면 POST 요청을 멱등하게 만들어 중복 요청의 부작용을 방지할 수 있다.'),
                                                                                                                           (576, '재시도 고려 가능한 408/409?', 1, 'medium', '408 Request Timeout', '409 Conflict', '400', '401', 12, '408은 네트워크 지연 등으로 인해 요청이 타임아웃 된 경우로, 재시도를 통해 성공할 가능성이 있다.'),
                                                                                                                           (577, 'Full Jitter 목적은?', 1, 'high', '서버 폭주 완화', '총 지연 줄임', 'TCP 우회', 'TLS 감소', 12, 'Full Jitter는 각 클라이언트의 재시도 타이밍을 무작위화하여 서버에 순간적으로 몰리는 부하를 줄이는 데 목적이 있다.'),
                                                                                                                           (578, '재시도 불가 오류 유형은?', 1, 'high', '400 필드 검증', '502', '408', '429', 12, '400 오류는 클라이언트의 잘못된 입력으로 인해 발생하므로, 같은 요청을 반복해도 실패하며 재시도에 적합하지 않다.'),
                                                                                                                           (579, '조건부 PUT 재시도 안전 이유?', 1, 'high', 'ETag 버전 동일 시만 수행', 'PUT 캐싱', 'HTTP/3 전용', '브라우저 보장', 12, 'ETag와 같은 조건부 헤더를 이용하면 자원이 변경되지 않은 경우에만 갱신되어 멱등성을 유지하면서도 안전한 재시도가 가능하다.'),
                                                                                                                           (580, '모바일 TCP 끊김 POST 문제 감소?', 1, 'high', '짧은 타임아웃 + 멱등 키', 'HTTP 1.0', '재시도 끔', '인증 제거', 12, '모바일 네트워크에서 POST 재전송이 불가피할 경우, 멱등 키와 짧은 타임아웃 설정으로 중복 생성 문제를 완화할 수 있다.'),
                                                                                                                           (581, 'Circuit Closed→Open 조건?', 1, 'low', '연속 실패 임계', '성공 200', '301', '쿠키 만료', 12, 'Circuit Breaker가 연속된 실패를 감지하면 Closed에서 Open으로 전환하여 추가 요청을 차단한다.'),
                                                                                                                           (582, 'Half-Open 성공 전이?', 1, 'low', 'Closed', 'Open', 'Forced-Open', 'Isolated', 12, 'Half-Open 상태에서 요청이 성공적으로 처리되면 Circuit Breaker는 Closed 상태로 복귀한다.'),
                                                                                                                           (583, 'Open 상태 바로 실패 목적?', 1, 'low', '백엔드 부하 차단', '캐시 무효', 'TLS 시간 줄임', 'DNS 재해석', 12, 'Circuit이 Open 상태일 때 바로 실패하게 함으로써 시스템 과부하를 방지하고 백엔드 보호가 가능하다.'),
                                                                                                                           (584, '재시도+CB 충돌 위험?', 1, 'medium', '과도 재시도→즉시 Open', 'Jitter 제거', 'Retry-After 무시', 'HTTP/2 끊김', 12, '재시도를 무분별하게 하면 Circuit Breaker가 빠르게 Open되어 전체 서비스 거부로 이어질 수 있다.'),
                                                                                                                           (585, 'Coalescing 효과 시나리오?', 1, 'medium', '같은 리소스 다수 GET', '다른 POST', 'WebSocket', 'SSE', 12, 'Coalescing은 동일 리소스에 대한 중복 GET 요청을 병합하여 네트워크 효율을 높이는 데 효과적이다.'),
                                                                                                                           (586, 'Equal Jitter 이점 아닌 것?', 2, 'medium', '스파이크 완화', '최대/최소 지연 예측', 'Full Jitter보다 대기 줄임', '서버 완화', 12, 'Equal Jitter는 랜덤성을 줄이기 때문에 최대/최소 지연 시간의 예측은 어려워지는 단점이 있다.'),
                                                                                                                           (587, 'Fallback 전략 사례?', 1, 'high', '캐시된 데이터로 표시', '재시도 0', 'CB 강제 Close', 'Retry-After 무시', 12, 'Fallback 전략은 실패 시에도 사용자에게 유의미한 결과를 제공하는 방식으로, 캐시된 데이터를 사용하는 것이 대표적이다.'),
                                                                                                                           (588, 'Hedged Request 주의점?', 1, 'high', '멱등 보장 필요', 'DNS TTL 0', 'KEEP-ALIVE 끊기', 'TLS 1.3', 12, '동일 요청을 여러 서버에 동시에 보내는 Hedged Request는 중복 수행이 발생하므로 반드시 멱등성을 전제로 해야 한다.'),
                                                                                                                           (589, 'Max-Retry-TTL 목적?', 1, 'high', '무제한 지연 방지', 'TCP FIN 감소', '브라우저 버그 회피', 'Keep-Alive 증가', 12, '최대 재시도 TTL(Time To Live)을 지정하면 재시도가 끝없이 이어지는 문제를 방지할 수 있다.'),
                                                                                                                           (590, 'CB 실시간 튜닝 기법?', 1, 'high', 'Feature Flag 기반 임계 조정', '콘솔 변수', '헤더 하드코드', '빌드 상수', 12, 'Feature Flag를 활용하면 운영 중에도 실시간으로 Circuit Breaker 임계값을 조정할 수 있어 유연한 대응이 가능하다.'),
                                                                                                                           (591, '자주 쓰는 SLO 쌍은?', 1, 'low', '가용성·오류율', 'CPU·메모리', '빌드시간·커버리지', 'PR 리뷰', 12, 'SLO는 주로 사용자 중심 지표인 가용성과 오류율을 함께 사용해 서비스 품질을 정의한다.'),
                                                                                                                           (592, 'P99 증가 의심 원인?', 1, 'low', '소수 요청 재시도 지연', '평균 느려짐', '404 급증', '로깅 오류', 12, 'P99는 가장 느린 1% 요청을 의미하므로 소수의 지연 요청이 큰 영향을 미친다.'),
                                                                                                                           (593, '분산 추적 유용 이유?', 1, 'medium', 'Trace로 재시도 체인 시각화', '헤더 암호화', '로그 제거', '패킷 캡처', 12, '분산 추적은 여러 시스템을 거치는 요청 흐름을 추적해 재시도나 병목을 시각화할 수 있다.'),
                                                                                                                           (594, 'Chaos 테스트 간단 도구?', 1, 'medium', 'MSW random error', 'CSS Lint', 'Bundle Analyzer', 'Lighthouse', 12, 'MSW는 네트워크 요청에 의도적 오류를 삽입할 수 있어 Chaos 테스트에 적합하다.'),
                                                                                                                           (595, '포스트모템 포함 아님?', 1, 'medium', '담당자 인적 정보', '타임라인', 'RCA', '재발 방지', 12, '포스트모템은 문제 해결 중심 문서로 개인 신상정보는 포함하지 않는다.'),
                                                                                                                           (596, '알림 임계 낮음 문제?', 1, 'high', 'Alert Fatigue', 'MTTR 증가', 'Slack→Email', 'Grafana 꺼짐', 12, '알림이 너무 자주 발생하면 사용자 무감각(Alert Fatigue)으로 이어져 중요한 알림도 무시된다.'),
                                                                                                                           (597, '롤아웃 안전 배포 전략?', 1, 'high', 'Feature Flag Gradual', 'Big-bang', 'Force-push', 'CI 캐시 무효', 12, 'Feature Flag를 통한 점진적 배포는 롤백이 쉽고 안정적이다.'),
                                                                                                                           (598, '로그 레벨 매핑?', 1, 'high', '시작 debug, 재시도 info, 실패 error', '모두 warn', '재시도 fatal', '성공 error', 12, '로그는 이벤트 중요도에 따라 debug/info/error 등으로 구분해 기록한다.'),
                                                                                                                           (599, '슬라이딩 윈도우 오류율 이유?', 1, 'high', '즉시값 대신 경향 파악', '메트릭 안 삭제', '테스트 속도', '다크 테마', 12, '슬라이딩 윈도우는 순간 오류보다 시간 흐름에 따른 경향을 파악하는 데 유리하다.'),
                                                                                                                           (600, '오류율 상승 자동 롤백 기능은?', 1, 'high', 'Canary 분석 → rollback', 'Merge Queue', 'multi-stage build', 'npm postinstall', 12, 'Canary 배포는 일부에만 배포 후 오류율 상승 시 자동 롤백을 가능하게 한다.'),
                                                                                                                           (601, 'Vue 템플릿에서 데이터 바인딩을 위한 기본 구문은?', 1, 'low', '{{  }}', '[[  ]]', '{{{  }}}', '(())', 13, 'Vue는 Mustache 구문({{ }})을 사용해 템플릿에서 데이터를 출력한다.'),
                                                                                                                           (602, 'Vue 인스턴스를 생성할 때 가장 먼저 호출되는 라이프사이클 훅은?', 1, 'low', 'beforeCreate', 'created', 'mounted', 'beforeMount', 13, 'beforeCreate 훅은 인스턴스 생성 직후 가장 먼저 실행되는 훅이다.'),
                                                                                                                           (603, '템플릿에서 HTML 특수문자를 이스케이프하지 않고 그대로 출력하려면 사용하는 구문은?', 1, 'low', 'v-html="rawHtml"', '{{ rawHtml }}', 'v-bind:html="rawHtml"', 'v-text="rawHtml"', 13, 'v-html은 HTML 문자열을 그대로 DOM에 삽입하며, 이스케이프 처리를 하지 않는다.'),
                                                                                                                           (604, '다음 중 Vue 템플릿에 JavaScript 표현식을 사용할 수 없는 위치는?', 3, 'medium', 'v-bind 디렉티브 값', 'v-on 디렉티브 핸들러', '속성 이름(attribute key)', '텍스트 보간(interpolation) 안', 13, '속성 이름에는 동적 표현식이 허용되지 않아 자바스크립트 표현식을 사용할 수 없다.'),
                                                                                                                           (605, 'v-bind:class에 객체를 전달할 때, 클래스가 적용되는 조건은?', 1, 'medium', '키에 대응하는 값이 true일 때', '키가 문자열이 아닐 때', '값이 null일 때', '객체 길이가 0일 때', 13, 'v-bind:class에 객체를 전달하면 값이 true인 키만 클래스 이름으로 적용된다.'),
                                                                                                                           (606, 'data 옵션에서 함수가 아닌 객체를 반환하면 발생하는 문제는?', 1, 'medium', '모든 인스턴스가 동일 객체를 공유해 반응성 오류', '템플릿 파싱이 실패하여 빌드 중단', 'watcher가 자동으로 해제됨', 'props 전달이 차단됨', 13, '객체를 공유하면 모든 컴포넌트 인스턴스가 동일 상태를 공유하게 되어 예기치 않은 오류가 발생한다.'),
                                                                                                                           (607, '‘this.message’가 DOM에 반영되는 시점은? (mounted 훅 내부에서 변경)', 1, 'high', 'mounted 훅 직후에 반영된다', 'nextTick 이후 첫 렌더링 때 반영된다', 'updated 훅 이후에만 반영된다', 'DOM에는 절대 반영되지 않는다', 13, 'mounted 훅이 끝난 후 Vue는 데이터 변경 사항을 감지하고 DOM 업데이트를 수행한다.'),
                                                                                                                           (608, '템플릿에서 v-bind 축약형으로 올바른 것은?', 1, 'high', ':title="msg"', '.bind(title)="msg"', '@bind:title="msg"', '#title="msg"', 13, 'v-bind는 축약형으로 : 를 사용하며, 이는 속성 바인딩을 나타낸다.'),
                                                                                                                           (609, 'v-on:click="count++" 구문이 예상대로 동작하려면 count는 어디에 있어야 하는가?', 1, 'high', 'data()가 반환하는 객체', 'methods 안', 'computed 안', 'watch 안', 13, 'count는 data에서 정의된 반응형 속성이어야 변경 시 DOM 반영이 가능하다.'),
                                                                                                                           (610, '다음 중 인스턴스 옵션 중 필수가 아닌 것은?', 1, 'high', 'methods', 'data', 'el / mount 대상', 'template 또는 render', 13, 'methods는 필요할 경우에만 정의되며 필수 옵션은 아니다.'),
                                                                                                                           (611, 'Vue 반응형 시스템의 핵심 개념은?', 1, 'low', '데이터 변경 ↔ DOM 자동 동기화', '가상 DOM을 직접 조작', '양방향 바인딩 없는 단방향 흐름', 'DOM 변화를 수동으로 감지', 13, 'Vue는 데이터가 변경되면 DOM을 자동으로 업데이트하는 반응형 시스템을 제공한다.'),
                                                                                                                           (612, '계산된 속성(computed)의 특징은?', 1, 'low', '의존 데이터가 변할 때만 재평가', '무조건 매 렌더링마다 실행', 'DOM 이벤트 발생 시에만 실행', '블로킹 I/O를 자동 회피', 13, 'computed는 의존성이 바뀔 때만 다시 계산되므로 성능 효율적이다.'),
                                                                                                                           (613, 'Vue 3에서 ref(0)으로 반환되는 값의 내부 형식은?', 1, 'low', '객체 { value: 0 } (Proxied)', 'Proxy 함수', '숫자 0 그 자체', 'WeakMap', 13, 'ref는 value 프로퍼티를 가진 객체 형태로 감싸져 있으며 Proxy를 통해 반응형으로 작동한다.'),
                                                                                                                           (614, 'watch와 computed의 주요 차이점으로 올바른 것은?', 1, 'medium', 'watch는 부수 효과(side-effect) 실행용', 'watch는 캐싱된 결과를 반환', 'computed는 비동기 호출만 지원', 'computed는 의존성 추적을 하지 않음', 13, 'watch는 데이터 변화에 따라 외부 효과(예: API 호출 등)를 수행하는 데 적합하다.'),
                                                                                                                           (615, 'reactive()에 전달해도 반응형이 되지 않는 값은?', 1, 'medium', 'Map 또는 Set', '평범한 Object', '배열(Array)', '중첩 객체가 없는 null-free 리터럴', 13, 'Map과 Set은 Vue의 Proxy 기반 reactive 시스템이 완전하게 추적하지 못하므로 반응형으로 동작하지 않는다.'),
                                                                                                                           (616, 'DOM 갱신 후 실행하려면 다음 코드 뒤에 무엇을 해야 하는가? count.value++;', 1, 'medium', 'await nextTick() 뒤에 console.log 실행', 'flushSync()로 감싼다', 'watchEffect 안에서 실행', 'count.value += 0 으로 강제 트리거', 13, 'nextTick을 사용하면 DOM 갱신이 완료된 다음에 콜백을 실행할 수 있어 안정적이다.'),
                                                                                                                           (617, 'Vue 3 반응형 시스템이 Vue 2의 defineProperty 대신 사용하는 기술은?', 1, 'high', 'ES6 Proxy', 'MutationObserver', 'WeakRef', 'Reflect.metadata', 13, 'Vue 3는 Proxy를 사용해 객체 전체에 대한 반응성을 동적으로 정의할 수 있게 되었다.'),
                                                                                                                           (618, 'shallowReactive()를 사용할 때의 이점은?', 1, 'high', '루트 레벨만 반응형으로 만들어 메모리·성능 절약', '깊은 중첩 객체까지 자동 추적', 'ref와 동일한 API 제공', 'Computed 속성을 자동 생성', 13, 'shallowReactive는 루트 속성만 반응형으로 만들어 불필요한 추적을 줄이고 성능을 향상시킨다.'),
                                                                                                                           (619, 'watch 구성에서 deep:true, immediate:true가 비효율적인 경우는?', 1, 'high', '변경 폭이 큰 대용량 중첩 객체를 감시', '원시형(ref) 값을 감시', 'deep 옵션 false', 'immediate false', 13, '대규모 중첩 객체는 deep:true 설정 시 많은 리소스를 사용하므로 성능 저하를 유발할 수 있다.'),
                                                                                                                           (620, 'watchEffect가 watch보다 적합한 상황은?', 1, 'high', '의존 대상을 명시하기 힘든 복합 반응형 로직', '특정 하나의 ref 변경에만 반응', '비동기 API 호출 후 에러 처리', 'props 유효성 검증', 13, 'watchEffect는 자동으로 의존성을 추적하므로 명확한 대상이 없거나 동적으로 변화하는 반응형 로직에 적합하다.'),
                                                                                                                           (621, '요소를 조건부로 렌더링하기 위한 기본 디렉티브는?', 1, 'low', 'v-if', 'v-for', 'v-bind', 'v-html', 13, 'v-if는 조건이 참일 때만 해당 요소를 DOM에 렌더링하는 기본 조건부 렌더링 디렉티브이다.'),
                                                                                                                           (622, '리스트 렌더링에 사용하는 디렉티브는?', 1, 'low', 'v-for', 'v-show', 'v-model', 'v-once', 13, 'v-for는 배열이나 객체를 기반으로 반복하여 DOM 요소를 렌더링할 때 사용하는 디렉티브이다.'),
                                                                                                                           (623, '양방향 폼 바인딩을 제공하는 디렉티브는?', 1, 'low', 'v-model', 'v-text', 'v-pre', 'v-slot', 13, 'v-model은 입력 요소의 값과 Vue 인스턴스의 데이터를 양방향으로 바인딩해준다.'),
                                                                                                                           (624, 'v-show 디렉티브의 특징으로 올바른 것은?', 1, 'medium', 'DOM을 한 번만 렌더링하고 display 속성을 토글', '조건이 false면 노드를 아예 생성하지 않는다', '렌더 비용이 v-if보다 높다', '서버 사이드 렌더링에서만 사용된다', 13, 'v-show는 DOM을 렌더링한 후 display 속성만 토글하여 렌더링 비용이 적다.'),
                                                                                                                           (625, 'v-bind .camel 수식어 기능은?', 1, 'medium', 'kebab-case 속성명을 camelCase로 변환', '문자열 값을 자동으로 number로 변환', 'HTML을 이스케이프하지 않고 출력', 'true 값을 전달하면 속성을 제거', 13, '.camel 수식어는 HTML 속성 이름을 JavaScript의 camelCase 명명으로 변환해준다.'),
                                                                                                                           (626, 'mounted 훅은 언제 호출되는가?', 1, 'medium', 'DOM 삽입 직후 최초 한 번', 'updated 훅 직후', '컴포넌트 생성 직후', 'beforeUnmount 직전', 13, 'mounted는 컴포넌트가 DOM에 삽입된 후 처음 한 번 호출된다.'),
                                                                                                                           (627, '컴포넌트 제거 직전에 호출되는 훅은?', 1, 'high', 'beforeUnmount', 'unmounted', 'beforeUpdate', 'errorCaptured', 13, 'beforeUnmount는 컴포넌트가 DOM에서 제거되기 직전에 호출되어 정리 작업에 활용된다.'),
                                                                                                                           (628, 'Composition API에서 DOM 삽입 후 실행 훅 등록 함수는?', 1, 'high', 'onMounted', 'onBeforeMount', 'useMounted', 'setupMounted', 13, 'onMounted는 Composition API에서 DOM이 삽입된 후 실행할 로직을 등록하는 훅이다.'),
                                                                                                                           (629, 'v-on .capture 수식어 역할은?', 1, 'high', '이벤트를 캡처 단계에서 처리', '이벤트 버블링 중단', '수신 이벤트를 상위로 전파', '리스너를 한 번만 실행', 13, '.capture는 이벤트 캡처 단계에서 리스너가 실행되도록 설정한다.'),
                                                                                                                           (630, '@keyup.enter 수식어 의미는?', 1, 'high', 'Enter 키가 눌렸을 때만 keyup 핸들러 실행', 'keyup 이벤트 캡처 단계', 'Enter 키 아닌 경우 전파 중단', 'keydown 이벤트 변환', 13, '@keyup.enter는 Enter 키 입력에만 반응하는 이벤트 리스너를 설정한다.'),
                                                                                                                           (631, '부모 → 자식 데이터 전달 메커니즘은?', 1, 'low', 'props', 'slots', 'provide/inject', '$refs', 13, '부모 컴포넌트는 props를 통해 자식에게 데이터를 전달한다.'),
                                                                                                                           (632, '자식이 부모에게 값을 전달할 때 호출하는 메서드는?', 1, 'low', '$emit', '$dispatch', '$broadcast', '$send', 13, '$emit은 자식 컴포넌트가 부모에게 사용자 정의 이벤트를 전달할 때 사용된다.'),
                                                                                                                           (633, '기본(이름 없는) 슬롯 태그는?', 1, 'low', '<slot>', '<slot name="default">', '<template #default>', '<slot-default>', 13, '기본 슬롯은 이름 없이 <slot> 태그만으로 정의할 수 있다.'),
                                                                                                                           (634, 'props 타입 유효성 검사 키는?', 1, 'medium', 'type', 'validator', 'required', 'default', 13, 'type은 props의 타입을 제한하는 옵션이며, 유효성 검사에 사용된다.'),
                                                                                                                           (635, '전역 컴포넌트 등록 API는?', 1, 'medium', 'app.component()', 'Vue.use()', 'defineComponent()', 'createRenderer()', 13, 'app.component()는 전역에서 사용할 수 있도록 컴포넌트를 등록할 때 사용하는 Vue 3 API이다.'),
                                                                                                                           (636, '스코프드 슬롯 템플릿 축약은?', 1, 'medium', '<template #item="slotProps">', '<slot name="item" :slotProps>', '<slot v-bind="item">', '<template v-slot:itemProps>', 13, '#item은 v-slot:item의 축약형으로 slotProps를 전달받아 사용할 수 있다.'),
                                                                                                                           (637, 'prop 값을 직접 변경 시 결과는?', 1, 'high', 'Vue가 경고 출력, 변경은 반응형 아님', '부모 원본 데이터 즉시 변경', '변경 허용되나 반응성 깨짐', '런타임 에러 발생', 13, 'props는 읽기 전용이며 직접 수정 시 Vue는 경고를 출력하고 반응형으로 처리하지 않는다.'),
                                                                                                                           (638, 'Composition API 자식이 v-model 지원하려면 emit 이벤트는?', 1, 'high', 'update:modelValue', 'modelValue', 'input', 'change:model', 13, 'v-model은 기본적으로 modelValue를 사용하며, 이를 업데이트하기 위해서는 update:modelValue 이벤트를 emit해야 한다.'),
                                                                                                                           (639, 'provide/inject 값을 반응형 유지하려면?', 1, 'high', 'reactive() 또는 ref()로 래핑한 값 제공', '원시 값 제공', 'JSON 직렬화', 'watchEffect 반환', 13, 'provide된 값이 반응형이 되려면 ref 또는 reactive로 래핑해 전달해야 한다.'),
                                                                                                                           (640, '슬롯 설명 중 틀린 것은?', 4, 'high', '슬롯 콘텐츠는 부모 범위에서 컴파일', '동일 컴포넌트 슬롯 이름은 유일', 'fallback 콘텐츠는 슬롯 비어 있을 때 표시', '스코프드 슬롯에서 자식→부모 데이터', 13, '스코프드 슬롯은 자식이 부모에게 데이터를 전달하는 방식이 아니라, 자식이 부모로부터 데이터(슬롯 props)를 제공받는 방식이다.'),
                                                                                                                           (641, 'Vue Router 동적 세그먼트 문법은?', 1, 'low', '/users/:id', '/users/{id}', '/users/<id>', '/users/*id', 13, 'Vue Router에서 :id 형식은 동적 세그먼트를 정의할 때 사용된다.'),
                                                                                                                           (642, 'Pinia 스토어 정의 함수는?', 1, 'low', 'defineStore', 'createStore', 'useStore', 'initializeStore', 13, 'Pinia에서 스토어를 정의할 때는 defineStore 함수를 사용한다.'),
                                                                                                                           (643, '라우터 링크 컴포넌트는?', 1, 'low', '<RouterLink>', '<RouterView>', '<LinkTo>', '<RouteLink>', 13, 'RouterLink는 라우터 링크를 렌더링하는 데 사용되는 컴포넌트이다.'),
                                                                                                                           (644, 'setup 내 current route 얻기 방법은?', 1, 'medium', 'const route = useRoute()', 'const route = this.$route', 'import { route } from ''vue-router''', 'const route = getCurrentRoute()', 13, 'setup 함수 안에서는 useRoute 훅을 사용하여 현재 라우트 정보를 가져올 수 있다.'),
                                                                                                                           (645, 'Pinia actions에서 비동기 함수 정의 추가 설정은?', 1, 'medium', '별도 설정 없이 async/await 사용', 'defineAsyncActions 플러그인', 'setupStore 옵션 true', 'store.$enableAsync() 호출', 13, 'Pinia에서는 actions 안에 직접 async 함수를 정의할 수 있으며, 별도의 설정이 필요 없다.'),
                                                                                                                           (646, 'Composition API 의존성 주입 함수 쌍은?', 1, 'medium', 'provide / inject', 'export / import', 'emit / on', 'dispatch / commit', 13, 'provide와 inject는 컴포넌트 간 의존성 주입을 구현하기 위한 Composition API 함수 쌍이다.'),
                                                                                                                           (647, 'history 모드 배포 시 서버 설정 주의?', 1, 'high', '모든 경로를 index.html로 우회', '404 캐싱', 'gzip 사용 금지', 'URL에 .html 확장자', 13, 'history 모드는 서버가 직접 경로를 처리하지 않으므로 모든 경로를 index.html로 우회 처리해야 한다.'),
                                                                                                                           (648, 'storeToRefs() 사용 이유는?', 1, 'high', 'state 속성을 ref로 분해해 반응형 링크 유지', 'actions 자동 바인딩', '스토어 영속화', '게터 비동기 변환', 13, 'storeToRefs는 store의 state 속성을 ref로 변환해 반응형 연결을 유지할 수 있도록 돕는다.'),
                                                                                                                           (649, 'onBeforeRouteLeave 호출 안 되는 경우는?', 1, 'high', '같은 경로, 쿼리만 변경', '다른 컴포넌트 네비게이션', 'router.replace(\'/\')', '브라우저 뒤로 가기', 13, 'onBeforeRouteLeave는 컴포넌트 간 이동 시 호출되므로 경로는 같고 쿼리만 변경되는 경우에는 호출되지 않는다.'),
                                                                                                                           (650, 'SSR에서 클라이언트 전용 코드 안전 실행 방법?', 1, 'high', 'if (typeof window !== \'undefined\') { ... }', 'onServerPrefetch 후 실행', 'await useSSRContext()', 'provide(\'client\', true)', 13, 'SSR 환경에서는 클라이언트 전용 API가 존재하지 않을 수 있으므로 window 객체 여부를 체크하여 안전하게 실행해야 한다.'),
                                                                                                                           (651, 'Vuex는 어떤 목적을 가지고 설계되었는가?', 3, 'low', '라우팅 관리', '컴포넌트 스타일링', '전역 상태 관리', 'API 연동', 14, 'Vuex는 여러 컴포넌트 간에 상태를 중앙에서 일관되게 관리할 수 있도록 설계된 상태 관리 라이브러리이다.'),
                                                                                                                           (652, 'Vuex의 상태는 어디에 저장되는가?', 2, 'low', '컴포넌트', 'store', 'getter', 'plugin', 14, 'Vuex에서 모든 상태는 중앙 store 객체에 저장되며, 애플리케이션 전체에서 공유된다.'),
                                                                                                                           (653, 'Vuex의 주요 네 가지 구성 요소는?', 3, 'low', 'state, view, router, service', 'data, props, methods, computed', 'state, getters, mutations, actions', 'store, plugin, route, controller', 14, 'Vuex는 상태(state), 계산된 상태(getters), 상태 변경(mutations), 비동기 처리(actions)로 구성된다.'),
                                                                                                                           (654, 'Vuex는 어떤 디자인 패턴에서 영감을 받았는가?', 3, 'medium', 'MVC', 'MVVM', 'Flux', 'Observer', 14, 'Vuex는 Facebook의 Flux 아키텍처에서 영향을 받아 단방향 데이터 흐름을 따른다.'),
                                                                                                                           (655, 'Vuex store를 Vue 인스턴스에 주입할 때 사용하는 속성은?', 1, 'medium', 'store', 'data', 'use', 'provide', 14, 'Vue 인스턴스를 생성할 때 store 옵션을 지정하면 전역적으로 상태 관리가 가능하다.'),
                                                                                                                           (656, 'Vuex에서 상태를 변경할 수 있는 유일한 방식은?', 2, 'medium', 'actions', 'mutations', 'getters', 'methods', 14, 'Vuex에서 상태를 변경할 수 있는 유일한 공식 경로는 mutation을 사용하는 것이다.'),
                                                                                                                           (657, 'store를 여러 모듈로 분할할 때 사용하는 속성은?', 1, 'high', 'modules', 'parts', 'reducers', 'groups', 14, 'Vuex는 모듈화를 위해 modules 속성을 사용하여 store를 기능별로 나눌 수 있다.'),
                                                                                                                           (658, 'Vuex는 상태를 어떤 방식으로 관리하는가?', 2, 'high', '계층 구조로 분산 저장', '싱글톤 구조의 중앙 집중 저장', '로컬 컴포넌트 상태 저장', '네임스페이스 기반 저장', 14, 'Vuex는 중앙 집중식(Single Source of Truth) 상태 관리를 지향한다.'),
                                                                                                                           (659, 'Vuex 상태를 컴포넌트에서 사용하기 위한 헬퍼 함수는?', 2, 'high', 'useState', 'mapState', 'getState', 'useStore', 14, 'mapState는 Vuex state를 컴포넌트 computed 속성에 쉽게 바인딩할 수 있는 헬퍼 함수이다.'),
                                                                                                                           (660, 'Vuex store를 생성하는 함수는?', 1, 'high', 'createStore', 'makeStore', 'useStore', 'initStore', 14, 'Vuex 4에서는 createStore 함수를 사용해 스토어를 생성한다.'),
                                                                                                                           (661, 'Vuex에서 state는 어떤 역할을 하는가?', 3, 'low', '상태 읽기 전용 값', '상태를 변경하는 메서드', '애플리케이션의 중앙 상태', '라우터 정보', 14, 'state는 Vuex에서 관리되는 전체 애플리케이션의 상태 데이터를 의미한다.'),
                                                                                                                           (662, 'getters의 주 목적은?', 3, 'low', '상태 변경', '비동기 처리', '계산된 상태 반환', '상태 초기화', 14, 'getters는 state를 기반으로 계산된 값을 반환하는 역할을 한다.'),
                                                                                                                           (663, 'mutations의 특징은?', 3, 'low', '비동기 가능', '상태 변경은 하지 않음', '동기적 상태 변경', '컴포넌트 호출에서만 사용', 14, 'mutations는 항상 동기적으로 동작해야 하며, 상태를 변경하는 유일한 경로다.'),
                                                                                                                           (664, 'getters는 어떤 형식으로 정의되는가?', 1, 'medium', '객체', '배열', '컴포넌트', 'router', 14, 'getters는 함수들을 포함한 객체 형태로 정의되며 각 함수는 state나 다른 getter를 사용할 수 있다.'),
                                                                                                                           (665, 'mutations의 첫 번째 인자는?', 3, 'medium', 'payload', 'getter', 'state', 'commit', 14, 'mutation 함수는 첫 번째 인자로 현재 state를 받으며, 두 번째 인자로 payload를 받을 수 있다.'),
                                                                                                                           (666, 'getters는 어떤 방식으로 호출되는가?', 2, 'medium', 'this.getters()', 'store.getters.name', 'store.call()', 'state.get()', 14, 'getters는 store.getters 객체를 통해 속성처럼 접근하여 사용할 수 있다.'),
                                                                                                                           (667, 'Vue 컴포넌트에서 state를 가져오기 위한 헬퍼 함수는?', 2, 'high', 'useState', 'mapState', 'connect', 'mapMutations', 14, 'mapState는 state 속성을 컴포넌트의 computed 속성과 쉽게 연결해주는 헬퍼 함수이다.'),
                                                                                                                           (668, 'commit() 함수는 무엇을 실행하는가?', 2, 'high', 'state 읽기', 'mutation 실행', 'action 호출', 'router 이동', 14, 'commit은 mutation을 실행하여 상태를 동기적으로 변경한다.'),
                                                                                                                           (669, 'state를 직접 변경하는 것이 권장되지 않는 이유는?', 1, 'high', '반응형이 깨짐', '에러 발생', 'state가 읽기 전용이기 때문', 'state는 컴포넌트 전용이기 때문', 14, 'state를 직접 변경하면 Vue의 반응형 시스템이 변경 사항을 추적하지 못할 수 있어 문제가 발생한다.'),
                                                                                                                           (670, 'getters 내부에서는 무엇을 사용할 수 있는가?', 1, 'high', 'state와 다른 getters', 'mutations 호출', '비동기 로직', 'DOM 접근', 14, 'getters 내부에서는 state와 다른 getters를 조합하여 새로운 계산된 데이터를 반환할 수 있다.'),
                                                                                                                           (671, 'Vuex에서 actions의 주된 목적은?', 2, 'low', '동기 상태 변경', '비동기 작업 처리', '컴포넌트 생성', '라우터 설정', 14, 'actions는 API 요청 등의 비동기 작업을 처리하고 mutation을 통해 상태를 변경한다.'),
                                                                                                                           (672, 'actions 내부에서 상태 변경을 위해 사용하는 함수는?', 2, 'low', 'state()', 'commit()', 'update()', 'mapState()', 14, 'actions 내부에서는 commit을 통해 mutation을 호출하여 상태를 변경한다.'),
                                                                                                                           (673, 'actions는 어떤 값을 반환할 수 있는가?', 3, 'low', 'store', 'state', 'promise', 'component', 14, 'actions는 Promise를 반환할 수 있어, 이후 처리 로직에서 then이나 await를 사용할 수 있다.'),
                                                                                                                           (674, 'actions의 첫 번째 인자는?', 2, 'medium', 'state', 'context', 'rootState', 'dispatch', 14, 'actions 함수는 context 객체를 첫 번째 인자로 받으며, 여기에는 commit, state, getters 등이 포함되어 있다.'),
                                                                                                                           (675, '비동기 요청을 처리한 후 mutation을 호출하려면?', 1, 'medium', 'dispatch → commit', 'commit → dispatch', 'mapState', 'direct setState', 14, '비동기 처리를 actions에서 수행한 뒤 commit을 호출해 mutation을 실행해야 한다.'),
                                                                                                                           (676, 'actions에서 다른 actions를 호출할 때 사용하는 메서드는?', 2, 'medium', 'commit', 'dispatch', 'invoke', 'runAction', 14, 'dispatch는 actions를 호출하는 데 사용되며, 다른 action을 중첩 호출할 때도 사용된다.'),
                                                                                                                           (677, 'actions 내부에서 context.commit을 사용하는 이유는?', 3, 'high', '뷰 업데이트', '상태 직접 접근', 'mutation 실행', 'getter 계산', 14, 'context.commit은 mutation을 호출하여 상태를 변경하기 위해 actions 내부에서 사용된다.'),
                                                                                                                           (678, 'actions에서 API 요청 실패를 처리하는 방법은?', 3, 'high', 'errorHandler()', 'throw new Error()', 'try...catch 블록 사용', 'setError()', 14, 'actions 내에서 발생할 수 있는 비동기 에러는 try...catch 블록을 사용하여 안전하게 처리한다.'),
                                                                                                                           (679, 'actions는 왜 mutation을 직접 호출하지 않고 commit을 사용하는가?', 1, 'high', '기능 분리', '보안상 이유', 'Vue 컴포넌트와 독립성 확보', 'strict 모드 때문', 14, 'actions는 비동기 로직과 mutation 호출을 분리함으로써 코드 가독성과 유지보수성을 높이기 위해 commit을 사용한다.'),
                                                                                                                           (680, 'Vuex에서 actions는 언제 호출되는가?', 3, 'high', '컴포넌트 렌더링 시', 'watcher에 의해', 'dispatch()로 호출될 때', 'router가 변경될 때', 14, 'actions는 컴포넌트나 다른 로직에서 dispatch 함수를 통해 호출될 때 실행된다.'),
                                                                                                                           (681, 'Pinia는 Vue에서 어떤 역할을 하는가?', 2, 'low', '라우팅 처리', '상태 관리', '스타일링 지원', '컴포넌트 등록', 14, 'Pinia는 Vue 애플리케이션에서 상태 관리를 담당하는 라이브러리로, 전역 상태를 효율적으로 관리할 수 있다.'),
                                                                                                                           (682, 'Pinia를 사용하려면 가장 먼저 해야 할 일은?', 3, 'low', 'Vue 설치', 'useStore 호출', 'createPinia 생성', 'setupState 실행', 14, 'Pinia를 사용하기 위해서는 가장 먼저 createPinia를 호출하여 Pinia 인스턴스를 생성해야 한다.'),
                                                                                                                           (683, 'Pinia에서 스토어를 생성하는 함수는?', 1, 'low', 'defineStore', 'createStore', 'makeStore', 'setupStore', 14, 'Pinia에서 스토어를 생성할 때 사용하는 함수는 defineStore이며, 고유 ID와 상태 정의를 통해 스토어를 만든다.'),
                                                                                                                           (684, 'defineStore의 첫 번째 인자는?', 2, 'medium', 'state', 'store 이름', 'actions', 'getter', 14, 'defineStore의 첫 번째 인자는 해당 스토어를 구분하기 위한 고유한 문자열인 store 이름이다.'),
                                                                                                                           (685, 'Pinia에서 상태를 가져올 때 사용하는 방식은?', 3, 'medium', 'this.$store.state', 'useStore().state', 'useStore()', 'getState()', 14, 'useStore()를 호출하면 store 인스턴스를 가져올 수 있으며, 그 안에 상태와 메서드가 포함되어 있다.'),
                                                                                                                           (686, 'Pinia는 어떤 Vue 기능과 잘 통합되는가?', 2, 'medium', 'watchEffect', 'Composition API', 'Option API', 'script setup', 14, 'Pinia는 Vue 3의 Composition API와 밀접하게 통합되어 있어 setup 함수 안에서 자연스럽게 사용할 수 있다.'),
                                                                                                                           (687, 'Pinia에서 정의한 store를 가져오려면?', 2, 'high', 'createStore()', 'useStore()', 'defineStore()', 'getState()', 14, 'useStore()를 통해 defineStore로 정의한 store를 가져와 사용할 수 있다.'),
                                                                                                                           (688, 'Pinia는 Vue 3 이전에도 사용할 수 있는가?', 2, 'high', '가능하다', 'Vue 2는 미지원', 'Vuex 기반', 'React 전용', 14, 'Pinia는 Vue 3 전용 상태 관리 라이브러리로, Vue 2에서는 공식적으로 지원하지 않는다.'),
                                                                                                                           (689, 'Pinia store는 어떻게 구성되는가?', 1, 'high', 'state, actions, getters', 'methods, data, props', 'modules, views', 'only state', 14, 'Pinia의 store는 상태(state), 동작(actions), 계산 속성(getters)으로 구성된다.'),
                                                                                                                           (690, 'Pinia는 Vue의 어떤 API와 함께 사용하는 것이 권장되는가?', 1, 'high', 'setup()', 'created()', 'mounted()', 'methods()', 14, 'Pinia는 Composition API를 사용하는 setup() 함수와 함께 사용하는 것이 가장 자연스럽고 권장된다.'),
                                                                                                                           (691, 'Pinia를 Vue 앱에 적용하려면 어떤 함수로 등록해야 하는가?', 1, 'low', 'app.use(pinia)', 'createPinia(pinia)', 'registerPinia()', 'initPinia()', 14, 'Pinia 인스턴스를 생성한 후 app.use(pinia)를 통해 Vue 애플리케이션에 등록해야 한다.'),
                                                                                                                           (692, 'Pinia에서 반응형 상태를 만들기 위해 사용하는 Vue 기능은?', 2, 'low', 'reactive()', 'ref()', 'computed()', 'watch()', 14, 'Pinia는 내부적으로 ref()를 사용해 반응형 상태를 정의하며, 이는 반응형 추적에 유리하다.'),
                                                                                                                           (693, 'Pinia의 store는 Vue 컴포넌트 내에서 어떻게 사용되는가?', 3, 'low', 'mapStore()', 'this.store', 'useStore()', 'getStore()', 14, '컴포넌트 내에서는 useStore()를 호출해 스토어 인스턴스를 받아 사용한다.'),
                                                                                                                           (694, 'Pinia와 Vue Router를 통합할 때 중요한 설정은?', 3, 'medium', 'routerView()', 'router.push()', 'store 내부에서 router 사용', '라우터와 store 분리', 14, 'store 내부에서 Vue Router 인스턴스를 사용하려면 setup 함수에서 router를 명시적으로 가져와 사용해야 한다.'),
                                                                                                                           (695, 'Pinia에서의 상태 변화는 Vue DevTools에서 추적 가능한가?', 3, 'medium', '아니다', '조건부 지원', '기본적으로 지원된다', '설치 필요', 14, 'Pinia는 Vue DevTools와 완벽히 통합되어 상태 변화를 기본적으로 추적할 수 있다.'),
                                                                                                                           (696, 'Pinia store를 여러 모듈로 나눌 때 사용하는 패턴은?', 2, 'medium', 'modules', 'defineStore 별도 파일 분리', 'Vuex 모듈', 'composition mixin', 14, 'Pinia는 Vuex의 modules 개념 대신 각 defineStore를 별도의 파일로 분리해 모듈화하는 것이 일반적이다.'),
                                                                                                                           (697, 'Pinia store 내부의 상태를 외부에서 반응형으로 가져오기 위해 사용하는 방법은?', 3, 'high', 'computed()', 'store.state', 'storeToRefs()', 'ref()', 14, 'storeToRefs()를 사용하면 store 내부 상태를 반응형으로 구조 분해하여 사용할 수 있다.'),
                                                                                                                           (698, 'Pinia는 어떤 패러다임에 더 잘 맞는가?', 2, 'high', '옵션 기반 API', 'Composition API', 'Class API', 'Template-only', 14, 'Pinia는 Composition API 기반으로 설계되었기 때문에 Composition API 패러다임과 잘 맞는다.'),
                                                                                                                           (699, 'Pinia는 Vue의 어떤 기능과 가장 밀접하게 통합되어 있는가?', 2, 'high', 'Vue Router', 'setup()', 'transition', 'lifecycle hooks', 14, 'Pinia는 setup() 함수와 밀접하게 통합되어 있어서, Composition API 기반의 구성에 최적화되어 있다.'),
                                                                                                                           (700, 'Pinia store를 컴포넌트에서 자동 추적하기 위해 사용하는 함수는?', 3, 'high', 'reactiveStore()', 'toRefs()', 'storeToRefs()', 'trackStore()', 14, 'storeToRefs()를 사용하면 반응형 추적이 자동으로 되며, store의 속성을 toRefs 형태로 변환해준다.'),
                                                                                                                           (701, 'Vue 템플릿에서 데이터 바인딩을 위한 기본 구문은?', 1, 'low', '{{  }}', '[[  ]]', '{{{  }}}', '(())', 15, 'Vue에서는 {{ }} 구문을 사용하여 템플릿에서 데이터 바인딩을 처리한다.'),
                                                                                                                           (702, 'Vue 인스턴스를 생성할 때 가장 먼저 호출되는 라이프사이클 훅은?', 1, 'low', 'beforeCreate', 'created', 'mounted', 'beforeMount', 15, 'beforeCreate는 인스턴스가 생성될 때 가장 먼저 호출되는 라이프사이클 훅이다.'),
                                                                                                                           (703, '템플릿에서 HTML 특수문자를 이스케이프하지 않고 그대로 출력하려면 사용하는 구문은?', 1, 'low', 'v-html="rawHtml"', '{{ rawHtml }}', 'v-bind:html="rawHtml"', 'v-text="rawHtml"', 15, 'v-html은 특수문자나 HTML 태그를 이스케이프하지 않고 그대로 출력한다.'),
                                                                                                                           (704, '다음 중 Vue 템플릿에 JavaScript 표현식을 사용할 수 없는 위치는?', 3, 'medium', 'v-bind 디렉티브 값', 'v-on 디렉티브 핸들러', '속성 이름(attribute key)', '텍스트 보간(interpolation) 안', 15, '속성 이름에는 JavaScript 표현식을 사용할 수 없고, 정적인 문자열만 허용된다.'),
                                                                                                                           (705, 'v-bind:class에 객체를 전달할 때, 클래스가 적용되는 조건은?', 1, 'medium', '키에 대응하는 값이 true일 때', '키가 문자열이 아닐 때', '값이 null일 때', '객체 길이가 0일 때', 15, 'v-bind:class에서 객체의 키는 클래스명이고, 값이 true일 때만 클래스가 적용된다.'),
                                                                                                                           (706, 'data 옵션에서 함수가 아닌 객체를 반환하면 발생하는 문제는?', 1, 'medium', '모든 인스턴스가 동일 객체를 공유해 반응성 오류', '템플릿 파싱이 실패하여 빌드 중단', 'watcher가 자동으로 해제됨', 'props 전달이 차단됨', 15, '객체를 직접 반환하면 모든 인스턴스가 같은 객체를 공유하게 되어 상태 관리에 오류가 생긴다.'),
                                                                                                                           (707, '‘this.message’가 DOM에 반영되는 시점은? (mounted 훅 내부에서 변경)', 1, 'high', 'mounted 훅 직후에 반영된다', 'nextTick 이후 첫 렌더링 때 반영된다', 'updated 훅 이후에만 반영된다', 'DOM에는 절대 반영되지 않는다', 15, 'mounted 훅에서 값을 변경하면 DOM에는 즉시 반영된다.'),
                                                                                                                           (708, '템플릿에서 v-bind 축약형으로 올바른 것은?', 1, 'high', ':title="msg"', '.bind(title)="msg"', '@bind:title="msg"', '#title="msg"', 15, 'v-bind는 : 기호로 축약해서 사용할 수 있으며, :title="msg" 형식이 맞다.'),
                                                                                                                           (709, 'v-on:click="count++" 구문이 예상대로 동작하려면 count는 어디에 있어야 하는가?', 1, 'high', 'data()가 반환하는 객체', 'methods 안', 'computed 안', 'watch 안', 15, '템플릿에서 사용되는 데이터는 data()가 반환하는 객체에 정의되어 있어야 반응형으로 동작한다.'),
                                                                                                                           (710, '다음 중 인스턴스 옵션 중 필수가 아닌 것은?', 1, 'high', 'methods', 'data', 'el / mount 대상', 'template 또는 render', 15, 'methods는 선택적으로 사용할 수 있는 옵션이며 필수는 아니다.'),
                                                                                                                           (711, 'Vue 반응형 시스템의 핵심 개념은?', 1, 'low', '데이터 변경 ↔ DOM 자동 동기화', '가상 DOM을 직접 조작', '양방향 바인딩 없는 단방향 흐름', 'DOM 변화를 수동으로 감지', 15, 'Vue는 데이터 변경 시 DOM이 자동으로 업데이트되는 반응형 시스템을 제공하여 개발자가 DOM 조작 없이 UI를 동기화할 수 있도록 한다.'),
                                                                                                                           (712, '계산된 속성(computed)의 특징은?', 1, 'low', '의존 데이터가 변할 때만 재평가', '무조건 매 렌더링마다 실행', 'DOM 이벤트 발생 시에만 실행', '블로킹 I/O를 자동 회피', 15, 'computed 속성은 의존하는 반응형 데이터가 변경될 때에만 재계산되며, 내부적으로 캐싱이 적용되어 성능을 최적화한다.'),
                                                                                                                           (713, 'Vue 3에서 ref(0)으로 반환되는 값의 내부 형식은?', 1, 'low', '객체 { value: 0 } (Proxied)', 'Proxy 함수', '숫자 0 그 자체', 'WeakMap', 15, 'ref(0)은 내부적으로 { value: 0 } 형식의 객체를 반환하며, Proxy로 감싸져 있어 반응성을 갖는다.'),
                                                                                                                           (714, 'watch와 computed의 주요 차이점으로 올바른 것은?', 1, 'medium', 'watch는 부수 효과(side-effect) 실행용', 'watch는 캐싱된 결과를 반환', 'computed는 비동기 호출만 지원', 'computed는 의존성 추적을 하지 않음', 15, 'watch는 주로 비동기 작업이나 API 호출 등 부수 효과를 감지하고 실행할 때 사용된다.'),
                                                                                                                           (715, 'reactive()에 전달해도 반응형이 되지 않는 값은?', 1, 'medium', 'Map 또는 Set', '평범한 Object', '배열(Array)', '중첩 객체가 없는 null-free 리터럴', 15, 'Map과 Set은 일반적인 reactive()로는 반응형 처리되지 않으며, 별도의 API를 사용해야 한다.'),
                                                                                                                           (716, 'DOM 갱신 후 실행하려면 다음 코드 뒤에 무엇을 해야 하는가? count.value++;', 1, 'medium', 'await nextTick() 뒤에 console.log 실행', 'flushSync()로 감싼다', 'watchEffect 안에서 실행', 'count.value += 0 으로 강제 트리거', 15, 'nextTick()은 DOM이 업데이트된 이후에 콜백을 실행하므로, 변경된 DOM 상태를 확인하거나 조작할 때 사용된다.'),
                                                                                                                           (717, 'Vue 3 반응형 시스템이 Vue 2의 defineProperty 대신 사용하는 기술은?', 1, 'high', 'ES6 Proxy', 'MutationObserver', 'WeakRef', 'Reflect.metadata', 15, 'Vue 3는 defineProperty의 한계를 극복하고 전체 객체 추적이 가능한 ES6 Proxy를 사용하여 반응형 시스템을 구성한다.'),
                                                                                                                           (718, 'shallowReactive()를 사용할 때의 이점은?', 1, 'high', '루트 레벨만 반응형으로 만들어 메모리·성능 절약', '깊은 중첩 객체까지 자동 추적', 'ref와 동일한 API 제공', 'Computed 속성을 자동 생성', 15, 'shallowReactive는 루트 속성만 반응형으로 만들어 깊은 감시를 줄이고 메모리 및 성능을 최적화할 수 있다.'),
                                                                                                                           (719, 'watch 구성에서 deep:true, immediate:true가 비효율적인 경우는?', 1, 'high', '변경 폭이 큰 대용량 중첩 객체를 감시', '원시형(ref) 값을 감시', 'deep 옵션 false', 'immediate false', 15, '대용량 중첩 객체에 대해 deep 감시와 즉시 실행을 함께 사용하면 불필요한 연산이 과도하게 발생할 수 있다.'),
                                                                                                                           (720, 'watchEffect가 watch보다 적합한 상황은?', 1, 'high', '의존 대상을 명시하기 힘든 복합 반응형 로직', '특정 하나의 ref 변경에만 반응', '비동기 API 호출 후 에러 처리', 'props 유효성 검증', 15, 'watchEffect는 의존성을 자동 추적하므로 어떤 값에 의존할지 명확하지 않은 경우에 유용하다.'),
                                                                                                                           (721, '요소를 조건부로 렌더링하기 위한 기본 디렉티브는?', 1, 'low', 'v-if', 'v-for', 'v-bind', 'v-html', 15, 'v-if는 조건에 따라 DOM 요소 자체를 렌더링하거나 제거하여 조건부 렌더링을 구현한다.'),
                                                                                                                           (722, '리스트 렌더링에 사용하는 디렉티브는?', 1, 'low', 'v-for', 'v-show', 'v-model', 'v-once', 15, 'v-for는 배열이나 객체를 기반으로 반복 렌더링을 수행할 수 있게 해주는 디렉티브다.'),
                                                                                                                           (723, '양방향 폼 바인딩을 제공하는 디렉티브는?', 1, 'low', 'v-model', 'v-text', 'v-pre', 'v-slot', 15, 'v-model은 input, select 등의 폼 요소와 데이터를 양방향으로 바인딩할 수 있도록 한다.'),
                                                                                                                           (724, 'v-show 디렉티브의 특징으로 올바른 것은?', 1, 'medium', 'DOM을 한 번만 렌더링하고 display 속성을 토글', '조건이 false면 노드를 아예 생성하지 않는다', '렌더 비용이 v-if보다 높다', '서버 사이드 렌더링에서만 사용된다', 15, 'v-show는 display 속성을 토글하여 요소의 표시 여부만 변경하고, DOM은 그대로 유지한다.'),
                                                                                                                           (725, 'v-bind .camel 수식어 기능은?', 1, 'medium', 'kebab-case 속성명을 camelCase로 변환', '문자열 값을 자동으로 number로 변환', 'HTML을 이스케이프하지 않고 출력', 'true 값을 전달하면 속성을 제거', 15, '.camel 수식어는 HTML 특성의 이름이 camelCase로 변환되어야 할 때 유용하다.'),
                                                                                                                           (726, 'mounted 훅은 언제 호출되는가?', 1, 'medium', 'DOM 삽입 직후 최초 한 번', 'updated 훅 직후', '컴포넌트 생성 직후', 'beforeUnmount 직전', 15, 'mounted는 컴포넌트가 DOM에 삽입된 후 한 번 호출되어 초기 DOM 접근 작업에 사용된다.'),
                                                                                                                           (727, '컴포넌트 제거 직전에 호출되는 훅은?', 1, 'high', 'beforeUnmount', 'unmounted', 'beforeUpdate', 'errorCaptured', 15, 'beforeUnmount는 컴포넌트가 제거되기 직전에 호출되어 정리 작업에 적합하다.'),
                                                                                                                           (728, 'Composition API에서 DOM 삽입 후 실행 훅 등록 함수는?', 1, 'high', 'onMounted', 'onBeforeMount', 'useMounted', 'setupMounted', 15, 'onMounted는 Composition API에서 DOM 삽입 후 로직을 실행하기 위한 훅 등록 함수이다.'),
                                                                                                                           (729, 'v-on .capture 수식어 역할은?', 1, 'high', '이벤트를 캡처 단계에서 처리', '이벤트 버블링 중단', '수신 이벤트를 상위로 전파', '리스너를 한 번만 실행', 15, '.capture는 이벤트 리스너를 캡처 단계에서 실행하게 하여 이벤트 흐름의 앞단에서 처리할 수 있게 한다.'),
                                                                                                                           (730, '@keyup.enter 수식어 의미는?', 1, 'high', 'Enter 키가 눌렸을 때만 keyup 핸들러 실행', 'keyup 이벤트 캡처 단계', 'Enter 키 아닌 경우 전파 중단', 'keydown 이벤트 변환', 15, '@keyup.enter는 keyup 이벤트 중 Enter 키 입력에만 반응하도록 제한한다.'),
                                                                                                                           (731, '부모 → 자식 데이터 전달 메커니즘은?', 1, 'low', 'props', 'slots', 'provide/inject', '$refs', 15, 'props는 부모 컴포넌트가 자식 컴포넌트로 데이터를 전달할 때 사용하는 공식적인 방법이다.'),
                                                                                                                           (732, '자식이 부모에게 값을 전달할 때 호출하는 메서드는?', 1, 'low', '$emit', '$dispatch', '$broadcast', '$send', 15, '$emit은 자식 컴포넌트가 사용자 정의 이벤트를 발생시켜 부모 컴포넌트가 처리할 수 있게 한다.'),
                                                                                                                           (733, '기본(이름 없는) 슬롯 태그는?', 1, 'low', '<slot>', '<slot name="default">', '<template #default>', '<slot-default>', 15, '<slot>은 기본 슬롯을 정의할 때 사용되며, 이름 없는 슬롯을 나타낸다.'),
                                                                                                                           (734, 'props 타입 유효성 검사 키는?', 1, 'medium', 'type', 'validator', 'required', 'default', 15, 'props의 type 속성은 전달된 데이터의 자료형을 유효성 검사할 때 사용된다.'),
                                                                                                                           (735, '전역 컴포넌트 등록 API는?', 1, 'medium', 'app.component()', 'Vue.use()', 'defineComponent()', 'createRenderer()', 15, 'app.component()는 Vue 3에서 전역 컴포넌트를 등록하는 공식 API이다.'),
                                                                                                                           (736, '스코프드 슬롯 템플릿 축약은?', 1, 'medium', '<template #item="slotProps">', '<slot name="item" :slotProps>', '<slot v-bind="item">', '<template v-slot:itemProps>', 15, '#item은 v-slot:item의 축약 문법으로 스코프드 슬롯의 이름과 데이터를 선언하는 방식이다.'),
                                                                                                                           (737, 'prop 값을 직접 변경 시 결과는?', 1, 'high', 'Vue가 경고 출력, 변경은 반응형 아님', '부모 원본 데이터 즉시 변경', '변경 허용되나 반응성 깨짐', '런타임 에러 발생', 15, 'Vue는 props를 읽기 전용으로 다루기 때문에 직접 변경하려고 하면 경고를 출력하며 반응성도 보장되지 않는다.'),
                                                                                                                           (738, 'Composition API 자식이 v-model 지원하려면 emit 이벤트는?', 1, 'high', 'update:modelValue', 'modelValue', 'input', 'change:model', 15, 'v-model은 기본적으로 update:modelValue 이벤트를 통해 값 변경을 부모에 알린다.'),
                                                                                                                           (739, 'provide/inject 값을 반응형 유지하려면?', 1, 'high', 'reactive() 또는 ref()로 래핑한 값 제공', '원시 값 제공', 'JSON 직렬화', 'watchEffect 반환', 15, 'provide에서 제공하는 값을 reactive 또는 ref로 래핑하면 자식에서도 반응형으로 유지할 수 있다.'),
                                                                                                                           (740, '슬롯 설명 중 틀린 것은?', 4, 'high', '슬롯 콘텐츠는 부모 범위에서 컴파일', '동일 컴포넌트 슬롯 이름은 유일', 'fallback 콘텐츠는 슬롯 비어 있을 때 표시', '스코프드 슬롯에서 자식→부모 데이터', 15, '스코프드 슬롯은 자식 컴포넌트가 데이터를 제공하고 부모가 이를 활용하므로, 데이터 흐름은 자식 → 부모가 아니다.'),
                                                                                                                           (741, 'Angular CLI에서 프로덕션용 번들을 생성하려면 어떤 명령을 사용해야 하는가?', 1, 'low', 'ng build --configuration production', 'ng serve --prod', 'ng deploy --prod', 'ng compile --prod', 15, '프로덕션 빌드를 위해 Angular CLI는 "ng build --configuration production" 명령을 사용하며, 최적화 및 압축 설정이 포함된 번들을 생성한다.'),
                                                                                                                           (742, 'Angular의 Ahead-of-Time 컴파일(AOT) 주된 장점은?', 1, 'low', '런타임에 컴파일 오버헤드가 제거되어 초기 로드 속도가 빨라진다', '템플릿 문법 오류를 무시하고 빌드를 계속한다', '의존성 주입을 비활성화해 번들 크기를 줄인다', '개발 서버가 자동 재시작된다', 15, 'AOT는 애플리케이션 빌드 시 컴파일을 수행하여 브라우저에서의 초기 로딩 성능을 향상시킨다.'),
                                                                                                                           (743, 'Angular 16의 기본 렌더러(컴파일러)로 채택된 엔진은?', 1, 'low', 'Ivy', 'View Engine', 'Renderer2', 'Zone.js', 15, 'Angular는 Ivy 컴파일러를 기본으로 사용하여 더욱 최적화된 렌더링과 디버깅 성능을 제공한다.'),
                                                                                                                           (744, 'Jasmine 단위 테스트에서 비동기 호출 완료를 알리기 위해 주입하는 헬퍼는?', 1, 'medium', 'done() 콜백', 'fixture.detectChanges()', 'fakeAsync()', 'flushMicrotasks()', 15, 'done() 콜백은 Jasmine에서 비동기 테스트가 끝났음을 명시적으로 알려주는 함수이다.'),
                                                                                                                           (745, 'Angular PWA 변환을 자동으로 설정해 주는 CLI 스키매틱 명령은?', 1, 'medium', 'ng add @angular/pwa', 'ng generate pwa', 'ng init --pwa', 'ng add service-worker', 15, 'ng add @angular/pwa 명령은 PWA 관련 설정 파일과 종속성을 자동으로 추가해준다.'),
                                                                                                                           (746, '앱을 국제화(i18n) 빌드할 때 locale 별 번들을 만들도록 지정하는 CLI 플래그는?', 1, 'medium', '--localize', '--i18n', '--translate', '--locale-build', 15, '--localize 플래그는 각 언어에 맞는 번들을 생성하여 다국어 지원을 가능하게 한다.'),
                                                                                                                           (747, '앱 전반에 걸쳐 사용되지 않는 코드가 번들에 포함되지 않도록 하는 Webpack/CLI 최적화 기법은?', 1, 'high', 'Tree shaking', 'Code splitting', 'Inlining', 'Polyfilling', 15, 'Tree shaking은 사용되지 않는 코드를 제거하여 번들 크기를 줄이는 최적화 기법이다.'),
                                                                                                                           (748, 'Angular Universal을 사용해 서버 사이드 렌더링(SSR)을 도입하면 얻는 직접적 이점으로 옳은 것은?', 1, 'high', '초기 HTML이 완성되어 SEO와 첫 콘텐츠 페인트(FCP)가 개선된다', '브라우저 번들 크기가 자동으로 50% 감소한다', 'Ivy가 비활성화되어 빌드 속도가 빨라진다', 'RxJS 의존성이 제거된다', 15, 'SSR은 클라이언트 렌더링 전에 HTML을 미리 렌더링하여 SEO 및 초기 로딩 성능을 개선한다.'),
                                                                                                                           (749, 'ng test 명령이 기본적으로 사용하는 테스트 러너는?', 1, 'high', 'Karma', 'Jest', 'Mocha', 'Vitest', 15, 'Angular CLI는 기본적으로 Karma 테스트 러너를 사용하여 유닛 테스트를 실행한다.'),
                                                                                                                           (750, 'Angular CLI 빌드 시 하위 브라우저용 ES5 코드 번들을 자동 생성해 주는 기능은?', 1, 'high', 'Differential loading', 'Lazy chunk preloading', 'Webpack module federation', 'Inline critical CSS', 15, 'Differential loading은 최신 브라우저에는 ES2015, 구형 브라우저에는 ES5 번들을 제공하여 호환성을 유지한다.'),
                                                                                                                           (751, 'NgRx는 어떤 프레임워크를 기반으로 한 상태 관리 라이브러리인가?', 3, 'low', 'React', 'Vue', 'Angular', 'Svelte', 16, 'NgRx는 Angular에 특화된 상태 관리 라이브러리로, Angular의 구조와 깊이 통합되어 동작한다.'),
                                                                                                                           (752, 'NgRx는 어떤 디자인 패턴에서 영감을 받았는가?', 2, 'low', 'MVC', 'Flux', 'MVVM', 'Factory', 16, 'NgRx는 Flux 아키텍처에서 영감을 받아 액션, 리듀서, 스토어의 구조를 따른다.'),
                                                                                                                           (753, 'NgRx에서 상태 관리를 위해 사용하는 핵심 단위는?', 2, 'low', 'Service', 'Store', 'Controller', 'Directive', 16, 'Store는 상태를 보관하고 변경을 통제하는 NgRx의 핵심 구성 요소이다.'),
                                                                                                                           (754, 'NgRx Store는 어떤 역할을 하는가?', 2, 'medium', '컴포넌트 생성', '상태 저장소 역할', '라우팅 제어', 'HTTP 요청', 16, 'Store는 애플리케이션 상태를 중앙에서 관리하고 컴포넌트 간 상태 공유를 가능하게 한다.'),
                                                                                                                           (755, 'NgRx의 구성 요소가 아닌 것은?', 3, 'medium', 'Actions', 'Reducers', 'Pipes', 'Selectors', 16, 'Pipes는 Angular의 기능이며, NgRx의 구성 요소는 아니다.'),
                                                                                                                           (756, 'NgRx에서 사용하는 상태는 어떤 성격을 가지는가?', 1, 'medium', '읽기 전용', '양방향 바인딩', '함수형 구조', '동적 할당', 16, 'NgRx의 상태는 불변성을 유지하며 외부에서 직접 변경되지 않도록 읽기 전용으로 설계되어 있다.'),
                                                                                                                           (757, 'NgRx는 어떤 방식으로 상태 변화를 처리하는가?', 3, 'high', '서비스 직접 호출', '컴포넌트 바인딩', '액션 → 리듀서', 'setState 호출', 16, 'NgRx는 액션을 디스패치하고 리듀서에서 상태를 변경하는 Flux 기반의 구조를 따른다.'),
                                                                                                                           (758, 'NgRx는 Angular의 어떤 기능과 긴밀하게 통합되는가?', 3, 'high', '서비스', '모듈 시스템', 'RxJS', '라우터', 16, 'RxJS는 NgRx의 비동기 및 스트림 기반 처리에 핵심적으로 사용되는 라이브러리이다.'),
                                                                                                                           (759, 'NgRx Store의 주된 이점은?', 2, 'high', '동적 스타일링', '상태 추적 가능', '라우팅 단순화', '컴포넌트 자동 생성', 16, 'NgRx Store는 시간에 따른 상태 변화 추적이 가능하여 디버깅과 테스트에 용이하다.'),
                                                                                                                           (760, 'NgRx는 어떤 언어의 기능을 강하게 활용하는가?', 4, 'high', 'Java', 'Kotlin', 'JavaScript', 'TypeScript', 16, 'NgRx는 Angular와 마찬가지로 TypeScript의 타입 시스템과 함수형 프로그래밍 특징을 적극 활용한다.'),
                                                                                                                           (761, 'NgRx에서 상태를 변경하기 위해 사용하는 함수는?', 1, 'low', 'Reducer', 'Selector', 'Effect', 'Service', 16, 'Reducer 함수는 상태를 업데이트하는 순수 함수로, 액션에 따라 새로운 상태를 반환한다.'),
                                                                                                                           (762, 'Action 객체가 반드시 가져야 하는 속성은?', 3, 'low', 'payload', 'state', 'type', 'reducer', 16, 'type은 액션의 식별자로서 반드시 포함되어야 하며, 리듀서에서 어떤 작업을 수행할지 결정한다.'),
                                                                                                                           (763, 'createAction을 통해 생성된 액션은 어떤 함수인가?', 3, 'low', '컴포넌트 생성 함수', '비동기 호출 함수', '액션 생성자 함수', '리듀서 함수', 16, 'createAction은 특정 type을 가진 액션 객체를 생성하는 팩토리 함수이다.'),
                                                                                                                           (764, 'createReducer의 주된 목적은?', 3, 'medium', 'state 초기화', '비동기 트리거', 'state 업데이트 정의', '라우팅 처리', 16, 'createReducer는 액션에 따라 상태를 어떻게 변화시킬지 정의하는 함수들의 집합이다.'),
                                                                                                                           (765, 'on() 함수는 어떤 경우에 사용되는가?', 2, 'medium', '컴포넌트 마운트 시', '액션 타입에 따라 상태 변경 정의 시', '비동기 호출 시', '라우터 트리거', 16, 'on()은 특정 액션 타입에 대해 상태를 어떻게 변경할지 정의하는 데 사용된다.'),
                                                                                                                           (766, '상태를 변경하지 않고 유지하려면 리듀서 내에서 무엇을 반환해야 하는가?', 3, 'medium', 'null', 'undefined', '기존 상태 그대로', 'empty object', 16, '상태를 변경하지 않을 때는 기존 상태 객체를 그대로 반환함으로써 무변화를 나타낸다.'),
                                                                                                                           (767, 'Action은 일반적으로 어떤 형식으로 정의되는가?', 3, 'high', '클래스', 'JSON', '객체 리터럴', '함수', 16, 'NgRx에서는 Action을 객체 리터럴 형태로 정의하며, type 속성을 필수로 포함한다.'),
                                                                                                                           (768, 'createReducer의 인자로 전달되는 값은?', 1, 'high', '초기 상태와 on() 배열', 'reducer 함수', 'selector 목록', 'effect 핸들러', 16, 'createReducer 함수는 초기 상태와 on() 호출들을 인자로 받아 리듀서 함수를 생성한다.'),
                                                                                                                           (769, 'Reducer 함수에서 상태를 변경할 때 지켜야 할 원칙은?', 2, 'high', '직접 변경', '불변성을 유지하며 새 객체 반환', '기존 상태에 추가', '비동기 변경', 16, 'NgRx는 상태 불변성을 지키는 것이 원칙이며, 기존 상태를 직접 변경하지 않고 새 상태 객체를 반환해야 한다.'),
                                                                                                                           (770, 'Action이 Reducer에 도달하려면 무엇을 통해 전달되는가?', 1, 'high', 'dispatch', 'store.select', 'effect.send', 'module.emit', 16, 'dispatch는 액션을 스토어에 전달하여 리듀서에 의해 상태가 변경되도록 한다.'),
                                                                                                                           (771, 'NgRx에서 Effects의 주된 목적은?', 2, 'low', '뷰 렌더링', '비동기 작업 처리', '라우터 제어', '스토어 생성', 16, 'Effects는 API 호출과 같은 비동기 로직을 처리하고 결과를 액션으로 리턴하는 데 사용된다.'),
                                                                                                                           (772, 'Effects는 어떤 라이브러리를 활용하여 작동하는가?', 1, 'low', 'rxjs', 'lodash', 'zone.js', 'redux', 16, 'Effects는 Observable 스트림을 처리하기 위해 rxjs 라이브러리를 기반으로 동작한다.'),
                                                                                                                           (773, 'createEffect 함수는 어떤 값을 반환하는가?', 2, 'low', '함수', 'Observable', 'Promise', 'Action', 16, 'createEffect는 Observable을 반환하며, 이 스트림은 액션에 따라 처리 로직을 정의한다.'),
                                                                                                                           (774, 'Effects 클래스에서 액션을 주입받는 기본 속성은?', 2, 'medium', 'store', 'actions$', 'dispatch', 'select', 16, 'actions$는 Effect 클래스에서 Observable로 들어오는 액션 스트림이다.'),
                                                                                                                           (775, '다음 중 switchMap을 사용하는 이유는?', 2, 'medium', '동기 처리', '이전 요청 취소 후 새 요청', '순차 실행', '에러 무시', 16, 'switchMap은 이전 요청을 취소하고 새 요청만 처리해 최신 요청만 유지한다.'),
                                                                                                                           (776, 'NgRx Effects는 액션을 어디로 전달하는가?', 2, 'medium', 'Selector', 'Reducer', 'Service', 'Component', 16, 'Effects는 액션을 Reducer로 보내어 상태 변경을 트리거한다.'),
                                                                                                                           (777, 'ofType() 오퍼레이터의 역할은?', 1, 'high', '타입별로 액션 필터링', '에러 처리', 'Observable 생성', '스토어 구독', 16, 'ofType은 특정 액션 타입만 필터링하여 효과 처리 로직을 적용할 수 있게 한다.'),
                                                                                                                           (778, 'Effects 내에서 비동기 작업 후 상태를 변경하려면 무엇을 호출해야 하는가?', 4, 'high', 'select()', 'dispatch()', 'new Action()', '다른 액션 반환', 16, 'Effects는 비동기 작업 후 상태 변경을 위해 새로운 액션을 반환한다.'),
                                                                                                                           (779, 'createEffect를 정의할 때 두 번째 인자의 옵션으로 사용되는 속성은?', 3, 'high', 'type', 'payload', 'dispatch', 'async', 16, 'dispatch 옵션은 해당 Effect가 자동 dispatch할지 여부를 결정한다.'),
                                                                                                                           (780, 'NgRx Effects를 사용하지 않고도 비동기 처리가 가능한가?', 1, 'high', '가능하지만 관리 어려움', '절대 불가능', '기본 제공됨', 'Vue에서만 가능', 16, 'Effects 없이도 비동기 처리가 가능하지만 로직 분리가 안 되어 유지 보수가 어렵다.'),
                                                                                                                           (781, 'NgRx에서 상태를 읽을 때 사용하는 함수는?', 3, 'low', 'dispatch()', 'createEffect()', 'select()', 'provideStore()', 16, 'select()는 Store에서 상태 값을 추출하는 데 사용된다.'),
                                                                                                                           (782, 'Selector의 주요 목적은?', 2, 'low', '상태 변경', '상태 추출 및 계산', '액션 생성', '라우팅 처리', 16, 'Selector는 Store의 특정 상태 조각을 추출하거나 계산된 값을 리턴한다.'),
                                                                                                                           (783, 'createSelector 함수는 어디에 정의되는가?', 2, 'low', '@ngrx/effects', '@ngrx/store', '@ngrx/router', '@angular/common', 16, 'createSelector는 @ngrx/store 패키지에서 제공된다.'),
                                                                                                                           (784, 'Selector의 장점 중 아닌 것은?', 4, 'medium', '재사용 가능', '성능 최적화', '메모이제이션 지원', '자동 상태 변경', 16, 'Selector는 상태를 추출할 뿐 변경은 하지 않으므로 자동 상태 변경 기능은 없다.'),
                                                                                                                           (785, 'Store에서 select()를 사용하려면 무엇이 필요한가?', 2, 'medium', 'action type', 'selector 함수', 'reducer map', 'router config', 16, 'select()는 특정 상태를 구독할 수 있도록 selector 함수를 필요로 한다.'),
                                                                                                                           (786, 'createFeatureSelector는 어떤 용도로 사용되는가?', 3, 'medium', 'feature module 생성', '전체 상태 접근', '특정 슬라이스 접근', '디버깅용', 16, 'createFeatureSelector는 상태 트리에서 특정 feature slice에 접근할 수 있게 한다.'),
                                                                                                                           (787, 'Selector가 상태를 감지할 수 있도록 도와주는 것은?', 2, 'high', 'Reducer', 'Observable', 'Promise', 'Component', 16, 'Selector는 Observable을 통해 상태 변경을 감지하고 반응한다.'),
                                                                                                                           (788, 'Store에서 상태를 구독하려면 어떤 연산자를 사용하는가?', 1, 'high', 'pipe()', 'map()', 'catchError()', 'filter()', 16, 'pipe()는 rxjs 연산자를 연결해 상태 변화를 감지하고 가공할 수 있게 한다.'),
                                                                                                                           (789, 'Selector는 어떤 패턴을 기반으로 동작하는가?', 2, 'high', '비동기 트리거', '구독/발행', '명령형 제어', 'Event bubbling', 16, 'Selector는 Observable 기반의 구독/발행 패턴을 따른다.'),
                                                                                                                           (790, 'Selector 내부에서 다른 Selector를 조합할 수 있는 기능은?', 3, 'high', 'createState()', 'combine()', 'createSelector()', 'onSelect()', 16, 'createSelector는 여러 상태 값을 결합하여 새로운 값을 계산할 수 있다.'),
                                                                                                                           (791, 'NgRx Entity의 주요 목적은?', 2, 'low', '비동기 요청 처리', '데이터 정규화 및 목록 관리', '라우터 상태 관리', '로딩 상태 추적', 16, 'Entity는 목록 데이터를 효율적으로 관리하기 위한 정규화 도구를 제공한다.'),
                                                                                                                           (792, 'NgRx Entity는 어떤 형태의 데이터를 관리하기에 적합한가?', 3, 'low', '단일 객체', '비동기 응답', 'ID 기반 다수 객체', '로컬 변수', 16, 'Entity는 ID 기반으로 여러 항목을 빠르게 조회하고 관리할 수 있게 한다.'),
                                                                                                                           (793, 'Entity Adapter를 생성하는 함수는?', 2, 'low', 'createReducer', 'createEntityAdapter', 'createSelector', 'defineAdapter', 16, 'createEntityAdapter는 Entity 관련 기능을 생성하는 NgRx 유틸리티 함수이다.'),
                                                                                                                           (794, 'Entity State에 포함되지 않는 기본 속성은?', 4, 'medium', 'ids', 'entities', 'selectedEntity', 'adapter', 16, 'adapter는 상태가 아니라 조작을 위한 유틸리티 객체이며 상태에는 포함되지 않는다.'),
                                                                                                                           (795, 'NgRx Entity에서 단일 항목을 가져오는 함수는?', 3, 'medium', 'selectEntity', 'getEntityById', 'selectById', 'findEntity', 16, 'selectById는 Entity 상태에서 특정 ID 항목을 조회하는 데 사용된다.'),
                                                                                                                           (796, 'addOne(), updateOne(), removeOne()은 무엇의 메서드인가?', 3, 'medium', 'NgRx Store', 'Reducer', 'Entity Adapter', 'Selector', 16, 'Entity Adapter는 상태를 업데이트하는 여러 메서드를 제공하며, 그중 addOne 등도 포함된다.'),
                                                                                                                           (797, 'Entity Adapter에서 상태를 초기화할 때 사용하는 함수는?', 3, 'high', 'initializeState', 'setState', 'getInitialState', 'init()', 16, 'getInitialState는 Entity의 초기 상태 객체를 생성하는 데 사용된다.'),
                                                                                                                           (798, 'NgRx Entity는 주로 어떤 성격의 앱에 유용한가?', 2, 'high', '단순 입력', '많은 목록 데이터를 다루는 앱', '정적 웹사이트', '싱글 컴포넌트 앱', 16, 'Entity는 다수의 데이터 항목을 효율적으로 처리하고 정규화할 필요가 있는 앱에서 유용하다.'),
                                                                                                                           (799, 'Entity에서 다수의 항목을 추가하는 함수는?', 1, 'high', 'addMany', 'insertMany', 'pushList', 'mergeEntities', 16, 'addMany는 배열 형태로 다수의 항목을 Entity State에 추가할 수 있게 한다.'),
                                                                                                                           (800, 'Entity Adapter는 어떤 방식으로 상태를 변경하는가?', 2, 'high', 'state 직접 수정', '불변성 유지하며 새 상태 반환', 'setter 호출', '데이터베이스 변경', 16, 'Entity Adapter는 기존 상태를 직접 변경하지 않고 새로운 상태 객체를 반환하여 불변성을 보장한다.'),
                                                                                                                           (801, '클라이언트 잘못된 요청(예: JSON 스키마 위반)에 대한 권장 HTTP 상태 코드는?', 1, 'low', '400 Bad Request', '401 Unauthorized', '500 Internal Server Error', '409 Conflict', 17, '400 Bad Request는 요청 본문 오류, 필수 필드 누락 등 클라이언트 오류를 의미한다.'),
                                                                                                                           (802, '인증 헤더가 누락된 요청에 서버가 반환해야 할 표준 상태 코드는?', 1, 'low', '401 Unauthorized', '403 Forbidden', '412 Precondition Failed', '502 Bad Gateway', 17, '401 Unauthorized는 인증이 필요한 요청에서 자격 증명이 없을 때 반환된다.'),
                                                                                                                           (803, 'REST API에서 존재하지 않는 리소스에 대한 GET 요청 시 적절한 응답 코드는?', 1, 'low', '404 Not Found', '410 Gone', '204 No Content', '422 Unprocessable Entity', 17, '404 Not Found는 클라이언트가 요청한 리소스를 서버가 찾을 수 없음을 나타낸다.'),
                                                                                                                           (804, 'RFC 7807 ‘Problem Details for HTTP APIs’가 권장하는 기본 Content-Type은?', 1, 'medium', 'application/problem+json', 'application/json; problem', 'text/problem', 'application/vnd.error+json', 17, 'application/problem+json은 API 오류 응답을 구조화된 방식으로 표현하기 위한 공식 미디어 타입이다.'),
                                                                                                                           (805, 'RFC 7807 JSON 응답 예시에서 반드시 포함해야 하는 필드는?', 1, 'medium', 'title', 'instance', 'detail', 'errors', 17, 'title은 문제를 요약하는 기본적인 설명 필드로, RFC 7807에서 필수로 지정한다.'),
                                                                                                                           (806, '다음 중 4xx와 5xx 상태 코드 차이에 대한 설명으로 옳지 않은 것은?', 4, 'medium', '4xx는 클라이언트 오류, 5xx는 서버 오류를 나타낸다', '5xx는 재시도 가능성이 4xx보다 높다', '4xx 오류라도 Problem Details 바디를 포함할 수 있다', '4xx는 절대 재시도해서는 안 된다', 17, '4xx 오류는 원인에 따라 재시도할 수 있으므로 "절대"라는 표현은 부적절하다.'),
                                                                                                                           (807, '동일 자원 중복 생성 시 서버가 반환해도 멱등성 규칙을 깨지지 않는 상태 코드는?', 1, 'high', '409 Conflict', '201 Created', '202 Accepted', '302 Found', 17, '409 Conflict는 동일 리소스가 이미 존재할 경우 반환되며 멱등성을 유지한다.'),
                                                                                                                           (808, 'Problem Details 바디에 커스텀 ‘code’ 정수 필드를 두는 주된 이점은?', 1, 'high', '클라이언트가 로컬라이징 메시지를 매핑하기 쉽다', 'HTTP 상태 코드 전송을 생략할 수 있다', 'JSON 패싱을 건너뛸 수 있다', 'CORS 프리플라이트를 우회한다', 17, '커스텀 code는 클라이언트에서 메시지나 처리 로직을 세분화할 수 있게 도와준다.'),
                                                                                                                           (809, '다음 중 idempotent 메서드가 아닌 것은?', 1, 'high', 'POST', 'PUT', 'DELETE', 'HEAD', 17, 'POST는 서버의 상태를 변경하므로 여러 번 호출 시 결과가 달라질 수 있어 idempotent하지 않다.'),
                                                                                                                           (810, '클라이언트가 429 Too Many Requests 응답을 받을 때 재시도 시점을 알기 위해 확인해야 하는 헤더는?', 1, 'high', 'Retry-After', 'Warning', 'WWW-Authenticate', 'Content-Encoding', 17, 'Retry-After는 클라이언트가 재요청을 언제 해야 하는지에 대한 정보를 제공한다.'),
                                                                                                                           (811, '브라우저 네트워크 오류 vs HTTP 오류 구분 방법은?', 1, 'low', '응답 없음 & error.request 존재 → 네트워크 오류', 'status 0이면 HTTP 오류', 'message에 Network Error 포함 시 HTTP 오류', 'https로 시작시 네트워크 오류 없음', 17, 'error.request는 요청이 서버에 도달하지 못했음을 의미하므로 네트워크 오류로 분류할 수 있다.'),
                                                                                                                           (812, '422 오류 UX 비추천 패턴은?', 1, 'low', '모달 전체 가리고 중앙만 오류', '필드 인라인 표시', '폼 상단 요약', '스낵바 알림', 17, '모달 전체를 가리는 방식은 맥락을 잃게 하므로 오류 인지와 수정이 어려워 비추천된다.'),
                                                                                                                           (813, '전역 오류 핸들러 역할은?', 1, 'low', '로그인 만료 등 공통 처리', '레이아웃 교체', 'CSS 초기화', 'History 재설정', 17, '전역 오류 핸들러는 인증 만료, 네트워크 오류 등 반복되는 공통 오류를 일괄 처리하는 데 사용된다.'),
                                                                                                                           (814, '오프라인 GET 요청 전략은?', 1, 'medium', '대기열 저장 후 복구 시 재시도', '캐시 비우고 에러', '503 구성', '무한 로딩', 17, '오프라인일 때 요청을 저장하고, 복구 후 재시도하면 사용자 경험이 향상된다.'),
                                                                                                                           (815, 'Error Boundary 해결 문제는?', 1, 'medium', '렌더 예외로 인한 흰 화면', 'API 500 재시도', 'CORS 차단', 'WebSocket', 17, 'Error Boundary는 React에서 컴포넌트 렌더링 중 예외가 발생했을 때 흰 화면을 방지한다.'),
                                                                                                                           (816, '중복 POST 방지 클라이언트 조치?', 1, 'medium', '이전 요청 취소 AbortController', 'Cache-Control no-store', 'POST→GET', '로그 제거', 17, 'AbortController를 사용하면 사용자의 중복 요청을 취소해 서버 부하를 줄일 수 있다.'),
                                                                                                                           (817, 'axios 취소 vs 네트워크 오류 구분 프로퍼티?', 1, 'high', 'error.code === ''ERR_CANCELED''', 'message 포함 Network', 'status -1', 'timeout 0', 17, 'axios의 취소는 error.code가 "ERR_CANCELED"인 것으로 구분할 수 있다.'),
                                                                                                                           (818, '국제화 오류 메시지 비추천 방법은?', 1, 'high', '서버가 완제품 문구 제공', '클라이언트 코드 매핑', 'title/detail 키 사용', '템플릿 변수 치환', 17, '서버가 완성된 문구를 제공하면 클라이언트 로컬라이징 및 유지보수가 어려워진다.'),
                                                                                                                           (819, '모바일 에러/재요청 데이터 최소화 우선 고려는?', 1, 'high', '오프라인 감지 후 백오프', '해상도 다운', '캐시 삭제', 'UDP 강제', 17, '오프라인 상태를 인지한 뒤 재시도 간격을 조절하면 모바일 데이터 사용량과 서버 부하를 줄일 수 있다.'),
                                                                                                                           (820, '사용자 메시지+디버그 정보 구조 권장?', 1, 'high', 'UI 요약 & 콘솔 raw trace', 'alert 모두', '서버 HTML 오류 페이지', '쿠키 저장', 17, '사용자에겐 요약 메시지를, 개발자에겐 콘솔에서 디버그 정보를 제공하는 것이 바람직하다.'),
                                                                                                                           (821, '멱등 메서드는?', 1, 'low', 'PUT', 'POST', 'PATCH', 'CONNECT', 17, 'PUT은 같은 요청을 여러 번 수행해도 결과가 동일하여 멱등성을 가진다.'),
                                                                                                                           (822, '고정 3초 4번 총 지연?', 1, 'low', '12초', '9초', '6초', '3초', 17, '고정 지연 3초를 4회 반복하면 총 12초가 된다.'),
                                                                                                                           (823, '지수 1s 배수2 3회 누적?', 1, 'medium', '7 s', '6 s', '5 s', '4 s', 17, '지수 백오프 1s, 2s, 4s를 합산하면 총 7초이다.'),
                                                                                                                           (824, 'Retry-After 120 권장 재시도?', 1, 'medium', '120초 이상 후', '60초', '즉시', '무시', 17, 'Retry-After 값은 서버가 지정한 대기 시간으로, 해당 시간 이후 재시도하는 것이 권장된다.'),
                                                                                                                           (825, 'POST 안전 재시도 보완책?', 1, 'medium', 'Idempotency-Key 헤더', 'HTTP/2 업그레이드', '빈 바디', 'PUT 사용', 17, 'Idempotency-Key는 POST 요청을 식별해 중복 수행을 방지하는 방식이다.'),
                                                                                                                           (826, '재시도 고려 가능한 408/409?', 1, 'medium', '408 Request Timeout', '409 Conflict', '400', '401', 17, '408은 요청 시간 초과로 인해 재시도 가능성이 있는 상태 코드이다.'),
                                                                                                                           (827, 'Full Jitter 목적은?', 1, 'high', '서버 폭주 완화', '총 지연 줄임', 'TCP 우회', 'TLS 감소', 17, 'Full Jitter는 재시도 간격을 무작위로 하여 재시도 쏠림 현상을 줄여 서버 폭주를 완화한다.'),
                                                                                                                           (828, '재시도 불가 오류 유형?', 1, 'high', '400 필드 검증', '502', '408', '429', 17, '400은 클라이언트 잘못으로 인한 오류이므로 같은 요청을 재시도해도 실패한다.'),
                                                                                                                           (829, '조건부 PUT 재시도 안전 이유?', 1, 'high', 'ETag 버전 동일 시만 수행', 'PUT 캐싱', 'HTTP/3 전용', '브라우저 보장', 17, 'ETag를 활용하면 서버 리소스가 변하지 않았을 때만 요청이 수행되어 안전한 재시도가 가능하다.'),
                                                                                                                           (830, '모바일 TCP 끊김 POST 문제 감소?', 1, 'high', '짧은 타임아웃 + 멱등 키', 'HTTP 1.0', '재시도 끔', '인증 제거', 17, '짧은 타임아웃과 멱등 키를 조합하면 모바일 네트워크 환경에서 POST 요청의 안전성이 높아진다.'),
                                                                                                                           (831, 'Circuit Closed→Open 조건?', 1, 'low', '연속 실패 임계', '성공 200', '301', '쿠키 만료', 17, 'Circuit Breaker는 연속된 요청 실패가 설정된 임계값을 초과하면 Open 상태로 전환된다.'),
                                                                                                                           (832, 'Half-Open 성공 전이?', 1, 'low', 'Closed', 'Open', 'Forced-Open', 'Isolated', 17, 'Half-Open 상태에서 요청이 성공하면 Circuit은 다시 Closed 상태로 전이된다.'),
                                                                                                                           (833, 'Open 상태 바로 실패 목적?', 1, 'low', '백엔드 부하 차단', '캐시 무효', 'TLS 시간 줄임', 'DNS 재해석', 17, 'Open 상태에서는 백엔드 호출을 막아 서버 자원을 보호하는 목적이 있다.'),
                                                                                                                           (834, '재시도+CB 충돌 위험?', 1, 'medium', '과도 재시도→즉시 Open', 'Jitter 제거', 'Retry-After 무시', 'HTTP/2 끊김', 17, '과도한 재시도가 Circuit Breaker를 강제로 Open 상태로 만들어 가용성에 영향을 줄 수 있다.'),
                                                                                                                           (835, 'Coalescing 효과 시나리오?', 1, 'medium', '같은 리소스 다수 GET', '다른 POST', 'WebSocket', 'SSE', 17, '동일한 GET 요청을 병합(Coalescing)하면 중복 요청을 줄이고 효율적으로 응답을 받을 수 있다.'),
                                                                                                                           (836, 'Equal Jitter 이점 아닌 것?', 2, 'medium', '스파이크 완화', '최대/최소 지연 예측', 'Full Jitter보다 대기 줄임', '서버 완화', 17, 'Equal Jitter는 지연 예측은 어렵기 때문에 "예측 가능성"은 장점이 아니다.'),
                                                                                                                           (837, 'Fallback 전략 사례?', 1, 'high', '캐시된 데이터로 표시', '재시도 0', 'CB 강제 Close', 'Retry-After 무시', 17, 'Fallback 전략은 장애 발생 시 캐시된 데이터 등으로 최소한의 사용자 경험을 보장하는 방법이다.'),
                                                                                                                           (838, 'Hedged Request 주의점?', 1, 'high', '멱등 보장 필요', 'DNS TTL 0', 'KEEP-ALIVE 끊기', 'TLS 1.3', 17, 'Hedged Request는 동일 요청을 병렬로 보내므로 멱등성이 보장되어야 한다.'),
                                                                                                                           (839, 'Max-Retry-TTL 목적?', 1, 'high', '무제한 지연 방지', 'TCP FIN 감소', '브라우저 버그 회피', 'Keep-Alive 증가', 17, '최대 TTL을 설정하면 무한 재시도나 과도한 대기 없이 빠르게 오류를 처리할 수 있다.'),
                                                                                                                           (840, 'CB 실시간 튜닝 기법?', 1, 'high', 'Feature Flag 기반 임계 조정', '콘솔 변수', '헤더 하드코드', '빌드 상수', 17, 'Feature Flag를 사용하면 런타임 중에도 Circuit Breaker의 임계 조건을 유연하게 조정할 수 있다.'),
                                                                                                                           (841, '자주 쓰는 SLO 쌍은?', 1, 'low', '가용성·오류율', 'CPU·메모리', '빌드시간·커버리지', 'PR 리뷰', 17, '서비스 수준 목표(SLO)는 주로 가용성과 오류율을 기준으로 서비스 품질을 평가한다.'),
                                                                                                                           (842, 'P99 증가 의심 원인?', 1, 'low', '소수 요청 재시도 지연', '평균 느려짐', '404 급증', '로깅 오류', 17, 'P99는 전체 요청 중 상위 1%의 응답 시간을 측정하므로 소수 요청의 지연이 큰 영향을 줄 수 있다.'),
                                                                                                                           (843, '분산 추적 유용 이유?', 1, 'medium', 'Trace로 재시도 체인 시각화', '헤더 암호화', '로그 제거', '패킷 캡처', 17, '분산 추적은 요청 흐름을 시각화해 병목과 재시도 체인을 파악하는 데 효과적이다.'),
                                                                                                                           (844, 'Chaos 테스트 간단 도구?', 1, 'medium', 'MSW random error', 'CSS Lint', 'Bundle Analyzer', 'Lighthouse', 17, 'MSW는 네트워크 요청을 모킹하며 오류를 시뮬레이션할 수 있어 chaos 테스트에 적합하다.'),
                                                                                                                           (845, '포스트모템 포함 아님?', 1, 'medium', '담당자 인적 정보', '타임라인', 'RCA', '재발 방지', 17, '포스트모템에는 사고 분석과 개선책이 포함되며, 담당자의 개인정보는 포함하지 않는다.'),
                                                                                                                           (846, '알림 임계 낮음 문제?', 1, 'high', 'Alert Fatigue', 'MTTR 증가', 'Slack→Email', 'Grafana 꺼짐', 17, '알림이 너무 자주 발생하면 무시되기 쉬워 경고 피로(Alert Fatigue)가 발생할 수 있다.'),
                                                                                                                           (847, '롤아웃 안전 배포 전략?', 1, 'high', 'Feature Flag Gradual', 'Big-bang', 'Force-push', 'CI 캐시 무효', 17, 'Feature Flag를 통해 점진적으로 사용자에게 기능을 배포하면 안정적인 롤아웃이 가능하다.'),
                                                                                                                           (848, '로그 레벨 매핑?', 1, 'high', '시작 debug, 재시도 info, 실패 error', '모두 warn', '재시도 fatal', '성공 error', 17, '상황에 따라 로그 레벨을 구분하면 가독성과 디버깅 효율성이 향상된다.'),
                                                                                                                           (849, '슬라이딩 윈도우 오류율 이유?', 1, 'high', '즉시값 대신 경향 파악', '메트릭 안 삭제', '테스트 속도', '다크 테마', 17, '슬라이딩 윈도우는 오류율의 추세를 반영해 순간값보다 안정적인 판단이 가능하다.'),
                                                                                                                           (850, '오류율 상승 자동 롤백 기능은?', 1, 'high', 'Canary 분석 → rollback', 'Merge Queue', 'multi-stage build', 'npm postinstall', 17, 'Canary 배포는 오류율이 높아질 경우 자동으로 롤백하도록 구성할 수 있다.'),
                                                                                                                           (851, '클라이언트 잘못된 요청(예: JSON 스키마 위반)에 대한 권장 HTTP 상태 코드는?', 1, 'low', '400 Bad Request', '401 Unauthorized', '500 Internal Server Error', '409 Conflict', 18, '400은 잘못된 요청 문법이나 유효성 오류를 나타내는 표준 상태 코드이다.'),
                                                                                                                           (852, '인증 헤더가 누락된 요청에 서버가 반환해야 할 표준 상태 코드는?', 1, 'low', '401 Unauthorized', '403 Forbidden', '412 Precondition Failed', '502 Bad Gateway', 18, '401은 인증이 필요한 요청에 자격 증명이 없을 때 반환된다.'),
                                                                                                                           (853, 'REST API에서 존재하지 않는 리소스에 대한 GET 요청 시 적절한 응답 코드는?', 1, 'low', '404 Not Found', '410 Gone', '204 No Content', '422 Unprocessable Entity', 18, '404는 클라이언트가 요청한 리소스가 서버에 존재하지 않을 때 사용하는 상태 코드이다.'),
                                                                                                                           (854, 'RFC 7807 ‘Problem Details for HTTP APIs’가 권장하는 기본 Content-Type은?', 1, 'medium', 'application/problem+json', 'application/json; problem', 'text/problem', 'application/vnd.error+json', 18, 'RFC 7807은 문제 세부사항 전달을 위해 application/problem+json을 권장한다.'),
                                                                                                                           (855, 'RFC 7807 JSON 응답 예시에서 반드시 포함해야 하는 필드는?', 1, 'medium', 'title', 'instance', 'detail', 'errors', 18, 'title은 오류의 요약 정보로, RFC 7807에 따라 필수로 포함되어야 한다.'),
                                                                                                                           (856, '다음 중 4xx와 5xx 상태 코드 차이에 대한 설명으로 옳지 않은 것은?', 4, 'medium', '4xx는 클라이언트 오류, 5xx는 서버 오류를 나타낸다', '5xx는 재시도 가능성이 4xx보다 높다', '4xx 오류라도 Problem Details 바디를 포함할 수 있다', '4xx는 절대 재시도해서는 안 된다', 18, '4xx 중 일부는 재시도할 수 있으므로 "절대"라는 표현은 부적절하다.'),
                                                                                                                           (857, '동일 자원 중복 생성 시 서버가 반환해도 멱등성 규칙을 깨지지 않는 상태 코드는?', 1, 'high', '409 Conflict', '201 Created', '202 Accepted', '302 Found', 18, '409 Conflict는 이미 존재하는 자원에 대한 충돌을 나타내며, 멱등성 위배 없이 반환 가능하다.'),
                                                                                                                           (858, 'Problem Details 바디에 커스텀 ‘code’ 정수 필드를 두는 주된 이점은?', 1, 'high', '클라이언트가 로컬라이징 메시지를 매핑하기 쉽다', 'HTTP 상태 코드 전송을 생략할 수 있다', 'JSON 패싱을 건너뛸 수 있다', 'CORS 프리플라이트를 우회한다', 18, '커스텀 code 필드는 클라이언트가 메시지를 분기 처리하거나 다국어로 매핑하는 데 도움이 된다.'),
                                                                                                                           (859, '다음 중 idempotent 메서드가 아닌 것은?', 1, 'high', 'POST', 'PUT', 'DELETE', 'HEAD', 18, 'POST는 동일 요청을 반복할 경우 결과가 달라질 수 있으므로 멱등성이 없다.'),
                                                                                                                           (860, '클라이언트가 429 Too Many Requests 응답을 받을 때 재시도 시점을 알기 위해 확인해야 하는 헤더는?', 1, 'high', 'Retry-After', 'Warning', 'WWW-Authenticate', 'Content-Encoding', 18, 'Retry-After 헤더는 클라이언트가 언제 다시 요청해야 할지 알려준다.'),
                                                                                                                           (861, '브라우저 네트워크 오류 vs HTTP 오류 구분 방법은?', 1, 'low', '응답 없음 & error.request 존재 → 네트워크 오류', 'status 0이면 HTTP 오류', 'message에 Network Error 포함 시 HTTP 오류', 'https로 시작시 네트워크 오류 없음', 18, 'error.request가 존재하고 응답이 없으면 네트워크 오류로 판단할 수 있다.'),
                                                                                                                           (862, '422 오류 UX 비추천 패턴은?', 1, 'low', '모달 전체 가리고 중앙만 오류', '필드 인라인 표시', '폼 상단 요약', '스낵바 알림', 18, '모달 전체를 가리는 방식은 사용자 피드백 및 수정을 어렵게 만들어 UX에 좋지 않다.'),
                                                                                                                           (863, '전역 오류 핸들러 역할은?', 1, 'low', '로그인 만료 등 공통 처리', '레이아웃 교체', 'CSS 초기화', 'History 재설정', 18, '전역 오류 핸들러는 인증 오류, 네트워크 실패 등 공통 오류를 일괄 처리하기 위해 사용된다.'),
                                                                                                                           (864, '오프라인 GET 요청 전략은?', 1, 'medium', '대기열 저장 후 복구 시 재시도', '캐시 비우고 에러', '503 구성', '무한 로딩', 18, '오프라인 시 요청을 큐에 저장하고 복구 후 재시도하면 사용자 경험을 향상시킬 수 있다.'),
                                                                                                                           (865, 'Error Boundary 해결 문제는?', 1, 'medium', '렌더 예외로 인한 흰 화면', 'API 500 재시도', 'CORS 차단', 'WebSocket', 18, 'Error Boundary는 React 컴포넌트에서 발생한 렌더링 오류로 인한 흰 화면을 방지한다.'),
                                                                                                                           (866, '중복 POST 방지 클라이언트 조치?', 1, 'medium', '이전 요청 취소 AbortController', 'Cache-Control no-store', 'POST→GET', '로그 제거', 18, 'AbortController를 사용하면 중복된 POST 요청을 취소하여 서버의 불필요한 부하를 줄일 수 있다.'),
                                                                                                                           (867, 'axios 취소 vs 네트워크 오류 구분 프로퍼티?', 1, 'high', 'error.code === ''ERR_CANCELED''', 'message 포함 Network', 'status -1', 'timeout 0', 18, 'axios의 요청 취소는 error.code에 "ERR_CANCELED"가 포함되어 명확하게 구분된다.'),
                                                                                                                           (868, '국제화 오류 메시지 비추천 방법은?', 1, 'high', '서버가 완제품 문구 제공', '클라이언트 코드 매핑', 'title/detail 키 사용', '템플릿 변수 치환', 18, '서버가 완제품 메시지를 제공하면 다국어 대응 및 UX 커스터마이징이 어렵다.'),
                                                                                                                           (869, '모바일 에러/재요청 데이터 최소화 우선 고려는?', 1, 'high', '오프라인 감지 후 백오프', '해상도 다운', '캐시 삭제', 'UDP 강제', 18, '모바일 환경에선 네트워크 상태를 감지하고 재시도 간격을 늘려 리소스 낭비를 줄이는 것이 중요하다.'),
                                                                                                                           (870, '사용자 메시지+디버그 정보 구조 권장?', 1, 'high', 'UI 요약 & 콘솔 raw trace', 'alert 모두', '서버 HTML 오류 페이지', '쿠키 저장', 18, '사용자에겐 요약된 메시지를, 개발자에겐 콘솔에서 디버그 정보를 제공하는 것이 이상적이다.'),
                                                                                                                           (871, '멱등 메서드는?', 1, 'low', 'PUT', 'POST', 'PATCH', 'CONNECT', 18, 'PUT 메서드는 같은 요청을 여러 번 수행해도 서버 상태가 동일하게 유지되어 멱등성을 가진다.'),
                                                                                                                           (872, '고정 3초 4번 총 지연?', 1, 'low', '12초', '9초', '6초', '3초', 18, '3초를 4회 반복하면 총 12초의 지연이 발생한다.'),
                                                                                                                           (873, '지수 1s 배수2 3회 누적?', 1, 'medium', '7 s', '6 s', '5 s', '4 s', 18, '1s, 2s, 4s를 더하면 총 7초로 지수 백오프의 누적 시간이다.'),
                                                                                                                           (874, 'Retry-After 120 권장 재시도?', 1, 'medium', '120초 이상 후', '60초', '즉시', '무시', 18, 'Retry-After 값은 서버가 제시한 재시도 시점을 나타내며 해당 시간 이후에 재시도해야 한다.'),
                                                                                                                           (875, 'POST 안전 재시도 보완책?', 1, 'medium', 'Idempotency-Key 헤더', 'HTTP/2 업그레이드', '빈 바디', 'PUT 사용', 18, 'Idempotency-Key를 사용하면 POST 요청의 중복 처리 방지와 안전한 재시도가 가능하다.'),
                                                                                                                           (876, '재시도 고려 가능한 408/409?', 1, 'medium', '408 Request Timeout', '409 Conflict', '400', '401', 18, '408은 네트워크 지연 등의 일시적 문제로 재시도가 가능한 상태 코드이다.'),
                                                                                                                           (877, 'Full Jitter 목적은?', 1, 'high', '서버 폭주 완화', '총 지연 줄임', 'TCP 우회', 'TLS 감소', 18, 'Full Jitter는 랜덤 지연을 통해 동시 재시도를 분산시켜 서버 부하를 줄인다.'),
                                                                                                                           (878, '재시도 불가 오류 유형?', 1, 'high', '400 필드 검증', '502', '408', '429', 18, '400 오류는 클라이언트 요청 자체가 잘못된 경우로 재시도해도 성공하지 않는다.'),
                                                                                                                           (879, '조건부 PUT 재시도 안전 이유?', 1, 'high', 'ETag 버전 동일 시만 수행', 'PUT 캐싱', 'HTTP/3 전용', '브라우저 보장', 18, 'ETag 조건을 검증하면 상태가 바뀌지 않은 경우에만 PUT을 실행하여 안전성을 확보할 수 있다.'),
                                                                                                                           (880, '모바일 TCP 끊김 POST 문제 감소?', 1, 'high', '짧은 타임아웃 + 멱등 키', 'HTTP 1.0', '재시도 끔', '인증 제거', 18, '짧은 타임아웃과 Idempotency-Key 조합은 모바일 환경에서 POST의 재전송 충돌을 줄이는 데 유효하다.'),
                                                                                                                           (881, 'Circuit Closed→Open 조건?', 1, 'low', '연속 실패 임계', '성공 200', '301', '쿠키 만료', 18, 'Circuit Breaker는 연속된 실패가 설정된 임계값을 초과하면 Open 상태로 전환된다.'),
                                                                                                                           (882, 'Half-Open 성공 전이?', 1, 'low', 'Closed', 'Open', 'Forced-Open', 'Isolated', 18, 'Half-Open 상태에서 요청이 성공하면 Closed 상태로 전이되어 정상 동작을 재개한다.'),
                                                                                                                           (883, 'Open 상태 바로 실패 목적?', 1, 'low', '백엔드 부하 차단', '캐시 무효', 'TLS 시간 줄임', 'DNS 재해석', 18, 'Open 상태는 백엔드가 실패 중임을 감지해 요청을 차단하고 부하를 줄이기 위한 상태이다.'),
                                                                                                                           (884, '재시도+CB 충돌 위험?', 1, 'medium', '과도 재시도→즉시 Open', 'Jitter 제거', 'Retry-After 무시', 'HTTP/2 끊김', 18, '재시도가 과도하면 Circuit Breaker가 Open 상태가 되어 전체 실패를 유발할 수 있다.'),
                                                                                                                           (885, 'Coalescing 효과 시나리오?', 1, 'medium', '같은 리소스 다수 GET', '다른 POST', 'WebSocket', 'SSE', 18, '동일 리소스에 대한 다수 GET 요청을 병합하면 성능을 최적화할 수 있다.'),
                                                                                                                           (886, 'Equal Jitter 이점 아닌 것?', 2, 'medium', '스파이크 완화', '최대/최소 지연 예측', 'Full Jitter보다 대기 줄임', '서버 완화', 18, 'Equal Jitter는 랜덤성이 일부 제한되어 있어 지연 시간 예측 가능성이 떨어진다.'),
                                                                                                                           (887, 'Fallback 전략 사례?', 1, 'high', '캐시된 데이터로 표시', '재시도 0', 'CB 강제 Close', 'Retry-After 무시', 18, '장애 시 캐시 데이터를 보여주는 것은 대표적인 Fallback 전략이다.'),
                                                                                                                           (888, 'Hedged Request 주의점?', 1, 'high', '멱등 보장 필요', 'DNS TTL 0', 'KEEP-ALIVE 끊기', 'TLS 1.3', 18, 'Hedged Request는 동일 요청을 여러 서버에 보내므로 멱등성이 보장되어야 한다.'),
                                                                                                                           (889, 'Max-Retry-TTL 목적?', 1, 'high', '무제한 지연 방지', 'TCP FIN 감소', '브라우저 버그 회피', 'Keep-Alive 증가', 18, '최대 재시도 TTL을 설정하면 무한 재시도로 인한 지연이나 시스템 자원 낭비를 막을 수 있다.'),
                                                                                                                           (890, 'CB 실시간 튜닝 기법?', 1, 'high', 'Feature Flag 기반 임계 조정', '콘솔 변수', '헤더 하드코드', '빌드 상수', 18, 'Feature Flag를 이용하면 운영 중에도 Circuit Breaker의 조건을 동적으로 변경할 수 있다.'),
                                                                                                                           (891, '자주 쓰는 SLO 쌍은?', 1, 'low', '가용성·오류율', 'CPU·메모리', '빌드시간·커버리지', 'PR 리뷰', 18, 'SLO는 서비스 품질을 수치로 정의하며, 보통 가용성과 오류율을 함께 사용한다.'),
                                                                                                                           (892, 'P99 증가 의심 원인?', 1, 'low', '소수 요청 재시도 지연', '평균 느려짐', '404 급증', '로깅 오류', 18, 'P99는 느린 상위 1% 요청의 영향을 받으므로 일부 요청의 재시도 지연이 원인이 될 수 있다.'),
                                                                                                                           (893, '분산 추적 유용 이유?', 1, 'medium', 'Trace로 재시도 체인 시각화', '헤더 암호화', '로그 제거', '패킷 캡처', 18, '분산 추적은 요청 흐름과 재시도 패턴을 시각화하여 문제 진단을 용이하게 한다.'),
                                                                                                                           (894, 'Chaos 테스트 간단 도구?', 1, 'medium', 'MSW random error', 'CSS Lint', 'Bundle Analyzer', 'Lighthouse', 18, 'MSW는 네트워크 레벨에서 무작위 오류를 시뮬레이션할 수 있어 Chaos 테스트에 적합하다.'),
                                                                                                                           (895, '포스트모템 포함 아님?', 1, 'medium', '담당자 인적 정보', '타임라인', 'RCA', '재발 방지', 18, '포스트모템에는 사고 원인 분석과 대응책이 포함되며, 인적 정보는 포함되지 않는다.'),
                                                                                                                           (896, '알림 임계 낮음 문제?', 1, 'high', 'Alert Fatigue', 'MTTR 증가', 'Slack→Email', 'Grafana 꺼짐', 18, '경고 임계값이 낮으면 알림이 너무 자주 발생해 무시되기 쉽고 Alert Fatigue가 발생한다.'),
                                                                                                                           (897, '롤아웃 안전 배포 전략?', 1, 'high', 'Feature Flag Gradual', 'Big-bang', 'Force-push', 'CI 캐시 무효', 18, 'Feature Flag를 사용하면 사용자 그룹별로 점진적 배포가 가능해 안전하다.'),
                                                                                                                           (898, '로그 레벨 매핑?', 1, 'high', '시작 debug, 재시도 info, 실패 error', '모두 warn', '재시도 fatal', '성공 error', 18, '로그는 단계별로 구분되어야 하며, debug/info/error 등 상황에 맞는 수준이 적절하다.'),
                                                                                                                           (899, '슬라이딩 윈도우 오류율 이유?', 1, 'high', '즉시값 대신 경향 파악', '메트릭 안 삭제', '테스트 속도', '다크 테마', 18, '슬라이딩 윈도우는 오류율의 순간값보다 전체 경향을 파악하기에 적합하다.'),
                                                                                                                           (900, '오류율 상승 자동 롤백 기능은?', 1, 'high', 'Canary 분석 → rollback', 'Merge Queue', 'multi-stage build', 'npm postinstall', 18, 'Canary 분석을 통해 오류율이 기준치를 넘으면 자동 롤백할 수 있는 기능이 포함된다.'),
                                                                                                                           (901, '클라이언트 잘못된 요청(예: JSON 스키마 위반)에 대한 권장 HTTP 상태 코드는?', 1, 'low', '400 Bad Request', '401 Unauthorized', '500 Internal Server Error', '409 Conflict', 19, '400 Bad Request는 클라이언트 요청이 문법적으로 잘못된 경우에 사용하는 표준 상태 코드로, JSON 스키마 위반과 같은 형식 오류에 적합하다.'),
                                                                                                                           (902, '인증 헤더가 누락된 요청에 서버가 반환해야 할 표준 상태 코드는?', 1, 'low', '401 Unauthorized', '403 Forbidden', '412 Precondition Failed', '502 Bad Gateway', 19, '401 Unauthorized는 인증이 필요한 자원에 대해 인증 자격이 없거나 인증 정보가 없을 때 반환되며, 인증 헤더 누락 상황에 정확히 대응한다.'),
                                                                                                                           (903, 'REST API에서 존재하지 않는 리소스에 대한 GET 요청 시 적절한 응답 코드는?', 1, 'low', '404 Not Found', '410 Gone', '204 No Content', '422 Unprocessable Entity', 19, '404 Not Found는 요청한 리소스를 찾을 수 없을 때 사용되며, 해당 리소스가 존재하지 않을 때의 GET 요청에 대한 표준 응답이다.'),
                                                                                                                           (904, 'RFC 7807 ‘Problem Details for HTTP APIs’가 권장하는 기본 Content-Type은?', 1, 'medium', 'application/problem+json', 'application/json; problem', 'text/problem', 'application/vnd.error+json', 19, 'RFC 7807 명세는 문제 상세 응답에 대해 "application/problem+json"을 기본 Content-Type으로 정의한다.'),
                                                                                                                           (905, 'RFC 7807 JSON 응답 예시에서 반드시 포함해야 하는 필드는?', 1, 'medium', 'title', 'instance', 'detail', 'errors', 19, 'RFC 7807의 필수 필드는 title, type, status로 정의되며, 그중 title은 문제의 짧은 요약으로 반드시 포함되어야 한다.'),
                                                                                                                           (906, '다음 중 4xx와 5xx 상태 코드 차이에 대한 설명으로 옳지 않은 것은?', 4, 'medium', '4xx는 클라이언트 오류, 5xx는 서버 오류를 나타낸다', '5xx는 재시도 가능성이 4xx보다 높다', '4xx 오류라도 Problem Details 바디를 포함할 수 있다', '4xx는 절대 재시도해서는 안 된다', 19, '4xx는 항상 재시도하면 안 되는 것은 아니며, 상황에 따라 클라이언트 조정 후 재시도할 수도 있으므로 "절대"라는 표현이 틀렸다.'),
                                                                                                                           (907, '동일 자원 중복 생성 시 서버가 반환해도 멱등성 규칙을 깨지지 않는 상태 코드는?', 1, 'high', '409 Conflict', '201 Created', '202 Accepted', '302 Found', 19, '409 Conflict는 자원의 중복 생성 충돌에 사용되며, 클라이언트가 동일 요청을 반복해도 상태가 변하지 않으므로 멱등성이 유지된다.'),
                                                                                                                           (908, 'Problem Details 바디에 커스텀 ‘code’ 정수 필드를 두는 주된 이점은?', 1, 'high', '클라이언트가 로컬라이징 메시지를 매핑하기 쉽다', 'HTTP 상태 코드 전송을 생략할 수 있다', 'JSON 패싱을 건너뛸 수 있다', 'CORS 프리플라이트를 우회한다', 19, '정수형 커스텀 code는 클라이언트 측에서 에러 메시지를 로컬라이징하는 데 용이하게 매핑할 수 있도록 도와준다.'),
                                                                                                                           (909, '다음 중 idempotent 메서드가 아닌 것은?', 1, 'high', 'POST', 'PUT', 'DELETE', 'HEAD', 19, 'POST는 서버 상태를 변경할 수 있고, 여러 번 수행할 경우 결과가 달라질 수 있어 멱등하지 않다.'),
                                                                                                                           (910, '클라이언트가 429 Too Many Requests 응답을 받을 때 재시도 시점을 알기 위해 확인해야 하는 헤더는?', 1, 'high', 'Retry-After', 'Warning', 'WWW-Authenticate', 'Content-Encoding', 19, 'Retry-After는 서버가 다시 요청을 수락할 수 있는 시점을 나타내는 헤더로, 429 응답 시 재시기 기준으로 사용된다.'),
                                                                                                                           (911, '브라우저 네트워크 오류 vs HTTP 오류 구분 방법은?', 1, 'low', '응답 없음 & error.request 존재 → 네트워크 오류', 'status 0이면 HTTP 오류', 'message에 Network Error 포함 시 HTTP 오류', 'https로 시작시 네트워크 오류 없음', 19, '응답이 전혀 없고 error.request만 있는 경우는 브라우저가 서버와 연결 자체에 실패한 네트워크 오류 상황을 나타낸다.'),
                                                                                                                           (912, '422 오류 UX 비추천 패턴은?', 1, 'low', '모달 전체 가리고 중앙만 오류', '필드 인라인 표시', '폼 상단 요약', '스낵바 알림', 19, '모달로 화면 전체를 가리는 방식은 사용자 경험을 저해하고 다른 오류 필드 확인을 방해하므로 권장되지 않는다.'),
                                                                                                                           (913, '전역 오류 핸들러 역할은?', 1, 'low', '로그인 만료 등 공통 처리', '레이아웃 교체', 'CSS 초기화', 'History 재설정', 19, '전역 오류 핸들러는 인증 만료, 권한 없음 등 애플리케이션 전반에 걸친 예외 상황을 통일적으로 처리하는 역할을 한다.'),
                                                                                                                           (914, '오프라인 GET 요청 전략은?', 1, 'medium', '대기열 저장 후 복구 시 재시도', '캐시 비우고 에러', '503 구성', '무한 로딩', 19, 'GET 요청을 큐에 저장했다가 온라인 복구 시 재요청하는 방식은 사용자 경험을 보존하면서 요청을 재시도할 수 있는 전략이다.'),
                                                                                                                           (915, 'Error Boundary 해결 문제는?', 1, 'medium', '렌더 예외로 인한 흰 화면', 'API 500 재시도', 'CORS 차단', 'WebSocket', 19, 'React의 Error Boundary는 렌더링 중 발생한 예외를 잡아 전체 애플리케이션이 흰 화면이 되는 것을 방지하는 데 사용된다.'),
                                                                                                                           (916, '중복 POST 방지 클라이언트 조치?', 1, 'medium', '이전 요청 취소 AbortController', 'Cache-Control no-store', 'POST→GET', '로그 제거', 19, 'AbortController를 사용하면 중복 POST 요청을 막기 위해 이전 요청을 명시적으로 취소할 수 있다.'),
                                                                                                                           (917, 'axios 취소 vs 네트워크 오류 구분 프로퍼티?', 1, 'high', 'error.code === ''ERR_CANCELED''', 'message 포함 Network', 'status -1', 'timeout 0', 19, 'Axios에서 요청 취소 시 error.code는 ''ERR_CANCELED''로 설정되므로, 네트워크 오류와 구분 가능하다.'),
                                                                                                                           (918, '국제화 오류 메시지 비추천 방법은?', 1, 'high', '서버가 완제품 문구 제공', '클라이언트 코드 매핑', 'title/detail 키 사용', '템플릿 변수 치환', 19, '서버가 완성된 메시지를 제공하면 다국어 처리가 어렵고 클라이언트의 유연한 로직 설계가 불가능해지므로 바람직하지 않다.'),
                                                                                                                           (919, '모바일 에러/재요청 데이터 최소화 우선 고려는?', 1, 'high', '오프라인 감지 후 백오프', '해상도 다운', '캐시 삭제', 'UDP 강제', 19, '모바일 환경에서는 네트워크 불안정성을 고려해 오프라인 감지 및 지수 백오프 전략이 데이터 낭비를 줄이는 데 효과적이다.'),
                                                                                                                           (920, '사용자 메시지+디버그 정보 구조 권장?', 1, 'high', 'UI 요약 & 콘솔 raw trace', 'alert 모두', '서버 HTML 오류 페이지', '쿠키 저장', 19, '사용자에게는 간결한 메시지를, 개발자에게는 콘솔의 상세 추적 로그를 제공하는 방식이 UX와 디버깅 모두에 효과적이다.'),
                                                                                                                           (921, '멱등 메서드는?', 1, 'low', 'PUT', 'POST', 'PATCH', 'CONNECT', 19, 'PUT은 동일한 요청을 여러 번 보내도 자원의 상태가 동일하게 유지되므로 멱등성을 가진다.'),
                                                                                                                           (922, '고정 3초 4번 총 지연?', 1, 'low', '12초', '9초', '6초', '3초', 19, '3초를 4회 반복하면 총 3×4=12초의 지연이 발생한다.'),
                                                                                                                           (923, '지수 1s 배수2 3회 누적?', 1, 'medium', '7 s', '6 s', '5 s', '4 s', 19, '지수 백오프 1초 시작, 2배씩 3회: 1+2+4=7초 누적된다.'),
                                                                                                                           (924, 'Retry-After 120 권장 재시도?', 1, 'medium', '120초 이상 후', '60초', '즉시', '무시', 19, 'Retry-After가 120이면 120초 이상 기다린 후 재시도하는 것이 서버 과부하 방지에 적절하다.'),
                                                                                                                           (925, 'POST 안전 재시도 보완책?', 1, 'medium', 'Idempotency-Key 헤더', 'HTTP/2 업그레이드', '빈 바디', 'PUT 사용', 19, 'Idempotency-Key는 POST 요청이 중복 실행되지 않도록 식별 키를 서버가 저장함으로써 재시도의 안정성을 확보한다.'),
                                                                                                                           (926, '재시도 고려 가능한 408/409?', 1, 'medium', '408 Request Timeout', '409 Conflict', '400', '401', 19, '408은 클라이언트 타임아웃이므로 네트워크 회복 후 재시도 가능성이 있으며, 409도 자원 충돌 해결 후 재시도 가능하다.'),
                                                                                                                           (927, 'Full Jitter 목적은?', 1, 'high', '서버 폭주 완화', '총 지연 줄임', 'TCP 우회', 'TLS 감소', 19, 'Full Jitter는 클라이언트 재시도 타이밍을 분산시켜 서버 폭주를 완화하고 충돌을 줄인다.'),
                                                                                                                           (928, '재시도 불가 오류 유형?', 1, 'high', '400 필드 검증', '502', '408', '429', 19, '400번대 중 필드 검증 오류는 클라이언트 요청이 잘못된 경우이므로 수정 없이 재시도해도 의미가 없다.'),
                                                                                                                           (929, '조건부 PUT 재시도 안전 이유?', 1, 'high', 'ETag 버전 동일 시만 수행', 'PUT 캐싱', 'HTTP/3 전용', '브라우저 보장', 19, '조건부 PUT은 ETag 값이 일치할 때만 동작하므로 중복 실행 시 자원 손상 없이 안전하게 재시도할 수 있다.'),
                                                                                                                           (930, '모바일 TCP 끊김 POST 문제 감소?', 1, 'high', '짧은 타임아웃 + 멱등 키', 'HTTP 1.0', '재시도 끔', '인증 제거', 19, '짧은 타임아웃과 Idempotency-Key를 병행하면 TCP 단절 후에도 POST 재시도를 안전하게 수행할 수 있다.'),
                                                                                                                           (931, 'Circuit Closed→Open 조건?', 1, 'low', '연속 실패 임계', '성공 200', '301', '쿠키 만료', 19, '서킷 브레이커가 Closed에서 Open으로 전환되기 위해서는 연속된 실패가 임계치를 초과해야 하며, 이는 시스템 보호를 위한 조건이다.'),
                                                                                                                           (932, 'Half-Open 성공 전이?', 1, 'low', 'Closed', 'Open', 'Forced-Open', 'Isolated', 19, 'Half-Open 상태에서 일정 수의 요청이 성공하면 정상화로 판단되어 다시 Closed 상태로 전이된다.'),
                                                                                                                           (933, 'Open 상태 바로 실패 목적?', 1, 'low', '백엔드 부하 차단', '캐시 무효', 'TLS 시간 줄임', 'DNS 재해석', 19, 'Open 상태는 백엔드가 과부하되었음을 의미하므로 요청을 즉시 실패시켜 부하를 차단하는 것이 목적이다.'),
                                                                                                                           (934, '재시도+CB 충돌 위험?', 1, 'medium', '과도 재시도→즉시 Open', 'Jitter 제거', 'Retry-After 무시', 'HTTP/2 끊김', 19, '재시도 로직이 서킷 브레이커 실패 조건을 빠르게 충족시켜 Open 상태를 유발할 수 있어 충돌 위험이 있다.'),
                                                                                                                           (935, 'Coalescing 효과 시나리오?', 1, 'medium', '같은 리소스 다수 GET', '다른 POST', 'WebSocket', 'SSE', 19, '같은 자원에 대한 GET 요청은 하나로 합쳐 처리할 수 있어 네트워크 효율 향상과 서버 부하 감소에 기여한다.'),
                                                                                                                           (936, 'Equal Jitter 이점 아닌 것?', 2, 'medium', '스파이크 완화', '최대/최소 지연 예측', 'Full Jitter보다 대기 줄임', '서버 완화', 19, 'Equal Jitter는 랜덤성을 완화하지만 지연 예측을 가능하게 하지는 않으므로 해당 이점은 아니다.'),
                                                                                                                           (937, 'Fallback 전략 사례?', 1, 'high', '캐시된 데이터로 표시', '재시도 0', 'CB 강제 Close', 'Retry-After 무시', 19, '서비스 실패 시 캐시된 데이터를 대신 보여주는 것은 일반적인 Fallback 전략의 예시이다.'),
                                                                                                                           (938, 'Hedged Request 주의점?', 1, 'high', '멱등 보장 필요', 'DNS TTL 0', 'KEEP-ALIVE 끊기', 'TLS 1.3', 19, 'Hedged Request는 동일 요청을 여러 서버에 보내기 때문에 결과 충돌 방지를 위해 멱등성이 보장되어야 한다.'),
                                                                                                                           (939, 'Max-Retry-TTL 목적?', 1, 'high', '무제한 지연 방지', 'TCP FIN 감소', '브라우저 버그 회피', 'Keep-Alive 증가', 19, 'Max-Retry-TTL은 재시도 총 지연 시간의 상한을 제한해 시스템 응답성과 안정성을 확보하는 데 사용된다.'),
                                                                                                                           (940, 'CB 실시간 튜닝 기법?', 1, 'high', 'Feature Flag 기반 임계 조정', '콘솔 변수', '헤더 하드코드', '빌드 상수', 19, 'Feature Flag를 이용하면 코드 수정 없이 운영 중에 서킷 브레이커 임계값을 유연하게 조정할 수 있다.'),
                                                                                                                           (941, '자주 쓰는 SLO 쌍은?', 1, 'low', '가용성·오류율', 'CPU·메모리', '빌드시간·커버리지', 'PR 리뷰', 19, '서비스 신뢰도를 평가할 때는 주로 가용성과 오류율을 기준으로 SLO를 정의한다.'),
                                                                                                                           (942, 'P99 증가 의심 원인?', 1, 'low', '소수 요청 재시도 지연', '평균 느려짐', '404 급증', '로깅 오류', 19, 'P99는 상위 1% 지연을 의미하며, 일부 재시도로 인해 지연된 요청들이 포함될 경우 값이 증가할 수 있다.'),
                                                                                                                           (943, '분산 추적 유용 이유?', 1, 'medium', 'Trace로 재시도 체인 시각화', '헤더 암호화', '로그 제거', '패킷 캡처', 19, '분산 추적은 여러 서비스 호출 간 재시도 및 병목 구간을 시각적으로 파악할 수 있게 해준다.'),
                                                                                                                           (944, 'Chaos 테스트 간단 도구?', 1, 'medium', 'MSW random error', 'CSS Lint', 'Bundle Analyzer', 'Lighthouse', 19, 'MSW를 활용하면 네트워크 요청에 대해 무작위 오류를 삽입해 간단한 Chaos 테스트 시뮬레이션이 가능하다.'),
                                                                                                                           (945, '포스트모템 포함 아님?', 1, 'medium', '담당자 인적 정보', '타임라인', 'RCA', '재발 방지', 19, '포스트모템은 사건 분석 문서로, 담당자 개인정보는 포함하지 않는 것이 원칙이다.'),
                                                                                                                           (946, '알림 임계 낮음 문제?', 1, 'high', 'Alert Fatigue', 'MTTR 증가', 'Slack→Email', 'Grafana 꺼짐', 19, '임계값이 너무 낮으면 빈번한 알림으로 인해 알림 피로도가 증가하여 진짜 문제를 놓칠 수 있다.'),
                                                                                                                           (947, '롤아웃 안전 배포 전략?', 1, 'high', 'Feature Flag Gradual', 'Big-bang', 'Force-push', 'CI 캐시 무효', 19, 'Feature Flag Gradual은 점진적으로 사용자에게 기능을 노출시켜 이슈 발생 시 빠른 차단이 가능하다.'),
                                                                                                                           (948, '로그 레벨 매핑?', 1, 'high', '시작 debug, 재시도 info, 실패 error', '모두 warn', '재시도 fatal', '성공 error', 19, '로그 레벨은 상황에 맞게 구분해 활용해야 하며, 시작은 debug, 재시도는 info, 실패는 error가 적절한 매핑이다.'),
                                                                                                                           (949, '슬라이딩 윈도우 오류율 이유?', 1, 'high', '즉시값 대신 경향 파악', '메트릭 안 삭제', '테스트 속도', '다크 테마', 19, '슬라이딩 윈도우는 오류율의 변화 추이를 반영해 일시적 오류보다는 경향성을 판단하는 데 유리하다.'),
                                                                                                                           (950, '오류율 상승 자동 롤백 기능은?', 1, 'high', 'Canary 분석 → rollback', 'Merge Queue', 'multi-stage build', 'npm postinstall', 19, '카나리 배포는 일정 비율 사용자에게만 새 버전을 배포해 오류율이 높을 경우 자동으로 롤백할 수 있도록 설계된다.'),
                                                                                                                           (951, '모든 요소에 스타일을 적용하려면 어떤 CSS 선택자를 사용해야 하는가?', 1, 'low', '*', '.', '#', '%', 20, '* 선택자는 전체 문서의 모든 요소에 스타일을 적용할 때 사용된다.'),
                                                                                                                           (952, '클래스 선택자를 선언할 때 사용하는 접두사는?', 1, 'low', '.', '#', '@', '&', 20, 'CSS에서 클래스 선택자는 마침표(.)를 접두사로 사용하여 지정한다.'),
                                                                                                                           (953, 'p 요소의 직접 자식 span만 선택하려면 올바른 선택자는?', 1, 'low', 'p > span', 'p span', 'p + span', 'p ~ span', 20, '‘p > span’ 선택자는 p 요소의 바로 아래 자식인 span만 선택하며, 정확한 구조 지정이 가능하다.'),
                                                                                                                           (954, 'id 선택자를 선언할 때 사용하는 접두사는?', 2, 'low', '.', '#', '$', '!', 20, 'id 선택자는 해시 기호(#)를 접두사로 사용하여 특정 id를 가진 요소를 지정한다.'),
                                                                                                                           (955, '다음 중 href 속성이 ''https://''로 시작하는 a 요소를 선택하는 올바른 방법은?', 1, 'medium', 'a[href^="https://"]', 'a[href$="https://"]', 'a[href*="https://"]', 'a[href]', 20, '[^="https://"]는 속성값이 해당 문자열로 시작하는 요소를 선택하므로 정확한 선택자가 된다.'),
                                                                                                                           (956, '속성 선택자 중 ''title'' 속성이 존재하는 모든 요소를 선택하는 선택자는?', 1, 'medium', '[title]', '[title*='''']', 'title', ':has(title)', 20, '[title]은 title 속성이 존재하는 모든 요소를 선택하는 기본적인 속성 선택자이다.'),
                                                                                                                           (957, '클래스 ''active''와 ''highlight''를 모두 가진 요소를 선택하려면?', 1, 'medium', '.active.highlight', '#active.highlight', '.active .highlight', '.active, .highlight', 20, '.active.highlight는 두 클래스 모두를 동시에 가진 요소를 선택할 수 있는 정확한 선택자이다.'),
                                                                                                                           (958, 'CSS에서 우선순위가 가장 높은 선택자는?', 3, 'medium', '태그 선택자', '클래스 선택자', 'id 선택자', '전체 선택자', 20, 'id 선택자는 고유성을 갖기 때문에 다른 선택자보다 우선순위가 높다.'),
                                                                                                                           (959, '다음 중 선택자 우선순위가 가장 높은 조합은?', 2, 'high', '.box #id', '#id .box', 'div.box', '* #id', 20, '#id .box는 id 선택자가 포함되어 있어 가장 높은 우선순위를 가진다.'),
                                                                                                                           (960, '우선순위를 임의로 높이고 싶을 때 사용하는 키워드는?', 2, 'high', 'important!', '!important', '#priority', '.force', 20, '!important는 어떤 선택자보다도 스타일 적용 우선순위를 가장 높게 만든다.'),
                                                                                                                           (961, '박스 모델에서 콘텐츠(content) 영역의 바깥쪽에 위치하는 두 영역은?', 2, 'low', 'margin, padding', 'border, margin', 'padding, border', 'margin, content', 20, '박스 모델에서 콘텐츠 바깥에는 padding과 border가 위치하며, 그 밖에 margin이 위치한다. padding과 border가 콘텐츠 외부에 바로 붙어 있다.'),
                                                                                                                           (962, '박스 모델에서 요소의 가장 바깥쪽 여백을 나타내는 것은?', 3, 'low', 'padding', 'border', 'margin', 'spacing', 20, 'margin은 요소의 가장 바깥쪽에 위치하여 외부 요소와의 간격을 정의한다.'),
                                                                                                                           (963, '콘텐츠 영역과 테두리(border) 사이의 공간은 무엇인가?', 2, 'low', 'margin', 'padding', 'spacing', 'outline', 20, 'padding은 콘텐츠와 테두리 사이의 내부 여백으로, 요소 내부 공간을 조정한다.'),
                                                                                                                           (964, '다음 중 블록 요소(block element)의 기본 특성이 아닌 것은?', 3, 'low', '가로 전체를 차지한다', '줄바꿈이 자동으로 된다', '한 줄에 여러 개 나란히 배치된다', '높이와 너비를 지정할 수 있다', 20, '블록 요소는 기본적으로 줄바꿈이 발생하며 가로를 채우지만, 한 줄에 여러 개 배치되는 특성은 인라인 요소의 특성이다.'),
                                                                                                                           (965, '`display: inline-block`의 특징은?', 3, 'medium', '블록 요소처럼 줄바꿈이 발생한다', '인라인 요소처럼 너비 지정이 불가능하다', '인라인처럼 나란히 배치되고, 블록처럼 사이즈 지정 가능하다', '요소가 사라진다', 20, '`inline-block`은 인라인처럼 나란히 배치되지만 width, height를 지정할 수 있는 블록 성질도 가진다.'),
                                                                                                                           (966, '`position: absolute`인 요소는 기본적으로 어디를 기준으로 배치되는가?', 2, 'medium', '자신의 부모 요소', '가장 가까운 static이 아닌 조상 요소', '브라우저 뷰포트', '자기 자신', 20, '`absolute`는 가장 가까운 position이 static이 아닌 조상 요소를 기준으로 위치가 결정된다.'),
                                                                                                                           (967, '박스 모델에서 `box-sizing: border-box`는 어떤 동작을 하는가?', 3, 'medium', 'margin을 포함해 총 너비를 계산', 'content만 너비로 계산', 'border와 padding을 포함해 총 너비를 계산', '아무 효과 없음', 20, '`border-box`를 사용하면 padding과 border가 width에 포함되어 요소 전체 크기를 쉽게 예측할 수 있다.'),
                                                                                                                           (968, '요소가 float될 경우, 해당 요소 이후 콘텐츠의 레이아웃이 흐트러지는 것을 방지하려면 어떤 속성을 사용해야 하는가?', 3, 'medium', 'overflow: hidden', 'z-index', 'clear', 'display: block', 20, '`clear` 속성은 float된 요소 다음에 위치한 요소가 제대로 흐름을 이어가도록 해준다.'),
                                                                                                                           (969, '`position: fixed`와 `absolute`의 차이점은?', 2, 'high', 'fixed는 부모 기준이고 absolute는 브라우저 기준이다', 'fixed는 뷰포트 기준이고 absolute는 조상 요소 기준이다', '둘 다 브라우저 기준이다', 'absolute는 항상 화면 중앙에 표시된다', 20, '`fixed`는 브라우저 뷰포트를 기준으로 위치가 고정되며, `absolute`는 조상 요소 기준으로 배치된다.'),
                                                                                                                           (970, 'z-index의 숫자가 클수록 어떻게 되는가?', 2, 'high', '더 뒤로 이동한다', '더 앞으로 표시된다', '반응형이 된다', '고정 위치가 된다', 20, '`z-index` 값이 클수록 위쪽 레이어에 위치하여 화면 상에서 앞에 표시된다.'),
                                                                                                                           (971, '`display: flex`를 설정하면 기본적으로 어떤 방향으로 아이템이 정렬되는가?', 2, 'low', '세로 방향(column)', '가로 방향(row)', '중앙 정렬', '우측 정렬', 20, 'Flex의 기본 주축 방향은 가로(row)이므로 아이템은 좌에서 우로 나열된다.'),
                                                                                                                           (972, 'Flexbox에서 주축(main axis)을 설정하는 속성은?', 4, 'low', 'flex-wrap', 'align-items', 'justify-content', 'flex-direction', 20, '`flex-direction`은 주축의 방향을 결정하며 row, column 등을 설정한다.'),
                                                                                                                           (973, '`justify-content: space-between`은 어떤 정렬을 의미하는가?', 2, 'low', '아이템들을 왼쪽에 정렬', '아이템 사이에 동일한 간격을 둠', '아이템을 오른쪽 정렬', '아이템의 가운데 정렬', 20, '`space-between`은 양 끝을 기준으로 아이템 간의 간격을 동일하게 배분한다.'),
                                                                                                                           (974, 'Flexbox에서 세로 정렬(교차축)을 설정하는 속성은?', 2, 'low', 'flex-grow', 'align-items', 'justify-content', 'flex-direction', 20, '`align-items`는 교차축(cross axis)에 따라 아이템을 정렬하는 데 사용된다.'),
                                                                                                                           (975, '`grid-template-columns: 1fr 2fr`은 어떤 의미인가?', 3, 'medium', '1열은 1px, 2열은 2px', '1열은 1단어, 2열은 2단어', '1열은 1비율, 2열은 2비율로 공간 분배', '1열은 고정, 2열은 유동적', 20, '`fr` 단위는 비율 단위로, 1fr은 전체 가용 공간의 1부분, 2fr은 2부분을 의미한다.'),
                                                                                                                           (976, 'Flexbox에서 자식 요소가 부모의 공간을 초과할 경우 줄바꿈을 허용하려면?', 1, 'medium', 'flex-wrap: wrap', 'justify-content: stretch', 'align-content: center', 'overflow: scroll', 20, '`flex-wrap: wrap`은 자식 요소가 공간을 초과할 경우 자동으로 줄바꿈을 하게 만든다.'),
                                                                                                                           (977, '`grid-area` 속성은 어떤 역할을 하는가?', 2, 'medium', '아이템의 배경을 설정', '그리드 내 아이템의 이름을 지정하여 위치 지정', '아이템 간의 간격을 설정', '아이템의 크기를 고정', 20, '`grid-area`는 그리드 아이템의 위치를 이름 기반으로 지정할 수 있게 해주는 속성이다.'),
                                                                                                                           (978, '`place-items: center`는 어떤 정렬 방식인가?', 3, 'medium', '가로만 가운데 정렬', '세로만 가운데 정렬', '가로와 세로 모두 가운데 정렬', '양 끝 정렬', 20, '`place-items: center`는 align-items와 justify-items를 동시에 가운데로 설정한다.'),
                                                                                                                           (979, 'Flex 아이템 간 정렬 우선순위로 적용되는 순서는?', 3, 'high', 'align-items > align-self > justify-content', 'justify-content > align-items > align-self', 'align-self > align-items > justify-content', 'justify-content > align-self > align-items', 20, 'align-self는 개별 요소에 직접 설정된 값이므로 우선순위가 가장 높고, 그 다음이 align-items이다.'),
                                                                                                                           (980, '`grid`를 사용하여 두 줄로 나누고, 각 줄에 3개의 동일한 열을 만들려면 올바른 설정은?', 1, 'high', 'grid-template-rows: repeat(2, 1fr); grid-template-columns: repeat(3, 1fr);', 'grid-columns: 3; grid-rows: 2;', 'grid-columns: auto; grid-template-rows: 2fr;', 'display: flex; flex-direction: column;', 20, 'repeat 문법을 사용하면 동일한 크기의 행과 열을 간결하게 정의할 수 있다.'),
                                                                                                                           (981, '반응형 웹 디자인의 주요 목표는 무엇인가?', 2, 'low', '웹사이트를 빠르게 로딩하기 위함', '모든 해상도와 장치에서 최적의 레이아웃을 제공하기 위함', '모든 브라우저에서 똑같이 보이기 위함', '폰트 크기를 크게 하기 위함', 20, '반응형 디자인은 다양한 디바이스에서 최적의 사용 경험을 제공하기 위한 접근법이다.'),
                                                                                                                           (982, '다음 중 뷰포트를 설정하는 메타 태그는?', 2, 'low', '<meta responsive=''true''>', '<meta name=''viewport'' content=''width=device-width, initial-scale=1.0''>', '<meta screen=''adaptive''>', '<meta name=''media'' content=''responsive''>', 20, 'viewport 메타 태그는 반응형 웹 구현을 위해 화면 크기와 스케일을 설정할 때 사용된다.'),
                                                                                                                           (983, '미디어 쿼리에서 화면 너비가 768px 이상일 때를 지정하는 문법은?', 2, 'low', '@media screen and (max-width: 768px)', '@media screen and (min-width: 768px)', '@media width >= 768px', '@media screen over 768px', 20, '`min-width`는 지정한 값 이상일 때 적용되는 미디어 쿼리 문법이다.'),
                                                                                                                           (984, 'rem 단위는 어떤 값을 기준으로 계산되는가?', 3, 'low', '부모 요소의 크기', '가장 가까운 컨테이너의 크기', '루트 요소(html)의 폰트 크기', '디바이스 해상도', 20, 'rem은 html 요소의 폰트 크기를 기준으로 상대 단위를 계산한다.'),
                                                                                                                           (985, '다음 중 모바일 우선 접근법(Mobile-first approach)의 핵심은?', 2, 'medium', '데스크탑 기준으로 시작한 후 모바일 대응', '모바일 스타일을 먼저 정의하고, 데스크탑에 맞춰 확장', '모바일 사이트와 데스크탑 사이트를 분리 개발', '모바일에서는 스타일을 최소화함', 20, '모바일 우선 접근은 기본 스타일을 모바일에 맞추고, 더 큰 화면에 대응해 점진적으로 확장하는 방식이다.'),
                                                                                                                           (986, '다음 중 반응형 이미지 구현 방식이 아닌 것은?', 4, 'medium', 'srcset 속성을 사용하는 것', 'CSS background-size: cover 사용', 'picture 요소를 사용하는 것', 'img 태그에 고정 px 값을 주는 것', 20, 'img에 고정된 px 크기를 주면 화면 크기에 따라 이미지 크기가 자동 조정되지 않기 때문에 반응형에 적합하지 않다.'),
                                                                                                                           (987, '다음 중 em 단위와 rem 단위의 주요 차이점은?', 3, 'medium', 'em은 절대 단위, rem은 상대 단위', 'em은 루트 기준, rem은 부모 기준', 'em은 부모 기준, rem은 루트 기준', '차이가 없다', 20, 'em은 부모 요소를 기준으로 하고, rem은 html 요소를 기준으로 계산되는 상대 단위이다.'),
                                                                                                                           (988, '다음 중 여러 조건을 AND로 묶어 미디어 쿼리를 작성하는 방법은?', 2, 'medium', '@media screen { min-width: 600px; max-width: 900px; }', '@media screen and (min-width: 600px) and (max-width: 900px)', '@media (min-width: 600px) or (max-width: 900px)', '@media screen && (600px ~ 900px)', 20, 'AND 조건을 쓰려면 screen and (조건) and (조건) 형식으로 연결해야 한다.'),
                                                                                                                           (989, '다음 중 반응형 디자인이 접근성을 높이는 이유로 적절한 것은?', 3, 'high', '웹사이트의 디자인이 더 화려해진다', '코드가 짧아진다', '모든 사용자에게 일관된 경험을 제공할 수 있다', '이미지 품질이 좋아진다', 20, '반응형 디자인은 디바이스와 해상도에 관계없이 일관된 UX를 제공하여 접근성을 높인다.'),
                                                                                                                           (990, '미디어 쿼리를 사용하여 프린트 전용 스타일을 정의하려면?', 1, 'high', '@media print', '@media only-screen', '@media screen-print', '@media screen and (print)', 20, '`@media print`는 문서를 인쇄할 때만 적용되는 스타일을 지정할 수 있다.'),
                                                                                                                           (991, 'CSS 트랜지션을 적용하려면 어떤 속성을 사용해야 하는가?', 2, 'low', 'animation', 'transition', 'duration', 'keyframes', 20, '`transition` 속성은 요소에 변화가 발생할 때 트랜지션 효과를 지정하기 위해 사용된다.'),
                                                                                                                           (992, '트랜지션 효과를 줄 때 지속 시간을 설정하는 속성은?', 3, 'low', 'transition-delay', 'transition-timing', 'transition-duration', 'transition-speed', 20, '`transition-duration`은 트랜지션이 얼마나 오래 지속될지를 지정하는 속성이다.'),
                                                                                                                           (993, '다음 중 `transition-timing-function`의 기본값은?', 2, 'low', 'linear', 'ease', 'ease-in-out', 'step-start', 20, '`ease`는 transition의 기본 타이밍 함수로, 시작은 느리고 중간은 빠르며 끝은 다시 느려지는 곡선을 따른다.'),
                                                                                                                           (994, '애니메이션을 무한 반복하고 싶다면 어떤 속성을 사용해야 하는가?', 3, 'low', 'animation-repeat: infinite;', 'animation-loop: true;', 'animation-iteration-count: infinite;', 'animation-cycle: always;', 20, '`animation-iteration-count: infinite;`는 애니메이션을 끝없이 반복하도록 지정하는 속성이다.'),
                                                                                                                           (995, '`@keyframes`을 사용하는 이유는?', 3, 'medium', '애니메이션을 설정된 시간만큼 지연하기 위해', '속도 조절을 위해', '애니메이션의 중간 단계를 정의하기 위해', '요소에 그림자를 주기 위해', 20, '`@keyframes`는 애니메이션의 시작, 중간, 끝 상태를 정의해 시간의 흐름에 따른 스타일 변화를 지정하는 데 사용된다.'),
                                                                                                                           (996, '`animation-fill-mode: forwards`는 어떤 효과를 주는가?', 2, 'medium', '애니메이션이 끝난 후 처음 상태로 돌아감', '애니메이션이 끝난 후 마지막 상태를 유지함', '애니메이션이 무한 반복됨', '애니메이션이 반대로 실행됨', 20, '`forwards`는 애니메이션이 완료된 후 마지막 keyframe 상태를 유지하게 만든다.'),
                                                                                                                           (997, '다음 중 `transform` 속성으로 할 수 있는 작업이 아닌 것은?', 3, 'medium', '회전', '크기 조절', '색상 변경', '이동', 20, '`transform`은 위치, 크기, 회전 등의 시각적 변화를 주지만 색상 변경은 할 수 없다.'),
                                                                                                                           (998, '복잡한 커스텀 속도 곡선을 지정하고 싶을 때 사용하는 값은?', 3, 'medium', 'linear', 'ease-in', 'cubic-bezier', 'bounce', 20, '`cubic-bezier`는 4개의 숫자를 이용해 커스텀 타이밍 함수를 정의할 수 있어 가장 유연하다.'),
                                                                                                                           (999, '`animation-direction: alternate`는 어떤 동작을 하나?', 3, 'high', '한 번만 실행', '앞으로만 실행', '앞뒤로 번갈아 실행', '랜덤하게 실행', 20, '`alternate`는 한 번은 정방향, 다음 번은 역방향으로 애니메이션을 반복 실행하게 만든다.'),
                                                                                                                           (1000, '다음 중 트랜지션이 작동하지 않는 속성은?', 3, 'high', 'width', 'height', 'display', 'opacity', 20, '`display` 속성은 트랜지션이 적용되지 않으며, 즉시 적용된다.'),
                                                                                                                           (1001, 'ESLint의 주요 목적은 무엇인가?', 2, 'low', '코드 포맷팅', '코드 스타일 검사 및 오류 탐지', 'HTML 검증', '데이터베이스 연결', 21, 'ESLint는 JavaScript 코드에서 문법 오류와 스타일 위반을 찾아내는 정적 분석 도구이다.'),
                                                                                                                           (1002, 'ESLint를 프로젝트에 설치할 때 사용하는 명령어는?', 1, 'low', 'npm install eslint', 'npm install prettier', 'npm install lint', 'npm install eslint-prettier', 21, 'ESLint는 npm 패키지로 제공되며, `npm install eslint` 명령으로 설치한다.'),
                                                                                                                           (1003, 'ESLint 초기화 설정을 위한 명령어는?', 1, 'low', 'eslint init', 'eslint setup', 'eslint create', 'eslint config', 21, '`eslint init`은 ESLint 설정 마법사를 실행하여 초기 설정 파일을 생성하는 명령어다.'),
                                                                                                                           (1004, 'ESLint는 기본적으로 어떤 언어를 대상으로 한다?', 3, 'low', 'Python', 'Java', 'JavaScript', 'C++', 21, 'ESLint는 JavaScript 전용 린터로, JS 코드 품질 향상에 중점을 둔다.'),
                                                                                                                           (1005, 'ESLint가 오류를 감지하는 기본 단위는?', 1, 'medium', '파일', '프로젝트', '라인', '토큰', 21, 'ESLint는 각 소스 파일을 단위로 읽고 분석하여 오류를 감지한다.'),
                                                                                                                           (1006, 'ESLint 설정 파일 확장자가 아닌 것은?', 4, 'medium', '.eslintrc.js', '.eslintrc.json', '.eslintrc.yaml', '.eslintconf', 21, '`.eslintconf`는 ESLint에서 인식하지 않는 확장자이다.'),
                                                                                                                           (1007, 'ESLint에서 규칙을 끄는 방법은?', 1, 'medium', 'rules: { ''규칙명'': ''off'' }', 'rules: { ''규칙명'': ''on'' }', 'disableRule()', 'eslintOff', 21, '규칙을 끄려면 설정 파일의 rules 객체에서 해당 규칙을 "off"로 지정한다.'),
                                                                                                                           (1008, 'ESLint를 CLI로 실행할 때 사용하는 기본 명령어는?', 3, 'high', 'eslint run', 'eslint check', 'eslint <파일경로>', 'eslint execute', 21, 'CLI에서는 `eslint` 명령어 뒤에 파일 경로를 지정해 실행한다.'),
                                                                                                                           (1009, 'ESLint 설정을 공유할 수 있도록 제공되는 것은?', 4, 'high', '플러그인', '공유 설정 패키지', 'Preset', 'All of the above', 21, 'ESLint는 플러그인, Preset, 설정 패키지 등을 통해 설정을 공유하고 확장할 수 있다.'),
                                                                                                                           (1010, 'ESLint를 설치할 때 전역 설치를 위한 명령어는?', 1, 'high', 'npm install -g eslint', 'npm add eslint', 'npm set eslint', 'npm run eslint', 21, '전역 설치는 `-g` 옵션을 사용하여 `npm install -g eslint`로 수행한다.'),
                                                                                                                           (1011, 'ESLint 설정 파일에서 규칙을 설정하는 속성은?', 1, 'low', 'rules', 'plugins', 'env', 'settings', 21, '`rules` 속성은 어떤 ESLint 규칙을 적용할지 지정하는 핵심 설정 영역이다.'),
                                                                                                                           (1012, 'ESLint 규칙 중 코드 스타일 관련 규칙을 설정하는 대표적인 항목은?', 2, 'low', 'no-console', 'semi', 'no-undef', 'no-unused-vars', 21, '`semi`는 문장의 끝에 세미콜론을 강제할지를 결정하는 코드 스타일 관련 규칙이다.'),
                                                                                                                           (1013, 'ESLint 설정 파일에서 환경(environment)을 설정하는 속성은?', 1, 'low', 'env', 'settings', 'globals', 'plugins', 21, '`env`는 실행 환경을 지정하며, 해당 환경에 따라 전역 변수와 규칙이 자동 적용된다.'),
                                                                                                                           (1014, 'Node.js 환경을 설정할 때 사용하는 ESLint env 옵션은?', 2, 'medium', 'browser: true', 'node: true', 'es2021: true', 'commonjs: true', 21, '`node: true`를 설정하면 Node.js 전역 객체 및 문법에 대한 린팅을 허용한다.'),
                                                                                                                           (1015, 'ESLint 설정 파일에서 전역 변수(global variables)를 선언하는 속성은?', 1, 'medium', 'globals', 'global', 'vars', 'expose', 21, '`globals`는 전역 변수를 명시적으로 선언해 ESLint 오류를 방지할 수 있다.'),
                                                                                                                           (1016, 'ESLint 플러그인은 주로 무엇을 확장하기 위해 사용하는가?', 2, 'medium', '코드 스타일', '문법 검사 범위', '빌드 속도', '버전 관리', 21, '플러그인은 ESLint의 문법 검사 범위를 확장하거나 새로운 규칙을 추가하기 위해 사용된다.'),
                                                                                                                           (1017, 'eslint:recommended 설정은 어떤 역할을 하는가?', 2, 'high', '모든 규칙을 끈다', '자주 발생하는 오류를 막는 기본 규칙을 적용한다', '코드 스타일을 통일한다', 'Prettier를 활성화한다', 21, '`eslint:recommended`는 기본적으로 중요한 오류를 방지하기 위한 핵심 규칙 모음을 적용한다.'),
                                                                                                                           (1018, 'ESLint 규칙에서 ''off'', ''warn'', ''error''는 각각 무엇을 의미하는가?', 1, 'high', '설정 끄기/경고/에러로 처리', '설정 켜기/무시/로그 출력', '강제 적용/권장/제외', '스킵/로그/실패', 21, '`off`, `warn`, `error`는 규칙의 적용 수준을 정의하며 각각 무시, 경고, 오류로 처리한다.'),
                                                                                                                           (1019, 'ESLint 설정 파일이 가장 먼저 찾는 파일 이름은?', 2, 'high', '.eslintconfig.js', '.eslintrc.js', 'eslint.config.json', 'config.eslint', 21, 'ESLint는 기본적으로 `.eslintrc.js` 파일을 우선적으로 찾는다.'),
                                                                                                                           (1020, 'ESLint에서 특정 파일이나 폴더를 무시할 때 사용하는 파일은?', 2, 'high', '.gitignore', '.eslintignore', '.eslintconfig', 'ignored.eslint', 21, '`.eslintignore` 파일을 통해 특정 파일이나 폴더에 ESLint 분석을 제외시킬 수 있다.'),
                                                                                                                           (1021, 'Prettier의 주요 기능은 무엇인가?', 2, 'low', '코드 스타일 검사', '코드 포맷팅 자동화', '오류 탐지', '파일 경로 관리', 21, 'Prettier는 코드의 스타일을 자동으로 정리해주는 포맷터로, 일관된 코드 형식을 유지하도록 도와준다.'),
                                                                                                                           (1022, 'Prettier를 설치하는 명령어는?', 1, 'low', 'npm install prettier', 'npm install eslint', 'npm install format', 'npm install prettier-eslint', 21, '`prettier` 패키지를 설치해야 하므로 `npm install prettier`가 정확한 명령어다.'),
                                                                                                                           (1023, 'Prettier로 코드를 포맷팅하는 기본 CLI 명령어는?', 3, 'low', 'prettier format', 'prettier lint', 'prettier --write', 'prettier fix', 21, '`--write` 옵션은 파일을 직접 수정하여 포맷팅하는 기본적인 방식이다.'),
                                                                                                                           (1024, 'Prettier는 기본적으로 어떤 오류를 다루는가?', 3, 'medium', 'Syntax Error', 'Runtime Error', 'Style Error', 'Type Error', 21, 'Prettier는 문법보다는 들여쓰기, 공백, 세미콜론 등 스타일 관련 오류를 자동으로 정리하는 데 중점을 둔다.'),
                                                                                                                           (1025, 'Prettier 설정 파일 확장자가 아닌 것은?', 4, 'medium', '.prettierrc', '.prettierrc.js', '.prettierrc.json', '.prettierconfig', 21, '`.prettierconfig`는 실제로 사용되지 않는 잘못된 설정 파일명이다.'),
                                                                                                                           (1026, 'Prettier 설정에서 줄 길이 최대치를 지정하는 옵션은?', 1, 'medium', 'printWidth', 'tabWidth', 'lineLength', 'wrapLine', 21, '`printWidth`는 코드 한 줄에 허용되는 최대 길이를 지정하는 옵션이다.'),
                                                                                                                           (1027, 'Prettier 설정에서 들여쓰기 크기를 지정하는 옵션은?', 2, 'high', 'indent', 'tabWidth', 'spaceSize', 'tabSize', 21, '`tabWidth`는 들여쓰기에 사용되는 공백 수를 설정하는 옵션이다.'),
                                                                                                                           (1028, 'Prettier에서 세미콜론 사용 여부를 설정하는 옵션은?', 1, 'high', 'semi', 'semicolon', 'endSemicolon', 'useSemi', 21, '`semi` 옵션을 통해 문장 끝에 세미콜론을 붙일지를 설정할 수 있다.'),
                                                                                                                           (1029, 'Prettier 설정에서 따옴표를 싱글로 사용할지 설정하는 옵션은?', 1, 'high', 'singleQuote', 'useSingleQuote', 'quoteType', 'preferSingle', 21, '`singleQuote: true`로 설정하면 문자열을 작은따옴표로 포맷팅한다.'),
                                                                                                                           (1030, 'Prettier를 VSCode에 통합할 때 필요한 확장 프로그램은?', 1, 'high', 'Prettier - Code formatter', 'ESLint Formatter', 'Code Beautifier', 'Auto Linter', 21, 'VSCode에서 Prettier 기능을 사용하려면 공식 확장 프로그램인 "Prettier - Code formatter"를 설치해야 한다.'),
                                                                                                                           (1031, 'ESLint와 Prettier를 함께 사용할 때 충돌을 방지하기 위한 패키지는?', 2, 'low', 'eslint-plugin-prettier', 'eslint-config-prettier', 'prettier-eslint-config', 'eslint-prettier-sync', 21, '`eslint-config-prettier`는 Prettier와 충돌하는 ESLint 규칙을 비활성화해 충돌을 방지한다.'),
                                                                                                                           (1032, 'eslint-plugin-prettier의 역할은?', 1, 'low', 'Prettier를 Lint 규칙처럼 동작시킴', 'Prettier 포맷만 적용', 'Lint 설정 제거', 'Prettier 비활성화', 21, 'eslint-plugin-prettier는 Prettier의 포맷팅 규칙을 ESLint의 규칙처럼 검사하고 경고/에러를 발생시킨다.'),
                                                                                                                           (1033, 'Prettier 설정이 ESLint 설정보다 우선되도록 하려면?', 3, 'low', 'prettier-last', 'eslint-prettier-last', 'prettier를 extends 마지막에 설정', 'eslint-plugin-prettier 우선 적용', 21, 'extends 배열의 마지막에 prettier를 두면 이전 설정보다 우선되어 적용된다.'),
                                                                                                                           (1034, 'Prettier와 ESLint를 동시에 적용하기 위한 설정 파일은?', 2, 'medium', '.eslintprettier.json', '.eslintrc', '.prettierrc', '.eslintconfig', 21, '`.eslintrc` 파일은 ESLint의 설정을 적용하며 Prettier 통합 설정도 함께 포함할 수 있다.'),
                                                                                                                           (1035, 'eslint-config-prettier를 사용하면 무엇이 비활성화되는가?', 2, 'medium', '모든 Lint 규칙', 'Prettier와 충돌하는 Lint 규칙', '모든 스타일 규칙', '커밋 훅', 21, '`eslint-config-prettier`는 Prettier 포맷팅과 충돌할 수 있는 ESLint 규칙만 비활성화한다.'),
                                                                                                                           (1036, 'VSCode에서 ESLint와 Prettier를 동시에 적용하려면 필요한 확장은?', 3, 'medium', 'Prettier only', 'ESLint only', '둘 다 설치', 'AutoLint', 21, 'VSCode에서는 ESLint와 Prettier 기능을 모두 사용하려면 해당 확장을 각각 설치해야 한다.'),
                                                                                                                           (1037, 'ESLint와 Prettier를 통합한 후, 코드 포맷팅 자동화를 위해 설정할 수 있는 VSCode 기능은?', 2, 'high', 'onSaveFormat', 'formatOnSave', 'saveFormatter', 'autoSaveLint', 21, '`editor.formatOnSave` 설정을 true로 하면 저장할 때 자동으로 포맷팅이 적용된다.'),
                                                                                                                           (1038, 'Prettier 설정을 eslint-plugin-prettier에 연결하려면 필요한 설정 속성은?', 1, 'high', 'rules.prettier/prettier', 'extends prettier', 'settings.prettier', 'plugin:prettier/setting', 21, '`rules` 속성에서 `prettier/prettier` 규칙을 설정하여 Prettier 관련 위반을 ESLint에서 검사하게 할 수 있다.'),
                                                                                                                           (1039, 'Prettier 규칙 위반을 ESLint 에러로 처리하는 것은?', 2, 'high', 'eslint-config-prettier', 'eslint-plugin-prettier', 'prettier-eslint', 'prettier-only', 21, '`eslint-plugin-prettier`는 Prettier 포맷 규칙 위반을 ESLint 에러로 표시해준다.'),
                                                                                                                           (1040, 'Prettier를 적용한 파일만 선택적으로 포맷팅하려면 사용할 수 있는 커맨드는?', 1, 'high', 'prettier --write ''src/**/*.{js,ts}''', 'eslint --fix', 'prettier --lint', 'prettier --check-only', 21, '`prettier --write`에 glob 패턴을 지정하면 원하는 파일만 선택적으로 포맷팅할 수 있다.'),
                                                                                                                           (1041, 'ESLint에서 사용자 정의 규칙을 만들려면 필요한 요소는?', 3, 'low', 'parser', 'plugin', 'rule', 'formatter', 21, '사용자 정의 규칙은 `rules` 객체에 구현해야 하며, 각 규칙은 특정 AST 패턴을 감시한다.'),
                                                                                                                           (1042, 'Prettier 설정 파일을 프로젝트 루트에 두는 이유는?', 2, 'low', 'CI/CD 설정을 위해', '포맷팅 기준을 통일하기 위해', '코드 압축을 위해', '로그 저장을 위해', 21, '프로젝트 루트에 설정 파일을 두면 팀 전체가 동일한 포맷팅 기준을 따를 수 있다.'),
                                                                                                                           (1043, 'ESLint 플러그인을 직접 개발할 때 필요한 핵심 구성 요소는?', 1, 'low', 'rules', 'presets', 'config.js', 'validators', 21, 'ESLint 플러그인은 rules 디렉토리 안에 규칙을 정의하는 파일이 있어야 한다.'),
                                                                                                                           (1044, '커스텀 규칙을 ESLint 설정 파일에 추가할 때 필요한 속성은?', 2, 'medium', 'customRules', 'rules', 'plugins', 'overrides', 21, 'ESLint 설정 파일에서 `rules` 항목을 사용하여 커스텀 규칙을 적용한다.'),
                                                                                                                           (1045, 'Prettier에서 프로젝트마다 다른 스타일을 적용하려면 사용하는 파일은?', 2, 'medium', '.prettierignore', 'prettier.config.js', '.prettierrules', '.prettiersettings', 21, '`prettier.config.js`는 JavaScript 형식으로 유연하게 설정을 작성할 수 있어 프로젝트별 설정에 적합하다.'),
                                                                                                                           (1046, 'ESLint 커스텀 플러그인 개발 시 필수적으로 포함되어야 하는 파일은?', 1, 'medium', 'rules/index.js', 'lib/rules.js', 'src/config.js', 'plugin.config.js', 21, 'ESLint 플러그인은 `rules/index.js` 파일에서 규칙들을 모듈로 정의해야 한다.'),
                                                                                                                           (1047, 'VSCode에서 저장 시 자동으로 Prettier 포맷팅을 적용하려면 설정해야 하는 옵션은?', 2, 'high', 'editor.autoFormatOnSave', 'editor.formatOnSave', 'editor.saveFormat', 'editor.prettify', 21, '`editor.formatOnSave` 설정은 저장 시 자동으로 Prettier가 적용되도록 한다.'),
                                                                                                                           (1048, 'Prettier 설정을 무시하고 특정 파일만 포맷팅 제외하려면 사용하는 파일은?', 1, 'high', '.prettierignore', '.eslintignore', '.formatignore', '.ignoreprettier', 21, '`.prettierignore` 파일에 경로를 지정하면 해당 파일은 Prettier 적용 대상에서 제외된다.'),
                                                                                                                           (1049, 'ESLint에서 특정 디렉토리만 별도 규칙으로 적용하려면 사용하는 설정 항목은?', 1, 'high', 'overrides', 'env', 'globals', 'parserOptions', 21, '`overrides`를 사용하면 특정 경로 또는 파일에 대해 개별 규칙을 설정할 수 있다.'),
                                                                                                                           (1050, 'Prettier 커스텀 설정을 여러 프로젝트에서 재사용하려면 사용하는 방법은?', 1, 'high', '공유 설정 패키지로 배포', '로컬에 복사', 'VSCode 설정만 변경', 'package.json에 직접 작성', 21, 'Prettier 설정을 모듈화한 후 패키지로 배포하면 여러 프로젝트에서 일관되게 사용할 수 있다.'),
                                                                                                                           (1051, 'Next.js는 어떤 프레임워크를 기반으로 만들어졌는가?', 2, 'low', 'Vue.js', 'React.js', 'Angular', 'Svelte', 22, 'Next.js는 React 기반의 프레임워크로, React의 기능을 확장하여 서버사이드 렌더링과 정적 생성 기능을 제공한다.'),
                                                                                                                           (1052, 'Next.js 프로젝트를 생성하는 명령어는?', 2, 'low', 'npx create-react-app', 'npx create-next-app', 'npm init next', 'yarn next-create', 22, '`npx create-next-app`은 공식적으로 지원되는 Next.js 프로젝트 생성 명령어이다.'),
                                                                                                                           (1053, 'Next.js에서 기본적으로 제공하는 파일 기반 라우팅 디렉토리는?', 3, 'low', 'src/', 'routes/', 'pages/', 'views/', 22, '`pages/` 디렉토리는 URL 경로와 1:1로 매핑되는 파일 기반 라우팅 기능을 제공한다.'),
                                                                                                                           (1054, 'Next.js의 기본 개발 서버 실행 명령어는?', 1, 'low', 'npm run dev', 'npm start', 'yarn build', 'next run', 22, '`npm run dev`는 개발 모드로 Next.js 서버를 실행하는 기본 명령어이다.'),
                                                                                                                           (1055, 'Next.js에서 build 후 production 서버를 실행하는 명령어는?', 1, 'medium', 'npm run start', 'npm run serve', 'next serve', 'yarn start', 22, '`npm run start`는 `next build` 이후 생성된 파일을 사용해 프로덕션 서버를 실행한다.'),
                                                                                                                           (1056, 'Next.js가 지원하는 기본 렌더링 방식은?', 4, 'medium', 'CSR', 'SSR', 'SSG', 'SSR과 SSG 모두 지원', 22, 'Next.js는 SSR과 SSG 모두 지원하는 하이브리드 렌더링 프레임워크이다.'),
                                                                                                                           (1057, 'Next.js 설정 파일 이름은?', 2, 'medium', 'nextconfig.js', 'next.config.js', 'config.next.js', 'next.js.config', 22, '`next.config.js`는 프로젝트 루트에 위치하는 Next.js 전용 설정 파일이다.'),
                                                                                                                           (1058, 'Next.js 프로젝트 루트에 있어야 하는 디렉토리가 아닌 것은?', 4, 'high', 'pages', 'public', 'styles', 'controllers', 22, '`controllers`는 백엔드 서버에서 주로 사용하는 구조이며, Next.js의 기본 구조에 포함되지 않는다.'),
                                                                                                                           (1059, 'Next.js의 public 디렉토리는 어떤 용도로 사용되는가?', 2, 'high', 'API 정의', '정적 파일 제공', '라우팅 설정', '컴포넌트 저장', 22, '`public` 디렉토리는 정적 이미지나 문서 등 브라우저에서 접근 가능한 파일을 저장하는 곳이다.'),
                                                                                                                           (1060, 'Next.js를 사용하면 얻을 수 있는 주요 이점은?', 2, 'high', '완전한 CSR', 'SSR 및 SEO 최적화', 'SPA 전용', '서버 부하 증가', 22, 'Next.js는 서버사이드 렌더링과 정적 생성 기능으로 SEO 최적화가 가능한 것이 주요 장점이다.'),
                                                                                                                           (1061, 'Next.js에서 새로운 페이지를 생성하려면 어디에 파일을 추가해야 하는가?', 2, 'low', 'components/', 'pages/', 'public/', 'api/', 22, '`pages/` 디렉토리에 파일을 추가하면 해당 파일명이 라우팅 경로가 되어 새로운 페이지가 생성된다.'),
                                                                                                                           (1062, 'Next.js에서 페이지 이동을 위해 사용하는 컴포넌트는?', 3, 'low', 'Navigate', 'RouterLink', 'Link', 'Move', 22, '`Link` 컴포넌트는 클라이언트 측에서 빠르게 페이지를 이동할 수 있도록 지원한다.'),
                                                                                                                           (1063, 'Next.js에서 프로그래밍 방식으로 페이지 이동을 할 때 사용하는 훅은?', 3, 'low', 'useHistory', 'useNavigate', 'useRouter', 'useLocation', 22, '`useRouter`는 Next.js의 라우터 객체에 접근하기 위한 훅으로, push 등 메서드를 제공한다.'),
                                                                                                                           (1064, 'Link 컴포넌트 안에 필수적으로 포함해야 하는 것은?', 1, 'medium', '<a> 태그', '<button> 태그', '<div> 태그', '<p> 태그', 22, 'Next.js의 `Link`는 내부적으로 `<a>` 태그와 함께 사용되어야 정상적인 이동과 SEO가 가능하다.'),
                                                                                                                           (1065, 'Next.js의 동적 라우팅(dynamic routing)은 어떤 파일명 패턴을 사용하는가?', 2, 'medium', 'page.js', '[param].js', '{param}.js', 'param.js', 22, '대괄호(`[]`)를 이용한 파일명은 URL의 파라미터를 동적으로 처리할 수 있게 한다.'),
                                                                                                                           (1066, 'Next.js에서 catch-all 라우트를 만들기 위한 파일명 패턴은?', 1, 'medium', '[...param].js', '[[param]].js', '{param}.js', '(param).js', 22, '`[...param].js`는 여러 경로를 포괄할 수 있는 catch-all 라우트 파일명 패턴이다.'),
                                                                                                                           (1067, 'useRouter 훅을 사용하여 현재 경로(path)를 가져오는 속성은?', 2, 'high', 'route', 'pathname', 'path', 'currentPath', 22, '`pathname` 속성은 현재 URL 경로를 문자열 형태로 반환한다.'),
                                                                                                                           (1068, 'Next.js에서 URL 쿼리 파라미터를 가져오기 위해 사용하는 것은?', 2, 'high', 'useQuery', 'useRouter().query', 'getQuery()', 'router.param', 22, '`useRouter().query`를 통해 현재 URL에 포함된 쿼리 파라미터를 가져올 수 있다.'),
                                                                                                                           (1069, 'Next.js에서 404 페이지를 커스텀하려면 어떤 파일을 만들어야 하는가?', 1, 'high', '404.js', 'error.js', 'notfound.js', 'fail.js', 22, 'Next.js는 `pages/404.js` 파일을 자동으로 인식해 커스텀 404 페이지로 사용한다.'),
                                                                                                                           (1070, 'Next.js에서 중첩된 라우팅(nested routing)을 구성하는 방법은?', 2, 'high', 'routes 디렉토리 추가', 'pages 안에 디렉토리 생성', 'src 안에 폴더 생성', 'components에 파일 추가', 22, '중첩된 폴더를 `pages/` 하위에 생성하면 폴더 구조에 맞는 URL이 자동 생성된다.'),
                                                                                                                           (1071, 'Next.js에서 서버사이드 렌더링(SSR)을 구현할 때 사용하는 함수는?', 2, 'low', 'getStaticProps', 'getServerSideProps', 'useEffect', 'getInitialProps', 22, '`getServerSideProps`는 매 요청마다 실행되어 서버에서 HTML을 렌더링할 수 있게 해준다.'),
                                                                                                                           (1072, 'Next.js에서 정적 사이트 생성(SSG)을 할 때 사용하는 함수는?', 1, 'low', 'getStaticProps', 'getServerSideProps', 'getInitialProps', 'fetchData', 22, '`getStaticProps`는 빌드 시 데이터를 가져와 HTML을 미리 생성하는 데 사용된다.'),
                                                                                                                           (1073, 'Next.js의 Incremental Static Regeneration(ISR)은 무엇을 의미하는가?', 2, 'low', '모든 페이지를 미리 생성', '정적 페이지를 주기적으로 재생성', '페이지를 항상 서버에서 생성', '클라이언트 사이드 데이터 요청', 22, 'ISR은 빌드 후에도 일부 정적 페이지를 갱신할 수 있는 기능이다.'),
                                                                                                                           (1074, 'getServerSideProps는 언제 호출되는가?', 3, 'medium', '빌드 타임', '클라이언트 렌더링 시', '요청 시마다', '페이지 로드 후', 22, '`getServerSideProps`는 사용자의 요청이 들어올 때마다 서버에서 실행된다.'),
                                                                                                                           (1075, 'Next.js에서 클라이언트 사이드에서 데이터를 가져올 때 사용하는 방법은?', 3, 'medium', 'getStaticProps', 'getServerSideProps', 'useEffect와 fetch', 'getInitialProps', 22, '클라이언트 사이드 데이터 요청은 `useEffect` 내부에서 fetch를 사용하는 방식으로 처리한다.'),
                                                                                                                           (1076, 'getStaticPaths는 어떤 상황에서 필요한가?', 1, 'medium', '정적 경로를 미리 정의할 때', '서버사이드 렌더링 할 때', 'API 호출 시', '라우터 초기화 시', 22, '`getStaticPaths`는 SSG에서 동적 경로의 정적 HTML을 생성하기 위한 경로 목록을 정의하는 데 사용된다.'),
                                                                                                                           (1077, 'Next.js에서 Fallback: true 설정은 어떤 의미인가?', 3, 'high', '모든 페이지를 미리 생성', '없으면 404 반환', '없는 페이지는 생성 후 제공', '서버에서 강제 새로고침', 22, 'fallback: true는 미리 생성되지 않은 페이지는 최초 요청 시 생성 후 캐시된다.'),
                                                                                                                           (1078, 'Next.js에서 데이터 Fetching 최적화를 위한 기본 전략은?', 2, 'high', '모든 요청 서버 처리', '정적 생성 + 필요 시 서버 요청', 'CSR만 사용', 'SSR만 사용', 22, 'Next.js는 정적 생성이 가능하면 우선 활용하고, 동적 데이터는 서버 요청으로 처리하는 전략을 취한다.'),
                                                                                                                           (1079, 'getServerSideProps, getStaticProps 함수에서 반환해야 하는 객체 속성은?', 3, 'high', 'response', 'data', 'props', 'serverData', 22, '두 함수는 `props` 키를 포함한 객체를 반환하여 컴포넌트에 데이터를 전달한다.'),
                                                                                                                           (1080, 'Next.js에서 클라이언트 요청에 따라 서버에서 매번 렌더링하는 방식은?', 2, 'high', 'SSG', 'SSR', 'ISR', 'CSR', 22, 'SSR(Server Side Rendering)은 요청 시 서버에서 HTML을 렌더링하여 응답하는 방식이다.'),
                                                                                                                           (1081, 'Next.js에서 API Route를 만들려면 파일을 어디에 생성해야 하는가?', 2, 'low', 'api/', 'pages/api/', 'server/', 'routes/', 22, '`pages/api/` 폴더는 Next.js에서 API Route로 인식되는 특별한 디렉토리이다.'),
                                                                                                                           (1082, 'Next.js API Route는 기본적으로 어떤 메서드를 지원하는가?', 3, 'low', 'GET만', 'POST만', 'GET과 POST 모두', 'PUT만', 22, 'Next.js API Route는 HTTP 요청 객체(req)를 통해 다양한 메서드(GET, POST 등)를 모두 지원할 수 있다.'),
                                                                                                                           (1083, 'Next.js API Route 핸들러 함수의 첫 번째 파라미터는 무엇인가?', 2, 'low', 'props', 'req', 'context', 'event', 22, 'API Route 함수의 첫 번째 인자는 요청 정보를 담고 있는 `req`(Request) 객체이다.'),
                                                                                                                           (1084, 'Next.js API Route 핸들러 함수의 두 번째 파라미터는 무엇인가?', 1, 'low', 'res', 'data', 'ctx', 'params', 22, '`res`(Response)는 API 응답을 구성할 때 사용하는 두 번째 인자이다.'),
                                                                                                                           (1085, 'Next.js API Route에서 클라이언트에 JSON 응답을 보내는 방법은?', 3, 'medium', 'res.end()', 'res.send()', 'res.json()', 'res.write()', 22, '`res.json()`은 객체를 JSON 형식으로 직렬화하여 클라이언트에 응답을 보낼 때 사용한다.'),
                                                                                                                           (1086, 'Next.js API Route에서 요청 메서드에 따라 분기할 때 사용하는 속성은?', 1, 'medium', 'req.method', 'req.type', 'req.query', 'req.header', 22, '`req.method`는 HTTP 요청의 메서드(GET, POST 등)를 문자열로 제공하므로 조건 분기에 사용된다.'),
                                                                                                                           (1087, 'Next.js API Route의 파일 이름이 [id].js일 때 의미하는 것은?', 2, 'medium', '정적 파일', '동적 라우트', 'SSR 페이지', 'API Fetch용 파일', 22, '대괄호 `[]`는 파일명을 파라미터로 인식하여 동적 라우팅이 가능하게 한다.'),
                                                                                                                           (1088, 'API Route를 통해 서버 측에서 환경 변수를 사용하는 파일은?', 2, 'high', '.gitignore', '.env.local', 'package.json', 'server.js', 22, '`.env.local`은 환경 변수 설정 파일이며, Next.js 서버 환경에서만 노출된다.'),
                                                                                                                           (1089, 'Next.js API Route에서 404 에러를 반환할 때 사용하는 응답 코드는?', 3, 'high', '200', '500', '404', '401', 22, '`404`는 요청한 리소스가 존재하지 않을 때 사용하는 표준 응답 코드이다.'),
                                                                                                                           (1090, 'API Route를 클라이언트 컴포넌트에서 호출할 때 가장 일반적으로 사용하는 함수는?', 1, 'high', 'fetch()', 'axios()', 'getServerSideProps()', 'useRouter()', 22, '클라이언트에서 API 요청을 보낼 때는 브라우저 내장 함수인 `fetch()`를 주로 사용한다.'),
                                                                                                                           (1091, 'Next.js에서 이미지 최적화를 위해 사용하는 컴포넌트는?', 2, 'low', '<img>', '<Image>', '<NextImage>', '<OptimizedImage>', 22, '`<Image>`는 Next.js가 제공하는 최적화된 이미지 컴포넌트로, 자동 크기 조절과 포맷 최적화를 지원한다.'),
                                                                                                                           (1092, 'Next.js에서 동적 import를 위해 사용하는 함수는?', 2, 'low', 'import()', 'dynamic()', 'load()', 'asyncImport()', 22, '`dynamic()` 함수는 코드 스플리팅을 위해 컴포넌트를 동적으로 import할 때 사용된다.'),
                                                                                                                           (1093, 'Next.js에서 코드 스플리팅을 기본으로 지원하는 이유는?', 1, 'low', '페이지 별로 코드를 나누어 로딩 속도 개선', '코드를 한 파일로 모으기 위해', '네트워크 트래픽 증가를 위해', 'SEO를 위해', 22, '페이지 단위의 코드 스플리팅을 통해 초기 로딩 속도를 줄이고 사용자 경험을 개선할 수 있다.'),
                                                                                                                           (1094, 'Next.js에서 PWA 지원을 위해 추가로 설치할 수 있는 패키지는?', 1, 'medium', 'next-pwa', 'next-seo', 'next-analytics', 'next-cloud', 22, '`next-pwa`는 Next.js 프로젝트를 Progressive Web App으로 전환하는 데 사용하는 공식 패키지이다.'),
                                                                                                                           (1095, 'Next.js의 Head 컴포넌트를 제공하는 패키지는?', 1, 'medium', 'next/head', 'react-helmet', 'next-helmet', 'head-next', 22, 'Next.js는 `<Head>` 컴포넌트를 통해 문서의 head 영역을 구성할 수 있으며, `next/head`에서 제공된다.'),
                                                                                                                           (1096, 'Next.js에서 글로벌 CSS 파일은 어디에 import해야 하는가?', 2, 'medium', '모든 컴포넌트 파일', 'pages/_app.js', 'pages/index.js', 'next.config.js', 22, '글로벌 CSS는 `pages/_app.js`에 한 번만 import해야 중복 없이 전체에 적용된다.'),
                                                                                                                           (1097, 'Next.js에서 Static 파일을 최적화하려면 사용하는 디렉토리는?', 2, 'high', 'src/static', 'public/', 'static/', 'staticFiles/', 22, '`public/` 디렉토리는 정적 파일 제공을 위한 Next.js의 기본 경로이며, 최적화에 자동 적용된다.'),
                                                                                                                           (1098, 'Next.js에서 외부 API 요청을 서버 측에서 미리 처리하고 싶을 때 사용하는 기능은?', 2, 'high', 'getStaticProps', 'getServerSideProps', 'getInitialProps', 'serverFetch', 22, '`getServerSideProps`는 서버 요청 시마다 데이터를 새로 받아 렌더링하는 방식으로 외부 API 요청에 적합하다.'),
                                                                                                                           (1099, 'Next.js 프로젝트를 Vercel에 배포할 때 특별한 설정이 필요한가?', 1, 'high', '필요 없다', 'next.config.js 수정 필요', '환경 변수를 수동 설정', '전용 서버 설정 필요', 22, 'Vercel은 Next.js의 제작사에서 운영하므로 별도 설정 없이 최적화된 배포 환경을 자동 제공한다.'),
                                                                                                                           (1100, 'Next.js에서 기본적으로 지원하는 SEO 관련 최적화는 무엇인가?', 4, 'high', '정적 페이지 생성', 'Server-side Rendering', '코드 스플리팅', '위 모든 것', 22, 'Next.js는 SEO 최적화를 위한 다양한 기능(SSG, SSR, 코드 스플리팅)을 기본적으로 지원한다.'),
                                                                                                                           (1101, 'Vue 템플릿에서 데이터 바인딩을 위한 기본 구문은?', 1, 'low', '{{  }}', '[[  ]]', '{{{  }}}', '(())', 23, '`{{ }}` 구문은 Vue에서 데이터를 HTML에 출력하기 위한 기본 보간법이다.'),
                                                                                                                           (1102, 'Vue 인스턴스를 생성할 때 가장 먼저 호출되는 라이프사이클 훅은?', 1, 'low', 'beforeCreate', 'created', 'mounted', 'beforeMount', 23, '`beforeCreate`는 Vue 인스턴스가 생성되기 직전에 실행되는 최초의 라이프사이클 훅이다.'),
                                                                                                                           (1103, '템플릿에서 HTML 특수문자를 이스케이프하지 않고 그대로 출력하려면 사용하는 구문은?', 1, 'low', 'v-html="rawHtml"', '{{ rawHtml }}', 'v-bind:html="rawHtml"', 'v-text="rawHtml"', 23, '`v-html` 디렉티브는 HTML을 문자열 그대로 해석하여 DOM에 삽입한다.'),
                                                                                                                           (1104, '다음 중 Vue 템플릿에 JavaScript 표현식을 사용할 수 없는 위치는?', 3, 'medium', 'v-bind 디렉티브 값', 'v-on 디렉티브 핸들러', '속성 이름(attribute key)', '텍스트 보간(interpolation) 안', 23, 'HTML의 속성 이름은 정적으로 해석되기 때문에 JavaScript 표현식을 사용할 수 없다.'),
                                                                                                                           (1105, 'v-bind:class에 객체를 전달할 때, 클래스가 적용되는 조건은?', 1, 'medium', '키에 대응하는 값이 true일 때', '키가 문자열이 아닐 때', '값이 null일 때', '객체 길이가 0일 때', 23, '객체의 각 키는 클래스 이름이 되고, 값이 true인 경우 해당 클래스가 적용된다.'),
                                                                                                                           (1106, 'data 옵션에서 함수가 아닌 객체를 반환하면 발생하는 문제는?', 1, 'medium', '모든 인스턴스가 동일 객체를 공유해 반응성 오류', '템플릿 파싱이 실패하여 빌드 중단', 'watcher가 자동으로 해제됨', 'props 전달이 차단됨', 23, 'data가 객체를 반환하지 않으면 모든 컴포넌트 인스턴스가 동일 객체를 공유하여 버그가 발생할 수 있다.'),
                                                                                                                           (1107, '‘this.message’가 DOM에 반영되는 시점은? (mounted 훅 내부에서 변경)', 1, 'high', 'mounted 훅 직후에 반영된다', 'nextTick 이후 첫 렌더링 때 반영된다', 'updated 훅 이후에만 반영된다', 'DOM에는 절대 반영되지 않는다', 23, '`mounted` 이후 변경된 데이터는 DOM 업데이트 큐에 등록되어 즉시 반영된다.'),
                                                                                                                           (1108, '템플릿에서 v-bind 축약형으로 올바른 것은?', 1, 'high', ':title="msg"', '.bind(title)="msg"', '@bind:title="msg"', '#title="msg"', 23, '`:`는 `v-bind:`의 축약형으로 속성에 값을 바인딩할 때 사용된다.'),
                                                                                                                           (1109, 'v-on:click="count++" 구문이 예상대로 동작하려면 count는 어디에 있어야 하는가?', 1, 'high', 'data()가 반환하는 객체', 'methods 안', 'computed 안', 'watch 안', 23, '`count`는 반응형 데이터로 선언되어야 하므로 `data()`의 반환 객체에 존재해야 한다.'),
                                                                                                                           (1110, '다음 중 인스턴스 옵션 중 필수가 아닌 것은?', 1, 'high', 'methods', 'data', 'el / mount 대상', 'template 또는 render', 23, '`methods`는 인스턴스의 동작을 정의하지만, 필수는 아니며 없을 수도 있다.'),
                                                                                                                           (1111, 'Vue 반응형 시스템의 핵심 개념은?', 1, 'low', '데이터 변경 ↔ DOM 자동 동기화', '가상 DOM을 직접 조작', '양방향 바인딩 없는 단방향 흐름', 'DOM 변화를 수동으로 감지', 23, 'Vue의 반응형 시스템은 데이터가 변경되면 DOM이 자동으로 동기화되어 개발자가 DOM을 직접 조작할 필요가 없다는 점이 핵심입니다.'),
                                                                                                                           (1112, '계산된 속성(computed)의 특징은?', 1, 'low', '의존 데이터가 변할 때만 재평가', '무조건 매 렌더링마다 실행', 'DOM 이벤트 발생 시에만 실행', '블로킹 I/O를 자동 회피', 23, 'computed는 의존하는 반응형 데이터가 변경될 때만 재평가되어 불필요한 계산을 줄입니다.'),
                                                                                                                           (1113, 'Vue 3에서 ref(0)으로 반환되는 값의 내부 형식은?', 1, 'low', '객체 { value: 0 } (Proxied)', 'Proxy 함수', '숫자 0 그 자체', 'WeakMap', 23, 'ref로 감싸면 내부적으로 { value: 0 } 형태의 객체가 생성되어 반응성을 갖습니다.'),
                                                                                                                           (1114, 'watch와 computed의 주요 차이점으로 올바른 것은?', 1, 'medium', 'watch는 부수 효과(side-effect) 실행용', 'watch는 캐싱된 결과를 반환', 'computed는 비동기 호출만 지원', 'computed는 의존성 추적을 하지 않음', 23, 'watch는 데이터 변화에 따른 부수 효과를 실행하기 위한 용도로 사용되며, computed는 값 반환에 중점을 둡니다.'),
                                                                                                                           (1115, 'reactive()에 전달해도 반응형이 되지 않는 값은?', 1, 'medium', 'Map 또는 Set', '평범한 Object', '배열(Array)', '중첩 객체가 없는 null-free 리터럴', 23, 'Vue의 reactive는 Map과 Set 같은 컬렉션 객체를 반응형으로 처리하지 못합니다.'),
                                                                                                                           (1116, 'DOM 갱신 후 실행하려면 다음 코드 뒤에 무엇을 해야 하는가? count.value++;', 1, 'medium', 'await nextTick() 뒤에 console.log 실행', 'flushSync()로 감싼다', 'watchEffect 안에서 실행', 'count.value += 0 으로 강제 트리거', 23, 'nextTick을 사용하면 DOM 업데이트가 완료된 후의 시점에서 코드를 실행할 수 있습니다.'),
                                                                                                                           (1117, 'Vue 3 반응형 시스템이 Vue 2의 defineProperty 대신 사용하는 기술은?', 1, 'high', 'ES6 Proxy', 'MutationObserver', 'WeakRef', 'Reflect.metadata', 23, 'Vue 3는 Proxy를 사용하여 객체의 모든 조작을 감지할 수 있어 더 정교한 반응형 처리가 가능합니다.'),
                                                                                                                           (1118, 'shallowReactive()를 사용할 때의 이점은?', 1, 'high', '루트 레벨만 반응형으로 만들어 메모리·성능 절약', '깊은 중첩 객체까지 자동 추적', 'ref와 동일한 API 제공', 'Computed 속성을 자동 생성', 23, 'shallowReactive는 최상위 속성만 반응형으로 만들어 불필요한 성능 낭비를 줄일 수 있습니다.'),
                                                                                                                           (1119, 'watch 구성에서 deep:true, immediate:true가 비효율적인 경우는?', 1, 'high', '변경 폭이 큰 대용량 중첩 객체를 감시', '원시형(ref) 값을 감시', 'deep 옵션 false', 'immediate false', 23, '대용량 중첩 객체에 deep:true와 immediate:true를 사용하면 초기 실행과 반복 평가로 인해 성능이 저하됩니다.'),
                                                                                                                           (1120, 'watchEffect가 watch보다 적합한 상황은?', 1, 'high', '의존 대상을 명시하기 힘든 복합 반응형 로직', '특정 하나의 ref 변경에만 반응', '비동기 API 호출 후 에러 처리', 'props 유효성 검증', 23, 'watchEffect는 명시적으로 추적 대상을 지정하지 않아도 자동으로 추적하므로 복잡한 의존성 구조에 적합합니다.'),
                                                                                                                           (1121, '요소를 조건부로 렌더링하기 위한 기본 디렉티브는?', 1, 'low', 'v-if', 'v-for', 'v-bind', 'v-html', 23, 'v-if는 조건에 따라 DOM 요소의 생성 여부를 제어할 수 있는 대표적인 디렉티브입니다.'),
                                                                                                                           (1122, '리스트 렌더링에 사용하는 디렉티브는?', 1, 'low', 'v-for', 'v-show', 'v-model', 'v-once', 23, 'v-for는 배열이나 객체의 항목을 반복하여 렌더링할 때 사용됩니다.'),
                                                                                                                           (1123, '양방향 폼 바인딩을 제공하는 디렉티브는?', 1, 'low', 'v-model', 'v-text', 'v-pre', 'v-slot', 23, 'v-model은 사용자 입력 값과 데이터 상태를 자동으로 동기화해주는 양방향 바인딩 디렉티브입니다.'),
                                                                                                                           (1124, 'v-show 디렉티브의 특징으로 올바른 것은?', 1, 'medium', 'DOM을 한 번만 렌더링하고 display 속성을 토글', '조건이 false면 노드를 아예 생성하지 않는다', '렌더 비용이 v-if보다 높다', '서버 사이드 렌더링에서만 사용된다', 23, 'v-show는 DOM 요소를 렌더링한 뒤 display 속성을 변경해 보여줍니다.'),
                                                                                                                           (1125, 'v-bind .camel 수식어 기능은?', 1, 'medium', 'kebab-case 속성명을 camelCase로 변환', '문자열 값을 자동으로 number로 변환', 'HTML을 이스케이프하지 않고 출력', 'true 값을 전달하면 속성을 제거', 23, '.camel 수식어는 HTML 속성에서 camelCase가 필요한 경우에 사용됩니다.'),
                                                                                                                           (1126, 'mounted 훅은 언제 호출되는가?', 1, 'medium', 'DOM 삽입 직후 최초 한 번', 'updated 훅 직후', '컴포넌트 생성 직후', 'beforeUnmount 직전', 23, 'mounted는 컴포넌트가 실제 DOM에 삽입된 직후 한 번 호출됩니다.'),
                                                                                                                           (1127, '컴포넌트 제거 직전에 호출되는 훅은?', 1, 'high', 'beforeUnmount', 'unmounted', 'beforeUpdate', 'errorCaptured', 23, 'beforeUnmount는 컴포넌트가 DOM에서 제거되기 직전에 호출됩니다.'),
                                                                                                                           (1128, 'Composition API에서 DOM 삽입 후 실행 훅 등록 함수는?', 1, 'high', 'onMounted', 'onBeforeMount', 'useMounted', 'setupMounted', 23, 'onMounted는 Composition API에서 컴포넌트가 마운트된 후 실행할 함수를 등록합니다.'),
                                                                                                                           (1129, 'v-on .capture 수식어 역할은?', 1, 'high', '이벤트를 캡처 단계에서 처리', '이벤트 버블링 중단', '수신 이벤트를 상위로 전파', '리스너를 한 번만 실행', 23, '.capture는 이벤트 캡처 단계에서 핸들러가 호출되도록 지정합니다.'),
                                                                                                                           (1130, '@keyup.enter 수식어 의미는?', 1, 'high', 'Enter 키가 눌렸을 때만 keyup 핸들러 실행', 'keyup 이벤트 캡처 단계', 'Enter 키 아닌 경우 전파 중단', 'keydown 이벤트 변환', 23, 'enter 수식어는 Enter 키가 눌릴 때만 이벤트 핸들러를 실행하도록 제한합니다.'),
                                                                                                                           (1131, '부모 → 자식 데이터 전달 메커니즘은?', 1, 'low', 'props', 'slots', 'provide/inject', '$refs', 23, 'props는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 기본 메커니즘입니다.'),
                                                                                                                           (1132, '자식이 부모에게 값을 전달할 때 호출하는 메서드는?', 1, 'low', '$emit', '$dispatch', '$broadcast', '$send', 23, '자식 컴포넌트는 이벤트를 $emit으로 발생시켜 부모에게 데이터를 전달할 수 있습니다.'),
                                                                                                                           (1133, '기본(이름 없는) 슬롯 태그는?', 1, 'low', '<slot>', '<slot name="default">', '<template #default>', '<slot-default>', 23, '기본 슬롯은 별도의 이름 없이 <slot> 태그로 정의됩니다.'),
                                                                                                                           (1134, 'props 타입 유효성 검사 키는?', 1, 'medium', 'type', 'validator', 'required', 'default', 23, 'type 키는 props의 타입을 지정하고 유효성 검사를 수행합니다.'),
                                                                                                                           (1135, '전역 컴포넌트 등록 API는?', 1, 'medium', 'app.component()', 'Vue.use()', 'defineComponent()', 'createRenderer()', 23, 'Vue 3에서는 전역 컴포넌트 등록 시 app.component()를 사용합니다.'),
                                                                                                                           (1136, '스코프드 슬롯 템플릿 축약은?', 1, 'medium', '<template #item="slotProps">', '<slot name="item" :slotProps>', '<slot v-bind="item">', '<template v-slot:itemProps>', 23, '<template #name="props"> 형태로 스코프드 슬롯을 간단하게 선언할 수 있습니다.'),
                                                                                                                           (1137, 'prop 값을 직접 변경 시 결과는?', 1, 'high', 'Vue가 경고 출력, 변경은 반응형 아님', '부모 원본 데이터 즉시 변경', '변경 허용되나 반응성 깨짐', '런타임 에러 발생', 23, 'props를 자식에서 직접 변경하면 Vue는 이를 감지하고 경고를 출력합니다.'),
                                                                                                                           (1138, 'Composition API 자식이 v-model 지원하려면 emit 이벤트는?', 1, 'high', 'update:modelValue', 'modelValue', 'input', 'change:model', 23, 'v-model을 Composition API에서 사용하려면 update:modelValue 이벤트를 emit해야 합니다.'),
                                                                                                                           (1139, 'provide/inject 값을 반응형 유지하려면?', 1, 'high', 'reactive() 또는 ref()로 래핑한 값 제공', '원시 값 제공', 'JSON 직렬화', 'watchEffect 반환', 23, 'provide에서 reactive 또는 ref로 감싼 값을 넘겨야 자식에서도 반응형으로 유지됩니다.'),
                                                                                                                           (1140, '슬롯 설명 중 틀린 것은?', 4, 'high', '슬롯 콘텐츠는 부모 범위에서 컴파일', '동일 컴포넌트 슬롯 이름은 유일', 'fallback 콘텐츠는 슬롯 비어 있을 때 표시', '스코프드 슬롯에서 자식→부모 데이터', 23, '스코프드 슬롯은 자식이 부모에게 데이터를 전달하는 방식이 아니라, 부모가 자식의 데이터를 참조하는 방식입니다.'),
                                                                                                                           (1141, 'Angular CLI에서 프로덕션용 번들을 생성하려면 어떤 명령을 사용해야 하는가?', 1, 'low', 'ng build --configuration production', 'ng serve --prod', 'ng deploy --prod', 'ng compile --prod', 23, '프로덕션용 번들을 생성하는 공식적인 Angular CLI 명령은 ng build --configuration production 입니다.'),
                                                                                                                           (1142, 'Angular의 Ahead-of-Time 컴파일(AOT) 주된 장점은?', 1, 'low', '런타임에 컴파일 오버헤드가 제거되어 초기 로드 속도가 빨라진다', '템플릿 문법 오류를 무시하고 빌드를 계속한다', '의존성 주입을 비활성화해 번들 크기를 줄인다', '개발 서버가 자동 재시작된다', 23, 'AOT는 컴파일을 빌드 시점에 수행하여 런타임 비용을 줄이고 초기 로딩 속도를 향상시킵니다.'),
                                                                                                                           (1143, 'Angular 16의 기본 렌더러(컴파일러)로 채택된 엔진은?', 1, 'low', 'Ivy', 'View Engine', 'Renderer2', 'Zone.js', 23, 'Ivy는 Angular 9부터 기본 렌더러로 도입되었으며 Angular 16에서도 기본으로 사용됩니다.'),
                                                                                                                           (1144, 'Jasmine 단위 테스트에서 비동기 호출 완료를 알리기 위해 주입하는 헬퍼는?', 1, 'medium', 'done() 콜백', 'fixture.detectChanges()', 'fakeAsync()', 'flushMicrotasks()', 23, 'done()은 비동기 테스트에서 테스트 종료 시점을 명시하는 콜백입니다.'),
                                                                                                                           (1145, 'Angular PWA 변환을 자동으로 설정해 주는 CLI 스키매틱 명령은?', 1, 'medium', 'ng add @angular/pwa', 'ng generate pwa', 'ng init --pwa', 'ng add service-worker', 23, 'ng add @angular/pwa는 필요한 모듈과 설정을 자동으로 추가해 PWA 구성을 돕습니다.'),
                                                                                                                           (1146, '앱을 국제화(i18n) 빌드할 때 locale 별 번들을 만들도록 지정하는 CLI 플래그는?', 1, 'medium', '--localize', '--i18n', '--translate', '--locale-build', 23, '--localize 플래그는 각 언어에 맞는 번들을 생성하여 다국어 지원을 가능하게 합니다.'),
                                                                                                                           (1147, '앱 전반에 걸쳐 사용되지 않는 코드가 번들에 포함되지 않도록 하는 Webpack/CLI 최적화 기법은?', 1, 'high', 'Tree shaking', 'Code splitting', 'Inlining', 'Polyfilling', 23, 'Tree shaking은 사용되지 않는 코드(Dead Code)를 제거하여 번들 크기를 줄이는 최적화 기법입니다.'),
                                                                                                                           (1148, 'Angular Universal을 사용해 서버 사이드 렌더링(SSR)을 도입하면 얻는 직접적 이점으로 옳은 것은?', 1, 'high', '초기 HTML이 완성되어 SEO와 첫 콘텐츠 페인트(FCP)가 개선된다', '브라우저 번들 크기가 자동으로 50% 감소한다', 'Ivy가 비활성화되어 빌드 속도가 빨라진다', 'RxJS 의존성이 제거된다', 23, 'SSR은 완성된 HTML을 제공하므로 SEO 향상과 초기 로딩 속도 개선에 도움이 됩니다.'),
                                                                                                                           (1149, 'ng test 명령이 기본적으로 사용하는 테스트 러너는?', 1, 'high', 'Karma', 'Jest', 'Mocha', 'Vitest', 23, 'Angular CLI에서 기본으로 사용하는 테스트 러너는 Karma입니다.'),
                                                                                                                           (1150, 'Angular CLI 빌드 시 하위 브라우저용 ES5 코드 번들을 자동 생성해 주는 기능은?', 1, 'high', 'Differential loading', 'Lazy chunk preloading', 'Webpack module federation', 'Inline critical CSS', 23, 'Differential loading은 브라우저에 따라 다른 코드 번들을 생성하여 호환성과 성능을 개선합니다.'),
                                                                                                                           (1151, '클라이언트 잘못된 요청(예: JSON 스키마 위반)에 대한 권장 HTTP 상태 코드는?', 1, 'low', '400 Bad Request', '401 Unauthorized', '500 Internal Server Error', '409 Conflict', 24, '400은 클라이언트의 요청이 잘못되었음을 나타내는 대표적인 상태 코드입니다.'),
                                                                                                                           (1152, '인증 헤더가 누락된 요청에 서버가 반환해야 할 표준 상태 코드는?', 1, 'low', '401 Unauthorized', '403 Forbidden', '412 Precondition Failed', '502 Bad Gateway', 24, '401은 인증이 필요하나 제공되지 않았을 때 반환되는 상태 코드입니다.'),
                                                                                                                           (1153, 'REST API에서 존재하지 않는 리소스에 대한 GET 요청 시 적절한 응답 코드는?', 1, 'low', '404 Not Found', '410 Gone', '204 No Content', '422 Unprocessable Entity', 24, '404는 요청한 리소스가 서버에 존재하지 않음을 의미합니다.'),
                                                                                                                           (1154, 'RFC 7807 ‘Problem Details for HTTP APIs’가 권장하는 기본 Content-Type은?', 1, 'medium', 'application/problem+json', 'application/json; problem', 'text/problem', 'application/vnd.error+json', 24, 'RFC 7807에서는 오류 응답 형식으로 application/problem+json을 명시적으로 권장합니다.'),
                                                                                                                           (1155, 'RFC 7807 JSON 응답 예시에서 반드시 포함해야 하는 필드는?', 1, 'medium', 'title', 'instance', 'detail', 'errors', 24, 'title은 오류 상황을 요약하는 필수 필드이며 사용자에게 즉시 보여줄 수 있습니다.'),
                                                                                                                           (1156, '다음 중 4xx와 5xx 상태 코드 차이에 대한 설명으로 옳지 않은 것은?', 4, 'medium', '4xx는 클라이언트 오류, 5xx는 서버 오류를 나타낸다', '5xx는 재시도 가능성이 4xx보다 높다', '4xx 오류라도 Problem Details 바디를 포함할 수 있다', '4xx는 절대 재시도해서는 안 된다', 24, '4xx 오류라도 사용자의 조치로 재시도가 가능한 경우가 있어 "절대 재시도 금지"는 잘못된 설명입니다.'),
                                                                                                                           (1157, '동일 자원 중복 생성 시 서버가 반환해도 멱등성 규칙을 깨지지 않는 상태 코드는?', 1, 'high', '409 Conflict', '201 Created', '202 Accepted', '302 Found', 24, '409는 이미 존재하는 리소스를 다시 생성하려 할 때 발생하므로 멱등성은 유지됩니다.'),
                                                                                                                           (1158, 'Problem Details 바디에 커스텀 ‘code’ 정수 필드를 두는 주된 이점은?', 1, 'high', '클라이언트가 로컬라이징 메시지를 매핑하기 쉽다', 'HTTP 상태 코드 전송을 생략할 수 있다', 'JSON 패싱을 건너뛸 수 있다', 'CORS 프리플라이트를 우회한다', 24, '커스텀 code 필드는 다국어 메시지 매핑 및 클라이언트 오류 분류에 유리합니다.'),
                                                                                                                           (1159, '다음 중 idempotent 메서드가 아닌 것은?', 1, 'high', 'POST', 'PUT', 'DELETE', 'HEAD', 24, 'POST는 호출할 때마다 리소스가 생성되므로 멱등하지 않습니다.'),
                                                                                                                           (1160, '클라이언트가 429 Too Many Requests 응답을 받을 때 재시도 시점을 알기 위해 확인해야 하는 헤더는?', 1, 'high', 'Retry-After', 'Warning', 'WWW-Authenticate', 'Content-Encoding', 24, 'Retry-After 헤더는 재시도 가능한 시간을 명시하여 클라이언트가 과도한 요청을 피하게 합니다.'),
                                                                                                                           (1161, '브라우저 네트워크 오류 vs HTTP 오류 구분 방법은?', 1, 'low', '응답 없음 & error.request 존재 → 네트워크 오류', 'status 0이면 HTTP 오류', 'message에 Network Error 포함 시 HTTP 오류', 'https로 시작시 네트워크 오류 없음', 24, '응답이 없고 error.request 객체가 존재하면 HTTP 요청은 성공하지 못한 네트워크 오류입니다.'),
                                                                                                                           (1162, '422 오류 UX 비추천 패턴은?', 1, 'low', '모달 전체 가리고 중앙만 오류', '필드 인라인 표시', '폼 상단 요약', '스낵바 알림', 24, '모달로 전체를 가리는 오류 처리는 사용자 경험을 방해하므로 권장되지 않습니다.'),
                                                                                                                           (1163, '전역 오류 핸들러 역할은?', 1, 'low', '로그인 만료 등 공통 처리', '레이아웃 교체', 'CSS 초기화', 'History 재설정', 24, '전역 오류 핸들러는 인증 만료, 네트워크 오류 등 전체 앱에서 공통적으로 처리할 이슈에 사용됩니다.'),
                                                                                                                           (1164, '오프라인 GET 요청 전략은?', 1, 'medium', '대기열 저장 후 복구 시 재시도', '캐시 비우고 에러', '503 구성', '무한 로딩', 24, '요청을 대기열에 저장하고 네트워크 복구 시 재시도하면 사용자 경험을 향상시킬 수 있습니다.'),
                                                                                                                           (1165, 'Error Boundary 해결 문제는?', 1, 'medium', '렌더 예외로 인한 흰 화면', 'API 500 재시도', 'CORS 차단', 'WebSocket', 24, 'Error Boundary는 렌더링 도중 발생하는 예외로 인한 앱 중단을 방지하기 위한 기술입니다.'),
                                                                                                                           (1166, '중복 POST 방지 클라이언트 조치?', 1, 'medium', '이전 요청 취소 AbortController', 'Cache-Control no-store', 'POST→GET', '로그 제거', 24, 'AbortController를 사용하면 이전 요청을 취소하여 중복 전송을 방지할 수 있습니다.'),
                                                                                                                           (1167, 'axios 취소 vs 네트워크 오류 구분 프로퍼티?', 1, 'high', 'error.code === ''ERR_CANCELED''', 'message 포함 Network', 'status -1', 'timeout 0', 24, 'axios는 요청 취소 시 error.code를 ''ERR_CANCELED''로 설정하므로 구분이 가능합니다.'),
                                                                                                                           (1168, '국제화 오류 메시지 비추천 방법은?', 1, 'high', '서버가 완제품 문구 제공', '클라이언트 코드 매핑', 'title/detail 키 사용', '템플릿 변수 치환', 24, '서버에서 완제품 문구를 제공하면 클라이언트에서 다국어 처리가 어렵고 유지보수가 어렵습니다.'),
                                                                                                                           (1169, '모바일 에러/재요청 데이터 최소화 우선 고려는?', 1, 'high', '오프라인 감지 후 백오프', '해상도 다운', '캐시 삭제', 'UDP 강제', 24, '오프라인 상황을 감지하고 재시도 요청을 지연(백오프)하면 불필요한 데이터 소모를 줄일 수 있습니다.'),
                                                                                                                           (1170, '사용자 메시지+디버그 정보 구조 권장?', 1, 'high', 'UI 요약 & 콘솔 raw trace', 'alert 모두', '서버 HTML 오류 페이지', '쿠키 저장', 24, '사용자에게는 간결한 메시지를, 개발자에게는 콘솔에 자세한 디버깅 정보를 제공하는 구조가 바람직합니다.'),
                                                                                                                           (1171, '멱등 메서드는?', 1, 'low', 'PUT', 'POST', 'PATCH', 'CONNECT', 24, 'PUT은 여러 번 호출하더라도 리소스 상태가 동일하게 유지되어 멱등성을 가집니다.'),
                                                                                                                           (1172, '고정 3초 4번 총 지연?', 1, 'low', '12초', '9초', '6초', '3초', 24, '3초씩 4번의 지연은 총 3×4 = 12초의 누적 지연입니다.'),
                                                                                                                           (1173, '지수 1s 배수2 3회 누적?', 1, 'medium', '7 s', '6 s', '5 s', '4 s', 24, '1초, 2초, 4초 지연을 합치면 총 7초입니다.'),
                                                                                                                           (1174, 'Retry-After 120 권장 재시도?', 1, 'medium', '120초 이상 후', '60초', '즉시', '무시', 24, 'Retry-After는 지정된 시간 이후에 요청하라는 의미로, 120초 후 재시도가 적절합니다.'),
                                                                                                                           (1175, 'POST 안전 재시도 보완책?', 1, 'medium', 'Idempotency-Key 헤더', 'HTTP/2 업그레이드', '빈 바디', 'PUT 사용', 24, 'Idempotency-Key를 사용하면 POST 요청도 멱등하게 만들어 중복 처리를 방지할 수 있습니다.'),
                                                                                                                           (1176, '재시도 고려 가능한 408/409?', 1, 'medium', '408 Request Timeout', '409 Conflict', '400', '401', 24, '408은 네트워크 문제로 인한 타임아웃이므로 재시도가 유효할 수 있습니다.'),
                                                                                                                           (1177, 'Full Jitter 목적은?', 1, 'high', '서버 폭주 완화', '총 지연 줄임', 'TCP 우회', 'TLS 감소', 24, 'Full Jitter는 클라이언트들이 동시에 재시도하는 것을 방지하여 서버에 대한 부하를 줄입니다.'),
                                                                                                                           (1178, '재시도 불가 오류 유형?', 1, 'high', '400 필드 검증', '502', '408', '429', 24, '400 오류는 클라이언트 요청 자체가 잘못된 경우로, 재시도해도 성공할 가능성이 없습니다.'),
                                                                                                                           (1179, '조건부 PUT 재시도 안전 이유?', 1, 'high', 'ETag 버전 동일 시만 수행', 'PUT 캐싱', 'HTTP/3 전용', '브라우저 보장', 24, 'ETag를 이용한 조건부 요청은 리소스 상태가 바뀌지 않은 경우에만 수행되므로 안전합니다.'),
                                                                                                                           (1180, '모바일 TCP 끊김 POST 문제 감소?', 1, 'high', '짧은 타임아웃 + 멱등 키', 'HTTP 1.0', '재시도 끔', '인증 제거', 24, '짧은 타임아웃으로 빠르게 실패하고 멱등 키로 재시도 시 중복을 방지할 수 있습니다.'),
                                                                                                                           (1181, 'Circuit Closed→Open 조건?', 1, 'low', '연속 실패 임계', '성공 200', '301', '쿠키 만료', 24, 'Circuit Breaker는 연속 실패 횟수가 임계치를 넘으면 Open 상태로 전환됩니다.'),
                                                                                                                           (1182, 'Half-Open 성공 전이?', 1, 'low', 'Closed', 'Open', 'Forced-Open', 'Isolated', 24, 'Half-Open 상태에서 요청이 성공하면 Circuit은 Closed 상태로 복구됩니다.'),
                                                                                                                           (1183, 'Open 상태 바로 실패 목적?', 1, 'low', '백엔드 부하 차단', '캐시 무효', 'TLS 시간 줄임', 'DNS 재해석', 24, 'Open 상태에서는 요청을 차단하여 백엔드에 부하가 전파되는 것을 방지합니다.'),
                                                                                                                           (1184, '재시도+CB 충돌 위험?', 1, 'medium', '과도 재시도→즉시 Open', 'Jitter 제거', 'Retry-After 무시', 'HTTP/2 끊김', 24, '재시도가 과도하면 CB가 Open되어 더 많은 요청이 차단되며 악순환이 발생할 수 있습니다.'),
                                                                                                                           (1185, 'Coalescing 효과 시나리오?', 1, 'medium', '같은 리소스 다수 GET', '다른 POST', 'WebSocket', 'SSE', 24, 'Coalescing은 같은 리소스에 대한 중복 GET 요청을 통합하여 네트워크 효율을 높입니다.'),
                                                                                                                           (1186, 'Equal Jitter 이점 아닌 것?', 2, 'medium', '스파이크 완화', '최대/최소 지연 예측', 'Full Jitter보다 대기 줄임', '서버 완화', 24, 'Equal Jitter는 일정한 예측 지연 범위를 제공하지만 Full Jitter보다 항상 대기 시간이 짧은 것은 아닙니다.'),
                                                                                                                           (1187, 'Fallback 전략 사례?', 1, 'high', '캐시된 데이터로 표시', '재시도 0', 'CB 강제 Close', 'Retry-After 무시', 24, '백엔드 실패 시 캐시 데이터를 사용하는 것은 전형적인 Fallback 전략입니다.'),
                                                                                                                           (1188, 'Hedged Request 주의점?', 1, 'high', '멱등 보장 필요', 'DNS TTL 0', 'KEEP-ALIVE 끊기', 'TLS 1.3', 24, 'Hedged Request는 동일 요청을 병렬로 보내므로 멱등성이 보장되어야 부작용을 방지할 수 있습니다.'),
                                                                                                                           (1189, 'Max-Retry-TTL 목적?', 1, 'high', '무제한 지연 방지', 'TCP FIN 감소', '브라우저 버그 회피', 'Keep-Alive 증가', 24, '최대 재시도 TTL 설정은 너무 긴 지연으로 인한 UX 악화를 방지합니다.'),
                                                                                                                           (1190, 'CB 실시간 튜닝 기법?', 1, 'high', 'Feature Flag 기반 임계 조정', '콘솔 변수', '헤더 하드코드', '빌드 상수', 24, 'Feature Flag를 이용하면 운영 중에도 조건을 변경할 수 있어 유연한 대응이 가능합니다.'),
                                                                                                                           (1191, '자주 쓰는 SLO 쌍은?', 1, 'low', '가용성·오류율', 'CPU·메모리', '빌드시간·커버리지', 'PR 리뷰', 24, 'SLO(Service Level Objective)는 일반적으로 가용성과 오류율 등 사용자 체감 품질 중심입니다.'),
                                                                                                                           (1192, 'P99 증가 의심 원인?', 1, 'low', '소수 요청 재시도 지연', '평균 느려짐', '404 급증', '로깅 오류', 24, '재시도로 인해 일부 요청의 응답 시간이 길어지면서 P99 지표가 상승할 수 있습니다.'),
                                                                                                                           (1193, '분산 추적 유용 이유?', 1, 'medium', 'Trace로 재시도 체인 시각화', '헤더 암호화', '로그 제거', '패킷 캡처', 24, 'Trace ID로 요청 흐름을 파악하면 재시도와 관련된 병목 지점을 분석할 수 있습니다.'),
                                                                                                                           (1194, 'Chaos 테스트 간단 도구?', 1, 'medium', 'MSW random error', 'CSS Lint', 'Bundle Analyzer', 'Lighthouse', 24, 'MSW를 통해 API 응답에 무작위 오류를 삽입하면 클라이언트 내결함성 테스트가 가능합니다.'),
                                                                                                                           (1195, '포스트모템 포함 아님?', 1, 'medium', '담당자 인적 정보', '타임라인', 'RCA', '재발 방지', 24, '포스트모템에는 재발 방지 방안과 RCA는 포함되지만, 담당자 개인 정보는 포함되지 않습니다.'),
                                                                                                                           (1196, '알림 임계 낮음 문제?', 1, 'high', 'Alert Fatigue', 'MTTR 증가', 'Slack→Email', 'Grafana 꺼짐', 24, '불필요한 경고가 많으면 알림에 무감각해지는 Alert Fatigue 현상이 발생합니다.'),
                                                                                                                           (1197, '롤아웃 안전 배포 전략?', 1, 'high', 'Feature Flag Gradual', 'Big-bang', 'Force-push', 'CI 캐시 무효', 24, 'Feature Flag를 이용한 점진적 배포는 위험을 최소화하며 안전한 롤아웃을 가능하게 합니다.'),
                                                                                                                           (1198, '로그 레벨 매핑?', 1, 'high', '시작 debug, 재시도 info, 실패 error', '모두 warn', '재시도 fatal', '성공 error', 24, '로그 레벨은 이벤트 중요도에 따라 구분해 적절히 기록하는 것이 유지보수에 유리합니다.'),
                                                                                                                           (1199, '슬라이딩 윈도우 오류율 이유?', 1, 'high', '즉시값 대신 경향 파악', '메트릭 안 삭제', '테스트 속도', '다크 테마', 24, '슬라이딩 윈도우는 일정 시간 동안의 오류율 평균을 유지해 안정적인 경향 분석이 가능합니다.'),
                                                                                                                           (1200, '오류율 상승 자동 롤백 기능은?', 1, 'high', 'Canary 분석 → rollback', 'Merge Queue', 'multi-stage build', 'npm postinstall', 24, 'Canary 배포 중 오류율이 기준치를 넘으면 자동으로 이전 버전으로 롤백할 수 있습니다.'),
                                                                                                                           (1201, 'Vue Test Utils는 어떤 프레임워크의 테스트를 지원하는가?', 3, 'low', 'React', 'Angular', 'Vue.js', 'Svelte', 25, 'Vue Test Utils는 Vue.js 컴포넌트를 테스트하기 위해 공식적으로 제공되는 도구입니다.'),
                                                                                                                           (1202, 'Vue Test Utils에서 컴포넌트를 마운트하는 기본 함수는?', 2, 'low', 'render()', 'mount()', 'create()', 'testMount()', 25, 'mount()는 실제 DOM에 컴포넌트를 마운트하여 전체 렌더링 테스트를 수행할 수 있게 합니다.'),
                                                                                                                           (1203, 'Vue Test Utils에서 ''wrapper''란 무엇을 의미하는가?', 1, 'low', '컴포넌트를 감싼 객체', '라우터 인스턴스', 'Vuex 스토어', '서버 인스턴스', 25, 'wrapper는 마운트된 컴포넌트를 감싸는 테스트 유틸 객체로 다양한 조작이 가능합니다.'),
                                                                                                                           (1204, 'Vue Test Utils를 사용하기 위해 반드시 필요한 테스트 러너는?', 2, 'medium', 'Jasmine', 'Mocha나 Jest', 'QUnit', 'AVA', 25, 'Vue Test Utils는 Mocha 또는 Jest 같은 JavaScript 테스트 러너와 함께 사용됩니다.'),
                                                                                                                           (1205, 'Vue Test Utils로 마운트된 컴포넌트를 검사할 수 있는 메서드는?', 2, 'medium', 'check()', 'find()', 'inspect()', 'query()', 25, 'find() 메서드는 컴포넌트 내 특정 요소를 선택하여 검사할 수 있게 해줍니다.'),
                                                                                                                           (1206, 'Vue Test Utils를 통해 컴포넌트의 텍스트를 얻을 때 사용하는 메서드는?', 2, 'medium', 'html()', 'text()', 'get()', 'query()', 25, 'text()는 선택된 요소의 텍스트 콘텐츠를 반환합니다.'),
                                                                                                                           (1207, 'Vue Test Utils에서 wrapper.vm은 무엇을 참조하는가?', 3, 'high', '뷰 루트 인스턴스', '테스트 파일', '컴포넌트의 Vue 인스턴스', '스토어 인스턴스', 25, 'wrapper.vm은 마운트된 컴포넌트의 실제 Vue 인스턴스를 참조합니다.'),
                                                                                                                           (1208, 'Vue Test Utils에서 ''setData()''의 역할은?', 2, 'high', 'props 설정', 'data 수동 수정', '컴포넌트 렌더링', '라우팅 변경', 25, 'setData()는 컴포넌트의 data 속성 값을 테스트 중 수동으로 변경할 때 사용됩니다.'),
                                                                                                                           (1209, 'Vue Test Utils의 ''trigger()'' 메서드는 어떤 역할을 하는가?', 2, 'high', '컴포넌트 생성', '이벤트 발생', '스토어 연결', '서버 요청', 25, 'trigger()는 클릭, 입력 등의 이벤트를 테스트 중 강제로 발생시킵니다.'),
                                                                                                                           (1210, 'Vue Test Utils를 통해 존재 여부를 확인하는 메서드는?', 1, 'high', 'exists()', 'visible()', 'checkExist()', 'queryExist()', 25, 'exists()는 요소나 컴포넌트가 DOM에 존재하는지를 boolean으로 반환합니다.'),
                                                                                                                           (1211, 'Vue Test Utils에서 전체 트리를 렌더링하는 함수는?', 2, 'low', 'shallowMount()', 'mount()', 'create()', 'renderAll()', 25, 'mount()는 자식 컴포넌트를 포함한 전체 트리를 렌더링합니다.'),
                                                                                                                           (1212, 'Vue Test Utils에서 자식 컴포넌트를 스텁 처리하는 함수는?', 2, 'low', 'mount()', 'shallowMount()', 'render()', 'stubMount()', 25, 'shallowMount()는 자식 컴포넌트를 스텁 처리하여 단위 테스트에 적합하게 합니다.'),
                                                                                                                           (1213, 'shallowMount()를 사용하면 얻을 수 있는 이점은?', 2, 'low', '전체 트리 검증', '렌더링 성능 최적화', '라우터 연결', '스토어 초기화', 25, '자식 컴포넌트를 스텁 처리함으로써 테스트 속도와 단순성을 확보할 수 있습니다.'),
                                                                                                                           (1214, 'shallowMount와 mount의 가장 큰 차이점은?', 2, 'medium', 'props 처리 방식', '자식 컴포넌트 렌더링 여부', 'data 초기화 방식', 'router 연결 여부', 25, 'shallowMount는 자식 컴포넌트를 렌더링하지 않는 반면, mount는 렌더링합니다.'),
                                                                                                                           (1215, 'mount()를 사용할 때 예상되는 부작용은?', 1, 'medium', '테스트 속도 감소', '컴포넌트 삭제', '라우팅 에러', 'Vue 인스턴스 중복', 25, '전체 트리 렌더링으로 인해 테스트가 느려질 수 있습니다.'),
                                                                                                                           (1216, 'shallowMount()가 주로 사용되는 테스트 목적은?', 2, 'medium', '통합 테스트', '단위 테스트', 'E2E 테스트', 'API 테스트', 25, 'shallowMount는 외부 의존성을 배제한 단위 테스트에 적합합니다.'),
                                                                                                                           (1217, 'mount()를 사용할 때 자식 컴포넌트까지 렌더링되면 어떤 문제가 생길 수 있는가?', 2, 'high', '의존성 없는 테스트 가능', '예상치 못한 실패 발생', '렌더링 속도 향상', '자동 이벤트 바인딩', 25, '자식 컴포넌트의 부작용으로 인해 테스트가 실패할 수 있습니다.'),
                                                                                                                           (1218, 'shallowMount() 시 자동으로 대체되는 것은?', 2, 'high', 'Vuex 모듈', '자식 컴포넌트', '라우터 인스턴스', 'Axios 요청', 25, 'shallowMount는 자식 컴포넌트를 자동으로 스텁 처리합니다.'),
                                                                                                                           (1219, 'mount()의 주요 사용 시나리오는?', 3, 'high', '비즈니스 로직 검증', '단일 컴포넌트 유닛 테스트', '전체 통합 시나리오 테스트', '스토어 비활성화', 25, 'mount는 전체 컴포넌트 구조를 포함한 통합 시나리오 테스트에 사용됩니다.'),
                                                                                                                           (1220, 'shallowMount() 사용 시 주의할 점은?', 2, 'high', '스토어 연결 여부', '자식 컴포넌트의 테스트 누락', '라우터 경로 변경', 'API 연결 지연', 25, '자식 컴포넌트가 스텁 처리되므로 해당 부분에 대한 테스트가 되지 않을 수 있습니다.'),
                                                                                                                           (1221, 'Vue Test Utils에서 버튼 클릭 이벤트를 발생시키는 메서드는?', 2, 'low', 'click()', 'trigger(''click'')', 'emit(''click'')', 'fire(''click'')', 25, 'trigger(''click'')은 실제 사용자 클릭처럼 이벤트를 시뮬레이션합니다.'),
                                                                                                                           (1222, 'input 요소에 값을 설정하고 변경 이벤트를 발생시키는 방법은?', 1, 'low', 'setValue()', 'updateInput()', 'changeInput()', 'modifyInput()', 25, 'setValue()는 input 요소에 값을 설정하고 input 이벤트를 자동으로 트리거합니다.'),
                                                                                                                           (1223, '컴포넌트의 props를 테스트 중 변경하려면 사용하는 메서드는?', 1, 'low', 'setProps()', 'updateProps()', 'changeProps()', 'mutateProps()', 25, 'setProps()는 테스트 중 컴포넌트의 props를 동적으로 수정할 수 있게 해줍니다.'),
                                                                                                                           (1224, 'Vue Test Utils의 find() 메서드는 무엇을 반환하는가?', 2, 'medium', 'Node 객체', 'Wrapper 객체', 'Text 객체', 'HTML 요소', 25, 'find()는 Wrapper 객체를 반환하며 이후 메서드 체이닝을 통해 테스트가 가능합니다.'),
                                                                                                                           (1225, 'emit() 메서드는 어떤 용도로 사용되는가?', 2, 'medium', '이벤트 수신', '이벤트 트리거', 'HTTP 요청', 'Vuex 디스패치', 25, 'emit()은 컴포넌트 내에서 커스텀 이벤트를 발생시킬 때 사용됩니다.'),
                                                                                                                           (1226, '컴포넌트가 특정 이벤트를 발생했는지 테스트할 때 사용하는 메서드는?', 1, 'medium', 'emitted()', 'triggered()', 'sent()', 'received()', 25, 'emitted()는 테스트 중 컴포넌트가 발생시킨 이벤트 목록을 확인할 수 있게 해줍니다.'),
                                                                                                                           (1227, 'Vue 컴포넌트가 emit한 이벤트의 payload를 확인하려면?', 1, 'high', 'emitted()', 'payload()', 'findEmits()', 'trigger()', 25, 'emitted() 메서드를 통해 어떤 이벤트가 어떤 값과 함께 발생했는지 확인할 수 있습니다.'),
                                                                                                                           (1228, 'emit된 이벤트 수를 체크하려면?', 1, 'high', 'emitted().length', 'trigger().count', 'findEmits().total', 'events().size', 25, 'emitted().eventName.length 형태로 호출 횟수를 확인할 수 있습니다.'),
                                                                                                                           (1229, 'setValue() 메서드를 사용한 후 필요한 추가 작업은?', 1, 'high', 'trigger(''input'')', 'trigger(''change'')', 'forceUpdate()', 'reRender()', 25, 'setValue() 후 input 이벤트 발생이 필요할 수 있으며 trigger(''input'')으로 처리할 수 있습니다.'),
                                                                                                                           (1230, 'Vue 컴포넌트 상호작용 테스트 시 DOM 변경을 강제로 반영하려면?', 2, 'high', 'forceUpdate()', 'nextTick()', 'reRender()', 'syncDOM()', 25, 'Vue의 DOM 업데이트는 비동기이므로 nextTick()을 통해 다음 DOM 사이클에서 검증할 수 있습니다.'),
                                                                                                                           (1231, 'Vue Test Utils에서 비동기 DOM 업데이트를 기다릴 때 사용하는 것은?', 3, 'low', 'waitFor()', 'flushPromises()', 'nextTick()', 'resolveDOM()', 25, 'nextTick()은 Vue의 DOM 업데이트가 완료된 후 실행되도록 보장하는 비동기 헬퍼입니다.'),
                                                                                                                           (1232, 'Vue 3에서는 비동기 테스트 시 어떤 helper를 권장하는가?', 1, 'low', 'flushPromises()', 'wait()', 'waitForEvent()', 'asyncTick()', 25, 'flushPromises()는 비동기 Promise 체인을 모두 소화한 후 다음 테스트를 진행할 수 있도록 도와줍니다.'),
                                                                                                                           (1233, 'setProps() 이후 변경 사항이 반영되기 전에 필요한 것은?', 1, 'low', 'nextTick()', 'setTimeout()', 'forceUpdate()', 'trigger(''update'')', 25, 'Vue는 반응형 시스템에서 변경사항이 DOM에 반영되기까지 nextTick()이 필요합니다.'),
                                                                                                                           (1234, 'Vue Test Utils에서 이벤트를 수동으로 발생시키려면?', 3, 'medium', 'click()', 'emit()', 'trigger()', 'activate()', 25, 'trigger() 메서드는 테스트 중 특정 DOM 이벤트를 강제로 발생시킵니다.'),
                                                                                                                           (1235, 'Vue Test Utils에서 input 이벤트를 발생시키는 올바른 방법은?', 2, 'medium', 'trigger(''change'')', 'trigger(''input'')', 'emit(''input'')', 'updateValue()', 25, 'trigger(''input'')을 통해 input 요소의 입력 이벤트를 시뮬레이션할 수 있습니다.'),
                                                                                                                           (1236, '비동기 호출이 완료되기 전 테스트가 끝나는 것을 방지하려면?', 1, 'medium', 'await nextTick()', 'trigger(''complete'')', 'setImmediate()', 'flushDOM()', 25, 'nextTick()을 await하면 DOM 업데이트와 비동기 처리가 완료된 후 테스트가 이어집니다.'),
                                                                                                                           (1237, 'Vue Test Utils에서 컴포넌트 이벤트 emit 테스트를 할 때 필요한 메서드는?', 2, 'high', 'triggerEmit()', 'emitted()', 'captureEvent()', 'emitCheck()', 25, 'emitted()는 컴포넌트에서 emit한 이벤트와 그 인자를 추적할 수 있습니다.'),
                                                                                                                           (1238, 'Promise 기반 로직 테스트 후 DOM 업데이트를 보장하려면?', 2, 'high', 'nextTick()', 'flushPromises()', 'resolveAsync()', 'trigger(''domUpdate'')', 25, 'flushPromises()는 pending 중인 Promise를 모두 해결하여 후속 DOM 업데이트를 보장합니다.'),
                                                                                                                           (1239, 'Vue Test Utils에서 DOM 변경을 감지한 후 테스트를 진행하려면?', 2, 'high', 'await wrapper.update()', 'await wrapper.vm.$nextTick()', 'await wrapper.flush()', 'await wrapper.domFlush()', 25, 'wrapper.vm.$nextTick()을 사용하면 해당 컴포넌트의 DOM 업데이트 완료를 기다릴 수 있습니다.'),
                                                                                                                           (1240, '컴포넌트 내부의 타이머 관련 테스트를 진행할 때 필요한 것은?', 1, 'high', 'jest.useTimers()', 'flushTimers()', 'nextTick()', 'triggerTimer()', 25, 'jest.useTimers()를 활성화하면 setTimeout 등의 타이머를 제어 가능하게 해줍니다.'),
                                                                                                                           (1241, 'Vue Test Utils에서 외부 의존성을 대체하는 방법은?', 2, 'low', 'mock()', 'stub()', 'replace()', 'substitute()', 25, 'stub()을 사용하면 자식 컴포넌트나 외부 모듈을 간단히 대체할 수 있습니다.'),
                                                                                                                           (1242, 'Vue Test Utils의 stubs 옵션은 어떤 역할을 하는가?', 1, 'low', '자식 컴포넌트 무시', 'props 자동 설정', '라우터 연결', '스토어 주입', 25, 'stubs는 테스트에서 자식 컴포넌트를 대체하여 단위 테스트에 집중할 수 있게 해줍니다.'),
                                                                                                                           (1243, 'Vue Test Utils에서 플러그인을 마운트할 때 사용하는 옵션은?', 3, 'low', 'use()', 'plugins', 'global.plugins', 'setupPlugins()', 25, 'global.plugins 옵션을 통해 Vue 플러그인을 테스트 환경에 주입할 수 있습니다.'),
                                                                                                                           (1244, 'Vue Test Utils에서 provide/inject를 테스트하려면 사용하는 옵션은?', 1, 'medium', 'provide', 'inject', 'plugin', 'mock', 25, 'provide 옵션을 사용하면 테스트 시 자식 컴포넌트에 inject될 데이터를 정의할 수 있습니다.'),
                                                                                                                           (1245, 'mock 옵션을 사용하면 주로 무엇을 대체하는가?', 3, 'medium', '라우터', '스토어', '글로벌 프로퍼티', '컴포넌트', 25, 'mock 옵션은 $axios, $router 등 전역 프로퍼티를 테스트 중 대체할 때 사용됩니다.'),
                                                                                                                           (1246, 'Vue Test Utils에서 $router를 Mock으로 대체하려면 사용하는 옵션은?', 1, 'medium', 'mocks: { $router: ... }', 'stubs: { RouterLink: ... }', 'plugins: [...]', 'global.routes', 25, 'mocks 옵션에 $router를 주입하면 라우터 기능을 테스트에서 모의할 수 있습니다.'),
                                                                                                                           (1247, 'Stub된 컴포넌트는 렌더링 결과에 어떤 영향을 미치는가?', 2, 'high', '원본 HTML을 그대로 출력', '간단한 Placeholder만 출력', '전체 트리 삭제', '랜덤 렌더링', 25, 'Stub된 컴포넌트는 대개 간단한 태그로 대체되며 실제 구현은 렌더되지 않습니다.'),
                                                                                                                           (1248, 'Vue Test Utils에서 특정 메서드 호출을 mock하려면 무엇을 사용해야 하는가?', 1, 'high', 'jest.fn()', 'sinon.spy()', 'vueMock()', 'mockCall()', 25, 'jest.fn()을 사용하면 함수의 호출 여부, 호출 횟수 등을 추적할 수 있습니다.'),
                                                                                                                           (1249, 'Vuex store를 테스트할 때 actions를 Mock할 수 있는 방법은?', 2, 'high', 'store.replaceActions()', 'mocks 옵션에 주입', 'store.mockActions()', 'store.stubActions()', 25, 'mocks 옵션을 통해 store의 action들을 테스트 전용 함수로 대체할 수 있습니다.'),
                                                                                                                           (1250, 'Vue Test Utils에서 플러그인 주입 없이 테스트하려면 필요한 것은?', 3, 'high', 'mock plugins', 'setupTestPlugin()', 'global.plugins 제거', '플러그인 무시 설정', 25, 'global.plugins 옵션을 제거하면 플러그인을 주입하지 않고 테스트할 수 있습니다.'),
                                                                                                                           (1251, 'Nuxt.js 프로젝트에서 기본적으로 라우트를 생성하는 폴더는?', 3, 'low', 'layouts', 'store', 'pages', 'components', 26, 'Nuxt는 pages 폴더의 파일 구조를 기반으로 자동 라우팅을 구성합니다.'),
                                                                                                                           (1252, 'Nuxt.js는 어떤 프레임워크를 기반으로 만들어졌는가?', 2, 'low', 'React', 'Vue', 'Angular', 'Svelte', 26, 'Nuxt.js는 Vue.js를 기반으로 하는 SSR/SPA 프레임워크입니다.'),
                                                                                                                           (1253, 'Nuxt.js에서 자동으로 생성된 라우터 경로는 어떤 파일 구조를 기반으로 하는가?', 3, 'low', 'store', 'components', 'pages', 'plugins', 26, 'pages 폴더 구조를 기반으로 Nuxt는 라우트를 자동 생성합니다.'),
                                                                                                                           (1254, '동적 라우팅을 위한 파일명 형식은?', 2, 'medium', '[id].vue', '_id.vue', 'id.vue', ':id.vue', 26, 'Nuxt.js에서는 대괄호([ ])를 사용해 동적 라우트를 정의합니다.'),
                                                                                                                           (1255, 'Nuxt.js의 기본 실행 포트는?', 1, 'medium', '3000', '8080', '5000', '4000', 26, 'Nuxt는 기본적으로 3000번 포트에서 실행됩니다.'),
                                                                                                                           (1256, 'Nuxt.js에서 글로벌 설정을 위한 파일은?', 1, 'medium', 'nuxt.config.js', 'settings.js', 'app.config.js', 'vue.config.js', 26, 'nuxt.config.js 파일은 Nuxt의 전체 설정을 관리하는 핵심 파일입니다.'),
                                                                                                                           (1257, 'Nuxt.js에서 미들웨어를 사용하는 주요 목적은?', 2, 'high', '서버 리셋', '라우트 접근 제어', '라우터 초기화', 'API 생성', 26, '미들웨어는 인증이나 접근 제어 등의 라우트 전처리에 사용됩니다.'),
                                                                                                                           (1258, 'nuxt generate 명령은 어떤 목적을 위해 사용하는가?', 2, 'high', '개발 서버 실행', '정적 사이트 생성', '스토어 초기화', '프로젝트 테스트', 26, 'nuxt generate 명령은 Nuxt 앱을 정적 사이트로 빌드합니다.'),
                                                                                                                           (1259, 'Nuxt.js 프로젝트에서 플러그인을 등록하는 폴더는?', 2, 'high', 'middleware', 'plugins', 'layouts', 'static', 26, 'plugins 폴더에 등록된 파일은 Nuxt 앱에서 전역적으로 사용되는 플러그인을 정의합니다.'),
                                                                                                                           (1260, 'Nuxt.js에서 SSR이란?', 2, 'high', 'Single Static Route', 'Server-Side Rendering', 'State Store Route', 'Server Session Request', 26, 'SSR은 초기 페이지를 서버에서 HTML로 렌더링하여 빠른 로드와 SEO에 유리합니다.'),
                                                                                                                           (1261, 'Nuxt.js에서 전체 페이지에 공통으로 적용되는 레이아웃은?', 1, 'low', 'default.vue', 'global.vue', 'main.vue', 'shared.vue', 26, 'default.vue는 Nuxt에서 모든 페이지에 기본으로 적용되는 공통 레이아웃 파일입니다.'),
                                                                                                                           (1262, '페이지 파일은 어떤 폴더 안에 위치해야 Nuxt.js에서 인식하는가?', 2, 'low', 'components', 'pages', 'layouts', 'store', 26, 'Nuxt는 pages 폴더 내에 있는 Vue 파일을 자동으로 라우트로 등록합니다.'),
                                                                                                                           (1263, 'Nuxt.js 페이지에서 layout을 지정하려면 사용하는 속성은?', 2, 'low', 'template', 'layout', 'useLayout', 'wrapper', 26, 'layout 속성은 해당 페이지에서 사용할 레이아웃을 명시하는 데 사용됩니다.'),
                                                                                                                           (1264, '레이아웃 파일은 어떤 폴더에 위치하는가?', 1, 'medium', 'layouts', 'pages', 'views', 'static', 26, '레이아웃 파일은 layouts 폴더에 위치해야 Nuxt가 이를 인식합니다.'),
                                                                                                                           (1265, '<nuxt/> 컴포넌트의 역할은?', 3, 'medium', '라우팅 처리', '페이지 전환 트리거', '페이지 내용 렌더링', '스토어 접근', 26, '<nuxt/>는 현재 활성화된 페이지 컴포넌트를 렌더링하는 데 사용됩니다.'),
                                                                                                                           (1266, '페이지 내에서 transition을 적용할 때 사용하는 키워드는?', 1, 'medium', 'pageTransition', 'animation', 'layoutAnimation', 'routerTransition', 26, 'pageTransition 속성을 사용하면 페이지 전환 시 트랜지션 효과를 지정할 수 있습니다.'),
                                                                                                                           (1267, '레이아웃 변경이 필요한 경우 사용하는 hook은?', 2, 'high', 'beforeCreate', 'layout()', 'setup()', 'useLayout()', 26, 'layout() 훅은 조건에 따라 동적으로 레이아웃을 변경할 수 있게 해줍니다.'),
                                                                                                                           (1268, 'Nuxt.js에서 layout 속성은 어디에 정의되는가?', 2, 'high', 'components', 'script', 'data', 'template', 26, 'layout 속성은 script 블록 안에서 정의되어야 Nuxt가 인식할 수 있습니다.'),
                                                                                                                           (1269, 'Nuxt.js에서 동적 레이아웃 전환은 어떻게 처리되는가?', 2, 'high', 'computed 속성', 'layout() 함수', 'transition 속성', 'nuxt.config.js', 26, 'layout() 함수는 조건에 따라 다른 레이아웃을 반환할 수 있어 동적 전환을 지원합니다.'),
                                                                                                                           (1270, '레이아웃을 조건부로 바꾸려면 무엇을 사용해야 하는가?', 2, 'high', 'computed layout', 'layout() 함수 반환', 'watchLayout()', 'layoutTransition', 26, 'layout() 함수에서 조건에 따른 값을 반환하면 레이아웃을 동적으로 전환할 수 있습니다.'),
                                                                                                                           (1271, 'Nuxt.js에서 상태 관리를 위해 사용하는 기본 라이브러리는?', 3, 'low', 'Pinia', 'Redux', 'Vuex', 'Zustand', 26, 'Nuxt.js는 기본적으로 Vuex를 상태 관리 라이브러리로 사용합니다.'),
                                                                                                                           (1272, 'Vuex 스토어 파일은 어떤 폴더에 위치해야 Nuxt가 인식하는가?', 1, 'low', 'store', 'pages', 'layouts', 'components', 26, 'store 폴더에 있는 파일은 자동으로 Vuex 스토어로 인식되어 초기화됩니다.'),
                                                                                                                           (1273, 'Vuex에서 상태 변경을 위한 함수는?', 2, 'low', 'getter', 'mutation', 'action', 'state', 26, 'mutations는 상태(state)를 직접 변경하기 위한 함수입니다.'),
                                                                                                                           (1274, 'Vuex의 상태를 가져오기 위한 헬퍼 함수는?', 3, 'medium', 'mapActions', 'mapMutations', 'mapState', 'useState', 26, 'mapState는 컴포넌트에서 Vuex state를 쉽게 가져오도록 도와주는 헬퍼입니다.'),
                                                                                                                           (1275, 'Vuex에서 비동기 처리를 담당하는 메서드는?', 2, 'medium', 'mutations', 'actions', 'state', 'store', 26, 'actions는 비동기 로직을 처리하고 필요한 경우 mutation을 호출하여 상태를 변경합니다.'),
                                                                                                                           (1276, 'Vuex의 getters의 주요 목적은?', 3, 'medium', '상태 변경', '비동기 로직', '상태 기반 계산', '모듈 등록', 26, 'getters는 state 기반 계산된 값을 캐싱하여 효율적으로 반환합니다.'),
                                                                                                                           (1277, 'Nuxt.js에서 store를 모듈 단위로 나누려면 어떤 설정이 필요한가?', 2, 'high', 'state: true', 'namespaced: true', 'modular: true', 'separate: true', 26, 'namespaced: true를 설정하면 각 모듈이 독립된 네임스페이스로 작동합니다.'),
                                                                                                                           (1278, 'store/index.js에서 반드시 export 되어야 하는 것은?', 2, 'high', 'getters', 'default function', 'mutations', 'modules', 26, 'store/index.js에서는 상태 초기화를 위한 default 함수를 export 해야 Nuxt가 스토어로 인식합니다.'),
                                                                                                                           (1279, 'Vuex의 state를 사용하는 방식은?', 2, 'high', 'this.$store.dispatch()', 'this.$store.state.key', 'this.$store.commit()', 'this.$store.inject()', 26, 'this.$store.state.key를 통해 직접 state의 특정 값에 접근할 수 있습니다.'),
                                                                                                                           (1280, 'Nuxt에서 store를 동적으로 생성하려면 어떤 속성을 설정하는가?', 3, 'high', 'dynamic: true', 'storeMode: ''dynamic''', 'export default () => new Vuex.Store()', 'useDynamic()', 26, 'export default () => new Vuex.Store() 형식으로 함수를 반환하면 동적 생성이 가능합니다.'),
                                                                                                                           (1281, 'Nuxt.js에서 asyncData는 어떤 시점에 실행되는가?', 3, 'low', '클라이언트 렌더링 후', '컴포넌트 생성 후', '서버 또는 클라이언트 렌더링 전에', '라우터 변경 시', 26, 'asyncData는 컴포넌트가 생성되기 전, 서버 또는 클라이언트에서 데이터를 미리 가져오는 데 사용됩니다.'),
                                                                                                                           (1282, 'asyncData는 어떤 타입의 값을 반환해야 하는가?', 4, 'low', 'Promise', 'Array', 'Function', 'Object', 26, 'asyncData는 객체를 반환하며 이 객체는 컴포넌트의 data로 병합됩니다.'),
                                                                                                                           (1283, 'asyncData와 fetch의 차이점 중 옳은 것은?', 3, 'low', '둘 다 컴포넌트 메서드로 정의된다', 'asyncData는 setup에서만 작동한다', 'fetch는 this 접근이 가능하다', 'fetch는 SSR에서 작동하지 않는다', 26, 'fetch는 일반 컴포넌트 메서드이므로 this에 접근할 수 있지만 asyncData는 그렇지 않습니다.'),
                                                                                                                           (1284, 'Nuxt.js에서 $axios는 어떤 역할을 하는가?', 2, 'medium', '뷰 전환', 'API 호출', '라우터 설정', '스토어 초기화', 26, '$axios는 Nuxt에서 API 요청을 수행하기 위한 핵심 HTTP 클라이언트입니다.'),
                                                                                                                           (1285, 'fetch() 함수는 어떤 시점에 호출되는가?', 3, 'medium', '라우터 변경 시', '컴포넌트 mounted 후', '페이지 진입 시', 'DOM 렌더링 후', 26, 'fetch는 페이지 진입 시 실행되며 컴포넌트의 데이터 초기화를 담당합니다.'),
                                                                                                                           (1286, '서버에서만 asyncData를 호출하게 하려면 어떻게 설정하는가?', 4, 'medium', 'ssrOnly: true', 'serverOnly: true', 'context.ssr = true', 'process.server 조건문 사용', 26, 'process.server를 조건문으로 활용하면 asyncData가 서버에서만 실행되도록 제어할 수 있습니다.'),
                                                                                                                           (1287, 'asyncData에서 this 키워드를 사용할 수 없는 이유는?', 3, 'high', '비동기라서', 'setup 훅 외부라서', 'context 기반 함수이기 때문', 'Vue 3 미지원', 26, 'asyncData는 컴포넌트 인스턴스가 생성되기 전에 실행되므로 this에 접근할 수 없습니다.'),
                                                                                                                           (1288, 'fetch와 asyncData를 함께 사용할 수 있는가?', 3, 'high', '불가능하다', '가능하지만 권장되지 않는다', '가능하다', 'Vuex를 사용할 경우만 가능', 26, 'fetch와 asyncData는 서로 보완적으로 사용할 수 있으며 실제로 함께 사용하는 것도 가능합니다.'),
                                                                                                                           (1289, 'API 요청을 공통으로 처리하기 위해 사용하는 Nuxt 모듈은?', 2, 'high', '@nuxt/http', '@nuxt/axios', '@nuxt/request', '@nuxt/fetch', 26, '@nuxt/axios 모듈은 Nuxt 애플리케이션에서 공통적으로 API 요청을 처리하기 위해 사용됩니다.'),
                                                                                                                           (1290, 'Nuxt에서 context를 활용하는 함수가 아닌 것은?', 3, 'high', 'asyncData', 'fetch', 'created', 'middleware', 26, 'created는 Vue 라이프사이클 훅이며 Nuxt의 context 객체를 직접 받지 않습니다.'),
                                                                                                                           (1291, 'Nuxt.js에서 환경 변수는 어떤 파일에 설정하는가?', 1, 'low', '.env', 'nuxt.config.js', 'package.json', 'store/index.js', 26, '.env 파일은 Nuxt.js 프로젝트에서 환경변수를 정의하는 표준 위치입니다.'),
                                                                                                                           (1292, 'SSR을 비활성화하려면 nuxt.config.js에서 어떤 속성을 설정해야 하는가?', 1, 'low', 'ssr: false', 'mode: ''spa''', 'static: true', 'target: ''spa''', 26, 'ssr: false를 설정하면 Nuxt는 서버 사이드 렌더링을 비활성화하고 SPA로 동작합니다.'),
                                                                                                                           (1293, '정적 사이트 생성을 위한 Nuxt 명령은?', 4, 'low', 'nuxt run', 'nuxt build', 'nuxt export', 'nuxt generate', 26, 'nuxt generate는 정적 HTML 파일로 사이트를 사전 렌더링하기 위한 명령어입니다.'),
                                                                                                                           (1294, 'nuxt.config.js에서 SEO를 위한 설정은 어디에 정의되는가?', 2, 'medium', 'meta', 'head', 'seo', 'titleTemplate', 26, 'head 속성은 title, meta 태그 등 SEO 관련 설정을 포함합니다.'),
                                                                                                                           (1295, 'Nuxt에서 외부 모듈을 추가할 때 사용하는 속성은?', 1, 'medium', 'modules', 'plugins', 'imports', 'include', 26, 'modules 배열에 외부 Nuxt 모듈을 등록하면 기능을 확장할 수 있습니다.'),
                                                                                                                           (1296, 'generate로 생성된 파일의 기본 디렉토리는?', 1, 'medium', 'dist', 'build', 'out', '.nuxt', 26, 'nuxt generate를 수행하면 dist 디렉토리에 정적 파일이 생성됩니다.'),
                                                                                                                           (1297, 'Nuxt에서 미들웨어로 로그인 여부를 검사할 때 위치는?', 2, 'high', 'layouts', 'middleware', 'pages', 'static', 26, 'middleware 폴더는 인증과 같은 라우팅 로직을 사전에 처리하는 데 사용됩니다.'),
                                                                                                                           (1298, '라우팅 설정을 커스터마이징할 때 사용하는 옵션은?', 1, 'high', 'router.extendRoutes', 'route.config', 'customRoutes', 'routes.options', 26, 'router.extendRoutes는 Nuxt의 자동 라우팅을 확장하거나 수정할 수 있게 해주는 옵션입니다.'),
                                                                                                                           (1299, '정적 파일을 제공하는 Nuxt 디렉토리는?', 3, 'high', 'assets', 'components', 'static', 'layouts', 26, 'static 디렉토리에 있는 파일은 / 경로 기준으로 정적으로 제공됩니다.'),
                                                                                                                           (1300, 'Nuxt.js를 Vercel에 배포할 때 사용하는 설정 파일은?', 4, 'high', '.vercel.json', 'vercel.config.js', 'nuxt.config.js', 'vercel.json', 26, 'vercel.json은 Vercel 배포 시 프로젝트 설정을 정의하는 공식 구성 파일입니다.'),
                                                                                                                           (1301, 'Angular Universal은 무엇을 위한 기술인가?', 2, 'low', '모바일 앱 개발', '서버 사이드 렌더링(SSR)', '데스크탑 앱 개발', 'PWA 개발', 27, 'Angular Universal은 Angular 앱에 서버 사이드 렌더링 기능을 제공하는 기술입니다.'),
                                                                                                                           (1302, 'Angular Universal을 사용하면 얻을 수 없는 효과는?', 3, 'low', '초기 로딩 속도 개선', 'SEO 향상', '브라우저 캐시 제어', '서버 측 렌더링', 27, '브라우저 캐시는 Universal 기능과 무관하며 클라이언트 측에서 처리됩니다.'),
                                                                                                                           (1303, 'Angular Universal의 핵심 모듈은?', 2, 'low', 'HttpClientModule', 'ServerModule', 'RouterModule', 'FormsModule', 27, 'ServerModule은 Angular 앱을 서버에서 렌더링할 수 있도록 도와주는 핵심 모듈입니다.'),
                                                                                                                           (1304, 'Angular Universal이 필요한 주요 이유는?', 2, 'medium', '동적 데이터 바인딩', '서버 초기 페이지 제공', '라우팅 단순화', 'API 구축', 27, '초기 페이지를 서버에서 렌더링해 전달함으로써 초기 로딩 성능과 SEO를 개선할 수 있습니다.'),
                                                                                                                           (1305, 'Universal 렌더링의 기본 동작 방식은?', 2, 'medium', '클라이언트에서만 렌더링', '서버에서 HTML 생성 후 클라이언트로 전송', 'SSR 후에도 HTML 미생성', '서버-클라이언트 양방향 바인딩', 27, '서버가 HTML을 먼저 생성한 뒤 클라이언트가 takeover하는 구조입니다.'),
                                                                                                                           (1306, 'Angular Universal을 추가할 때 사용하는 CLI 명령어는?', 1, 'medium', 'ng add @angular/ssr', 'ng generate universal', 'ng add universal', 'ng install angular-server', 27, 'ng add @angular/ssr 명령은 Universal 기능을 프로젝트에 통합합니다.'),
                                                                                                                           (1307, 'Universal 렌더링을 통해 특히 이점이 큰 앱은?', 2, 'high', '채팅 앱', 'SEO가 중요한 앱', '실시간 게임 앱', '데스크탑 앱', 27, '서버에서 콘텐츠를 미리 렌더링하면 검색 엔진이 더 쉽게 콘텐츠를 수집할 수 있습니다.'),
                                                                                                                           (1308, 'Angular Universal 프로젝트의 서버 진입점 파일은?', 2, 'high', 'main.ts', 'server.ts', 'index.ts', 'app.module.ts', 27, 'server.ts 파일은 Express 서버 설정 및 SSR 핸들링의 시작점이 됩니다.'),
                                                                                                                           (1309, 'Angular Universal이 사용하는 서버 프레임워크는 주로 무엇인가?', 2, 'high', 'Spring', 'Express', 'Koa', 'Django', 27, 'Express는 Angular Universal 프로젝트의 SSR 서버로 기본적으로 사용됩니다.'),
                                                                                                                           (1310, 'Universal 렌더링 후 Angular가 클라이언트에서 takeover 하는 과정을 무엇이라 부르는가?', 2, 'high', 'Rehydration', 'Hydration', 'Serialization', 'Deserialization', 27, 'Hydration은 서버가 렌더링한 HTML을 클라이언트에서 Angular 앱이 takeover하는 과정입니다.'),
                                                                                                                           (1311, 'Angular Universal을 프로젝트에 추가하는 CLI 명령어는?', 1, 'low', 'ng add @nguniversal/express-engine', 'ng generate universal', 'ng install universal', 'ng build server', 27, '@nguniversal/express-engine은 Express 기반 SSR을 구성하는 공식 패키지입니다.'),
                                                                                                                           (1312, 'SSR을 활성화하면 Angular 프로젝트에 추가되는 서버 프레임워크는?', 2, 'low', 'NestJS', 'Express', 'Koa', 'Fastify', 27, 'Angular Universal은 기본적으로 Express를 백엔드 SSR 서버로 사용합니다.'),
                                                                                                                           (1313, 'SSR 빌드를 실행할 때 사용하는 명령어는?', 3, 'low', 'ng build', 'ng run project-name:server', 'npm run build:ssr', 'ng start server', 27, 'npm run build:ssr 명령어는 SSR을 위한 서버와 클라이언트 번들을 동시에 생성합니다.'),
                                                                                                                           (1314, 'SSR 빌드 후 서버를 실행하는 명령어는?', 1, 'medium', 'npm run dev:ssr', 'npm start', 'ng serve server', 'ng deploy', 27, 'npm run dev:ssr 명령어는 SSR 서버를 실행하여 로컬 개발을 진행할 수 있게 합니다.'),
                                                                                                                           (1315, 'Angular Universal이 생성하는 server.ts 파일의 역할은?', 3, 'medium', '라우팅 관리', 'API 서버 구축', '서버 사이드 렌더링 핸들링', '컴포넌트 등록', 27, 'server.ts는 Express 서버에서 SSR 로직을 설정하고 요청을 처리하는 진입점입니다.'),
                                                                                                                           (1316, 'SSR 빌드시 dist 폴더 내 서버 파일이 위치하는 기본 경로는?', 1, 'medium', 'dist/server', 'dist/browser', 'dist/angular', 'dist/universal', 27, 'SSR용 서버 빌드 파일은 dist/server 경로에 생성됩니다.'),
                                                                                                                           (1317, 'Angular Universal 프로젝트에서 서버 코드를 수정한 경우 필요한 작업은?', 3, 'high', '브라우저 새로고침', 'ng serve 재시작', 'server build 재빌드', 'ng lint', 27, '서버 코드를 수정하면 SSR 동작에 영향을 주므로 server 빌드를 다시 실행해야 반영됩니다.'),
                                                                                                                           (1318, 'Angular Universal 서버는 기본적으로 어떤 포트에서 동작하는가?', 1, 'high', '3000', '4000', '4200', '8080', 27, 'Universal 서버는 기본적으로 포트 3000에서 실행됩니다.'),
                                                                                                                           (1319, 'Angular Universal 서버 코드에서 요청 객체를 받는 함수는?', 3, 'high', 'handleRequest()', 'ngServer()', 'ngExpressEngine()', 'expressHandler()', 27, 'ngExpressEngine()은 Angular 템플릿을 서버 측에서 렌더링하기 위한 Express 엔진입니다.'),
                                                                                                                           (1320, 'SSR 설정시 Angular AppServerModule은 어떤 역할을 하는가?', 3, 'high', 'API 서버 구성', '라우터 미들웨어 설정', '서버 사이드 렌더링 모듈 정의', '로그 기록', 27, 'AppServerModule은 서버 측 렌더링을 위한 Angular 모듈로, AppModule의 확장 버전입니다.'),
                                                                                                                           (1321, '서버 측 렌더링(SSR) 흐름에서 가장 먼저 수행되는 것은?', 2, 'low', '브라우저 렌더링', '서버 HTML 생성', 'API 호출', '라우터 이동', 27, 'SSR은 서버가 먼저 HTML을 생성한 후 클라이언트에 전달하는 과정으로 시작됩니다.'),
                                                                                                                           (1322, 'Angular Universal 서버는 요청을 받으면 어떤 엔진을 호출하는가?', 2, 'low', 'renderEngine', 'ngExpressEngine', 'serverEngine', 'htmlGenerator', 27, 'ngExpressEngine은 Angular 앱을 서버에서 렌더링하는 Express용 렌더링 엔진입니다.'),
                                                                                                                           (1323, 'SSR 처리 시 Angular가 렌더링을 완료하면 서버는 무엇을 클라이언트에 반환하는가?', 3, 'low', 'JSON 데이터', 'Static Files', 'HTML 페이지', 'API 응답', 27, '서버는 렌더링이 완료된 HTML을 클라이언트에 반환합니다.'),
                                                                                                                           (1324, '서버 사이드 렌더링에서 상태 동기화는 어느 과정에서 일어나는가?', 1, 'medium', 'Hydration', 'Serialization', 'Navigation', 'Injection', 27, 'Hydration은 서버에서 생성한 HTML을 클라이언트에서 takeover하면서 상태를 동기화하는 과정입니다.'),
                                                                                                                           (1325, '서버 렌더링 중 API 요청을 막지 않고 처리하는 방법은?', 2, 'medium', '지연 렌더링', 'transferState 사용', 'streaming', 'browserPreload', 27, 'transferState를 사용하면 서버에서 가져온 데이터를 클라이언트로 전달하여 중복 요청을 방지할 수 있습니다.'),
                                                                                                                           (1326, '서버와 클라이언트 간 상태 전송을 위한 Angular 서비스는?', 1, 'medium', 'TransferHttpCacheModule', 'HttpClientModule', 'ServerStateModule', 'HydrationService', 27, 'TransferHttpCacheModule은 서버에서 가져온 HTTP 데이터를 클라이언트에 재사용 가능하게 합니다.'),
                                                                                                                           (1327, '서버 응답이 끝나기 전에 클라이언트가 초기화되는 것을 무엇이라 부르는가?', 2, 'high', 'Rehydration', 'Preboot', 'Prefetching', 'ServerWait', 27, 'Preboot은 사용자의 초기 이벤트를 기록하여 Angular 앱이 takeover 후 이를 재생합니다.'),
                                                                                                                           (1328, '서버 사이드 렌더링 후 클라이언트가 takeover 하지 않으면 생기는 문제는?', 3, 'high', '라우팅 실패', 'SEO 실패', '앱이 비활성화 상태로 남음', '속도 저하', 27, 'Hydration이 일어나지 않으면 앱이 사용자와 상호작용할 수 없는 비활성 상태로 남습니다.'),
                                                                                                                           (1329, '서버 사이드 렌더링에서 preboot의 역할은?', 2, 'high', '애니메이션 동기화', '초기 이벤트 기록', '라우터 히스토리 관리', '데이터베이스 연결', 27, 'preboot은 서버 렌더링 중 발생한 사용자 이벤트를 기록하여 클라이언트 초기화 후 재생합니다.'),
                                                                                                                           (1330, '서버 측 렌더링 흐름에서 TransferState를 사용하는 주된 이유는?', 2, 'high', '보안 강화', 'API 요청 최소화', '렌더링 속도 향상', '라우터 최적화', 27, 'TransferState는 서버에서 이미 로드한 데이터를 클라이언트로 전달하여 중복 요청을 줄입니다.'),
                                                                                                                           (1331, 'Angular Universal에서 라우팅은 주로 어디에서 처리되는가?', 2, 'low', '클라이언트', '서버', '브라우저', 'CDN', 27, 'SSR에서는 서버가 초기 요청을 받아 라우팅 및 렌더링을 처리합니다.'),
                                                                                                                           (1332, '서버 측 라우팅을 위해 사용하는 Angular 모듈은?', 3, 'low', 'HttpClientModule', 'ServerModule', 'RouterModule', 'UniversalModule', 27, 'RouterModule은 서버에서도 라우팅 처리를 위해 필요합니다.'),
                                                                                                                           (1333, 'Angular SSR에서 라우트별 HTML 생성을 가능하게 하는 기능은?', 2, 'low', 'Static Rendering', 'Prerendering', 'Dynamic Routing', 'Lazy Loading', 27, 'Prerendering은 각 라우트에 대해 미리 HTML 파일을 생성하는 SSR 기법입니다.'),
                                                                                                                           (1334, 'Angular Universal 프로젝트에서 prefetch 데이터를 저장하는 방법은?', 3, 'medium', 'sessionStorage', 'localStorage', 'TransferState', 'Cookie', 27, 'TransferState를 사용하면 서버에서 가져온 데이터를 클라이언트에서 재사용할 수 있습니다.'),
                                                                                                                           (1335, '라우팅 이벤트를 감지하여 SSR 데이터 프리페칭을 수행하려면 무엇을 사용해야 하는가?', 2, 'medium', 'ActivatedRoute', 'Router Events', 'NavigationEnd', 'RouteGuard', 27, 'Router Events는 라우터의 상태 변화를 감지하고 prefetch 등 다양한 작업을 트리거할 수 있습니다.'),
                                                                                                                           (1336, '라우트 기반 프리페칭 전략 중 잘못된 것은?', 4, 'medium', 'Immediate Prefetching', 'On-Demand Prefetching', 'Preloading Strategy', 'Delayed Loading', 27, 'Delayed Loading은 공식적인 Angular 프리페칭 전략이 아닙니다.'),
                                                                                                                           (1337, 'SSR을 통해 첫 페이지에 대해 얻을 수 있는 주요 이점은?', 1, 'high', '클라이언트 부하 감소', '코드 난독화', '라우터 초기화 최소화', 'CSS 최적화', 27, 'SSR은 초기 HTML을 서버에서 생성하므로 클라이언트의 연산 부하가 줄어듭니다.'),
                                                                                                                           (1338, '데이터를 라우트마다 미리 가져오려면 Angular에서 무엇을 사용해야 하는가?', 1, 'high', 'Resolvers', 'Guards', 'Interceptors', 'Pipes', 27, 'Resolvers는 라우터가 활성화되기 전에 데이터를 미리 로드하는 데 사용됩니다.'),
                                                                                                                           (1339, '서버에서 라우팅 시 발생할 수 있는 문제를 방지하기 위한 권장 방법은?', 2, 'high', '라우터 Lazy Load 제거', 'TransferState 활용', 'HTTP 요청 차단', 'RouterModule 제거', 27, 'TransferState를 사용하면 서버에서의 데이터 로딩 결과를 클라이언트로 전달할 수 있어 문제를 줄입니다.'),
                                                                                                                           (1340, '라우팅 시 데이터 프리페칭 최적화를 위해 사용하는 전략은?', 1, 'high', 'PreloadAllModules', 'LazyLoadModules', 'SyncLoadModules', 'AllRoutesPrefetch', 27, 'PreloadAllModules는 라우팅 후 백그라운드에서 모든 모듈을 미리 로드하여 응답성을 높입니다.'),
                                                                                                                           (1341, 'SSR에서 초기 렌더링 후 클라이언트가 takeover하는 과정은 무엇이라 불리는가?', 1, 'low', 'Hydration', 'Serialization', 'Prefetching', 'Rendering', 27, 'Hydration은 SSR로 생성된 HTML을 클라이언트에서 takeover하여 활성화하는 과정입니다.'),
                                                                                                                           (1342, 'Angular Universal 앱의 성능 최적화를 위해 가장 권장되는 방법은?', 1, 'low', '이미지 Lazy Loading', '모든 코드를 클라이언트에 동시 전송', '서버 캐시 비활성화', '브라우저 히스토리 비활성화', 27, '이미지 Lazy Loading은 페이지 로딩 속도를 개선하는 기본적인 성능 최적화 기법입니다.'),
                                                                                                                           (1343, 'Angular Universal 앱 배포 시 Node 서버와 함께 사용하는 서버는?', 3, 'low', 'Nginx', 'Apache', 'Express', 'Spring Boot', 27, 'Express는 Angular Universal의 기본 서버 프레임워크로 SSR을 처리합니다.'),
                                                                                                                           (1344, 'SSR 페이지 캐싱을 통해 얻을 수 있는 주요 이점은?', 2, 'medium', '코드 경량화', '초기 응답 시간 단축', 'CSS 최적화', '라우터 트래픽 감소', 27, 'SSR에서 캐싱은 HTML을 미리 저장하여 서버의 처리 시간을 단축시킬 수 있습니다.'),
                                                                                                                           (1345, 'Static SSR 페이지를 생성하는 Angular 명령어는?', 2, 'medium', 'ng deploy', 'ng prerender', 'ng static', 'ng build static', 27, 'ng prerender 명령어는 사전 정의된 라우트를 기반으로 정적 HTML 파일을 생성합니다.'),
                                                                                                                           (1346, '서버 캐시를 구현할 때 가장 많이 사용하는 미들웨어는?', 2, 'medium', 'compression', 'express-cache-controller', 'helmet', 'body-parser', 27, 'express-cache-controller는 Express 기반 SSR에서 캐시 정책을 제어하기 위한 미들웨어입니다.'),
                                                                                                                           (1347, 'Angular Universal 앱에서 SEO를 향상시키기 위한 방법은?', 1, 'high', 'Canonical URL 설정', 'CSS 최적화', 'Lazy Loading 제거', 'State 저장', 27, 'Canonical URL은 검색 엔진이 중복 페이지를 인식하지 않도록 도와주는 중요한 SEO 설정입니다.'),
                                                                                                                           (1348, 'SSR 시 TransferState의 주요 목적은?', 2, 'high', '라우터 히스토리 저장', '서버와 클라이언트 간 데이터 공유', '서버 성능 향상', '미들웨어 로깅', 27, 'TransferState는 SSR 시 데이터를 클라이언트로 전달하여 동일한 요청을 반복하지 않도록 합니다.'),
                                                                                                                           (1349, 'Static Generation과 SSR의 주요 차이점은?', 1, 'high', 'Static은 빌드 시 HTML 생성, SSR은 요청 시 생성', 'SSR은 정적 파일만 생성', 'Static은 항상 서버 필요', 'SSR은 파일 시스템만 사용', 27, 'Static Generation은 정적 HTML을 미리 생성하는 반면, SSR은 요청마다 동적으로 생성됩니다.'),
                                                                                                                           (1350, 'Angular Universal 배포시 서버 부하를 줄이기 위한 전략은?', 2, 'high', 'SSR 모든 요청 처리', 'Static 페이지 최대한 활용', 'SPA 모드 사용', '라우터 동기화', 27, '가능한 라우트를 prerender하여 정적 페이지로 제공하면 서버 부하를 크게 줄일 수 있습니다.'),
                                                                                                                           (1351, 'Jasmine은 어떤 종류의 테스트 프레임워크인가?', 2, 'low', 'E2E 테스트', '유닛 테스트', '통합 테스트', 'UI 테스트', 28, 'Jasmine은 JavaScript 코드의 단위(유닛)를 테스트하기 위한 BDD 기반 테스트 프레임워크입니다.'),
                                                                                                                           (1352, 'Jasmine 테스트를 그룹화하는 함수는?', 2, 'low', 'test()', 'describe()', 'group()', 'it()', 28, 'describe() 함수는 관련된 테스트 케이스들을 하나의 그룹으로 묶을 때 사용됩니다.'),
                                                                                                                           (1353, 'Jasmine에서 개별 테스트 케이스를 정의하는 함수는?', 2, 'low', 'describe()', 'it()', 'testCase()', 'example()', 28, 'it() 함수는 실제 테스트할 개별 테스트 케이스를 정의할 때 사용됩니다.'),
                                                                                                                           (1354, 'Jasmine에서 테스트 시작 전 실행되는 함수는?', 3, 'medium', 'beforeAll()', 'afterEach()', 'beforeEach()', 'init()', 28, 'beforeEach()는 각 테스트 케이스가 실행되기 전에 공통적으로 실행되는 초기화 함수입니다.'),
                                                                                                                           (1355, 'Jasmine에서 모든 테스트가 끝난 후 실행되는 함수는?', 2, 'medium', 'afterEach()', 'afterAll()', 'beforeAll()', 'done()', 28, 'afterAll()은 모든 테스트 스위트가 완료된 후 한 번만 실행됩니다.'),
                                                                                                                           (1356, 'Jasmine의 BDD 스타일 문법에서 ''expect''는 무엇을 정의하는가?', 2, 'medium', '테스트 스위트', '예상 결과', '비동기 콜백', '모듈 임포트', 28, 'expect는 테스트에서 실제 값이 예상한 값과 일치하는지를 검증하는 단언(assertion)입니다.'),
                                                                                                                           (1357, 'Jasmine에서 여러 조건 중 하나라도 실패하면?', 2, 'high', '다음 조건 무시', '전체 테스트 실패', '계속 진행', '조건 무효화', 28, '테스트 내의 단언(expect)이 실패하면 해당 테스트는 실패로 간주됩니다.'),
                                                                                                                           (1358, 'Jasmine 테스트를 임시로 비활성화할 때 사용하는 함수는?', 3, 'high', 'it.skip()', 'xdescribe()', 'xit()', 'disabled()', 28, 'xit()은 해당 테스트 케이스를 실행하지 않고 스킵할 때 사용됩니다.'),
                                                                                                                           (1359, 'Jasmine에서 테스트 스위트를 비활성화하는 함수는?', 3, 'high', 'skipSuite()', 'disabledDescribe()', 'xdescribe()', 'xgroup()', 28, 'xdescribe()는 전체 테스트 그룹을 일시적으로 비활성화하는 데 사용됩니다.'),
                                                                                                                           (1360, 'Jasmine 테스트 스위트 실행 순서는?', 3, 'high', '랜덤', '정렬된 순서', '정의된 순서', '우선순위 지정', 28, 'Jasmine은 기본적으로 코드에 정의된 순서대로 테스트를 실행합니다.'),
                                                                                                                           (1361, 'Jasmine에서 ''toBe()'' 매처는 무엇을 비교하는가?', 2, 'low', '값만 비교', '참조 비교', '깊은 복사 비교', '타입 비교', 28, 'toBe()는 객체의 참조까지 포함한 엄격한 동일성(===)을 비교합니다.'),
                                                                                                                           (1362, 'Jasmine에서 ''toEqual()'' 매처는 어떤 비교를 수행하는가?', 2, 'low', '참조 비교', '값 비교', '주소 비교', '타입 체크', 28, 'toEqual()은 객체나 배열 등 구조가 같은 값을 비교합니다.'),
                                                                                                                           (1363, 'Jasmine에서 ''toBeTruthy()'' 매처는 어떤 결과를 기대하는가?', 3, 'low', 'false', 'null', 'truthy 값', 'undefined', 28, 'toBeTruthy()는 true로 간주될 수 있는 모든 truthy 값을 기대합니다.'),
                                                                                                                           (1364, 'Jasmine에서 배열이나 객체의 포함 여부를 검사하는 매처는?', 2, 'medium', 'toBeDefined()', 'toContain()', 'toMatch()', 'toBeGreaterThan()', 28, 'toContain()은 배열이나 문자열에 특정 값이 포함되어 있는지를 검사합니다.'),
                                                                                                                           (1365, 'Jasmine 테스트 구조에서 ''beforeEach''는 어떤 역할을 하는가?', 2, 'medium', '모든 테스트 후 초기화', '각 테스트 전에 준비 작업 수행', '모든 테스트 후 실행', '모든 테스트를 스킵', 28, 'beforeEach()는 각 it() 테스트 실행 전 초기 설정 작업을 수행합니다.'),
                                                                                                                           (1366, 'Jasmine 매처 중 정규 표현식 검증에 사용하는 것은?', 1, 'medium', 'toMatch()', 'toContain()', 'toBeDefined()', 'toBeTruthy()', 28, 'toMatch()는 문자열이 정규 표현식과 일치하는지를 확인합니다.'),
                                                                                                                           (1367, 'Jasmine에서 값이 undefined가 아닌지 확인하는 매처는?', 3, 'high', 'toBeNull()', 'toBeFalsy()', 'toBeDefined()', 'toEqual()', 28, 'toBeDefined()는 undefined가 아님을 검증하는 데 사용됩니다.'),
                                                                                                                           (1368, 'Jasmine에서 ''not''을 사용하면 매처의 의미가 어떻게 변하는가?', 2, 'high', '조건이 강제된다', '반대 조건을 테스트', '항상 true 반환', '비교를 생략', 28, 'expect(value).not.toEqual(x)과 같이 사용하면 반대 조건을 테스트합니다.'),
                                                                                                                           (1369, 'Jasmine에서 두 값이 ''같거나 크다''를 검사하는 매처는?', 1, 'high', 'toBeGreaterThanOrEqual()', 'toBeLessThan()', 'toBe()', 'toEqual()', 28, 'toBeGreaterThanOrEqual()은 크거나 같은 값을 테스트할 때 사용됩니다.'),
                                                                                                                           (1370, 'Jasmine 매처 중 배열의 길이를 검증하는 매처는?', 1, 'high', 'toHaveLength()', 'toContainLength()', 'toMatchLength()', 'toEqualLength()', 28, 'toHaveLength()는 배열이나 문자열의 길이를 검증합니다.'),
                                                                                                                           (1371, 'Jasmine에서 비동기 테스트를 완료하기 위해 사용하는 인자는?', 2, 'low', 'resolve', 'done', 'finish', 'end', 28, 'done은 비동기 테스트가 끝났음을 Jasmine에 알리기 위해 사용됩니다.'),
                                                                                                                           (1372, '비동기 테스트에서 done() 호출을 잊으면 테스트 결과는?', 2, 'low', '성공', '실패', '무시', '강제 패스', 28, 'done()을 호출하지 않으면 Jasmine은 테스트가 끝나지 않았다고 판단하여 실패 처리합니다.'),
                                                                                                                           (1373, 'setTimeout을 사용하는 테스트에서 반드시 해야 하는 것은?', 3, 'low', 'spy 생성', 'afterEach 호출', 'done() 호출', 'flush() 호출', 28, 'setTimeout 등 비동기 작업이 포함된 테스트에서는 done()을 호출해 완료를 알려야 합니다.'),
                                                                                                                           (1374, 'Jasmine의 비동기 테스트는 기본적으로 몇 초 후 타임아웃이 발생하는가?', 3, 'medium', '1초', '3초', '5초', '10초', 28, '기본적으로 Jasmine은 비동기 테스트에서 5초를 넘기면 타임아웃으로 간주합니다.'),
                                                                                                                           (1375, '비동기 작업 완료 후 done.fail()을 호출하면 테스트 결과는?', 2, 'medium', '성공', '실패', '경고', '건너뜀', 28, 'done.fail()은 비동기 작업 도중 에러가 발생했음을 알리고 테스트를 실패 처리합니다.'),
                                                                                                                           (1376, 'async/await를 사용할 때 Jasmine에서 done()을 사용해야 하는가?', 2, 'medium', '항상 필요', '필요 없다', '테스트마다 다름', 'await 내부만 필요', 28, 'async/await 구문을 사용할 경우 done()을 따로 사용할 필요가 없습니다.'),
                                                                                                                           (1377, 'fakeAsync() 함수의 주된 역할은?', 2, 'high', '실제 비동기 호출', '비동기 코드 동기화', 'spy 생성', 'mock 데이터 제공', 28, 'fakeAsync()는 setTimeout 같은 비동기 코드를 동기적으로 제어할 수 있게 합니다.'),
                                                                                                                           (1378, 'tick() 함수는 어떤 상황에서 사용하는가?', 1, 'high', '비동기 지연을 시뮬레이션', 'HTTP 요청 차단', '스파이 추적', '테스트 그룹 생성', 28, 'tick()은 fakeAsync() 내부에서 비동기 지연 시간만큼 시뮬레이션합니다.'),
                                                                                                                           (1379, 'flush() 함수는 어떤 역할을 하는가?', 1, 'high', '모든 pending 타이머 실행', '모든 spy 제거', '테스트 그룹 제거', '모든 에러 무시', 28, 'flush()는 모든 지연된 타이머를 즉시 실행하여 테스트 흐름을 빠르게 진행시킵니다.'),
                                                                                                                           (1380, '비동기 테스트 중 특정 지연 시간을 시뮬레이션하려면 어떤 조합을 사용하는가?', 1, 'high', 'fakeAsync() + tick()', 'async() + flush()', 'it() + spyOn()', 'beforeEach() + done()', 28, 'fakeAsync() + tick() 조합은 비동기 지연을 동기적 흐름으로 제어할 때 사용됩니다.'),
                                                                                                                           (1381, 'Jasmine에서 함수를 가로채고 감시하는 도구는? (정답: Spy - Jasmine에서 특정 함수의 호출 여부, 인자, 반환값 등을 감시할 수 있게 하는 테스트 도구)', 2, 'low', 'Mock', 'Spy', 'Stub', 'Fake', 28, 'Spy는 Jasmine에서 함수의 호출 여부, 인자, 반환값 등을 감시하기 위해 사용되는 도구로, 테스트 대상 함수의 동작을 추적할 수 있게 해준다.'),
                                                                                                                           (1382, 'SpyOn 함수의 주요 기능은? (정답: 함수 호출 감시 - SpyOn은 특정 객체의 메서드 호출 여부, 호출 횟수, 인자 등을 감시할 수 있다)', 2, 'low', '테스트 실행', '함수 호출 감시', '컴포넌트 생성', '라우팅 추적', 28, 'spyOn 함수는 객체의 메서드를 감시하도록 설정하여 호출 여부와 인자 등을 추적할 수 있도록 도와준다.'),
                                                                                                                           (1383, 'Jasmine에서 ''and.returnValue()''를 사용하면? (정답: 지정된 값을 반환한다 - 원래 함수 대신 특정 값을 반환하게 설정할 수 있다)', 2, 'low', '원래 함수를 호출한다', '지정된 값을 반환한다', '오류를 발생시킨다', '비동기 동작을 차단한다', 28, 'and.returnValue()는 원래 함수를 실행하는 대신 지정된 값을 반환하도록 설정하여 테스트에서 예측 가능한 출력을 얻을 수 있게 해준다.'),
                                                                                                                           (1384, 'SpyOn을 사용할 때 필요한 첫 번째 인자는 무엇인가? (정답: 타겟 객체 - 감시하고자 하는 객체를 첫 번째 인자로 전달해야 한다)', 2, 'medium', '테스트 케이스', '타겟 객체', '메서드 이름', '리턴 값', 28, 'spyOn의 첫 번째 인자는 감시할 대상 객체로, 이 객체에 포함된 특정 메서드를 두 번째 인자로 지정하여 감시할 수 있다.'),
                                                                                                                           (1385, 'SpyOn을 사용할 때 두 번째 인자는 무엇인가? (정답: 메서드 이름 - 감시 대상 객체의 어떤 메서드를 감시할지 지정하는 문자열)', 3, 'medium', '리턴 값', '타겟 객체', '메서드 이름', '테스트 설명', 28, 'spyOn 함수의 두 번째 인자는 감시할 메서드의 이름으로, 해당 메서드의 호출 여부와 인자를 추적한다.'),
                                                                                                                           (1386, 'spy.calls.any()는 무엇을 확인하는가? (정답: 한 번이라도 호출되었는지 여부 - 호출이 한 번이라도 있었는지를 boolean으로 반환)', 3, 'medium', '호출 횟수', '최초 호출 여부', '한 번이라도 호출되었는지 여부', '모든 호출 데이터', 28, 'spy.calls.any()는 감시 중인 함수가 테스트 동안 한 번이라도 호출되었는지를 boolean 값으로 반환한다.'),
                                                                                                                           (1387, '스파이가 호출된 횟수를 확인하는 방법은? (정답: spy.calls.count() - Jasmine의 API로 스파이 함수의 호출 횟수를 반환함)', 2, 'high', 'spy.callCount()', 'spy.calls.count()', 'spy.getCall()', 'spy.count()', 28, 'spy.calls.count()는 해당 스파이가 몇 번 호출되었는지를 정수로 반환해준다.'),
                                                                                                                           (1388, '스파이가 호출된 인자를 확인하려면? (정답: spy.calls.argsFor() - 특정 호출에 전달된 인자들을 확인할 수 있는 메서드)', 1, 'high', 'spy.calls.argsFor()', 'spy.args()', 'spy.calls.getArguments()', 'spy.arguments()', 28, 'spy.calls.argsFor(index)는 지정한 호출 순서의 인자 리스트를 배열로 반환하여 확인할 수 있게 해준다.'),
                                                                                                                           (1389, 'SpyOnProperty()는 무엇을 스파이하는가? (정답: 객체 프로퍼티 - 객체의 getter/setter를 감시하고자 할 때 사용)', 2, 'high', '객체 메서드', '객체 프로퍼티', '라우트 파라미터', 'DOM 이벤트', 28, 'spyOnProperty는 객체의 속성 접근(getter/setter)을 감시하기 위해 사용되며, 속성의 접근 및 변경 여부를 추적한다.'),
                                                                                                                           (1390, 'Jasmine에서 스파이를 리셋하려면 사용하는 함수는? (정답: spy.calls.reset() - 호출 기록을 초기화하는 함수)', 3, 'high', 'reset()', 'spy.resetCalls()', 'spy.calls.reset()', 'spy.clear()', 28, 'spy.calls.reset()은 이전 호출 기록을 제거하여 테스트 간 간섭 없이 새롭게 감시를 시작할 수 있도록 한다.'),
                                                                                                                           (1391, 'Angular에서 컴포넌트 테스트를 준비할 때 사용하는 함수는? (정답: configureTestingModule() - 테스트 모듈 설정 및 구성)', 1, 'low', 'configureTestingModule()', 'setupTesting()', 'initTesting()', 'initializeTest()', 28, 'configureTestingModule은 Angular 테스트 환경에서 선언, 모듈, 프로바이더 등을 설정하여 테스트 실행을 준비한다.'),
                                                                                                                           (1392, 'TestBed는 무엇을 위한 Angular 유틸리티인가? (정답: 컴포넌트 테스트 환경 구성 - Angular의 테스트 환경을 구성하는 핵심 도구)', 2, 'low', '라우팅 제어', '컴포넌트 테스트 환경 구성', 'HTTP 요청 처리', '서버 사이드 렌더링', 28, 'TestBed는 Angular의 테스트 환경을 구성하고 컴포넌트, 서비스 등을 설정하여 테스트를 실행할 수 있도록 한다.'),
                                                                                                                           (1393, 'TestBed.configureTestingModule()에서 등록하는 것이 아닌 것은? (정답: controllers - Angular에서는 controllers라는 옵션이 존재하지 않음)', 4, 'low', 'declarations', 'imports', 'providers', 'controllers', 28, 'TestBed의 configureTestingModule 설정에는 controllers 옵션이 없으며, declarations, imports, providers 등이 포함된다.'),
                                                                                                                           (1394, 'Angular 테스트에서 컴포넌트 인스턴스를 얻기 위해 사용하는 객체는? (정답: ComponentFixture - 컴포넌트와 템플릿 접근 및 테스트에 사용)', 1, 'medium', 'ComponentFixture', 'TestRunner', 'TestComponent', 'TestingModule', 28, 'ComponentFixture는 테스트 중인 컴포넌트 인스턴스와 그 DOM에 접근할 수 있는 객체이다.'),
                                                                                                                           (1395, 'fixture.detectChanges()의 역할은? (정답: 컴포넌트 변경 사항 반영 - 데이터 바인딩 및 DOM 갱신 트리거)', 2, 'medium', '라우터 초기화', '컴포넌트 변경 사항 반영', '테스트 종료', '서버 통신 시작', 28, 'detectChanges()는 Angular의 변경 감지를 수동으로 트리거하여 컴포넌트의 바인딩과 DOM을 최신 상태로 만든다.'),
                                                                                                                           (1396, 'TestBed.createComponent()가 반환하는 것은? (정답: 컴포넌트 인스턴스 - 테스트를 위한 컴포넌트 생성 및 제어)', 1, 'medium', '컴포넌트 인스턴스', '서비스 인스턴스', 'HTTP 요청 객체', 'Router 객체', 28, 'createComponent()는 테스트 대상 컴포넌트를 생성하고 fixture 객체를 반환하여 테스트 제어를 가능하게 한다.'),
                                                                                                                           (1397, 'Angular에서 서비스 테스트를 위해 사용되는 함수는? (정답: inject() - 의존성 주입 기반의 서비스 테스트 구성)', 2, 'high', 'TestService()', 'inject()', 'getService()', 'setupService()', 28, 'inject() 함수는 테스트 케이스 내부에서 Angular 의존성 주입을 통해 서비스 인스턴스를 획득하게 해준다.'),
                                                                                                                           (1398, 'TestBed.inject()로 얻은 인스턴스는 어디에서 사용 가능한가? (정답: 해당 스펙 내에서만 - 테스트 케이스 내부에서만 유효함)', 2, 'high', '모든 테스트 케이스', '해당 스펙 내에서만', '어플리케이션 전체', '루트 모듈', 28, 'TestBed.inject()는 해당 테스트 블록 또는 함수 범위 내에서만 유효하며, 전역 사용은 불가능하다.'),
                                                                                                                           (1399, 'Angular 테스트에서 async() 함수의 주요 역할은? (정답: 비동기 작업 대기 - 비동기 로직 완료 후 테스트 진행)', 2, 'high', '동기화 보장', '비동기 작업 대기', '라우터 초기화', '모듈 등록', 28, 'async()는 Angular 테스트에서 비동기 작업 완료를 기다린 후 테스트가 진행되도록 도와주는 헬퍼 함수이다.'),
                                                                                                                           (1400, 'Angular 테스트 환경을 재설정하려면 호출해야 하는 함수는? (정답: TestBed.resetTestingModule() - 테스트 환경 재사용을 방지하고 새롭게 초기화)', 2, 'high', 'TestBed.clearTestingModule()', 'TestBed.resetTestingModule()', 'TestBed.rebuild()', 'TestBed.cleanup()', 28, 'resetTestingModule()은 테스트 환경을 초기 상태로 되돌려 테스트 간 간섭을 방지한다.'),
                                                                                                                           (1401, '클라이언트 잘못된 요청(예: JSON 스키마 위반)에 대한 권장 HTTP 상태 코드는? (정답: 400 Bad Request - 클라이언트 측의 요청 오류를 나타냄)', 1, 'low', '400 Bad Request', '401 Unauthorized', '500 Internal Server Error', '409 Conflict', 29, '400 상태 코드는 클라이언트 요청에 잘못된 구문이나 유효하지 않은 데이터를 포함한 경우 사용된다.'),
                                                                                                                           (1402, '인증 헤더가 누락된 요청에 서버가 반환해야 할 표준 상태 코드는? (정답: 401 Unauthorized - 인증이 필요한 리소스 접근 시 사용)', 1, 'low', '401 Unauthorized', '403 Forbidden', '412 Precondition Failed', '502 Bad Gateway', 29, '401은 인증 정보가 누락되었거나 유효하지 않은 경우 인증이 필요하다는 의미로 서버가 반환한다.'),
                                                                                                                           (1403, 'REST API에서 존재하지 않는 리소스에 대한 GET 요청 시 적절한 응답 코드는? (정답: 404 Not Found - 리소스가 존재하지 않음을 명시)', 1, 'low', '404 Not Found', '410 Gone', '204 No Content', '422 Unprocessable Entity', 29, '404는 요청된 자원이 서버에 존재하지 않을 때 반환되며, 잘못된 경로나 삭제된 리소스를 나타낸다.'),
                                                                                                                           (1404, 'RFC 7807 ‘Problem Details for HTTP APIs’가 권장하는 기본 Content-Type은? (정답: application/problem+json - 문제 세부 정보 표준 포맷의 MIME 타입)', 1, 'medium', 'application/problem+json', 'application/json; problem', 'text/problem', 'application/vnd.error+json', 29, 'RFC 7807에서 문제 세부 정보를 JSON 형식으로 표현하기 위해 application/problem+json을 MIME 타입으로 권장한다.'),
                                                                                                                           (1405, 'RFC 7807 JSON 응답 예시에서 반드시 포함해야 하는 필드는? (정답: title - 오류의 간략한 요약 제목 역할)', 1, 'medium', 'title', 'instance', 'detail', 'errors', 29, 'title 필드는 오류 상황을 요약하여 사람이 읽기 쉬운 설명을 제공하며 필수로 포함되어야 한다.'),
                                                                                                                           (1406, '다음 중 4xx와 5xx 상태 코드 차이에 대한 설명으로 옳지 않은 것은? (정답: 4xx는 절대 재시도해서는 안 된다 - 일부 4xx는 사용자 수정 후 재시도 가능)', 4, 'medium', '4xx는 클라이언트 오류, 5xx는 서버 오류를 나타낸다', '5xx는 재시도 가능성이 4xx보다 높다', '4xx 오류라도 Problem Details 바디를 포함할 수 있다', '4xx는 절대 재시도해서는 안 된다', 29, '일부 4xx(예: 400, 429 등)는 사용자가 수정 후 다시 시도할 수 있으므로 "절대 재시도 불가"는 옳지 않다.'),
                                                                                                                           (1407, '동일 자원 중복 생성 시 서버가 반환해도 멱등성 규칙을 깨지지 않는 상태 코드는? (정답: 409 Conflict - 동일 자원 존재 시 중복 충돌로 응답, 상태 변경 없음)', 1, 'high', '409 Conflict', '201 Created', '202 Accepted', '302 Found', 29, '409는 요청이 리소스와 충돌할 때 발생하며, 멱등한 요청에서도 서버 상태를 변경하지 않으므로 안전하다.'),
                                                                                                                           (1408, 'Problem Details 바디에 커스텀 ‘code’ 정수 필드를 두는 주된 이점은? (정답: 클라이언트가 로컬라이징 메시지를 매핑하기 쉽다 - 코드 기반으로 사용자 메시지 구성 가능)', 1, 'high', '클라이언트가 로컬라이징 메시지를 매핑하기 쉽다', 'HTTP 상태 코드 전송을 생략할 수 있다', 'JSON 패싱을 건너뛸 수 있다', 'CORS 프리플라이트를 우회한다', 29, '정수 기반 코드 필드를 제공하면 클라이언트는 언어별 메시지 템플릿과 쉽게 매핑할 수 있다.'),
                                                                                                                           (1409, '다음 중 idempotent 메서드가 아닌 것은? (정답: POST - 서버 상태를 변경하며, 여러 번 호출하면 결과가 달라질 수 있음)', 1, 'high', 'POST', 'PUT', 'DELETE', 'HEAD', 29, 'POST는 리소스를 생성하거나 변경하며, 같은 요청을 여러 번 실행할 경우 결과가 달라질 수 있어 멱등하지 않다.'),
                                                                                                                           (1410, '클라이언트가 429 Too Many Requests 응답을 받을 때 재시도 시점을 알기 위해 확인해야 하는 헤더는? (정답: Retry-After - 재시도 가능한 시점을 명시하는 HTTP 헤더)', 1, 'high', 'Retry-After', 'Warning', 'WWW-Authenticate', 'Content-Encoding', 29, 'Retry-After 헤더는 서버가 과부하일 때, 클라이언트가 다음 요청을 언제부터 시도할 수 있는지 명시한다.'),
                                                                                                                           (1411, '브라우저 네트워크 오류 vs HTTP 오류 구분 방법은? (정답: 응답 없음 & error.request 존재 → 네트워크 오류 - 서버 응답 자체가 없고 request 객체만 존재하면 네트워크 오류로 간주)', 1, 'low', '응답 없음 & error.request 존재 → 네트워크 오류', 'status 0이면 HTTP 오류', 'message에 Network Error 포함 시 HTTP 오류', 'https로 시작시 네트워크 오류 없음', 29, '브라우저에서 error 객체에 response 없이 request만 존재하면 서버와 통신이 되지 않은 네트워크 오류로 판단한다.'),
                                                                                                                           (1412, '422 오류 UX 비추천 패턴은? (정답: 모달 전체 가리고 중앙만 오류 - 사용자의 오류 위치 인지가 어렵고 UX 흐름을 방해함)', 1, 'low', '모달 전체 가리고 중앙만 오류', '필드 인라인 표시', '폼 상단 요약', '스낵바 알림', 29, '모달이 전체를 가리고 오류를 중앙에 표시하면 사용자는 어느 필드가 잘못되었는지 인지하기 어렵고 흐름이 끊긴다.'),
                                                                                                                           (1413, '전역 오류 핸들러 역할은? (정답: 로그인 만료 등 공통 처리 - 인증 만료나 권한 오류 같은 반복 처리 상황에 적합)', 1, 'low', '로그인 만료 등 공통 처리', '레이아웃 교체', 'CSS 초기화', 'History 재설정', 29, '전역 오류 핸들러는 인증 오류나 세션 만료 같은 반복적인 공통 에러 처리를 한 곳에서 일괄 처리하는 역할을 한다.'),
                                                                                                                           (1414, '오프라인 GET 요청 전략은? (정답: 대기열 저장 후 복구 시 재시도 - 네트워크 복구 시 정상 흐름 복원 가능)', 1, 'medium', '대기열 저장 후 복구 시 재시도', '캐시 비우고 에러', '503 구성', '무한 로딩', 29, 'GET 요청을 대기열에 저장하고 네트워크 복구 후 재시도하면 사용자 경험을 유지하며 재시도 흐름을 제어할 수 있다.'),
                                                                                                                           (1415, 'Error Boundary 해결 문제는? (정답: 렌더 예외로 인한 흰 화면 - 컴포넌트 렌더 중 예외가 발생해 전체 UI가 손상될 때)', 1, 'medium', '렌더 예외로 인한 흰 화면', 'API 500 재시도', 'CORS 차단', 'WebSocket', 29, 'React에서 Error Boundary는 렌더링 중 예외가 발생해 UI가 전부 깨지는 문제를 방지하고 대체 UI를 보여준다.'),
                                                                                                                           (1416, '중복 POST 방지 클라이언트 조치? (정답: 이전 요청 취소 AbortController - 같은 요청이 중복되지 않도록 취소 기능 활용)', 1, 'medium', '이전 요청 취소 AbortController', 'Cache-Control no-store', 'POST→GET', '로그 제거', 29, 'AbortController를 활용하면 이전 요청을 중단시켜 서버에 중복 요청이 가지 않도록 방지할 수 있다.'),
                                                                                                                           (1417, 'axios 취소 vs 네트워크 오류 구분 프로퍼티? (정답: error.code === ''ERR_CANCELED'' - 취소된 요청만 해당 코드가 명시됨)', 1, 'high', 'error.code === ''ERR_CANCELED''', 'message 포함 Network', 'status -1', 'timeout 0', 29, 'axios 요청이 취소되면 error.code가 ''ERR_CANCELED''로 설정되므로 네트워크 오류와 명확히 구분할 수 있다.'),
                                                                                                                           (1418, '국제화 오류 메시지 비추천 방법은? (정답: 서버가 완제품 문구 제공 - 번역 및 지역화가 어려워 유지보수에 불리함)', 1, 'high', '서버가 완제품 문구 제공', '클라이언트 코드 매핑', 'title/detail 키 사용', '템플릿 변수 치환', 29, '서버가 완성된 문구를 제공하면 다국어 번역 및 클라이언트 UX 맞춤 처리가 어려워지는 단점이 있다.'),
                                                                                                                           (1419, '모바일 에러/재요청 데이터 최소화 우선 고려는? (정답: 오프라인 감지 후 백오프 - 네트워크 상태를 감지하여 불필요한 재요청을 지연)', 1, 'high', '오프라인 감지 후 백오프', '해상도 다운', '캐시 삭제', 'UDP 강제', 29, '모바일 환경에서는 오프라인 상태를 감지하고 요청을 지연(backoff)시켜 배터리 및 네트워크 자원을 절약할 수 있다.'),
                                                                                                                           (1420, '사용자 메시지+디버그 정보 구조 권장? (정답: UI 요약 & 콘솔 raw trace - 사용자에게는 요약 제공, 개발자에겐 상세 로그 유지)', 1, 'high', 'UI 요약 & 콘솔 raw trace', 'alert 모두', '서버 HTML 오류 페이지', '쿠키 저장', 29, '사용자에게는 간결한 메시지를, 개발자에게는 콘솔이나 로그로 상세 오류 트레이스를 제공하는 것이 UX 및 디버깅에 효과적이다.'),
                                                                                                                           (1421, '멱등 메서드는? (정답: PUT - 여러 번 실행해도 결과가 동일한 요청 메서드)', 1, 'low', 'PUT', 'POST', 'PATCH', 'CONNECT', 29, 'PUT은 같은 요청을 여러 번 보내더라도 리소스 상태가 동일하게 유지되므로 멱등한 메서드이다.'),
                                                                                                                           (1422, '고정 3초 4번 총 지연? (정답: 12초 - 3초씩 4회 대기)', 1, 'low', '12초', '9초', '6초', '3초', 29, '3초씩 4회 대기하면 총 지연 시간은 3 * 4 = 12초이다.'),
                                                                                                                           (1423, '지수 1s 배수2 3회 누적? (정답: 7 s - 1 + 2 + 4초)', 1, 'medium', '7 s', '6 s', '5 s', '4 s', 29, '지수 백오프에서 1초로 시작하여 2배씩 증가하는 경우, 1 + 2 + 4 = 7초가 된다.'),
                                                                                                                           (1424, 'Retry-After 120 권장 재시도? (정답: 120초 이상 후 - 헤더에 명시된 시간 이후 재시도해야 서버 부하 방지)', 1, 'medium', '120초 이상 후', '60초', '즉시', '무시', 29, 'Retry-After 헤더는 서버가 지정한 시간까지 클라이언트가 재요청을 중단해야 함을 명시한다.'),
                                                                                                                           (1425, 'POST 안전 재시도 보완책? (정답: Idempotency-Key 헤더 - 동일 키에 대한 요청은 서버가 중복 처리 방지)', 1, 'medium', 'Idempotency-Key 헤더', 'HTTP/2 업그레이드', '빈 바디', 'PUT 사용', 29, 'Idempotency-Key를 통해 서버는 동일한 키에 대해 중복 요청을 무시하여 POST의 안전한 재시도를 지원한다.'),
                                                                                                                           (1426, '재시도 고려 가능한 408/409? (정답: 408 Request Timeout - 네트워크 지연으로 응답 실패 시 재시도 가능)', 1, 'medium', '408 Request Timeout', '409 Conflict', '400', '401', 29, '408은 일시적인 네트워크 타임아웃이므로 일정 시간 후 재시도가 유효할 수 있다.'),
                                                                                                                           (1427, 'Full Jitter 목적은? (정답: 서버 폭주 완화 - 랜덤 지연을 주어 동시 재시도로 인한 서버 부하 방지)', 1, 'high', '서버 폭주 완화', '총 지연 줄임', 'TCP 우회', 'TLS 감소', 29, 'Full Jitter는 재시도 간 지연을 무작위로 하여 동시 요청을 분산시키고 서버 부하를 줄인다.'),
                                                                                                                           (1428, '재시도 불가 오류 유형? (정답: 400 필드 검증 - 클라이언트 입력이 잘못되어 재요청해도 실패)', 1, 'high', '400 필드 검증', '502', '408', '429', 29, '400 오류는 클라이언트가 잘못된 데이터를 보낸 경우로, 재요청하더라도 성공할 가능성이 없으므로 재시도 대상이 아니다.'),
                                                                                                                           (1429, '조건부 PUT 재시도 안전 이유? (정답: ETag 버전 동일 시만 수행 - 서버 자원의 현재 버전과 일치할 때만 실행)', 1, 'high', 'ETag 버전 동일 시만 수행', 'PUT 캐싱', 'HTTP/3 전용', '브라우저 보장', 29, 'ETag 조건을 통해 서버의 자원이 클라이언트의 버전과 일치할 때만 수정이 이루어지므로 멱등성을 유지할 수 있다.'),
                                                                                                                           (1430, '모바일 TCP 끊김 POST 문제 감소? (정답: 짧은 타임아웃 + 멱등 키 - 빠르게 실패하고 안전한 재시도 유도)', 1, 'high', '짧은 타임아웃 + 멱등 키', 'HTTP 1.0', '재시도 끔', '인증 제거', 29, '짧은 타임아웃으로 빠르게 실패를 감지하고, 멱등 키로 중복 요청을 제어하여 신뢰성 있게 재시도할 수 있다.'),
                                                                                                                           (1431, 'Circuit Closed→Open 조건? (정답: 연속 실패 임계 - 지정된 실패 횟수 초과 시 자동으로 Open 상태 전이)', 1, 'low', '연속 실패 임계', '성공 200', '301', '쿠키 만료', 29, 'Circuit Breaker는 일정 횟수 이상 연속 실패가 발생하면 자동으로 회로를 열어 호출을 차단한다.'),
                                                                                                                           (1432, 'Half-Open 성공 전이? (정답: Closed - 테스트 성공 시 CircuitBreaker가 정상 상태로 복원)', 1, 'low', 'Closed', 'Open', 'Forced-Open', 'Isolated', 29, 'Half-Open 상태에서 일부 요청이 성공하면 CircuitBreaker는 다시 Closed 상태로 돌아간다.'),
                                                                                                                           (1433, 'Open 상태 바로 실패 목적? (정답: 백엔드 부하 차단 - 불필요한 호출을 막아 서버 보호)', 1, 'low', '백엔드 부하 차단', '캐시 무효', 'TLS 시간 줄임', 'DNS 재해석', 29, 'Open 상태에서는 요청이 즉시 실패하여 백엔드에 트래픽이 가지 않도록 해 서버 보호에 기여한다.'),
                                                                                                                           (1434, '재시도+CB 충돌 위험? (정답: 과도 재시도→즉시 Open - 재시도가 계속되면 실패율 상승으로 회로가 열린다)', 1, 'medium', '과도 재시도→즉시 Open', 'Jitter 제거', 'Retry-After 무시', 'HTTP/2 끊김', 29, '과도한 재시도는 실패율을 급격히 높여 CircuitBreaker가 Open 상태로 빠르게 전이될 위험을 높인다.'),
                                                                                                                           (1435, 'Coalescing 효과 시나리오? (정답: 같은 리소스 다수 GET - 중복 요청을 병합하여 서버 요청 수 감소)', 1, 'medium', '같은 리소스 다수 GET', '다른 POST', 'WebSocket', 'SSE', 29, 'Coalescing은 동일한 리소스에 대한 중복 GET 요청을 병합하여 서버에 보내는 요청 수를 줄이는 최적화 기법이다.'),
                                                                                                                           (1436, 'Equal Jitter 이점 아닌 것? (정답: 최대/최소 지연 예측 - Equal Jitter는 지연의 랜덤성을 유지하여 정확한 예측이 어려움)', 2, 'medium', '스파이크 완화', '최대/최소 지연 예측', 'Full Jitter보다 대기 줄임', '서버 완화', 29, 'Equal Jitter는 무작위 지연을 도입하기 때문에 예측 가능한 최대/최소 지연 시간을 보장하지 않는다.'),
                                                                                                                           (1437, 'Fallback 전략 사례? (정답: 캐시된 데이터로 표시 - 서버 응답 실패 시 대체 데이터 제공)', 1, 'high', '캐시된 데이터로 표시', '재시도 0', 'CB 강제 Close', 'Retry-After 무시', 29, 'Fallback 전략은 서버 실패 시 로컬 캐시 등 대체 수단을 활용하여 사용자 경험을 유지하는 데 목적이 있다.'),
                                                                                                                           (1438, 'Hedged Request 주의점? (정답: 멱등 보장 필요 - 동일 요청을 여러 서버에 보내므로 중복 처리 위험)', 1, 'high', '멱등 보장 필요', 'DNS TTL 0', 'KEEP-ALIVE 끊기', 'TLS 1.3', 29, 'Hedged Request는 요청을 병렬로 여러 서버에 보내므로 중복 처리를 막기 위해 멱등성을 보장해야 한다.'),
                                                                                                                           (1439, 'Max-Retry-TTL 목적? (정답: 무제한 지연 방지 - 최대 누적 지연 시간 제한하여 재시도 루프 차단)', 1, 'high', '무제한 지연 방지', 'TCP FIN 감소', '브라우저 버그 회피', 'Keep-Alive 증가', 29, 'Max-Retry-TTL은 전체 재시도 지연 시간이 일정 한계를 넘지 않도록 하여 사용자 경험을 보호한다.'),
                                                                                                                           (1440, 'CB 실시간 튜닝 기법? (정답: Feature Flag 기반 임계 조정 - 운영 중에도 설정을 유연하게 조절 가능)', 1, 'high', 'Feature Flag 기반 임계 조정', '콘솔 변수', '헤더 하드코드', '빌드 상수', 29, 'Feature Flag를 사용하면 CircuitBreaker 임계값을 실시간으로 조정할 수 있어 운영 중 대응이 유연하다.'),
                                                                                                                           (1441, '자주 쓰는 SLO 쌍은?', 1, 'low', '가용성·오류율', 'CPU·메모리', '빌드시간·커버리지', 'PR 리뷰', 29, '가용성과 오류율은 사용자 경험과 직접적으로 연관되는 핵심 지표로, SLO와 SLA 기준 수립에 가장 자주 사용된다.'),
                                                                                                                           (1442, 'P99 증가 의심 원인?', 1, 'low', '소수 요청 재시도 지연', '평균 느려짐', '404 급증', '로깅 오류', 29, 'P99는 가장 느린 1%의 요청 시간으로, 일부 요청의 반복 재시도나 비정상적인 지연이 주요 원인이 된다.'),
                                                                                                                           (1443, '분산 추적 유용 이유?', 1, 'medium', 'Trace로 재시도 체인 시각화', '헤더 암호화', '로그 제거', '패킷 캡처', 29, 'Trace를 통해 마이크로서비스 간의 호출 흐름과 재시도 시점을 시각적으로 파악할 수 있어 문제 진단에 효과적이다.'),
                                                                                                                           (1444, 'Chaos 테스트 간단 도구?', 1, 'medium', 'MSW random error', 'CSS Lint', 'Bundle Analyzer', 'Lighthouse', 29, 'MSW는 실제 API 호출 대신 무작위 오류 응답을 시뮬레이션함으로써 Chaos 테스트를 간편하게 수행할 수 있다.'),
                                                                                                                           (1445, '포스트모템 포함 아님?', 1, 'medium', '담당자 인적 정보', '타임라인', 'RCA', '재발 방지', 29, '포스트모템은 시스템적 원인 분석과 개선에 집중하므로 개인 정보는 포함하지 않는다.'),
                                                                                                                           (1446, '알림 임계 낮음 문제?', 1, 'high', 'Alert Fatigue', 'MTTR 증가', 'Slack→Email', 'Grafana 꺼짐', 29, '잦고 사소한 알림은 사용자로 하여금 중요한 경보도 무시하게 만드는 Alert Fatigue 현상을 초래할 수 있다.'),
                                                                                                                           (1447, '롤아웃 안전 배포 전략?', 1, 'high', 'Feature Flag Gradual', 'Big-bang', 'Force-push', 'CI 캐시 무효', 29, 'Feature Flag는 기능을 점진적으로 켜는 방식으로 위험을 줄이고 문제 발생 시 쉽게 롤백 가능하다.'),
                                                                                                                           (1448, '로그 레벨 매핑?', 1, 'high', '시작 debug, 재시도 info, 실패 error', '모두 warn', '재시도 fatal', '성공 error', 29, '로그 레벨을 단계별로 구분하면 원인 분석 시 중요한 이벤트를 효과적으로 추적할 수 있다.'),
                                                                                                                           (1449, '슬라이딩 윈도우 오류율 이유?', 1, 'high', '즉시값 대신 경향 파악', '메트릭 안 삭제', '테스트 속도', '다크 테마', 29, '슬라이딩 윈도우는 최신 데이터를 중심으로 경향을 파악하므로 민감하게 변화에 대응할 수 있다.'),
                                                                                                                           (1450, '오류율 상승 자동 롤백 기능은?', 1, 'high', 'Canary 분석 → rollback', 'Merge Queue', 'multi-stage build', 'npm postinstall', 29, 'Canary 배포는 일부 사용자에게만 먼저 배포해 오류를 사전에 탐지하고 자동으로 롤백할 수 있게 한다.'),
                                                                                                                           (1451, '클라이언트 잘못된 요청(예: JSON 스키마 위반)에 대한 권장 HTTP 상태 코드는?', 1, 'low', '400 Bad Request', '401 Unauthorized', '500 Internal Server Error', '409 Conflict', 30, '400 Bad Request는 클라이언트의 요청이 구문 오류나 형식 오류로 인해 서버가 처리할 수 없음을 나타낸다.'),
                                                                                                                           (1452, '인증 헤더가 누락된 요청에 서버가 반환해야 할 표준 상태 코드는?', 1, 'low', '401 Unauthorized', '403 Forbidden', '412 Precondition Failed', '502 Bad Gateway', 30, '401 Unauthorized는 인증이 필요한 요청에서 인증 정보가 누락되었거나 유효하지 않을 때 반환된다.'),
                                                                                                                           (1453, 'REST API에서 존재하지 않는 리소스에 대한 GET 요청 시 적절한 응답 코드는?', 1, 'low', '404 Not Found', '410 Gone', '204 No Content', '422 Unprocessable Entity', 30, '404 Not Found는 요청한 리소스가 서버에 존재하지 않을 때 사용하는 표준 상태 코드이다.'),
                                                                                                                           (1454, 'RFC 7807 ‘Problem Details for HTTP APIs’가 권장하는 기본 Content-Type은?', 1, 'medium', 'application/problem+json', 'application/json; problem', 'text/problem', 'application/vnd.error+json', 30, 'RFC 7807은 표준화된 오류 정보를 제공하기 위해 application/problem+json을 Content-Type으로 지정한다.'),
                                                                                                                           (1455, 'RFC 7807 JSON 응답 예시에서 반드시 포함해야 하는 필드는?', 1, 'medium', 'title', 'instance', 'detail', 'errors', 30, 'title은 오류의 일반적인 요약을 제공하는 필수 필드로, 사용자 및 개발자 모두에게 오류를 식별하는 데 도움을 준다.'),
                                                                                                                           (1456, '다음 중 4xx와 5xx 상태 코드 차이에 대한 설명으로 옳지 않은 것은?', 4, 'medium', '4xx는 클라이언트 오류, 5xx는 서버 오류를 나타낸다', '5xx는 재시도 가능성이 4xx보다 높다', '4xx 오류라도 Problem Details 바디를 포함할 수 있다', '4xx는 절대 재시도해서는 안 된다', 30, '일부 4xx 오류(예: 429, 408 등)는 조건이 해소되면 재시도 가능하므로 "절대 재시도 안 됨"은 잘못된 설명이다.'),
                                                                                                                           (1457, '동일 자원 중복 생성 시 서버가 반환해도 멱등성 규칙을 깨지지 않는 상태 코드는?', 1, 'high', '409 Conflict', '201 Created', '202 Accepted', '302 Found', 30, '409 Conflict는 이미 존재하는 자원에 대한 요청이므로, 상태 변경 없이 동일 상태를 유지해 멱등성을 보장한다.'),
                                                                                                                           (1458, 'Problem Details 바디에 커스텀 ‘code’ 정수 필드를 두는 주된 이점은?', 1, 'high', '클라이언트가 로컬라이징 메시지를 매핑하기 쉽다', 'HTTP 상태 코드 전송을 생략할 수 있다', 'JSON 패싱을 건너뛸 수 있다', 'CORS 프리플라이트를 우회한다', 30, '정수 code 필드는 클라이언트에서 지역화 메시지를 코드에 따라 매핑할 수 있어 사용자 맞춤 응답이 용이하다.'),
                                                                                                                           (1459, '다음 중 idempotent 메서드가 아닌 것은?', 1, 'high', 'POST', 'PUT', 'DELETE', 'HEAD', 30, 'POST는 서버 상태를 변경할 수 있으며, 여러 번 요청 시 결과가 달라질 수 있어 멱등성이 아니다.'),
                                                                                                                           (1460, '클라이언트가 429 Too Many Requests 응답을 받을 때 재시도 시점을 알기 위해 확인해야 하는 헤더는?', 1, 'high', 'Retry-After', 'Warning', 'WWW-Authenticate', 'Content-Encoding', 30, 'Retry-After 헤더는 클라이언트에게 서버가 허용하는 다음 요청 가능 시점을 명시적으로 알려준다.'),
                                                                                                                           (1461, '브라우저 네트워크 오류 vs HTTP 오류 구분 방법은?', 1, 'low', '응답 없음 & error.request 존재 → 네트워크 오류', 'status 0이면 HTTP 오류', 'message에 Network Error 포함 시 HTTP 오류', 'https로 시작시 네트워크 오류 없음', 30, '응답 객체가 없고 error.request가 존재하는 경우, 요청은 전송되었지만 응답이 없었다는 의미로 네트워크 오류다.'),
                                                                                                                           (1462, '422 오류 UX 비추천 패턴은?', 1, 'low', '모달 전체 가리고 중앙만 오류', '필드 인라인 표시', '폼 상단 요약', '스낵바 알림', 30, '전체 모달을 가리고 오류만 중앙에 띄우는 방식은 사용자가 문제의 원인을 직관적으로 파악하기 어렵게 만든다.'),
                                                                                                                           (1463, '전역 오류 핸들러 역할은?', 1, 'low', '로그인 만료 등 공통 처리', '레이아웃 교체', 'CSS 초기화', 'History 재설정', 30, '전역 오류 핸들러는 인증 만료, 네트워크 문제 등 전체 애플리케이션에서 일관된 오류 처리를 담당한다.'),
                                                                                                                           (1464, '오프라인 GET 요청 전략은?', 1, 'medium', '대기열 저장 후 복구 시 재시도', '캐시 비우고 에러', '503 구성', '무한 로딩', 30, '오프라인 시 요청을 저장하고 복구 후 재전송하는 전략은 사용자 경험을 개선하고 데이터 낭비를 줄인다.'),
                                                                                                                           (1465, 'Error Boundary 해결 문제는?', 1, 'medium', '렌더 예외로 인한 흰 화면', 'API 500 재시도', 'CORS 차단', 'WebSocket', 30, 'React에서 Error Boundary는 컴포넌트 렌더 중 예외를 감지하여 전체 앱 마비 대신 안전한 대체 UI를 제공한다.'),
                                                                                                                           (1466, '중복 POST 방지 클라이언트 조치?', 1, 'medium', '이전 요청 취소 AbortController', 'Cache-Control no-store', 'POST→GET', '로그 제거', 30, 'AbortController를 통해 사용자의 중복 입력이나 요청을 감지해 이전 요청을 취소하면 중복 POST를 방지할 수 있다.'),
                                                                                                                           (1467, 'axios 취소 vs 네트워크 오류 구분 프로퍼티?', 1, 'high', 'error.code === ''ERR_CANCELED''', 'message 포함 Network', 'status -1', 'timeout 0', 30, 'axios에서 명시적으로 요청을 취소한 경우 error.code가 ERR_CANCELED로 설정되어 네트워크 오류와 구분된다.'),
                                                                                                                           (1468, '국제화 오류 메시지 비추천 방법은?', 1, 'high', '서버가 완제품 문구 제공', '클라이언트 코드 매핑', 'title/detail 키 사용', '템플릿 변수 치환', 30, '서버가 직접 문구를 제공하면 번역, 유지보수가 어렵고 클라이언트 UX 다양화에 제한이 생긴다.'),
                                                                                                                           (1469, '모바일 에러/재요청 데이터 최소화 우선 고려는?', 1, 'high', '오프라인 감지 후 백오프', '해상도 다운', '캐시 삭제', 'UDP 강제', 30, '모바일 환경에서는 불안정한 네트워크 감지를 통해 재시도를 늦추는 것이 데이터 낭비를 줄이는 효과적인 전략이다.'),
                                                                                                                           (1470, '사용자 메시지+디버그 정보 구조 권장?', 1, 'high', 'UI 요약 & 콘솔 raw trace', 'alert 모두', '서버 HTML 오류 페이지', '쿠키 저장', 30, '사용자는 간결한 오류 요약을 보고, 개발자는 콘솔의 상세 로그로 문제를 진단할 수 있도록 정보를 분리 제공하는 것이 좋다.'),
                                                                                                                           (1471, '멱등 메서드는?', 1, 'low', 'PUT', 'POST', 'PATCH', 'CONNECT', 30, 'PUT은 동일한 요청을 여러 번 보내도 서버의 상태가 변하지 않아 멱등성을 가진다.'),
                                                                                                                           (1472, '고정 3초 4번 총 지연?', 1, 'low', '12초', '9초', '6초', '3초', 30, '3초씩 4회를 대기하면 3×4=12초가 되어 총 지연 시간은 12초이다.'),
                                                                                                                           (1473, '지수 1s 배수2 3회 누적?', 1, 'medium', '7 s', '6 s', '5 s', '4 s', 30, '1초, 2초, 4초의 합은 7초로, 지수 백오프 전략에 따른 누적 지연 시간이다.'),
                                                                                                                           (1474, 'Retry-After 120 권장 재시도?', 1, 'medium', '120초 이상 후', '60초', '즉시', '무시', 30, 'Retry-After 헤더는 최소 대기 시간을 의미하므로 120초 이상 기다린 후 재시도해야 한다.'),
                                                                                                                           (1475, 'POST 안전 재시도 보완책?', 1, 'medium', 'Idempotency-Key 헤더', 'HTTP/2 업그레이드', '빈 바디', 'PUT 사용', 30, 'Idempotency-Key는 동일 요청인지 서버가 식별 가능하게 해 중복 처리 방지에 사용된다.'),
                                                                                                                           (1476, '재시도 고려 가능한 408/409?', 1, 'medium', '408 Request Timeout', '409 Conflict', '400', '401', 30, '408은 네트워크 지연 등 일시적 상황으로 재시도가 유효할 수 있다.'),
                                                                                                                           (1477, 'Full Jitter 목적은?', 1, 'high', '서버 폭주 완화', '총 지연 줄임', 'TCP 우회', 'TLS 감소', 30, '재시도 시점을 무작위로 분산시켜 서버에 동시에 요청이 몰리는 것을 방지한다.'),
                                                                                                                           (1478, '재시도 불가 오류 유형?', 1, 'high', '400 필드 검증', '502', '408', '429', 30, '400 필드 오류는 잘못된 입력으로, 같은 요청을 반복해도 성공할 수 없기 때문에 재시도에 적합하지 않다.'),
                                                                                                                           (1479, '조건부 PUT 재시도 안전 이유?', 1, 'high', 'ETag 버전 동일 시만 수행', 'PUT 캐싱', 'HTTP/3 전용', '브라우저 보장', 30, 'ETag 조건이 일치할 때만 실행되므로 충돌 없이 안전하게 반복 요청 가능하다.'),
                                                                                                                           (1480, '모바일 TCP 끊김 POST 문제 감소?', 1, 'high', '짧은 타임아웃 + 멱등 키', 'HTTP 1.0', '재시도 끔', '인증 제거', 30, '빠르게 실패를 감지하고 안전한 재시도를 위해 멱등성을 식별할 수 있는 키를 사용한다.'),
                                                                                                                           (1481, 'Circuit Closed→Open 조건?', 1, 'low', '연속 실패 임계', '성공 200', '301', '쿠키 만료', 30, '지정된 횟수 이상 연속으로 실패하면 회로가 열려 더 이상의 요청을 막는다.'),
                                                                                                                           (1482, 'Half-Open 성공 전이?', 1, 'low', 'Closed', 'Open', 'Forced-Open', 'Isolated', 30, 'Half-Open 상태에서 요청이 성공하면 회로는 정상 상태인 Closed로 전이된다.'),
                                                                                                                           (1483, 'Open 상태 바로 실패 목적?', 1, 'low', '백엔드 부하 차단', '캐시 무효', 'TLS 시간 줄임', 'DNS 재해석', 30, '이미 실패가 감지된 상태에서는 추가 요청을 차단해 서버 자원을 보호한다.'),
                                                                                                                           (1484, '재시도+CB 충돌 위험?', 1, 'medium', '과도 재시도→즉시 Open', 'Jitter 제거', 'Retry-After 무시', 'HTTP/2 끊김', 30, '재시도가 너무 잦으면 실패율이 증가해 회로 차단 조건을 빠르게 만족시켜 충돌을 유발할 수 있다.'),
                                                                                                                           (1485, 'Coalescing 효과 시나리오?', 1, 'medium', '같은 리소스 다수 GET', '다른 POST', 'WebSocket', 'SSE', 30, '동일 리소스에 대한 다수의 GET 요청을 병합하여 불필요한 중복 요청을 줄일 수 있다.'),
                                                                                                                           (1486, 'Equal Jitter 이점 아닌 것?', 2, 'medium', '스파이크 완화', '최대/최소 지연 예측', 'Full Jitter보다 대기 줄임', '서버 완화', 30, 'Equal Jitter는 무작위성을 도입해 스파이크 완화가 목적이므로 예측 가능성은 낮다.'),
                                                                                                                           (1487, 'Fallback 전략 사례?', 1, 'high', '캐시된 데이터로 표시', '재시도 0', 'CB 강제 Close', 'Retry-After 무시', 30, '서버 장애 시에도 사용자에게 캐시된 정보를 제공해 UX 저하를 방지할 수 있다.'),
                                                                                                                           (1488, 'Hedged Request 주의점?', 1, 'high', '멱등 보장 필요', 'DNS TTL 0', 'KEEP-ALIVE 끊기', 'TLS 1.3', 30, '동일 요청을 여러 서버에 보내는 전략이므로 요청이 멱등성을 가져야 안전하다.'),
                                                                                                                           (1489, 'Max-Retry-TTL 목적?', 1, 'high', '무제한 지연 방지', 'TCP FIN 감소', '브라우저 버그 회피', 'Keep-Alive 증가', 30, '재시도 전체에 제한 시간을 설정해 무한 대기나 지연을 방지하는 목적이다.'),
                                                                                                                           (1490, 'CB 실시간 튜닝 기법?', 1, 'high', 'Feature Flag 기반 임계 조정', '콘솔 변수', '헤더 하드코드', '빌드 상수', 30, 'Feature Flag를 사용하면 실시간으로 임계치를 조정할 수 있어 운영 민첩성이 향상된다.'),
                                                                                                                           (1491, '자주 쓰는 SLO 쌍은?', 1, 'low', '가용성·오류율', 'CPU·메모리', '빌드시간·커버리지', 'PR 리뷰', 30, '서비스 품질을 나타내는 대표적인 지표로, SLA 수립에도 자주 활용된다.'),
                                                                                                                           (1492, 'P99 증가 의심 원인?', 1, 'low', '소수 요청 재시도 지연', '평균 느려짐', '404 급증', '로깅 오류', 30, 'P99는 평균보다 극단값에 민감하여 일부 요청의 반복 지연이 주요 원인이 된다.'),
                                                                                                                           (1493, '분산 추적 유용 이유?', 1, 'medium', 'Trace로 재시도 체인 시각화', '헤더 암호화', '로그 제거', '패킷 캡처', 30, 'Trace를 통해 서비스 간 호출 흐름과 지연 구간을 시각적으로 파악할 수 있다.'),
                                                                                                                           (1494, 'Chaos 테스트 간단 도구?', 1, 'medium', 'MSW random error', 'CSS Lint', 'Bundle Analyzer', 'Lighthouse', 30, 'MSW는 네트워크 오류를 시뮬레이션하여 클라이언트 측 Chaos 테스트를 간편하게 수행할 수 있다.'),
                                                                                                                           (1495, '포스트모템 포함 아님?', 1, 'medium', '담당자 인적 정보', '타임라인', 'RCA', '재발 방지', 30, '포스트모템은 시스템 중심의 분석 문서로서 개인 정보는 포함하지 않는다.'),
                                                                                                                           (1496, '알림 임계 낮음 문제?', 1, 'high', 'Alert Fatigue', 'MTTR 증가', 'Slack→Email', 'Grafana 꺼짐', 30, '중요하지 않은 알림이 많으면 사용자 주의가 분산되어 실제 중요한 알림을 놓칠 수 있다.'),
                                                                                                                           (1497, '롤아웃 안전 배포 전략?', 1, 'high', 'Feature Flag Gradual', 'Big-bang', 'Force-push', 'CI 캐시 무효', 30, '점진적으로 기능을 활성화하면 위험을 분산시키고 문제 발생 시 빠른 복구가 가능하다.'),
                                                                                                                           (1498, '로그 레벨 매핑?', 1, 'high', '시작 debug, 재시도 info, 실패 error', '모두 warn', '재시도 fatal', '성공 error', 30, '단계별 로그 레벨 구분은 문제 진단과 모니터링에서 중요한 단서를 제공한다.'),
                                                                                                                           (1499, '슬라이딩 윈도우 오류율 이유?', 1, 'high', '즉시값 대신 경향 파악', '메트릭 안 삭제', '테스트 속도', '다크 테마', 30, '슬라이딩 윈도우는 일정 시간대의 오류 경향을 반영해 민감하게 대응 가능하다.'),
                                                                                                                           (1500, '오류율 상승 자동 롤백 기능은?', 1, 'high', 'Canary 분석 → rollback', 'Merge Queue', 'multi-stage build', 'npm postinstall', 30, 'Canary 배포는 오류 발생 시 자동으로 이전 안정 상태로 롤백할 수 있게 해 운영 리스크를 줄인다.'),
                                                                                                                           (1501, '클라이언트 잘못된 요청(예: JSON 스키마 위반)에 대한 권장 HTTP 상태 코드는?', 1, 'low', '400 Bad Request', '401 Unauthorized', '500 Internal Server Error', '409 Conflict', 31, '400 Bad Request는 요청 구문은 올바르지만 유효성 검사 실패 등으로 서버가 처리할 수 없음을 나타낸다.'),
                                                                                                                           (1502, '인증 헤더가 누락된 요청에 서버가 반환해야 할 표준 상태 코드는?', 1, 'low', '401 Unauthorized', '403 Forbidden', '412 Precondition Failed', '502 Bad Gateway', 31, '401 Unauthorized는 인증이 필요한 자원에 인증 정보 없이 접근했을 때 반환된다.'),
                                                                                                                           (1503, 'REST API에서 존재하지 않는 리소스에 대한 GET 요청 시 적절한 응답 코드는?', 1, 'low', '404 Not Found', '410 Gone', '204 No Content', '422 Unprocessable Entity', 31, '404 Not Found는 요청한 리소스가 서버에 존재하지 않을 때 반환되는 표준 응답 코드이다.'),
                                                                                                                           (1504, 'RFC 7807 ‘Problem Details for HTTP APIs’가 권장하는 기본 Content-Type은?', 1, 'medium', 'application/problem+json', 'application/json; problem', 'text/problem', 'application/vnd.error+json', 31, 'RFC 7807은 오류 정보를 표준화된 JSON 형식으로 전달하기 위해 application/problem+json을 권장한다.'),
                                                                                                                           (1505, 'RFC 7807 JSON 응답 예시에서 반드시 포함해야 하는 필드는?', 1, 'medium', 'title', 'instance', 'detail', 'errors', 31, 'title은 오류 내용을 간단히 요약해 사용자와 개발자가 오류 상황을 빠르게 이해할 수 있도록 돕는다.'),
                                                                                                                           (1506, '다음 중 4xx와 5xx 상태 코드 차이에 대한 설명으로 옳지 않은 것은?', 4, 'medium', '4xx는 클라이언트 오류, 5xx는 서버 오류를 나타낸다', '5xx는 재시도 가능성이 4xx보다 높다', '4xx 오류라도 Problem Details 바디를 포함할 수 있다', '4xx는 절대 재시도해서는 안 된다', 31, '일부 4xx 오류는 조건 수정 후 재시도가 가능하므로 "절대 재시도 안 됨"은 잘못된 설명이다.'),
                                                                                                                           (1507, '동일 자원 중복 생성 시 서버가 반환해도 멱등성 규칙을 깨지지 않는 상태 코드는?', 1, 'high', '409 Conflict', '201 Created', '202 Accepted', '302 Found', 31, '409 Conflict는 요청이 서버 상태를 변경하지 않기 때문에 멱등성을 유지한다.'),
                                                                                                                           (1508, 'Problem Details 바디에 커스텀 ‘code’ 정수 필드를 두는 주된 이점은?', 1, 'high', '클라이언트가 로컬라이징 메시지를 매핑하기 쉽다', 'HTTP 상태 코드 전송을 생략할 수 있다', 'JSON 패싱을 건너뛸 수 있다', 'CORS 프리플라이트를 우회한다', 31, '정수 기반 커스텀 code는 클라이언트에서 지역화된 사용자 메시지로 쉽게 매핑할 수 있다.'),
                                                                                                                           (1509, '다음 중 idempotent 메서드가 아닌 것은?', 1, 'high', 'POST', 'PUT', 'DELETE', 'HEAD', 31, 'POST는 요청을 반복 실행할 때마다 서버 상태를 바꿀 수 있어 멱등하지 않다.'),
                                                                                                                           (1510, '클라이언트가 429 Too Many Requests 응답을 받을 때 재시도 시점을 알기 위해 확인해야 하는 헤더는?', 1, 'high', 'Retry-After', 'Warning', 'WWW-Authenticate', 'Content-Encoding', 31, 'Retry-After는 클라이언트가 다음 요청을 보낼 수 있는 시점을 명시적으로 알려주는 HTTP 표준 헤더이다.'),
                                                                                                                           (1511, '브라우저 네트워크 오류 vs HTTP 오류 구분 방법은?', 1, 'low', '응답 없음 & error.request 존재 → 네트워크 오류', 'status 0이면 HTTP 오류', 'message에 Network Error 포함 시 HTTP 오류', 'https로 시작시 네트워크 오류 없음', 31, '요청은 전송됐지만 응답이 없고 error.request가 존재하면 네트워크 오류로 간주한다.'),
                                                                                                                           (1512, '422 오류 UX 비추천 패턴은?', 1, 'low', '모달 전체 가리고 중앙만 오류', '필드 인라인 표시', '폼 상단 요약', '스낵바 알림', 31, '전체를 덮는 모달은 오류의 위치를 파악하기 어렵게 만들어 UX를 저하시킨다.'),
                                                                                                                           (1513, '전역 오류 핸들러 역할은?', 1, 'low', '로그인 만료 등 공통 처리', '레이아웃 교체', 'CSS 초기화', 'History 재설정', 31, '전역 오류 핸들러는 인증 만료, 네트워크 오류 등 모든 페이지에 공통 적용 가능한 예외를 처리한다.'),
                                                                                                                           (1514, '오프라인 GET 요청 전략은?', 1, 'medium', '대기열 저장 후 복구 시 재시도', '캐시 비우고 에러', '503 구성', '무한 로딩', 31, '요청을 대기열에 저장해 네트워크 복구 시 자동으로 재시도하면 사용자 경험을 유지할 수 있다.'),
                                                                                                                           (1515, 'Error Boundary 해결 문제는?', 1, 'medium', '렌더 예외로 인한 흰 화면', 'API 500 재시도', 'CORS 차단', 'WebSocket', 31, 'React의 Error Boundary는 렌더링 중 예외로 전체 앱이 흰 화면이 되는 것을 방지한다.'),
                                                                                                                           (1516, '중복 POST 방지 클라이언트 조치?', 1, 'medium', '이전 요청 취소 AbortController', 'Cache-Control no-store', 'POST→GET', '로그 제거', 31, 'AbortController를 사용하면 이전 요청을 취소하고 중복된 POST를 방지할 수 있다.'),
                                                                                                                           (1517, 'axios 취소 vs 네트워크 오류 구분 프로퍼티?', 1, 'high', 'error.code === ''ERR_CANCELED''', 'message 포함 Network', 'status -1', 'timeout 0', 31, 'axios에서는 명시적으로 요청이 취소된 경우 ERR_CANCELED 코드가 설정된다.'),
                                                                                                                           (1518, '국제화 오류 메시지 비추천 방법은?', 1, 'high', '서버가 완제품 문구 제공', '클라이언트 코드 매핑', 'title/detail 키 사용', '템플릿 변수 치환', 31, '서버가 문구를 직접 제공하면 다국어 지원이 어렵고 유지보수가 복잡해진다.'),
                                                                                                                           (1519, '모바일 에러/재요청 데이터 최소화 우선 고려는?', 1, 'high', '오프라인 감지 후 백오프', '해상도 다운', '캐시 삭제', 'UDP 강제', 31, '모바일 환경에서는 네트워크 상태를 감지해 재시도를 지연시키는 것이 데이터 낭비를 줄이는 데 효과적이다.'),
                                                                                                                           (1520, '사용자 메시지+디버그 정보 구조 권장?', 1, 'high', 'UI 요약 & 콘솔 raw trace', 'alert 모두', '서버 HTML 오류 페이지', '쿠키 저장', 31, '사용자에게는 간결한 메시지를, 개발자에게는 콘솔에서 확인 가능한 상세 로그를 제공하는 구조가 이상적이다.'),
                                                                                                                           (1521, '멱등 메서드는?', 1, 'low', 'PUT', 'POST', 'PATCH', 'CONNECT', 31, 'PUT은 여러 번 호출해도 서버의 상태가 동일하게 유지되므로 멱등 메서드이다.'),
                                                                                                                           (1522, '고정 3초 4번 총 지연?', 1, 'low', '12초', '9초', '6초', '3초', 31, '3초씩 4회를 대기하면 총 지연 시간은 3×4=12초이다.'),
                                                                                                                           (1523, '지수 1s 배수2 3회 누적?', 1, 'medium', '7 s', '6 s', '5 s', '4 s', 31, '1초, 2초, 4초의 합은 7초로, 지수 백오프 전략에 따라 누적 지연이 증가한다.'),
                                                                                                                           (1524, 'Retry-After 120 권장 재시도?', 1, 'medium', '120초 이상 후', '60초', '즉시', '무시', 31, 'Retry-After는 서버가 재시도를 허용하는 시점을 의미하므로 120초 이상 기다린 후 요청해야 한다.'),
                                                                                                                           (1525, 'POST 안전 재시도 보완책?', 1, 'medium', 'Idempotency-Key 헤더', 'HTTP/2 업그레이드', '빈 바디', 'PUT 사용', 31, 'Idempotency-Key는 서버가 요청을 구별할 수 있도록 하여 POST 요청의 중복 처리를 방지한다.'),
                                                                                                                           (1526, '재시도 고려 가능한 408/409?', 1, 'medium', '408 Request Timeout', '409 Conflict', '400', '401', 31, '408 오류는 일시적 네트워크 문제로 인해 발생하며, 상황이 개선되면 재시도해 성공할 수 있다.'),
                                                                                                                           (1527, 'Full Jitter 목적은?', 1, 'high', '서버 폭주 완화', '총 지연 줄임', 'TCP 우회', 'TLS 감소', 31, 'Full Jitter는 재시도 시점을 무작위로 분산시켜 서버로의 동시 요청 폭주를 방지한다.'),
                                                                                                                           (1528, '재시도 불가 오류 유형은?', 1, 'high', '400 필드 검증', '502', '408', '429', 31, '400 필드 오류는 클라이언트의 잘못된 입력으로 인해 발생하므로 수정 없이 재시도해도 실패한다.'),
                                                                                                                           (1529, '조건부 PUT 재시도 안전 이유?', 1, 'high', 'ETag 버전 동일 시만 수행', 'PUT 캐싱', 'HTTP/3 전용', '브라우저 보장', 31, '조건부 PUT은 서버 상태가 요청 조건과 일치할 때만 수행되므로 멱등성을 확보할 수 있다.'),
                                                                                                                           (1530, '모바일 TCP 끊김 POST 문제 감소?', 1, 'high', '짧은 타임아웃 + 멱등 키', 'HTTP 1.0', '재시도 끔', '인증 제거', 31, '모바일에서 연결 실패 시 빠르게 타임아웃하고 멱등 키로 안전하게 재시도하면 데이터 중복 문제를 줄일 수 있다.'),
                                                                                                                           (1531, 'Circuit Closed→Open 조건?', 1, 'low', '연속 실패 임계', '성공 200', '301', '쿠키 만료', 31, 'Circuit Breaker는 설정된 실패 임계치를 초과하면 회로를 열어 추가 요청을 차단한다.'),
                                                                                                                           (1532, 'Half-Open 성공 전이?', 1, 'low', 'Closed', 'Open', 'Forced-Open', 'Isolated', 31, 'Half-Open 상태에서 테스트 요청이 성공하면 회복된 것으로 판단하고 Closed 상태로 전이된다.'),
                                                                                                                           (1533, 'Open 상태 바로 실패 목적?', 1, 'low', '백엔드 부하 차단', '캐시 무효', 'TLS 시간 줄임', 'DNS 재해석', 31, 'Open 상태에서는 백엔드 서버의 과부하를 방지하기 위해 요청을 차단한다.'),
                                                                                                                           (1534, '재시도+CB 충돌 위험?', 1, 'medium', '과도 재시도→즉시 Open', 'Jitter 제거', 'Retry-After 무시', 'HTTP/2 끊김', 31, '과도한 재시도는 실패율을 높여 회로 차단 조건을 빠르게 유발할 수 있다.'),
                                                                                                                           (1535, 'Coalescing 효과 시나리오?', 1, 'medium', '같은 리소스 다수 GET', '다른 POST', 'WebSocket', 'SSE', 31, '동일한 GET 요청을 병합(Coalescing)하면 네트워크 사용량을 줄이고 응답 속도를 개선할 수 있다.'),
                                                                                                                           (1536, 'Equal Jitter 이점 아닌 것?', 2, 'medium', '스파이크 완화', '최대/최소 지연 예측', 'Full Jitter보다 대기 줄임', '서버 완화', 31, 'Equal Jitter는 분산을 목적으로 하며 지연 시간을 정확히 예측하기 어렵다.'),
                                                                                                                           (1537, 'Fallback 전략 사례?', 1, 'high', '캐시된 데이터로 표시', '재시도 0', 'CB 강제 Close', 'Retry-After 무시', 31, '서버 장애 시 캐시된 데이터를 보여주면 사용자 경험을 유지할 수 있다.'),
                                                                                                                           (1538, 'Hedged Request 주의점?', 1, 'high', '멱등 보장 필요', 'DNS TTL 0', 'KEEP-ALIVE 끊기', 'TLS 1.3', 31, 'Hedged Request는 동일 요청을 병렬로 보내므로 멱등성이 보장되어야 안전하다.'),
                                                                                                                           (1539, 'Max-Retry-TTL 목적?', 1, 'high', '무제한 지연 방지', 'TCP FIN 감소', '브라우저 버그 회피', 'Keep-Alive 증가', 31, '전체 재시도에 TTL을 설정하면 무한 루프 또는 장기 대기를 방지할 수 있다.'),
                                                                                                                           (1540, 'CB 실시간 튜닝 기법?', 1, 'high', 'Feature Flag 기반 임계 조정', '콘솔 변수', '헤더 하드코드', '빌드 상수', 31, 'Feature Flag를 사용하면 실시간으로 회로 차단 조건을 조절할 수 있어 운영 유연성이 높아진다.'),
                                                                                                                           (1541, '자주 쓰는 SLO 쌍은?', 1, 'low', '가용성·오류율', 'CPU·메모리', '빌드시간·커버리지', 'PR 리뷰', 31, '가용성과 오류율은 SLA 기준에도 사용되는 가장 일반적인 SLO 지표이다.'),
                                                                                                                           (1542, 'P99 증가 의심 원인?', 1, 'low', '소수 요청 재시도 지연', '평균 느려짐', '404 급증', '로깅 오류', 31, 'P99는 극단값 중심 통계로 소수의 지연 요청이 큰 영향을 미친다.'),
                                                                                                                           (1543, '분산 추적 유용 이유?', 1, 'medium', 'Trace로 재시도 체인 시각화', '헤더 암호화', '로그 제거', '패킷 캡처', 31, '분산 추적은 마이크로서비스 간 호출 흐름과 지연 지점을 시각화해 문제 해결을 돕는다.'),
                                                                                                                           (1544, 'Chaos 테스트 간단 도구?', 1, 'medium', 'MSW random error', 'CSS Lint', 'Bundle Analyzer', 'Lighthouse', 31, 'MSW는 클라이언트 테스트 시 무작위 오류 응답을 쉽게 시뮬레이션할 수 있다.'),
                                                                                                                           (1545, '포스트모템 포함 아님?', 1, 'medium', '담당자 인적 정보', '타임라인', 'RCA', '재발 방지', 31, '포스트모템은 시스템적인 분석에 집중하며 개인정보는 제외된다.'),
                                                                                                                           (1546, '알림 임계 낮음 문제?', 1, 'high', 'Alert Fatigue', 'MTTR 증가', 'Slack→Email', 'Grafana 꺼짐', 31, '불필요한 경고가 많으면 사용자 피로도가 높아져 실제 중요한 알림도 무시될 수 있다.'),
                                                                                                                           (1547, '롤아웃 안전 배포 전략?', 1, 'high', 'Feature Flag Gradual', 'Big-bang', 'Force-push', 'CI 캐시 무효', 31, 'Feature Flag는 기능을 점진적으로 켜 위험을 낮추고 문제가 생기면 빠르게 롤백 가능하다.'),
                                                                                                                           (1548, '로그 레벨 매핑?', 1, 'high', '시작 debug, 재시도 info, 실패 error', '모두 warn', '재시도 fatal', '성공 error', 31, '로그를 목적별로 debug/info/error 등으로 구분하면 가독성과 분석 효율이 향상된다.'),
                                                                                                                           (1549, '슬라이딩 윈도우 오류율 이유?', 1, 'high', '즉시값 대신 경향 파악', '메트릭 안 삭제', '테스트 속도', '다크 테마', 31, '슬라이딩 윈도우는 최근 일정 시간 동안의 오류 경향을 민감하게 반영하여 운영 판단에 유용하다.'),
                                                                                                                           (1550, '오류율 상승 자동 롤백 기능은?', 1, 'high', 'Canary 분석 → rollback', 'Merge Queue', 'multi-stage build', 'npm postinstall', 31, 'Canary 배포 후 오류율이 상승하면 자동으로 롤백하여 서비스 안정성을 유지할 수 있다.'),
                                                                                                                           (1551, '클라이언트 잘못된 요청(예: JSON 스키마 위반)에 대한 권장 HTTP 상태 코드는?', 1, 'low', '400 Bad Request', '401 Unauthorized', '500 Internal Server Error', '409 Conflict', 32, '400은 요청 구문은 맞지만 유효성 검증에 실패한 경우 적절한 상태 코드이다.'),
                                                                                                                           (1552, '인증 헤더가 누락된 요청에 서버가 반환해야 할 표준 상태 코드는?', 1, 'low', '401 Unauthorized', '403 Forbidden', '412 Precondition Failed', '502 Bad Gateway', 32, '401은 인증 자격 증명이 없거나 올바르지 않을 때 반환된다.'),
                                                                                                                           (1553, 'REST API에서 존재하지 않는 리소스에 대한 GET 요청 시 적절한 응답 코드는?', 1, 'low', '404 Not Found', '410 Gone', '204 No Content', '422 Unprocessable Entity', 32, '404는 클라이언트가 요청한 리소스가 서버에 없음을 나타낸다.'),
                                                                                                                           (1554, 'RFC 7807 ‘Problem Details for HTTP APIs’가 권장하는 기본 Content-Type은?', 1, 'medium', 'application/problem+json', 'application/json; problem', 'text/problem', 'application/vnd.error+json', 32, 'application/problem+json은 표준화된 오류 응답 표현을 위한 MIME 타입이다.'),
                                                                                                                           (1555, 'RFC 7807 JSON 응답 예시에서 반드시 포함해야 하는 필드는?', 1, 'medium', 'title', 'instance', 'detail', 'errors', 32, 'title 필드는 오류의 요약 정보로 필수 항목이며, 문제를 빠르게 이해하는 데 도움을 준다.'),
                                                                                                                           (1556, '다음 중 4xx와 5xx 상태 코드 차이에 대한 설명으로 옳지 않은 것은?', 4, 'medium', '4xx는 클라이언트 오류, 5xx는 서버 오류를 나타낸다', '5xx는 재시도 가능성이 4xx보다 높다', '4xx 오류라도 Problem Details 바디를 포함할 수 있다', '4xx는 절대 재시도해서는 안 된다', 32, '일부 4xx 오류는 수정 후 재시도가 가능하므로 절대 재시도 불가라는 설명은 부적절하다.'),
                                                                                                                           (1557, '동일 자원 중복 생성 시 서버가 반환해도 멱등성 규칙을 깨지지 않는 상태 코드는?', 1, 'high', '409 Conflict', '201 Created', '202 Accepted', '302 Found', 32, '409는 자원이 이미 존재하므로 상태가 바뀌지 않아 멱등성을 유지한다.'),
                                                                                                                           (1558, 'Problem Details 바디에 커스텀 ‘code’ 정수 필드를 두는 주된 이점은?', 1, 'high', '클라이언트가 로컬라이징 메시지를 매핑하기 쉽다', 'HTTP 상태 코드 전송을 생략할 수 있다', 'JSON 패싱을 건너뛸 수 있다', 'CORS 프리플라이트를 우회한다', 32, '정수 기반 code는 사용자별 메시지 매핑에 유용하며 유지보수가 용이하다.'),
                                                                                                                           (1559, '다음 중 idempotent 메서드가 아닌 것은?', 1, 'high', 'POST', 'PUT', 'DELETE', 'HEAD', 32, 'POST는 서버 상태를 변경하므로 멱등하지 않다.'),
                                                                                                                           (1560, '클라이언트가 429 Too Many Requests 응답을 받을 때 재시도 시점을 알기 위해 확인해야 하는 헤더는?', 1, 'high', 'Retry-After', 'Warning', 'WWW-Authenticate', 'Content-Encoding', 32, 'Retry-After는 서버가 재시도 가능하다고 판단하는 시점을 명시하는 표준 헤더이다.'),
                                                                                                                           (1561, '브라우저 네트워크 오류 vs HTTP 오류 구분 방법은?', 1, 'low', '응답 없음 & error.request 존재 → 네트워크 오류', 'status 0이면 HTTP 오류', 'message에 Network Error 포함 시 HTTP 오류', 'https로 시작시 네트워크 오류 없음', 32, '응답이 없고 error.request 객체만 존재하면 서버와 연결되지 않았다는 뜻으로 네트워크 오류이다.'),
                                                                                                                           (1562, '422 오류 UX 비추천 패턴은?', 1, 'low', '모달 전체 가리고 중앙만 오류', '필드 인라인 표시', '폼 상단 요약', '스낵바 알림', 32, '오류가 발생한 필드와 무관하게 중앙에 오류만 보여주면 사용자가 문제를 파악하기 어렵다.'),
                                                                                                                           (1563, '전역 오류 핸들러 역할은?', 1, 'low', '로그인 만료 등 공통 처리', '레이아웃 교체', 'CSS 초기화', 'History 재설정', 32, '전역 오류 핸들러는 인증 만료, 네트워크 오류 등 공통 예외에 일관된 대응이 가능하도록 한다.'),
                                                                                                                           (1564, '오프라인 GET 요청 전략은?', 1, 'medium', '대기열 저장 후 복구 시 재시도', '캐시 비우고 에러', '503 구성', '무한 로딩', 32, '오프라인 상태에서 요청을 대기열에 저장해두었다가 복구되면 자동 전송하여 UX를 향상시킨다.'),
                                                                                                                           (1565, 'Error Boundary 해결 문제는?', 1, 'medium', '렌더 예외로 인한 흰 화면', 'API 500 재시도', 'CORS 차단', 'WebSocket', 32, 'React에서는 렌더링 중 에러가 발생하면 UI 전체가 깨지는데, 이를 Error Boundary로 감지해 대처할 수 있다.'),
                                                                                                                           (1566, '중복 POST 방지 클라이언트 조치?', 1, 'medium', '이전 요청 취소 AbortController', 'Cache-Control no-store', 'POST→GET', '로그 제거', 32, 'AbortController를 사용하면 사용자의 중복 클릭 등으로 인한 요청을 취소할 수 있다.'),
                                                                                                                           (1567, 'axios 취소 vs 네트워크 오류 구분 프로퍼티?', 1, 'high', 'error.code === ''ERR_CANCELED''', 'message 포함 Network', 'status -1', 'timeout 0', 32, 'axios는 명시적으로 취소된 요청에는 ERR_CANCELED 코드가 설정되어 네트워크 오류와 구별할 수 있다.'),
                                                                                                                           (1568, '국제화 오류 메시지 비추천 방법은?', 1, 'high', '서버가 완제품 문구 제공', '클라이언트 코드 매핑', 'title/detail 키 사용', '템플릿 변수 치환', 32, '서버가 완제품 문구를 제공하면 클라이언트 측 다국어 처리나 메시지 재사용이 어렵다.'),
                                                                                                                           (1569, '모바일 에러/재요청 데이터 최소화 우선 고려는?', 1, 'high', '오프라인 감지 후 백오프', '해상도 다운', '캐시 삭제', 'UDP 강제', 32, '오프라인 상태를 감지하고 재시도 시점을 조절하면 불필요한 트래픽을 줄일 수 있다.'),
                                                                                                                           (1570, '사용자 메시지+디버그 정보 구조 권장?', 1, 'high', 'UI 요약 & 콘솔 raw trace', 'alert 모두', '서버 HTML 오류 페이지', '쿠키 저장', 32, '사용자는 간결한 메시지를 보고, 개발자는 콘솔의 상세 로그로 문제를 분석할 수 있도록 분리한다.'),
                                                                                                                           (1571, '멱등 메서드는?', 1, 'low', 'PUT', 'POST', 'PATCH', 'CONNECT', 32, 'PUT은 동일 요청을 여러 번 보내도 서버 상태가 유지되므로 멱등성을 가진다.'),
                                                                                                                           (1572, '고정 3초 4번 총 지연?', 1, 'low', '12초', '9초', '6초', '3초', 32, '고정된 간격(3초)으로 4번 대기하면 총 지연 시간은 3×4=12초이다.'),
                                                                                                                           (1573, '지수 1s 배수2 3회 누적?', 1, 'medium', '7 s', '6 s', '5 s', '4 s', 32, '지연 시간이 1, 2, 4초로 증가하면 누적 시간은 7초가 된다.'),
                                                                                                                           (1574, 'Retry-After 120 권장 재시도?', 1, 'medium', '120초 이상 후', '60초', '즉시', '무시', 32, 'Retry-After 헤더는 서버가 허용하는 재시도 시점을 알려주므로 그 이후에 재요청해야 한다.'),
                                                                                                                           (1575, 'POST 안전 재시도 보완책?', 1, 'medium', 'Idempotency-Key 헤더', 'HTTP/2 업그레이드', '빈 바디', 'PUT 사용', 32, 'Idempotency-Key를 사용하면 서버는 중복 요청 여부를 판단해 중복 처리 방지가 가능하다.'),
                                                                                                                           (1576, '재시도 고려 가능한 408/409?', 1, 'medium', '408 Request Timeout', '409 Conflict', '400', '401', 32, '408은 일시적인 네트워크 오류로 재시도 후 성공 가능성이 있다.'),
                                                                                                                           (1577, 'Full Jitter 목적은?', 1, 'high', '서버 폭주 완화', '총 지연 줄임', 'TCP 우회', 'TLS 감소', 32, 'Full Jitter는 재시도 시점을 무작위화해 요청이 몰리는 것을 방지하고 서버 부하를 줄인다.'),
                                                                                                                           (1578, '재시도 불가 오류 유형?', 1, 'high', '400 필드 검증', '502', '408', '429', 32, '400은 클라이언트 입력 오류로, 재시도해도 성공할 수 없으므로 무의미하다.'),
                                                                                                                           (1579, '조건부 PUT 재시도 안전 이유?', 1, 'high', 'ETag 버전 동일 시만 수행', 'PUT 캐싱', 'HTTP/3 전용', '브라우저 보장', 32, 'ETag를 이용한 조건부 요청은 상태 일치 시에만 실행되어 멱등성이 보장된다.'),
                                                                                                                           (1580, '모바일 TCP 끊김 POST 문제 감소?', 1, 'high', '짧은 타임아웃 + 멱등 키', 'HTTP 1.0', '재시도 끔', '인증 제거', 32, '빠른 실패 감지와 멱등 키 활용으로 POST 중복 처리 문제를 방지할 수 있다.'),
                                                                                                                           (1581, 'Circuit Closed→Open 조건?', 1, 'low', '연속 실패 임계', '성공 200', '301', '쿠키 만료', 32, 'Circuit Breaker는 실패가 임계치를 넘으면 회로를 열어 더 이상의 요청을 차단한다.'),
                                                                                                                           (1582, 'Half-Open 성공 전이?', 1, 'low', 'Closed', 'Open', 'Forced-Open', 'Isolated', 32, 'Half-Open 상태에서 요청이 성공하면 시스템이 안정되었다고 판단하여 Closed 상태로 전환된다.'),
                                                                                                                           (1583, 'Open 상태 바로 실패 목적?', 1, 'low', '백엔드 부하 차단', '캐시 무효', 'TLS 시간 줄임', 'DNS 재해석', 32, 'Open 상태에서는 요청을 즉시 실패시켜 서버 자원을 보호한다.'),
                                                                                                                           (1584, '재시도+CB 충돌 위험?', 1, 'medium', '과도 재시도→즉시 Open', 'Jitter 제거', 'Retry-After 무시', 'HTTP/2 끊김', 32, '과도한 재시도는 실패율을 급격히 올려 Circuit Breaker가 강제로 열릴 수 있다.'),
                                                                                                                           (1585, 'Coalescing 효과 시나리오?', 1, 'medium', '같은 리소스 다수 GET', '다른 POST', 'WebSocket', 'SSE', 32, '여러 클라이언트가 동일 리소스를 요청할 때 이를 하나로 병합하면 효율성이 높아진다.'),
                                                                                                                           (1586, 'Equal Jitter 이점 아닌 것?', 2, 'medium', '스파이크 완화', '최대/최소 지연 예측', 'Full Jitter보다 대기 줄임', '서버 완화', 32, 'Equal Jitter는 지연을 무작위로 분산시키므로 지연 시간 예측은 어렵다.'),
                                                                                                                           (1587, 'Fallback 전략 사례?', 1, 'high', '캐시된 데이터로 표시', '재시도 0', 'CB 강제 Close', 'Retry-After 무시', 32, 'Fallback 전략으로 캐시된 데이터를 제공하면 서버 오류에도 사용자 경험을 유지할 수 있다.'),
                                                                                                                           (1588, 'Hedged Request 주의점?', 1, 'high', '멱등 보장 필요', 'DNS TTL 0', 'KEEP-ALIVE 끊기', 'TLS 1.3', 32, 'Hedged Request는 동일 요청을 여러 서버에 보내므로 멱등성이 필수다.'),
                                                                                                                           (1589, 'Max-Retry-TTL 목적?', 1, 'high', '무제한 지연 방지', 'TCP FIN 감소', '브라우저 버그 회피', 'Keep-Alive 증가', 32, 'Max-Retry-TTL은 재시도 요청이 무한히 대기하지 않도록 제한하여 서비스 안정성을 보장한다.'),
                                                                                                                           (1590, 'CB 실시간 튜닝 기법?', 1, 'high', 'Feature Flag 기반 임계 조정', '콘솔 변수', '헤더 하드코드', '빌드 상수', 32, 'Feature Flag를 통해 운영 중에도 회로 차단 임계값을 즉시 조정할 수 있어 민첩한 대응이 가능하다.'),
                                                                                                                           (1591, '자주 쓰는 SLO 쌍은? (정답: 가용성·오류율 - 시스템 안정성과 신뢰도를 측정하는 핵심 지표 조합)', 1, 'low', '가용성·오류율', 'CPU·메모리', '빌드시간·커버리지', 'PR 리뷰', 32, '가용성과 오류율은 SLA와 SLO의 핵심 지표로, 서비스의 가용성과 실패율을 종합적으로 측정하는 데 사용된다.'),
                                                                                                                           (1592, 'P99 증가 의심 원인? (정답: 소수 요청 재시도 지연 - 평균과 달리 P99는 일부 극단값에 민감하게 반응하여 지연 원인을 파악 가능)', 1, 'low', '소수 요청 재시도 지연', '평균 느려짐', '404 급증', '로깅 오류', 32, 'P99는 요청 중 상위 1%에 해당하는 지연을 측정하므로 일부 재시도 지연이 크게 반영된다.'),
                                                                                                                           (1593, '분산 추적 유용 이유? (정답: Trace로 재시도 체인 시각화 - 마이크로서비스 환경에서 호출 흐름과 재시도 발생 지점을 시각화 가능)', 1, 'medium', 'Trace로 재시도 체인 시각화', '헤더 암호화', '로그 제거', '패킷 캡처', 32, 'Trace를 통해 서비스 간 요청 흐름을 시각화하여 병목이나 재시도 문제의 위치를 정확히 파악할 수 있다.'),
                                                                                                                           (1594, 'Chaos 테스트 간단 도구? (정답: MSW random error - 클라이언트에서 오류 응답을 무작위로 시뮬레이션하여 혼란 테스트 가능)', 1, 'medium', 'MSW random error', 'CSS Lint', 'Bundle Analyzer', 'Lighthouse', 32, 'MSW는 가짜 네트워크 요청과 응답을 정의할 수 있어 클라이언트 혼란 상황을 테스트하는 데 적합하다.'),
                                                                                                                           (1595, '포스트모템 포함 아님? (정답: 담당자 인적 정보 - 사고 분석 문서에는 책임자 노출보다 문제 원인과 재발 방지 방안이 핵심)', 1, 'medium', '담당자 인적 정보', '타임라인', 'RCA', '재발 방지', 32, '포스트모템은 인적 비난보다 시스템적인 문제 해결과 예방 방안에 집중해야 한다.'),
                                                                                                                           (1596, '알림 임계 낮음 문제? (정답: Alert Fatigue - 과도한 알림으로 인해 실제 심각한 문제 경고도 무시되는 현상이 발생)', 1, 'high', 'Alert Fatigue', 'MTTR 증가', 'Slack→Email', 'Grafana 꺼짐', 32, '경고가 너무 잦으면 사용자 피로도가 높아져 실제 위협도 무시되는 경향이 있다.'),
                                                                                                                           (1597, '롤아웃 안전 배포 전략은? (정답: Feature Flag Gradual - 기능 플래그를 통해 일부 사용자에게 점진적으로 배포하며 안정성 확보)', 1, 'high', 'Feature Flag Gradual', 'Big-bang', 'Force-push', 'CI 캐시 무효', 32, '기능 플래그를 이용하면 점진적 기능 적용이 가능하여 문제가 발생하면 빠르게 롤백할 수 있다.'),
                                                                                                                           (1598, '로그 레벨 매핑? (정답: 시작 debug, 재시도 info, 실패 error - 로그 수준을 상황에 맞게 구분하여 가독성과 분석 효율 증가)', 1, 'high', '시작 debug, 재시도 info, 실패 error', '모두 warn', '재시도 fatal', '성공 error', 32, '적절한 로그 레벨은 이슈의 심각도 판단과 대응을 빠르게 할 수 있도록 돕는다.'),
                                                                                                                           (1599, '슬라이딩 윈도우 오류율 이유? (정답: 즉시값 대신 경향 파악 - 일정 시간 동안의 평균 오류율을 계산해 일시적 변화보다 경향성에 집중)', 1, 'high', '즉시값 대신 경향 파악', '메트릭 안 삭제', '테스트 속도', '다크 테마', 32, '슬라이딩 윈도우는 순간적인 이상치보다 전체적인 추세를 파악하는 데 효과적이다.'),
                                                                                                                           (1600, '오류율 상승 자동 롤백 기능은? (정답: Canary 분석 → rollback - 점진 배포 후 오류율이 증가하면 자동으로 이전 안정 상태로 되돌림)', 1, 'high', 'Canary 분석 → rollback', 'Merge Queue', 'multi-stage build', 'npm postinstall', 32, 'Canary 배포는 오류 감지 시 빠르게 이전 상태로 복구 가능한 안전한 배포 전략이다.'),
                                                                                                                           (1601, '소프트웨어 테스트의 주요 목적 중 하나가 아닌 것은? (정답: 프로젝트의 디자인을 결정하기 위해 - 테스트는 기능 검증이지 시스템 아키텍처 설계를 위한 것이 아님)', 3, 'low', '버그를 사전에 방지하기 위해', '코드의 품질을 보장하기 위해', '프로젝트의 디자인을 결정하기 위해', '기능이 의도대로 동작하는지 확인하기 위해', 33, '테스트는 구현된 기능을 검증하는 과정이며, 시스템 설계 결정은 테스트의 목적이 아니다.'),
                                                                                                                           (1602, '단위 테스트(Unit Test)는 보통 어떤 범위를 테스트하는가? (정답: 개별 함수나 메서드 - 최소 단위의 기능 동작을 검증하는 테스트)', 3, 'low', '전체 페이지 흐름', '데이터베이스 연결', '개별 함수나 메서드', '네트워크 요청 전체', 33, '단위 테스트는 가장 작은 실행 단위인 함수나 메서드 단위에서 작동 여부를 검증한다.'),
                                                                                                                           (1603, '테스트 피라미드에서 가장 많은 수를 차지해야 하는 테스트는? (정답: 단위 테스트 - 빠르고 독립적이며 유지보수가 쉬워 기본이 됨)', 1, 'low', '단위 테스트', '스냅샷 테스트', '통합 테스트', 'E2E 테스트', 33, '단위 테스트는 작성이 빠르고 의존성이 적어 다수의 테스트 작성을 장려한다.'),
                                                                                                                           (1604, 'TDD(Test Driven Development)의 순서로 올바른 것은? (정답: 테스트 → 코딩 → 리팩터링 - 테스트를 먼저 작성한 후 코드 구현 및 개선)', 2, 'low', '코딩 → 테스트 → 리팩터링', '테스트 → 코딩 → 리팩터링', '디자인 → 코딩 → 테스트', '리팩터링 → 테스트 → 코딩', 33, 'TDD는 테스트 실패 → 구현 → 테스트 통과 → 리팩터링의 주기를 따르는 개발 방식이다.'),
                                                                                                                           (1605, 'E2E(End-to-End) 테스트의 주요 목적은? (정답: 실제 사용자 흐름을 시뮬레이션하여 전반적인 기능 확인 - 전체 시스템의 흐름을 검증)', 3, 'medium', '모듈 간의 상호작용만 테스트', '단일 함수의 반환 값 테스트', '실제 사용자 흐름을 시뮬레이션하여 전반적인 기능 확인', '컴포넌트 내부 상태만 검증', 33, 'E2E 테스트는 전체 사용 시나리오가 제대로 작동하는지 확인하는 통합적인 테스트 방식이다.'),
                                                                                                                           (1606, '통합 테스트(Integration Test)의 핵심 목적은? (정답: 여러 모듈이 함께 작동하는지를 확인 - 모듈 간 상호작용과 통합 문제 검증)', 3, 'medium', '하나의 API 응답만 확인', '모든 데이터베이스 데이터를 삭제', '여러 모듈이 함께 작동하는지를 확인', '브라우저 렌더링 최적화', 33, '통합 테스트는 여러 구성 요소 간의 연결 상태와 흐름의 문제를 조기에 확인할 수 있다.'),
                                                                                                                           (1607, 'Mock 객체는 어떤 목적으로 사용되는가? (정답: 실제 의존성을 제거하고 테스트 대상에 집중하기 위해 - 외부 요소 없이 독립적 테스트 가능)', 2, 'medium', '실제 UI 렌더링 속도를 측정하기 위해', '실제 의존성을 제거하고 테스트 대상에 집중하기 위해', '컴파일 시간을 단축하기 위해', '스타일을 테스트하기 위해', 33, 'Mock은 외부 리소스를 대체하여 독립적이고 신뢰성 높은 단위 테스트를 가능하게 한다.'),
                                                                                                                           (1608, 'Stub과 Spy의 차이점으로 올바른 설명은? (정답: Spy는 호출 여부를 기록하고 Stub은 미리 정의된 값을 반환한다 - Spy는 추적 중심, Stub은 동작 모사)', 2, 'medium', 'Stub은 호출 여부를 기록하고 Spy는 반환 값을 고정한다', 'Spy는 호출 여부를 기록하고 Stub은 미리 정의된 값을 반환한다', '둘은 완전히 동일하다', 'Stub은 네트워크 요청에만 사용된다', 33, 'Spy는 실제 메서드가 호출됐는지 확인하는 도구이고, Stub은 결과를 고정시켜 반환한다.'),
                                                                                                                           (1609, '다음 중 테스트 유지보수를 어렵게 만드는 주요 원인은? (정답: 테스트가 구현 세부사항에 너무 의존함 - 내부 변경에 민감하게 반응하여 잦은 수정 유발)', 3, 'high', '테스트가 너무 작아서 디버깅이 쉬움', '테스트가 명확하게 의도를 드러냄', '테스트가 구현 세부사항에 너무 의존함', '테스트가 모든 흐름을 자동화함', 33, '테스트가 내부 구현에 밀접하게 연결되어 있으면 코드 변경 시 테스트도 함께 수정해야 하므로 유지보수가 어렵다.'),
                                                                                                                           (1610, '테스트 작성 시점 중 ''코드를 작성한 후 테스트하는 방식''을 부르는 말은? (정답: Test Last - 기능 개발 후 나중에 테스트 코드를 작성하는 방식)', 3, 'high', 'TDD', 'BDD', 'Test Last', 'Test First', 33, 'Test Last는 구현이 끝난 후 테스트를 작성하는 방식으로, TDD(Test First)와 대조된다.'),
                                                                                                                           (1611, '입력값을 받아 2배로 반환하는 순수 함수의 테스트에서 가장 중요한 검증 요소는? (정답: 입력에 따라 항상 예측 가능한 값을 반환하는지 - 순수 함수는 동일 입력에 대해 항상 동일한 결과를 반환해야 함)', 3, 'low', '콘솔 출력 여부', '실행 시간', '입력에 따라 항상 예측 가능한 값을 반환하는지', '함수명이 의미론적으로 맞는지', 33, '순수 함수는 외부 상태에 영향을 받지 않고 동일한 입력에 대해 항상 동일한 출력을 반환해야 한다.'),
                                                                                                                           (1612, 'Jest에서 테스트 함수를 작성할 때 사용하는 기본 함수는? (정답: test() - 테스트 이름과 실행 로직을 정의하는 기본 함수)', 2, 'low', 'run()', 'test()', 'verify()', 'assert()', 33, 'test() 함수는 Jest에서 테스트 케이스를 정의할 때 사용하는 대표적인 API이다.'),
                                                                                                                           (1613, '다음 중 단위 테스트가 아닌 것은? (정답: API 서버가 DB와 연결되는지 확인 - 이는 외부 시스템과 연동된 통합 테스트에 해당)', 3, 'low', '계산 함수가 올바르게 작동하는지 확인', '이벤트 핸들러가 특정 상태를 변경하는지 확인', 'API 서버가 DB와 연결되는지 확인', '입력값 없이 반환값이 정해진 함수 검증', 33, '단위 테스트는 외부 의존성이 없는 기능을 테스트하며, DB 연결은 통합 테스트에 해당한다.'),
                                                                                                                           (1614, 'Jest에서 `expect(value).toBe(4)`에서 사용된 `toBe`는 어떤 역할을 하는가? (정답: 값이 정확히 일치하는지 비교 - toBe는 엄격한 동등성(===) 비교 수행)', 3, 'low', '값이 포함되어 있는지 확인', '객체의 구조를 비교', '값이 정확히 일치하는지 비교', '함수 호출 여부 확인', 33, 'toBe는 JavaScript의 === 연산자처럼 두 값이 타입까지 정확히 같은지 비교한다.'),
                                                                                                                           (1615, '경계값 테스트(Boundary Test)가 중요한 이유는? (정답: 에러가 가장 자주 발생하는 구간이기 때문에 - 조건의 경계에서 오류 발생 확률이 높음)', 3, 'medium', 'UI에 더 가까운 테스트라서', '실행 시간이 길어서', '에러가 가장 자주 발생하는 구간이기 때문에', '개발자가 자주 빼먹는 요소이기 때문에', 33, '경계값 근처는 조건문 오동작 가능성이 높아 테스트가 특히 중요하다.'),
                                                                                                                           (1616, '함수에 예외 상황을 강제로 발생시키고 그 처리를 검증하는 테스트는 어떤 유형인가? (정답: 예외 테스트 - 예상된 예외 처리 로직이 잘 작동하는지 검증)', 3, 'medium', '성능 테스트', '엣지 케이스 테스트', '예외 테스트', '경고 테스트', 33, '예외 테스트는 에러 상황에서도 시스템이 정상 동작하는지 확인하는 데 중점을 둔다.'),
                                                                                                                           (1617, 'Jest에서 beforeEach() 함수의 주된 용도는? (정답: 각 테스트가 실행되기 전에 초기화 작업 수행 - 상태 초기화나 반복 준비 작업에 사용)', 2, 'medium', '모든 테스트 후 리포트를 출력', '각 테스트가 실행되기 전에 초기화 작업 수행', '테스트 실행 여부 확인', '테스트 종료 후 정리', 33, 'beforeEach는 반복되는 설정을 테스트마다 자동 실행하여 코드 중복을 줄여준다.'),
                                                                                                                           (1618, '다음 중 순수 함수(Pure Function)의 특징이 아닌 것은? (정답: 부작용(side-effect)을 가짐 - 순수 함수는 외부 상태에 영향을 주지 않음)', 3, 'medium', '동일한 입력 → 동일한 출력', '외부 상태에 의존하지 않음', '부작용(side-effect)을 가짐', '예측 가능하고 테스트하기 쉬움', 33, '순수 함수는 외부 상태를 변경하지 않으며, 항상 같은 입력에 대해 같은 결과를 반환해야 한다.'),
                                                                                                                           (1619, '테스트 대상 함수가 내부적으로 다른 모듈을 호출할 경우 가장 적절한 단위 테스트 전략은? (정답: Mocking을 통해 외부 모듈 의존 제거 - 테스트의 독립성과 신뢰성 확보)', 3, 'high', '그대로 테스트', '그 모듈도 같이 실행', 'Mocking을 통해 외부 모듈 의존 제거', '함수를 삭제함', 33, 'Mocking은 외부 의존성을 제거하여 테스트 범위를 함수 자체에 한정시킨다.'),
                                                                                                                           (1620, '단위 테스트 작성 시 테스트 커버리지를 지나치게 100%로 맞추는 것이 비효율적인 이유는? (정답: 의미 없는 테스트가 늘어날 수 있다 - 커버리지를 맞추기 위한 테스트는 실질적 검증 가치가 낮을 수 있음)', 2, 'high', '코드를 짧게 유지할 수 없다', '의미 없는 테스트가 늘어날 수 있다', '코드가 느려진다', '테스트 파일이 너무 많아진다', 33, '커버리지를 맞추기 위해 불필요한 테스트를 작성하면 유지보수 비용이 늘어나고 실질적 검증에 도움이 되지 않는다.'),
                                                                                                                           (1621, 'React Testing Library에서 가장 기본이 되는 렌더링 함수는?', 3, 'low', 'renderComponent()', 'mount()', 'render()', 'testRender()', 33, 'React Testing Library에서 컴포넌트를 테스트 환경에 렌더링할 때 사용하는 가장 기본 함수는 render()이다.'),
                                                                                                                           (1622, '컴포넌트 내부의 버튼 클릭 이벤트 테스트에서 주로 사용하는 메서드는?', 3, 'low', 'fire()', 'simulate()', 'fireEvent.click()', 'trigger()', 33, 'React Testing Library에서는 fireEvent.click()을 사용하여 클릭 이벤트를 시뮬레이션한다.'),
                                                                                                                           (1623, '컴포넌트 테스트 시 `getByText()`는 어떤 요소를 찾는가?', 2, 'low', 'id 값이 같은 요소', '텍스트 노드에 해당하는 요소', 'input name 속성의 값', '클래스명이 같은 요소', 33, '`getByText()`는 텍스트 콘텐츠를 기반으로 DOM 요소를 선택할 때 사용된다.'),
                                                                                                                           (1624, 'React 컴포넌트 테스트에서 `screen` 객체의 목적은?', 3, 'low', 'UI의 크기를 조정하기 위함', '테스트 화면을 캡처하기 위함', 'DOM 탐색을 전역에서 수행할 수 있게 함', '스타일을 테스트하기 위함', 33, '`screen` 객체는 render 함수로 렌더링된 요소를 전역에서 탐색할 수 있도록 돕는다.'),
                                                                                                                           (1625, '컴포넌트에 `props`를 전달하여 렌더링 테스트를 할 때 사용하는 방법은?', 3, 'medium', 'render(<Component>)', 'render(Component, props)', 'render(<Component {...props} />)', 'mount(Component, props)', 33, 'props를 전달한 컴포넌트는 JSX 문법인 `<Component {...props} />` 형식으로 전달하여 render해야 한다.'),
                                                                                                                           (1626, '상태 변경(setState)이 발생하는 컴포넌트를 테스트할 때 필요한 함수는?', 3, 'medium', 'waitFor()', 'render()', 'act()', 'flush()', 33, '상태 업데이트나 비동기 작업은 React의 act()로 감싸야 테스트 환경에서 정상적으로 처리된다.'),
                                                                                                                           (1627, '비동기 UI 요소가 나타나는 테스트에서 사용해야 할 방법은?', 4, 'medium', 'getByText()', 'queryByTestId()', 'waitForElementToBeRemoved()', 'waitFor()', 33, '`waitFor()`은 비동기 요소가 나타나거나 상태가 변경될 때까지 기다리는 유틸리티 함수이다.'),
                                                                                                                           (1628, '컴포넌트 테스트에서 사용자 입력을 시뮬레이션하려면 어떤 함수가 적절한가?', 2, 'medium', 'simulateInput()', 'fireEvent.change()', 'act.input()', 'input()', 33, '`fireEvent.change()`를 사용하면 input 요소의 change 이벤트를 시뮬레이션할 수 있다.'),
                                                                                                                           (1629, '테스트 대상 컴포넌트가 Context API를 사용하는 경우, 테스트 시 가장 적절한 방법은?', 2, 'high', 'useContext로 직접 호출', 'Provider로 감싸서 렌더링', 'mockProvider 사용 금지', 'Context 내부를 무시', 33, 'Context API를 사용하는 컴포넌트는 Provider로 감싸서 테스트해야 실제 실행 환경과 동일한 효과를 낼 수 있다.'),
                                                                                                                           (1630, '다음 중 ''접근성 기준''에 따라 요소를 찾는 React Testing Library 함수는?', 2, 'high', 'getByText()', 'getByRole()', 'querySelector()', 'getById()', 33, '`getByRole()`은 접근성을 고려하여 요소의 역할(role) 기반으로 선택하는 방식이다.'),
                                                                                                                           (1631, 'Snapshot 테스트의 주요 목적은?', 1, 'low', '컴포넌트의 UI가 변경되지 않았는지 검증하기 위해', '네트워크 지연을 테스트하기 위해', '브라우저 호환성을 확인하기 위해', 'DB 연결을 확인하기 위해', 33, 'Snapshot 테스트는 컴포넌트 UI 구조의 변경 여부를 쉽게 검출하기 위해 사용된다.'),
                                                                                                                           (1632, 'Jest에서 스냅샷 테스트를 생성하는 메서드는?', 3, 'low', 'toMatchText()', 'toEqual()', 'toMatchSnapshot()', 'toRenderSame()', 33, '`toMatchSnapshot()`은 현재 출력된 UI를 스냅샷으로 저장하거나 비교할 때 사용된다.'),
                                                                                                                           (1633, 'Snapshot 테스트가 실패했을 때 주로 해야 할 작업은?', 3, 'low', '테스트를 무시한다', '브라우저를 재시작한다', '스냅샷을 업데이트하거나, 변경 원인을 확인한다', '파일명을 바꾼다', 33, '스냅샷이 실패하면 변경 사항을 검토하고 실제 변경 의도였다면 업데이트한다.'),
                                                                                                                           (1634, '다음 중 Mocking이 필요한 상황으로 적절한 것은?', 2, 'medium', '순수 함수 테스트 시', 'DB와 연결된 의존 모듈을 테스트할 때', 'DOM 구조가 없는 테스트', 'static 파일 테스트', 33, 'DB와 같은 외부 의존성을 가지는 모듈은 테스트에서 mock 처리해야 안정적이다.'),
                                                                                                                           (1635, 'Jest의 `jest.fn()`은 어떤 역할을 하는가?', 3, 'medium', '새 DOM 요소를 생성한다', '비동기 API 요청을 실행한다', 'Mock 함수(더미 함수)를 생성한다', '스냅샷을 자동 생성한다', 33, '`jest.fn()`은 테스트용 더미 함수를 생성해 호출 여부 등을 추적할 수 있게 해준다.'),
                                                                                                                           (1636, 'Jest에서 특정 모듈을 Mock 처리하려면 사용하는 함수는?', 2, 'medium', 'jest.module()', 'jest.mock()', 'mock.module()', 'spyOn()', 33, '`jest.mock()`은 모듈 전체를 mock 처리하기 위한 Jest의 기본 함수이다.'),
                                                                                                                           (1637, 'Mock 함수가 실제로 호출되었는지를 확인하려면 어떤 Matcher를 사용해야 하는가?', 2, 'medium', 'toBeCalled()', 'toHaveBeenCalled()', 'toMatchSnapshot()', 'toEqual()', 33, '`toHaveBeenCalled()`는 mock 함수가 호출되었는지를 검증하는 Matcher이다.'),
                                                                                                                           (1638, '스냅샷 테스트의 단점으로 적절한 것은?', 2, 'high', '자동화가 되지 않는다', 'UI가 너무 자주 바뀌면 테스트 유지가 어렵다', '로직을 테스트할 수 없다', '컴포넌트를 렌더링하지 않는다', 33, 'UI 변경이 자주 발생하는 경우 스냅샷 유지보수가 어려워진다.'),
                                                                                                                           (1639, '비동기 API를 테스트할 때 실제 서버를 호출하지 않기 위해 사용하는 방식은?', 3, 'high', '실제 API를 호출하고 검증', '코드를 주석 처리함', 'Mock 서버나 Mock 데이터를 사용함', '그냥 무시하고 테스트함', 33, '실제 API 대신 mock 서버나 데이터를 사용하는 것이 테스트 안정성을 높인다.'),
                                                                                                                           (1640, '다음 중 MSW(Mock Service Worker)의 주요 용도는?', 3, 'high', 'React 컴포넌트를 렌더링하기 위해', 'HTML을 정리하기 위해', '실제 API를 대체하는 가짜 응답을 테스트에서 제공하기 위해', '데이터베이스 테스트를 위해', 33, 'MSW는 실제 API 대신 클라이언트 요청에 대해 가짜 응답을 반환해 테스트를 돕는다.'),
                                                                                                                           (1641, '통합 테스트(Integration Test)의 주요 목적은?', 2, 'low', '단일 함수의 내부 동작 확인', '여러 모듈이 함께 작동하는 흐름을 검증', '브라우저 렌더링 속도 테스트', '사용자 입력 시뮬레이션 테스트', 33, '통합 테스트는 모듈 간의 연계 동작이 올바른지 검증하기 위한 테스트이다.'),
                                                                                                                           (1642, '통합 테스트에서 주로 테스트하는 것은?', 2, 'low', '데이터베이스 쿼리만 단독 테스트', 'API 호출부터 화면 반영까지의 흐름', '서버 CPU 사용량', 'HTML 정적 구조', 33, '통합 테스트는 API 요청부터 UI 반영까지 전체 흐름을 검증하는 것이 목적이다.'),
                                                                                                                           (1643, 'React 기반의 통합 테스트에서 가장 흔히 테스트하는 시나리오는?', 2, 'low', '컴포넌트 렌더링 여부만 확인', '버튼 클릭 시 API 요청 및 UI 변경 흐름', 'DOM 트리 구조 출력', '단일 스타일 변경 테스트', 33, '사용자 행동과 UI 반응을 함께 테스트하는 것이 통합 테스트의 핵심이다.'),
                                                                                                                           (1644, '통합 테스트에서 상태 관리 라이브러리(Redux, Zustand 등)를 다룰 때 가장 중요한 것은?', 2, 'medium', '비동기 호출 순서만 보기', 'store가 UI에 올바르게 반영되는지 확인', 'reducer 내부 구현 확인', '액션 생성 함수 테스트', 33, '상태 관리의 목적은 UI 반영이므로 store 상태와 UI 연동 여부를 테스트해야 한다.'),
                                                                                                                           (1645, '다음 중 React 앱에서 실제 사용자 흐름을 통합 테스트할 때 적절한 도구는?', 1, 'medium', 'Cypress', 'Prettier', 'Webpack', 'Babel', 33, 'Cypress는 E2E 테스트 도구로, 사용자의 실제 동작 시나리오를 테스트할 수 있다.'),
                                                                                                                           (1646, '비동기 통합 테스트에서 API 응답을 기다릴 때 사용하는 방식은?', 2, 'medium', 'setTimeout', 'async/await + waitFor() 조합', 'done() 함수 제거', 'forceFlush()', 33, '비동기 처리 결과를 기다릴 때는 async/await와 waitFor를 함께 사용한다.'),
                                                                                                                           (1647, 'API 요청 중 에러가 발생했을 때 UI가 제대로 에러 상태를 표시하는지 검증하는 테스트는?', 3, 'medium', '성능 테스트', '렌더링 테스트', '에러 처리 통합 테스트', '단위 테스트', 33, '에러 처리 통합 테스트는 사용자에게 적절한 에러 메시지를 보여주는지 확인하는 과정이다.'),
                                                                                                                           (1648, '통합 테스트를 작성할 때 가장 중요한 고려사항은?', 2, 'high', '컴포넌트 개수', '테스트가 실제 사용자 행동과 유사한지 여부', '코드 라인 수', '서버 상태', 33, '테스트는 실제 사용자 경험을 반영해야 의미 있는 통합 테스트가 된다.'),
                                                                                                                           (1649, '다음 중 API 요청/응답을 Mock 처리해 통합 테스트하는 기술은?', 3, 'high', 'RTL Snapshot', 'RESTClient', 'Mock Service Worker (MSW)', 'SASS Loader', 33, 'MSW는 API 요청을 가로채고 개발 환경에서 가짜 응답을 전달하는 데 유용하다.'),
                                                                                                                           (1650, '통합 테스트에서 ‘비정상 흐름’을 일부러 유도해 테스트하는 목적은?', 4, 'high', '테스트 커버리지 확보를 위해', '코드를 더 빨리 실행하기 위해', '사용자에게 실제로 에러를 보여주기 위해', '의도된 예외 처리 경로가 안전하게 작동하는지 확인하기 위해', 33, '비정상 상황을 시뮬레이션하여 에러 핸들링이 잘 작동하는지 확인하는 것이 중요하다.'),
                                                                                                                           (1651, 'E2E(End-to-End) 테스트의 주요 목적은?', 3, 'low', '단일 함수의 성능을 테스트하기 위해', '컴포넌트 단위 렌더링을 검증하기 위해', '전체 사용자 흐름이 정상적으로 작동하는지 확인하기 위해', '테스트 커버리지를 높이기 위해', 34, 'E2E 테스트는 실제 사용자처럼 전체 시스템을 사용하여 기능이 정상 동작하는지 확인하는 것이 목적이다.'),
                                                                                                                           (1652, '다음 중 E2E 테스트에 해당하는 시나리오는?', 2, 'low', '계산 함수의 반환값 검증', '로그인 → 장바구니 담기 → 결제 완료까지 시뮬레이션', '컴포넌트 내부 상태 확인', 'CSS class 적용 여부 확인', 34, 'E2E 테스트는 사용자의 전체 흐름을 시뮬레이션하는 것으로, 로그인부터 결제까지의 과정이 이에 해당된다.'),
                                                                                                                           (1653, 'E2E 테스트는 일반적으로 어떤 방식으로 실행되는가?', 3, 'low', '서버 로그를 통해 결과를 분석', '테스트 전용 API를 통해 직접 테스트', '브라우저를 실제로 열어 사용자처럼 동작을 시뮬레이션', '백엔드만 대상으로 테스트', 34, 'E2E 테스트는 브라우저를 열어 실제 사용자가 하는 방식대로 인터랙션을 테스트한다.'),
                                                                                                                           (1654, 'E2E 테스트 도구로 널리 사용되는 것이 아닌 것은?', 3, 'low', 'Cypress', 'Playwright', 'Postman', 'Selenium', 34, 'Postman은 API 테스트 도구이지 E2E 테스트 도구로는 사용되지 않는다.'),
                                                                                                                           (1655, 'E2E 테스트 시 시나리오 설계에서 가장 먼저 고려할 점은?', 2, 'medium', '컴포넌트의 크기', '사용자의 실제 행동 흐름', '데이터베이스 용량', '브라우저 렌더링 성능', 34, 'E2E 테스트는 사용자의 행동을 기반으로 설계되므로 실제 사용 흐름을 가장 먼저 고려해야 한다.'),
                                                                                                                           (1656, '다음 중 E2E 테스트의 특징으로 올바른 설명은?', 3, 'medium', '코드 레벨의 정확한 단위 테스트가 된다', '빠르지만 신뢰도가 낮다', '느리지만 실제 사용자 경험을 반영할 수 있다', '브라우저 없이 실행된다', 34, 'E2E 테스트는 실제 브라우저 환경에서 사용자처럼 행동하기 때문에 신뢰도는 높지만 속도는 느리다.'),
                                                                                                                           (1657, 'E2E 테스트가 단위 테스트에 비해 가지는 단점은?', 3, 'medium', '로컬에서 실행이 불가능하다', '실제 동작을 확인할 수 없다', '속도가 느리고, 설정이 복잡할 수 있다', '코드 커버리지를 높일 수 없다', 34, 'E2E 테스트는 설정이 복잡하고 실행 속도가 느리며 유지보수 비용이 높다.'),
                                                                                                                           (1658, 'E2E 테스트에서 테스트 환경을 격리해야 하는 주된 이유는?', 3, 'medium', '테스트 속도를 높이기 위해', 'UI를 더 멋지게 보이게 하기 위해', '테스트 결과가 외부 상태에 따라 달라지지 않도록 하기 위해', '브라우저 화면을 크게 보기 위해', 34, '환경을 격리하지 않으면 외부 요인에 따라 결과가 달라질 수 있어 테스트 신뢰도가 낮아진다.'),
                                                                                                                           (1659, 'E2E 테스트와 통합 테스트의 주된 차이점은?', 3, 'high', '통합 테스트는 화면을 테스트하지 않는다', 'E2E는 단일 함수 테스트이고, 통합은 전체 흐름 테스트다', 'E2E는 실제 사용자 인터페이스를 테스트하고, 통합 테스트는 코드 간 상호작용을 테스트한다', '둘은 동일하다', 34, 'E2E는 브라우저를 통한 실제 사용 시나리오 테스트이고, 통합 테스트는 시스템 내부 모듈 간의 연동 테스트이다.'),
                                                                                                                           (1660, 'E2E 테스트에서 테스트가 실패했을 때 가장 먼저 해야 할 행동은?', 2, 'high', '모든 테스트를 다시 작성한다', '실제 UI를 직접 열어 실패한 시나리오를 재현해본다', '코드를 전부 삭제한다', '다른 브라우저를 설치한다', 34, '실제 UI에서 시나리오를 따라가며 어떤 단계에서 실패했는지 확인하는 것이 우선이다.'),
                                                                                                                           (1661, 'Cypress에서 웹 페이지를 열기 위해 사용하는 명령어는?', 2, 'low', 'cy.open()', 'cy.visit()', 'cy.launch()', 'cy.page()', 34, 'cy.visit()은 테스트 중 웹 페이지로 이동할 때 사용하는 Cypress 명령어이다.'),
                                                                                                                           (1662, 'Cypress에서 특정 요소를 선택하기 위한 명령어는?', 3, 'low', 'cy.select()', 'cy.find()', 'cy.get()', 'cy.query()', 34, 'cy.get()은 Cypress에서 DOM 요소를 선택하는 기본적인 메서드이다.'),
                                                                                                                           (1663, 'Cypress에서 텍스트 입력을 시뮬레이션하려면 어떤 명령어를 사용해야 하는가?', 1, 'low', 'cy.type()', 'cy.input()', 'cy.write()', 'cy.fill()', 34, 'cy.type()은 input, textarea 등 입력 필드에 텍스트를 입력할 때 사용된다.'),
                                                                                                                           (1664, '버튼 클릭을 Cypress로 테스트하려면 어떤 명령어를 사용해야 하는가?', 2, 'low', 'cy.push()', 'cy.click()', 'cy.tap()', 'cy.fire()', 34, 'cy.click()은 Cypress에서 클릭 이벤트를 시뮬레이션하는 표준 명령어이다.'),
                                                                                                                           (1665, 'Cypress에서 체이닝 방식으로 연속 동작을 정의할 수 있는 이유는?', 1, 'medium', '모든 명령어가 비동기적으로 처리되기 때문', 'JavaScript의 특성 때문', 'Cypress는 HTML을 직접 수정하기 때문', '실제 브라우저를 사용하지 않기 때문', 34, 'Cypress 명령어는 자동으로 기다림(자동 대기)을 제공하여 비동기 흐름에서도 체이닝이 가능하다.'),
                                                                                                                           (1666, '다음 중 Cypress에서 사용 가능한 Assertion 함수는?', 1, 'medium', 'should()', 'must()', 'verify()', 'assert()', 34, '`should()`는 Cypress에서 요소나 상태에 대한 조건을 검증할 때 사용하는 대표적인 Assertion이다.'),
                                                                                                                           (1667, 'Cypress 테스트에서 ‘id가 login인 요소’를 선택하는 올바른 구문은?', 2, 'medium', 'cy.get(\'login\')', 'cy.get(\'#login\')', 'cy.get(\'.login\')', 'cy.get(\'id=login\')', 34, 'id 선택자는 CSS에서 #을 사용하므로 Cypress에서도 #login으로 선택해야 한다.'),
                                                                                                                           (1668, 'Cypress에서 네트워크 요청을 가로채거나 대체할 때 사용하는 명령어는?', 3, 'medium', 'cy.replace()', 'cy.api()', 'cy.intercept()', 'cy.mock()', 34, 'cy.intercept()는 네트워크 요청을 중간에서 가로채고 응답을 조작할 수 있게 해준다.'),
                                                                                                                           (1669, 'Cypress에서 테스트를 시작할 때 가장 먼저 정의하는 함수는?', 1, 'high', 'describe()', 'start()', 'suite()', 'run()', 34, 'Cypress 테스트는 describe() 블록으로 테스트 그룹을 구성하여 시작한다.'),
                                                                                                                           (1670, '다음 중 Cypress의 ‘it()’ 함수의 목적은?', 2, 'high', '테스트 스위트 전체 정의', '단일 테스트 시나리오를 정의', '환경 설정 수행', '스냅샷을 저장', 34, 'it()은 describe() 안에서 실제 개별 테스트 단위를 정의하는 함수이다.'),
                                                                                                                           (1671, 'E2E 테스트에서 로그인 후 페이지 접근 여부를 테스트하려면 어떤 흐름이 필요한가?', 3, 'low', '컴포넌트 렌더링만 확인', '로그인 없이 바로 이동', '로그인 수행 후 토큰 기반 접근 확인', '스크린샷 저장 후 비교', 34, '로그인을 시뮬레이션한 뒤 인증 토큰을 통해 접근이 허용되는지 검증해야 한다.'),
                                                                                                                           (1672, 'Cypress에서 로그인 상태를 재사용하려면 가장 적절한 방법은?', 3, 'low', '테스트마다 로그인 절차 반복', '브라우저 자동 리프레시 사용', 'localStorage나 쿠키를 직접 설정', '테스트 후 세션을 삭제', 34, '로그인 과정을 매번 반복하지 않기 위해 localStorage나 쿠키에 인증 정보를 미리 설정해두는 것이 효율적이다.'),
                                                                                                                           (1673, 'Cypress에서 특정 URL로 이동했는지 검증할 때 사용하는 메서드는?', 1, 'low', 'cy.url()', 'cy.path()', 'cy.redirect()', 'cy.location()', 34, 'cy.url()은 현재 페이지의 URL을 확인하여 이동 여부를 검증할 때 사용된다.'),
                                                                                                                           (1674, 'E2E 테스트에서 로그인과 같은 공통 작업을 테스트 전에 실행하려면 어떤 Hook을 사용하는가?', 1, 'medium', 'before()', 'setup()', 'onLogin()', 'preRun()', 34, 'before()는 각 테스트 실행 전 공통 설정을 처리하는 데 사용된다.'),
                                                                                                                           (1675, '다음 중 상태가 여러 테스트 간 공유되지 않도록 하기 위한 전략은?', 3, 'medium', '브라우저 새로고침', 'DOM 요소 초기화', '각 테스트마다 상태를 명시적으로 초기화', 'URL을 변경하지 않음', 34, '테스트 간 영향을 방지하려면 상태를 명확히 초기화해 테스트의 독립성을 유지해야 한다.'),
                                                                                                                           (1676, '라우팅 테스트에서 로그인하지 않은 사용자가 접근할 수 없도록 하는 테스트는?', 3, 'medium', '인증 우회 테스트', '보안 무시 테스트', '비인가 접근 차단 테스트', '라우팅 백도어 테스트', 34, '비인가 사용자가 접근하려 할 때 차단되고 리디렉션 되는지 확인하는 테스트이다.'),
                                                                                                                           (1677, '상태 검증에서 가장 중요하게 테스트해야 할 것은?', 3, 'medium', '상태 저장 위치', 'Redux나 Zustand의 reducer 함수 호출 여부', '사용자의 인터랙션 결과로 UI가 올바르게 반영되었는지', '브라우저 쿠키 변경 여부', 34, '사용자의 행동이 UI에 제대로 반영되는지가 상태 검증 테스트의 핵심이다.'),
                                                                                                                           (1678, 'Cypress에서 로그인 API를 미리 호출하여 세션을 설정하는 방법은?', 2, 'high', 'cy.routeLogin()', 'cy.session()', 'cy.init()', 'cy.apiAuth()', 34, 'cy.session()은 로그인 세션을 재사용 가능하도록 저장하고 복원하는 데 사용된다.'),
                                                                                                                           (1679, '다음 중 상태 기반 UI 테스트에 포함될 수 없는 것은?', 3, 'high', '버튼 클릭 후 텍스트가 변경되었는지 확인', '비동기 요청 후 목록이 갱신되었는지 확인', '컴포넌트 이름이 올바른지 확인', '상태에 따라 요소가 보이거나 숨겨졌는지 확인', 34, '컴포넌트 이름은 UI 상태 변화와 무관하므로 상태 기반 테스트에 포함되지 않는다.'),
                                                                                                                           (1680, 'E2E 테스트에서 사용자 상태에 따라 라우팅을 분기시키는 케이스를 테스트할 때 가장 중요한 점은?', 2, 'high', '사용자 정보를 console.log로 출력하는 것', '로그인된 상태/비로그인 상태 모두를 분리해 시나리오를 테스트하는 것', 'URL을 정적으로 지정하는 것', '브라우저를 수동 조작하는 것', 34, '상태별 사용자 흐름을 각각 테스트하여 모든 조건에서 라우팅이 의도대로 동작하는지 확인해야 한다.'),
                                                                                                                           (1681, 'Visual Regression Test의 주요 목적은?', 3, 'low', '코드 내부 로직을 검증하기 위해', '컴포넌트의 상태 관리를 테스트하기 위해', 'UI의 시각적 변화 여부를 감지하기 위해', '페이지 로딩 속도를 측정하기 위해', 34, 'Visual Regression Test는 UI의 시각적 차이를 감지하여 의도하지 않은 변경을 탐지하기 위한 테스트이다.'),
                                                                                                                           (1682, '다음 중 Visual Regression Test 도구가 아닌 것은?', 4, 'low', 'Percy', 'jest-image-snapshot', 'Chromatic', 'Vitest', 34, 'Vitest는 유닛 테스트 프레임워크로, 시각적 비교를 위한 VRT 도구는 아니다.'),
                                                                                                                           (1683, '화면의 스냅샷을 저장하고 픽셀 단위로 비교하는 방식을 사용하는 테스트는?', 4, 'low', '단위 테스트', '통합 테스트', 'E2E 테스트', 'Visual Regression Test', 34, 'Visual Regression Test는 이전 스냅샷과 픽셀 단위로 비교하여 시각적 변화 여부를 감지한다.'),
                                                                                                                           (1684, 'Visual Regression Test가 실패하는 주요 이유는?', 2, 'medium', '코드가 너무 길어서', 'UI가 이전과 다르게 렌더링되었기 때문', '브라우저 종류가 달라서', '서버가 응답하지 않아서', 34, 'UI의 작은 변화(글자, 마진 등)도 이전 이미지와 다르면 VRT는 실패로 처리한다.'),
                                                                                                                           (1685, 'Percy와 같은 도구에서 시각적 차이를 허용하는 기준 값은?', 2, 'medium', 'margin', 'threshold', 'resolution', 'offset', 34, 'threshold는 비교 이미지 간 픽셀 차이 허용 범위를 지정하는 값이다.'),
                                                                                                                           (1686, 'Visual Regression Test를 구성할 때 테스트가 불안정해지는 주요 원인은?', 2, 'medium', 'API 속도 변화', '브라우저 창 크기 불일치', '컴포넌트 이름 중복', '로딩 스피너 미적용', 34, '브라우저 크기가 달라지면 렌더링 결과가 달라져 비교가 실패할 수 있다.'),
                                                                                                                           (1687, '다음 중 VRT를 적용하기 가장 적절한 대상은?', 3, 'medium', '네트워크 요청', 'Redux 상태 변경', '버튼 위치, 폰트 크기 등의 UI 요소', '서버 응답 시간', 34, 'VRT는 UI 요소의 위치나 스타일 등 시각적 변경을 감지하는 데 특화되어 있다.'),
                                                                                                                           (1688, 'Chromatic은 어떤 프레임워크 기반에서 동작하는 VRT 도구인가?', 1, 'high', 'Storybook', 'React Testing Library', 'Cypress', 'Next.js', 34, 'Chromatic은 Storybook과 통합되어 컴포넌트 단위 시각적 회귀 테스트를 지원한다.'),
                                                                                                                           (1689, 'jest-image-snapshot의 역할은?', 2, 'high', '이미지를 애니메이션으로 변환', '이미지를 저장하고 이전 이미지와 비교', '브라우저 렌더링을 가속', '컴포넌트 이름을 리팩터링', 34, 'jest-image-snapshot은 이미지 기반으로 스냅샷을 비교하여 VRT를 수행한다.'),
                                                                                                                           (1690, 'Visual Regression Test에서 false positive를 줄이기 위한 전략은?', 3, 'high', '이미지 비교를 제거한다', 'threshold를 0으로 설정한다', '애니메이션 요소를 제외하거나 지연시간(wait)을 설정한다', '매번 스냅샷을 덮어쓴다', 34, '애니메이션이나 비동기 요소는 비교 시 오차를 발생시켜 false positive를 유발할 수 있다.'),
                                                                                                                           (1691, 'E2E 테스트와 Visual Regression Test를 함께 사용하는 가장 큰 이유는?', 3, 'low', '테스트 실행 속도를 높이기 위해', '코드 커버리지를 자동 계산하기 위해', '기능 흐름과 UI 변경을 동시에 검증하기 위해', '서버 상태를 유지하기 위해', 34, '기능 검증과 함께 UI 시각적 변화까지 함께 검증함으로써 품질을 높일 수 있다.'),
                                                                                                                           (1692, '다음 중 E2E + VRT 통합 전략에 해당하지 않는 것은?', 3, 'low', '로그인 후 페이지 이동과 화면 비교를 함께 수행', '버튼 클릭 후 발생하는 UI 변경을 시각적으로 캡처', '데이터베이스 백업만 테스트', '사용자 흐름 기반 테스트에 스냅샷 비교 추가', 34, '데이터베이스 백업은 기능 테스트에도 VRT에도 해당되지 않는 항목이다.'),
                                                                                                                           (1693, 'E2E + VRT를 통합할 때 가장 먼저 고려해야 할 것은?', 3, 'medium', '데이터베이스 마이그레이션', '브라우저 호환성 문제', '테스트 대상의 사용자 흐름과 시각적 변화 포인트 정의', '컴포넌트 폴더 구조', 34, '테스트 포인트와 시각적 변화가 발생하는 시점을 명확히 정의해야 VRT를 효과적으로 적용할 수 있다.'),
                                                                                                                           (1694, '다음 중 실제 사용자 시나리오 + UI 비교를 자동화하는 데 가장 적합한 조합은?', 2, 'medium', 'Jest + Webpack', 'Cypress + Percy', 'React Testing Library + ESLint', 'Vitest + Tailwind', 34, 'Cypress는 사용자 흐름을 테스트하고 Percy는 UI 변화 감지를 지원하므로 통합 테스트에 적합하다.'),
                                                                                                                           (1695, 'E2E + VRT 테스트에서 동일한 테스트가 자주 실패한다면 먼저 확인해야 할 것은?', 1, 'medium', '화면 캡처 타이밍과 애니메이션 여부', '테스트 파일명', 'CSS 변수 정의 방식', '사용자 ID 값', 34, '화면 캡처 시점에 애니메이션이 작동 중이면 비교 이미지가 달라져 테스트가 실패할 수 있다.'),
                                                                                                                           (1696, '다음 중 E2E → VRT 흐름을 구성한 예시로 올바른 것은?', 2, 'medium', '1. 스냅샷 찍기 → 2. 로그인 → 3. 클릭', '1. 클릭 → 2. 페이지 이동 → 3. 화면 캡처 → 4. 이미지 비교', '1. assert 호출 → 2. 테스트 종료 → 3. UI 스냅샷 저장', '1. 서버 로그 수집 → 2. 컴포넌트 리렌더링', 34, '기능 수행 후 화면을 캡처하고 이미지 비교하는 것이 VRT의 흐름이다.'),
                                                                                                                           (1697, 'E2E + VRT 통합 테스트 시, 테스트가 불안정하게 자주 깨질 경우 해결 전략은?', 3, 'high', '스냅샷 비교를 제거한다', '테스트 실행 시간을 줄인다', '애니메이션 제거 및 특정 요소가 로드된 후 비교', '코드를 전체 리팩터링한다', 34, '불안정성은 대부분 애니메이션, 비동기 요소가 원인이므로 이를 제어하면 안정성이 향상된다.'),
                                                                                                                           (1698, '다음 중 통합된 테스트 시나리오 예로 가장 적절한 것은?', 2, 'high', '페이지 로딩 속도 측정만 수행', '사용자가 결제 버튼을 누르고 완료 화면의 디자인도 함께 검증', 'Redux 상태만 비교', '컴포넌트 수동 클릭', 34, '사용자 흐름과 그에 따른 UI 결과까지 함께 테스트하는 것이 통합 테스트의 예이다.'),
                                                                                                                           (1699, 'E2E + VRT 통합 테스트에서 테스트 유지보수성을 높이기 위한 방법은?', 2, 'high', '모든 스냅샷을 자동 업데이트', '기능별 테스트 시나리오 분리 및 UI 변화 최소화 기준 설정', '컴포넌트를 재설계한다', '테스트를 하나로 몰아넣는다', 34, '기능별로 나누고 변경 기준을 명확히 하면 테스트 유지보수가 쉬워진다.'),
                                                                                                                           (1700, 'CI 환경에서 E2E + VRT 통합 테스트를 자동화하려면 필요한 구성 요소는?', 2, 'high', 'npm run build 명령어만 있으면 됨', 'GitHub Actions, 테스트 도구, 시각 비교 도구가 포함된 워크플로우', '브라우저 콘솔 로그', '크롬 확장 프로그램', 34, 'CI 자동화에는 워크플로우 구성과 함께 테스트 및 시각 비교 도구가 함께 필요하다.'),
                                                                                                                           (1701, '현재 작업 중인 디렉토리를 출력하는 명령어는?', 2, 'low', 'cd', 'pwd', 'ls', 'dir', 35, 'pwd는 현재 위치한 디렉토리 경로를 출력하는 명령어이다.'),
                                                                                                                           (1702, '파일 내용을 화면에 출력하는 명령어는?', 2, 'low', 'echo', 'cat', 'print', 'more', 35, 'cat은 파일의 내용을 터미널에 그대로 출력하는 명령어이다.'),
                                                                                                                           (1703, '디렉토리를 생성하는 명령어는?', 1, 'low', 'mkdir', 'makedir', 'diradd', 'newdir', 35, 'mkdir은 "make directory"의 줄임말로 새 디렉토리를 생성하는 명령어이다.'),
                                                                                                                           (1704, '파일을 삭제하는 명령어는?', 3, 'medium', 'erase', 'del', 'rm', 'rmdir', 35, 'rm은 Unix 계열에서 파일을 삭제할 때 사용하는 명령어이다.'),
                                                                                                                           (1705, '숨김 파일을 포함해 모든 파일을 나열하는 명령어는?', 1, 'medium', 'ls -a', 'ls -l', 'ls -h', 'ls -f', 35, 'ls -a 옵션은 숨김 파일(점으로 시작하는 파일)까지 모두 출력한다.'),
                                                                                                                           (1706, '파일의 복사에 사용하는 명령어는?', 2, 'medium', 'mv', 'cp', 'copy', 'clone', 35, 'cp는 파일이나 디렉토리를 복사할 때 사용하는 기본 명령어이다.'),
                                                                                                                           (1707, '심볼릭 링크를 생성하는 명령어는?', 3, 'high', 'link', 'symlink', 'ln -s', 'mklink', 35, 'ln -s는 대상 파일에 대한 심볼릭 링크를 생성하는 Unix 계열 명령어이다.'),
                                                                                                                           (1708, '디스크 공간을 확인하는 명령어는?', 1, 'high', 'df', 'du', 'lsblk', 'space', 35, 'df는 파일 시스템의 디스크 사용량을 요약해서 보여준다.'),
                                                                                                                           (1709, '파일 시스템의 사용량을 확인하는 명령어는?', 2, 'high', 'df -h', 'du -sh', 'ls -lh', 'top', 35, 'du -sh는 특정 디렉토리나 파일의 사용량을 요약해 사람이 읽기 쉽게 보여준다.'),
                                                                                                                           (1710, '파일 경로에서 . 은 무엇을 의미하는가?', 2, 'high', '홈 디렉토리', '현재 디렉토리', '루트 디렉토리', '상위 디렉토리', 35, '.은 현재 작업 중인 디렉토리를 의미하며, 명령어 실행 경로를 지정할 때 자주 사용된다.'),
                                                                                                                           (1711, '현재 로그인한 사용자를 확인하는 명령어는?', 1, 'low', 'whoami', 'me', 'id', 'logname', 35, 'whoami 명령어는 현재 로그인한 사용자의 사용자명을 출력한다.'),
                                                                                                                           (1712, '파일의 소유자와 그룹을 변경하는 명령어는?', 2, 'low', 'chmod', 'chown', 'usermod', 'groupadd', 35, 'chown 명령어는 파일의 소유자와 그룹을 변경하는 데 사용된다.'),
                                                                                                                           (1713, '새 사용자를 추가하는 명령어는?', 1, 'low', 'useradd', 'adduser', 'newuser', 'mkuser', 35, 'useradd는 새로운 시스템 사용자를 생성하는 명령어이다.'),
                                                                                                                           (1714, '파일 권한을 변경하는 명령어는?', 1, 'medium', 'chmod', 'chgrp', 'setperm', 'setchmod', 35, 'chmod는 파일의 읽기, 쓰기, 실행 권한을 설정하거나 변경하는 명령어이다.'),
                                                                                                                           (1715, '그룹을 추가하는 명령어는?', 2, 'medium', 'addgroup', 'groupadd', 'newgroup', 'mkgroup', 35, 'groupadd는 시스템에 새로운 그룹을 생성하는 명령어이다.'),
                                                                                                                           (1716, '사용자의 현재 그룹 목록을 확인하는 명령어는?', 1, 'medium', 'groups', 'usergroups', 'id -g', 'usermod -g', 35, 'groups 명령어는 현재 사용자가 속한 그룹들을 모두 출력한다.'),
                                                                                                                           (1717, '파일 권한 755의 의미는?', 2, 'high', 'rwx rwx rwx', 'rwx r-x r-x', 'rw- rw- rw-', 'r-- r-- r--', 35, '755는 소유자는 읽기/쓰기/실행, 그룹과 기타는 읽기/실행 권한을 의미한다.'),
                                                                                                                           (1718, '비밀번호를 설정하는 명령어는?', 1, 'high', 'passwd', 'setpass', 'userpass', 'changepass', 35, 'passwd 명령어는 사용자 계정의 비밀번호를 설정하거나 변경할 수 있다.'),
                                                                                                                           (1719, '파일에 대한 접근 권한을 부여할 때 사용하는 심볼은?', 4, 'high', 'x', 'w', 'r', '모두 해당', 35, 'r(읽기), w(쓰기), x(실행)은 모두 접근 권한을 부여할 때 사용하는 심볼이다.'),
                                                                                                                           (1720, '파일의 소유자 변경 시 사용하는 명령어는?', 3, 'high', 'chmod', 'chgrp', 'chown', 'chperm', 35, 'chown은 파일의 소유자(owner)를 변경하는 데 사용하는 명령어이다.'),
                                                                                                                           (1721, '현재 실행 중인 프로세스를 확인하는 명령어는?', 1, 'low', 'ps', 'run', 'jobs', 'top', 35, 'ps 명령어는 현재 실행 중인 프로세스들의 정보를 출력해준다.'),
                                                                                                                           (1722, '실시간으로 시스템 상태를 보여주는 명령어는?', 3, 'low', 'ps', 'jobs', 'top', 'uptime', 35, 'top은 CPU, 메모리 사용량 등 시스템 상태를 실시간으로 보여주는 명령어이다.'),
                                                                                                                           (1723, '백그라운드 작업을 포그라운드로 전환하는 명령어는?', 1, 'low', 'fg', 'bg', 'resume', 'bring', 35, 'fg는 백그라운드에서 실행 중인 작업을 포그라운드로 다시 전환하는 명령어이다.'),
                                                                                                                           (1724, '작업을 백그라운드로 전환하는 명령어는?', 1, 'medium', 'bg', 'fg', 'bgjob', 'ctrl+z', 35, 'bg 명령어는 일시중지된 작업을 백그라운드에서 계속 실행하도록 전환한다.'),
                                                                                                                           (1725, '특정 프로세스를 강제 종료하는 명령어는?', 3, 'medium', 'exit', 'halt', 'kill', 'stop', 35, 'kill 명령어는 프로세스 ID를 지정하여 해당 프로세스를 종료할 수 있다.'),
                                                                                                                           (1726, '현재 실행 중인 작업 목록을 보는 명령어는?', 1, 'medium', 'jobs', 'tasks', 'runlist', 'active', 35, 'jobs 명령어는 백그라운드에서 실행 중이거나 일시 중지된 작업들을 보여준다.'),
                                                                                                                           (1727, '시그널 번호 9는 무엇을 의미하는가?', 3, 'high', '프로세스 일시중지', '프로세스 종료', '프로세스 강제 종료', '메모리 반환', 35, '시그널 9(SIGKILL)는 프로세스를 강제로 종료시킬 때 사용하는 시그널이다.'),
                                                                                                                           (1728, '특정 이름의 프로세스를 종료할 수 있는 명령어는?', 1, 'high', 'killall', 'pskill', 'endproc', 'shutdown', 35, 'killall은 프로세스 이름을 기준으로 해당 프로세스를 모두 종료할 수 있다.'),
                                                                                                                           (1729, '작업의 우선순위를 조정하는 명령어는?', 3, 'high', 'nice', 'priority', 'renice', 'taskmod', 35, 'renice는 이미 실행 중인 프로세스의 우선순위(niceness)를 변경하는 명령어이다.'),
                                                                                                                           (1730, '특정 명령을 백그라운드에서 실행하려면 어떻게 하는가?', 1, 'high', '명령어 &', 'run 명령어', 'exec 명령어', 'start 명령어', 35, '명령어 뒤에 &를 붙이면 해당 명령이 백그라운드에서 실행된다.'),
                                                                                                                           (1731, 'Debian 계열에서 패키지를 설치하는 명령어는?', 3, 'low', 'yum install', 'dnf install', 'apt install', 'rpm -i', 35, 'apt install은 Debian 및 Ubuntu 계열에서 패키지를 설치할 때 사용하는 명령어이다.'),
                                                                                                                           (1732, 'RedHat 계열에서 패키지를 설치하는 명령어는?', 2, 'low', 'apt install', 'yum install', 'brew install', 'pkg install', 35, 'yum install은 RedHat 및 CentOS 계열에서 패키지를 설치할 때 사용된다.'),
                                                                                                                           (1733, '설치된 모든 패키지를 나열하는 명령어는?', 4, 'low', 'yum list', 'dpkg -l', 'apt list --installed', '모두 해당', 35, 'yum, dpkg, apt 모두 설치된 패키지를 나열할 수 있는 명령어이며, 모두 정답이다.'),
                                                                                                                           (1734, 'apt 패키지 목록을 업데이트하는 명령어는?', 2, 'medium', 'apt upgrade', 'apt update', 'apt refresh', 'apt reload', 35, 'apt update는 패키지 저장소의 최신 목록을 가져오는 명령어이다.'),
                                                                                                                           (1735, 'dnf를 사용하는 Linux 배포판은?', 3, 'medium', 'Ubuntu', 'Debian', 'Fedora', 'Arch', 35, 'dnf는 RedHat 계열의 최신 배포판인 Fedora에서 사용된다.'),
                                                                                                                           (1736, 'RPM 패키지를 수동 설치하는 명령어는?', 1, 'medium', 'rpm -i', 'yum install rpm', 'rpm --install', 'rpm +i', 35, 'rpm -i는 RPM 파일을 설치할 때 사용하는 표준 명령어이다.'),
                                                                                                                           (1737, '설치된 패키지를 삭제하는 apt 명령어는?', 3, 'high', 'apt delete', 'apt erase', 'apt remove', 'apt uninstall', 35, 'apt remove는 apt로 설치된 패키지를 삭제할 때 사용하는 명령어이다.'),
                                                                                                                           (1738, '소스코드로 소프트웨어를 설치할 때 사용되는 기본 명령은?', 4, 'high', './configure', 'make install', 'tar -xzvf', '모두 해당', 35, '소스코드 설치 과정에는 압축 해제(tar), 구성(configure), 컴파일 및 설치(make install) 단계가 모두 포함된다.'),
                                                                                                                           (1739, '리눅스에서 실행 파일 권한을 설정하는 명령어는?', 1, 'high', 'chmod +x', 'chmod -r', 'make install', 'setrun', 35, 'chmod +x 명령어는 파일에 실행 권한을 부여하여 실행 가능하게 만든다.'),
                                                                                                                           (1740, 'Flatpak과 Snap은 어떤 유형의 패키지 시스템인가?', 3, 'high', '전통적 패키지', '모듈형 패키지', '컨테이너 기반 패키지', '비공식 저장소', 35, 'Flatpak과 Snap은 앱을 격리된 환경에서 실행할 수 있도록 설계된 컨테이너 기반 패키지 시스템이다.'),
                                                                                                                           (1741, '시스템의 현재 날짜와 시간을 확인하는 명령어는?', 3, 'low', 'clock', 'time', 'date', 'now', 35, 'date 명령어는 현재 시스템의 날짜와 시간을 출력하는 데 사용된다.'),
                                                                                                                           (1742, '로그 파일은 일반적으로 어느 디렉토리에 저장되는가?', 2, 'low', '/log', '/var/log', '/etc/log', '/usr/log', 35, '리눅스 시스템에서 대부분의 로그 파일은 /var/log 디렉토리에 저장된다.'),
                                                                                                                           (1743, '시스템의 부팅 로그를 확인하는 명령어는?', 1, 'low', 'dmesg', 'bootlog', 'sysboot', 'initlog', 35, 'dmesg 명령어는 커널 부팅 메시지와 초기 하드웨어 정보 등을 출력한다.'),
                                                                                                                           (1744, '시스템 서비스 상태를 확인하는 명령어는?', 3, 'medium', 'service', 'status', 'systemctl status', 'checksvc', 35, 'systemctl status는 systemd 기반 시스템에서 서비스의 상태를 확인할 때 사용된다.'),
                                                                                                                           (1745, '서비스를 시작하는 systemctl 명령어는?', 2, 'medium', 'systemctl enable', 'systemctl start', 'systemctl begin', 'systemctl run', 35, 'systemctl start는 지정된 서비스를 즉시 시작할 때 사용하는 명령어이다.'),
                                                                                                                           (1746, 'journalctl 명령어는 무엇을 위한 것인가?', 3, 'medium', '파일 시스템 관리', '프로세스 추적', '시스템 로그 조회', '네트워크 설정', 35, 'journalctl은 systemd 시스템에서 로그 메시지를 조회하는 데 사용된다.'),
                                                                                                                           (1747, 'cron 작업 설정 파일은 어디에 위치하는가?', 4, 'high', '/etc/cron.d', '/etc/crontab', '/var/cron', '모두 해당', 35, 'cron 작업은 여러 경로에 분산되어 있으며 모두 설정 파일 경로로 사용된다.'),
                                                                                                                           (1748, 'crontab에서 ''*''는 어떤 의미인가?', 2, 'high', '무시', '모든 값', '시간 초과', '반복 없음', 35, '*는 모든 가능한 값을 의미하며, 매 분/시/일/월 등 반복 실행을 지정할 때 사용된다.'),
                                                                                                                           (1749, '로그 파일에서 최근 항목만 확인하려면 사용하는 명령어는?', 3, 'high', 'cat', 'head', 'tail', 'less', 35, 'tail 명령어는 파일의 끝 부분, 즉 최근 항목들을 출력할 때 사용된다.'),
                                                                                                                           (1750, '리눅스 시스템 로그를 모니터링하기 위해 사용하는 명령어는?', 1, 'high', 'journalctl -f', 'syslogctl', 'watch log', 'logwatch', 35, 'journalctl -f는 실시간으로 시스템 로그를 모니터링하는 데 사용된다.'),
                                                                                                                           (1751, 'OSI 7계층에서 데이터 링크 계층은 몇 번째인가?', 2, 'low', '1계층', '2계층', '3계층', '4계층', 36, '데이터 링크 계층은 OSI 모델에서 2계층이며, MAC 주소 기반 통신을 담당한다.'),
                                                                                                                           (1752, '패킷을 목적지까지 전달하는 역할을 하는 계층은?', 3, 'low', '물리 계층', '데이터 링크 계층', '네트워크 계층', '전송 계층', 36, '네트워크 계층은 IP 주소를 기반으로 패킷의 목적지까지 경로를 결정한다.'),
                                                                                                                           (1753, '클라이언트-서버 모델에서 서버의 역할은?', 2, 'low', '요청 전송', '요청 수신 및 응답', '브라우저 실행', '라우팅 수행', 36, '서버는 클라이언트로부터 요청을 받아 처리하고 응답을 제공한다.'),
                                                                                                                           (1754, 'TCP와 UDP의 주요 차이점은?', 3, 'medium', 'TCP는 비연결형', 'UDP는 신뢰성 있음', 'TCP는 연결 지향적', 'UDP는 흐름 제어 지원', 36, 'TCP는 데이터를 전송하기 전에 연결을 설정하는 연결 지향적 프로토콜이다.'),
                                                                                                                           (1755, '이더넷 프레임에서 목적지 MAC 주소의 길이는?', 4, 'medium', '32비트', '64비트', '128비트', '48비트', 36, 'MAC 주소는 48비트(6바이트) 길이로 구성되어 있다.'),
                                                                                                                           (1756, '라우터의 주요 기능은?', 3, 'medium', '암호화', '파일 전송', '네트워크 간 데이터 전달', '응용 프로그램 실행', 36, '라우터는 네트워크 간 패킷을 전달하고 경로를 결정하는 기능을 수행한다.'),
                                                                                                                           (1757, 'OSI 7계층 중 실제 전송 매체와 관련된 계층은?', 2, 'high', '응용 계층', '물리 계층', '세션 계층', '전송 계층', 36, '물리 계층은 전기적, 기계적 신호를 통해 실제 데이터를 전송하는 계층이다.'),
                                                                                                                           (1758, 'P2P 방식의 특징은?', 3, 'high', '중앙 집중형', '브라우저 기반', '서버 불필요', '클라이언트만 존재', 36, 'P2P는 각 노드가 서버 역할도 할 수 있어 중앙 서버 없이 통신이 가능하다.'),
                                                                                                                           (1759, '데이터 전송 중 오류 제어와 흐름 제어를 담당하는 계층은?', 2, 'high', '데이터 링크 계층', '전송 계층', '세션 계층', '응용 계층', 36, '전송 계층은 데이터 전송의 신뢰성과 흐름 제어를 제공한다.'),
                                                                                                                           (1760, '방화벽의 주된 역할은?', 3, 'high', '데이터 압축', '보안 감시', '패킷 필터링', '포트 포워딩', 36, '방화벽은 허용된 패킷만 통과시키고, 나머지는 차단하여 보안을 유지한다.'),
                                                                                                                           (1761, 'IPv4 주소는 몇 비트로 구성되어 있는가?', 2, 'low', '16비트', '32비트', '64비트', '128비트', 36, 'IPv4 주소는 32비트로 구성되어 있으며, 이를 8비트씩 나누어 4개의 옥텟으로 표현한다.'),
                                                                                                                           (1762, '다음 중 사설 IP 주소 대역은?', 1, 'low', '172.16.0.0/12', '8.8.8.8', '192.0.2.0', '100.64.0.0', 36, '172.16.0.0/12는 사설 IP 대역으로 내부 네트워크에서 사용된다.'),
                                                                                                                           (1763, '255.255.255.0에 해당하는 서브넷 마스크는?', 1, 'low', '/24', '/16', '/8', '/32', 36, '255.255.255.0은 24비트를 네트워크로 사용하는 /24 서브넷 마스크에 해당한다.'),
                                                                                                                           (1764, '서브넷팅의 주요 목적은?', 3, 'medium', '보안 향상', '속도 개선', 'IP 낭비 방지', '데이터 암호화', 36, '서브넷팅은 IP 주소를 효율적으로 나누어 낭비를 줄이는 데 목적이 있다.'),
                                                                                                                           (1765, 'IP 주소와 서브넷 마스크를 설정하는 명령어는?', 2, 'medium', 'ipconfig', 'ifconfig', 'netstat', 'ping', 36, 'ifconfig는 네트워크 인터페이스의 IP와 서브넷 설정에 사용된다.'),
                                                                                                                           (1766, 'IPv6 주소의 비트 수는?', 3, 'medium', '32비트', '64비트', '128비트', '256비트', 36, 'IPv6는 확장된 주소 공간을 제공하며 128비트 주소 체계를 사용한다.'),
                                                                                                                           (1767, '클래스 C 주소의 기본 서브넷 마스크는?', 3, 'high', '255.0.0.0', '255.255.0.0', '255.255.255.0', '255.255.255.255', 36, '클래스 C 주소는 기본적으로 255.255.255.0의 서브넷 마스크를 사용한다.'),
                                                                                                                           (1768, 'IPv4 주소 192.168.1.1에서 네트워크 부분은 어디까지인가? (기본 /24 기준)', 2, 'high', '192.168.0.0', '192.168.1.0', '192.168.1.1', '192.168.1.255', 36, '/24 기준에서는 IP 주소의 처음 24비트가 네트워크 주소이므로 192.168.1.0이 된다.'),
                                                                                                                           (1769, '브로드캐스트 주소란?', 3, 'high', '모든 네트워크', '특정 호스트', '모든 호스트', '라우터 전용', 36, '브로드캐스트 주소는 동일 네트워크의 모든 호스트에게 메시지를 전송할 때 사용된다.'),
                                                                                                                           (1770, '프라이빗 IP는 어떤 용도로 사용되는가?', 3, 'high', '공공 웹사이트', '라우터 간 통신', '로컬 네트워크', '방화벽 설정', 36, '프라이빗 IP는 내부 네트워크 전용으로 외부 인터넷과 직접 연결되지 않는다.'),
                                                                                                                           (1771, 'HTTP는 어떤 계층의 프로토콜인가?', 2, 'low', '전송 계층', '응용 계층', '네트워크 계층', '데이터 링크 계층', 36, 'HTTP는 웹 브라우저와 서버 간의 데이터 전송을 담당하는 응용 계층 프로토콜이다.'),
                                                                                                                           (1772, 'HTTP 요청 메서드 중 데이터를 서버에 전송할 때 사용하는 것은?', 2, 'low', 'GET', 'POST', 'PUT', 'HEAD', 36, 'POST 메서드는 서버로 데이터를 전송하기 위한 용도로 사용된다.'),
                                                                                                                           (1773, '웹 브라우저가 웹 서버에 처음 요청을 보낼 때 사용하는 메서드는?', 3, 'low', 'POST', 'DELETE', 'GET', 'CONNECT', 36, 'GET은 웹 서버에서 리소스를 요청할 때 가장 기본적으로 사용되는 HTTP 메서드이다.'),
                                                                                                                           (1774, 'HTTPS는 HTTP에 어떤 보안 프로토콜을 추가한 것인가?', 1, 'medium', 'TLS', 'IPSec', 'SSH', 'SSL', 36, 'HTTPS는 HTTP에 TLS(또는 이전 버전 SSL)를 적용해 암호화된 통신을 가능하게 한다.'),
                                                                                                                           (1775, '다음 중 안전하지 않은 요청 메서드는?', 2, 'medium', 'GET', 'POST', 'HEAD', 'OPTIONS', 36, 'POST는 서버의 상태를 변경할 수 있어 안전하지 않은(non-idempotent) 메서드로 분류된다.'),
                                                                                                                           (1776, 'HTTP 상태 코드 404는 무엇을 의미하는가?', 3, 'medium', '성공', '리디렉션', '요청 오류', '서버 오류', 36, '404는 요청한 리소스를 서버에서 찾을 수 없음을 나타내는 클라이언트 측 오류 코드이다.'),
                                                                                                                           (1777, 'HTTPS는 어떤 포트 번호를 기본으로 사용하는가?', 3, 'high', '80', '21', '443', '8080', 36, 'HTTPS는 기본적으로 443번 포트를 사용하여 암호화된 HTTP 통신을 수행한다.'),
                                                                                                                           (1778, 'HTTP 상태 코드 중 200은 어떤 의미인가?', 1, 'high', '성공', '리디렉션', '클라이언트 오류', '서버 오류', 36, '200 OK는 요청이 성공적으로 처리되었음을 의미한다.'),
                                                                                                                           (1779, 'PUT과 POST의 주요 차이점은?', 2, 'high', 'POST는 덮어쓰기', 'PUT은 멱등성 있음', 'PUT은 삭제용', 'POST는 읽기 전용', 36, 'PUT은 동일한 요청을 여러 번 보내도 결과가 같아야 하는 멱등성을 갖는다.'),
                                                                                                                           (1780, 'HEAD 요청의 주요 목적은?', 3, 'high', '본문 확인', '파일 다운로드', '메타정보 확인', '쿠키 설정', 36, 'HEAD 메서드는 본문 없이 응답 헤더만 받아와 리소스의 메타정보를 확인할 수 있다.'),
                                                                                                                           (1781, 'DNS의 주요 역할은?', 3, 'low', 'IP를 MAC으로 변환', 'IP를 포트로 변환', '도메인을 IP로 변환', '포트를 도메인으로 변환', 36, 'DNS는 사람이 읽을 수 있는 도메인 이름을 컴퓨터가 이해할 수 있는 IP 주소로 변환해준다.'),
                                                                                                                           (1782, '도메인 이름의 최상위 도메인은?', 2, 'low', 'com', '.', 'www', 'root', 36, '도메인 이름의 최상위 도메인(TLD)은 .com, .org 등의 형식을 가지며, .은 root를 나타낸다.'),
                                                                                                                           (1783, '도메인 이름에서 ''google.com''의 ''google''은 어떤 부분인가?', 4, 'low', 'TLD', '루트 도메인', '서브도메인', '2차 도메인', 36, 'google은 com이라는 TLD 아래에 있는 2차 도메인이다.'),
                                                                                                                           (1784, 'DNS 쿼리 중 반복 쿼리 방식은?', 2, 'medium', 'recursive', 'iterative', 'direct', 'referral', 36, 'iterative 쿼리는 요청자가 각 DNS 서버를 차례로 직접 질의하는 방식이다.'),
                                                                                                                           (1785, '도메인 이름에서 ''www''는 어떤 역할인가?', 3, 'medium', 'TLD', '루트 도메인', '호스트명', '레코드명', 36, 'www는 특정 서비스를 제공하는 호스트명을 나타내며 일반적으로 웹 서버를 의미한다.'),
                                                                                                                           (1786, 'DNS의 A 레코드는 어떤 정보를 포함하는가?', 2, 'medium', '도메인 → 도메인', '도메인 → IP', 'IP → 도메인', '도메인 → 포트', 36, 'A 레코드는 도메인 이름을 IPv4 주소로 매핑하는 정보를 포함한다.'),
                                                                                                                           (1787, 'DNS 서버가 요청을 다른 서버로 넘기는 방식은?', 3, 'high', '리다이렉션', '프록시', '포워딩', 'DNS 레코드', 36, '포워딩은 DNS 서버가 직접 응답하지 않고 다른 DNS 서버에 요청을 전달하는 방식이다.'),
                                                                                                                           (1788, '역방향 DNS 조회에 사용되는 레코드는?', 1, 'high', 'PTR', 'CNAME', 'MX', 'A', 36, 'PTR 레코드는 IP 주소를 도메인 이름으로 매핑하는 역방향 조회에 사용된다.'),
                                                                                                                           (1789, 'CNAME 레코드의 역할은?', 1, 'high', '별칭 제공', '포트 지정', '이메일 서버 지정', '서브넷 마스크 지정', 36, 'CNAME 레코드는 하나의 도메인에 다른 도메인의 별칭을 지정할 때 사용된다.'),
                                                                                                                           (1790, '다음 중 DNS 캐싱을 담당하는 요소는?', 4, 'high', '네임 서버', '브라우저', 'ISP', '모두 해당', 36, '브라우저, 운영체제, ISP 등 다양한 계층에서 DNS 응답을 캐싱하여 속도를 향상시킨다.'),
                                                                                                                           (1791, 'HTTPS의 보안은 어떤 기술에 기반하는가?', 2, 'low', 'AES', 'TLS', 'IPSec', 'SSH', 36, 'HTTPS는 TLS를 기반으로 데이터를 암호화하고 인증 및 무결성을 보장한다.'),
                                                                                                                           (1792, '웹사이트가 본인의 것임을 증명하는 기술은?', 2, 'low', '방화벽', 'SSL 인증서', '쿠키', '도메인 등록', 36, 'SSL 인증서는 서버가 자신이 주장하는 도메인 소유자임을 인증하는 데 사용된다.'),
                                                                                                                           (1793, '세션 하이재킹 방지를 위한 기본 대책은?', 1, 'low', '세션 ID 암호화', 'IP 변경', '포트 변경', '페이지 리디렉션', 36, '세션 ID를 암호화하거나 복잡하게 만들어 탈취로 인한 위험을 줄일 수 있다.'),
                                                                                                                           (1794, '쿠키는 어떤 데이터 저장 방식인가?', 2, 'medium', '서버 측 저장', '클라이언트 측 저장', '네트워크 저장', '브라우저 캐시', 36, '쿠키는 클라이언트(브라우저)에 저장되어 상태 정보를 유지하는 데 사용된다.'),
                                                                                                                           (1795, 'JWT에서 서명된 토큰이 위조되지 않았음을 보장하는 부분은?', 3, 'medium', 'header', 'payload', 'signature', 'issuer', 36, 'JWT의 signature는 토큰이 발급자에 의해 서명되었음을 증명하며, 변조를 방지한다.'),
                                                                                                                           (1796, 'XSS 공격 방지 방법 중 하나는?', 1, 'medium', '입력 값 이스케이프', '방화벽 설치', 'IP 차단', '포트 스캐닝', 36, 'XSS 방지를 위해 사용자의 입력값을 HTML 이스케이프 처리해야 한다.'),
                                                                                                                           (1797, 'CSRF 공격을 방지하기 위한 기술은?', 2, 'high', 'OAuth', '토큰 검증', 'SSL 인증서', '암호화 키 공유', 36, 'CSRF 방지를 위해 요청 시 토큰을 검증하여 외부 요청을 구분한다.'),
                                                                                                                           (1798, '보안이 적용된 HTTP 통신의 기본 포트는?', 3, 'high', '80', '8080', '443', '21', 36, 'HTTPS는 보안이 적용된 HTTP이며, 기본적으로 443번 포트를 사용한다.'),
                                                                                                                           (1799, 'OAuth 2.0에서 토큰 발급을 담당하는 주체는?', 3, 'high', '리소스 소유자', '클라이언트', '인증 서버', '브라우저', 36, 'OAuth 2.0에서 인증 서버는 클라이언트를 인증하고 토큰을 발급하는 역할을 한다.'),
                                                                                                                           (1800, 'HTTPS는 기본적으로 어떤 계층에서 동작하는가?', 3, 'high', '응용 계층', '세션 계층', '전송 계층', '링크 계층', 36, 'HTTPS는 HTTP에 TLS를 추가한 것으로, 암호화 처리는 전송 계층에서 이루어진다.'),
                                                                                                                           (1801, 'Git은 어떤 형식의 시스템인가?', 2, 'low', '클라우드 스토리지', '버전 관리 시스템', '파일 서버', 'DBMS', 37, 'Git은 코드의 변경 이력을 관리하고 협업을 위한 버전 관리 시스템이다.'),
                                                                                                                           (1802, 'Git을 설치한 후 버전을 확인하는 명령어는?', 2, 'low', 'git check', 'git version', 'git install', 'git info', 37, 'git version 명령어는 현재 설치된 Git의 버전을 출력한다.'),
                                                                                                                           (1803, 'Git 저장소를 초기화하는 명령어는?', 3, 'low', 'git start', 'git new', 'git init', 'git create', 37, 'git init은 새로운 Git 저장소를 생성하고 초기화할 때 사용된다.'),
                                                                                                                           (1804, 'Git은 어떤 모델을 기반으로 동작하는가?', 2, 'medium', '파일 차이 추적 모델', '파일 전체 스냅샷 모델', 'SQL 데이터 모델', 'REST API 모델', 37, 'Git은 변경된 부분만 저장하지 않고 전체 파일의 스냅샷을 저장한다.'),
                                                                                                                           (1805, 'Git의 핵심 구조가 아닌 것은?', 3, 'medium', 'Commit', 'Branch', 'Pull Request', 'Repository', 37, 'Pull Request는 Git 기능이 아닌 GitHub 등의 플랫폼에서 제공하는 기능이다.'),
                                                                                                                           (1806, 'Git이 다른 버전 관리 시스템과 구별되는 가장 큰 특징은?', 2, 'medium', '클라우드 기반', '분산 버전 관리', '서버 의존성', 'GUI 필수', 37, 'Git은 중앙 서버 없이도 로컬에서 전체 히스토리를 관리할 수 있는 분산 버전 관리 시스템이다.'),
                                                                                                                           (1807, 'Git 저장소 내 숨겨진 디렉토리는?', 2, 'high', '.gitconfig', '.git', '.repository', '.version', 37, '.git 디렉토리는 Git이 저장소로 인식하는 핵심 메타데이터를 포함한 디렉토리이다.'),
                                                                                                                           (1808, 'Git 기본 사용자 이름 설정 명령어는?', 2, 'high', 'git user set', 'git config user.name', 'git set username', 'git setup name', 37, 'git config user.name은 커밋 시 사용할 이름을 설정하는 명령어이다.'),
                                                                                                                           (1809, 'Git 저장소에서 ''working directory''란 무엇인가?', 2, 'high', '원격 저장소 경로', '현재 작업 중인 로컬 폴더', '서버 경로', '커밋된 파일 저장소', 37, 'working directory는 사용자가 실제 파일을 수정하고 작업하는 공간이다.'),
                                                                                                                           (1810, 'Git 저장소에서 ''staging area''란?', 3, 'high', '커밋된 파일 공간', '수정 대기 중 공간', '커밋 준비 중인 공간', '삭제 대기 공간', 37, 'staging area는 커밋하기 전에 어떤 파일을 포함할지 결정하는 중간 영역이다.'),
                                                                                                                           (1811, 'Git에서 변경 사항을 스테이징 영역에 추가하는 명령어는?', 2, 'low', 'git commit', 'git add', 'git push', 'git status', 37, 'git add 명령어는 수정한 파일을 staging area에 추가하는 데 사용된다.'),
                                                                                                                           (1812, '스테이징 영역에 추가된 파일을 저장소에 기록하는 명령어는?', 3, 'low', 'git save', 'git push', 'git commit', 'git merge', 37, 'git commit은 staging area의 변경 사항을 저장소에 기록한다.'),
                                                                                                                           (1813, '현재 작업 디렉토리의 변경 상태를 확인하는 명령어는?', 1, 'low', 'git status', 'git show', 'git commit', 'git log', 37, 'git status 명령어는 현재 변경된 파일과 staging 여부 등을 보여준다.'),
                                                                                                                           (1814, '마지막 커밋 메시지를 수정하는 명령어는?', 2, 'medium', 'git amend', 'git commit --amend', 'git edit', 'git rebase', 37, 'git commit --amend는 가장 최근 커밋의 메시지나 내용을 수정할 수 있다.'),
                                                                                                                           (1815, '수정한 파일을 이전 상태로 되돌리는 명령어는?', 3, 'medium', 'git undo', 'git reset file', 'git restore file', 'git rollback', 37, 'git restore file 명령어는 변경된 파일을 마지막 커밋 상태로 되돌린다.'),
                                                                                                                           (1816, 'git log 명령어는 무엇을 보여주는가?', 2, 'medium', '브랜치 목록', '커밋 기록', '변경된 파일 목록', '서버 상태', 37, 'git log는 저장소의 커밋 이력을 시간 순으로 보여준다.'),
                                                                                                                           (1817, '스테이징 영역에서 파일을 제거하는 명령어는?', 3, 'high', 'git remove', 'git unstage', 'git reset HEAD <file>', 'git restore', 37, 'git reset HEAD <file> 명령어는 파일을 staging area에서 제거한다.'),
                                                                                                                           (1818, '로컬 저장소에 새 파일을 생성하고 Git이 추적하도록 하려면 필요한 명령어는?', 2, 'high', 'git create', 'git add', 'git push', 'git commit', 37, 'git add는 Git이 새로 생성된 파일을 추적할 수 있도록 staging area에 추가한다.'),
                                                                                                                           (1819, '파일이 staging 되었는지 아닌지 구분하는 명령어는?', 1, 'high', 'git diff', 'git compare', 'git check', 'git log', 37, 'git diff는 staging 전과 후의 변경 사항을 비교하여 상태를 확인할 수 있다.'),
                                                                                                                           (1820, '작업 트리와 스테이징 영역의 차이를 보는 명령어는?', 2, 'high', 'git status', 'git diff', 'git branch', 'git show', 37, 'git diff는 작업 디렉토리와 staging area 간의 차이를 보여준다.'),
                                                                                                                           (1821, 'Git에서 브랜치를 생성하는 명령어는?', 1, 'low', 'git branch <branch-name>', 'git create branch', 'git new branch', 'git make branch', 37, 'git branch <branch-name>은 새로운 브랜치를 생성하는 명령어이다.'),
                                                                                                                           (1822, '현재 브랜치를 확인하는 명령어는?', 2, 'low', 'git show-branch', 'git branch', 'git current', 'git check', 37, 'git branch 명령어는 현재 브랜치와 전체 브랜치 목록을 출력한다.'),
                                                                                                                           (1823, '다른 브랜치로 이동하는 명령어는?', 1, 'low', 'git switch', 'git change branch', 'git move branch', 'git jump', 37, 'git switch는 다른 브랜치로 전환할 때 사용하는 명령어이다.'),
                                                                                                                           (1824, '브랜치를 삭제하는 명령어는?', 3, 'medium', 'git remove branch', 'git delete branch', 'git branch -d <branch-name>', 'git clear branch', 37, 'git branch -d는 병합된 브랜치를 안전하게 삭제할 수 있는 명령어이다.'),
                                                                                                                           (1825, '브랜치를 병합할 때 사용하는 명령어는?', 1, 'medium', 'git merge', 'git attach', 'git connect', 'git combine', 37, 'git merge 명령어는 현재 브랜치에 다른 브랜치의 변경 사항을 병합한다.'),
                                                                                                                           (1826, '병합 충돌이 발생했을 때 가장 먼저 해야 할 일은?', 2, 'medium', 'push 하기', '충돌 해결', 'commit 하기', 'reset 하기', 37, '충돌이 발생하면 먼저 충돌된 파일을 수정하고 해결한 뒤 커밋해야 한다.'),
                                                                                                                           (1827, 'Fast-forward 병합이 가능한 상황은?', 1, 'high', '브랜치가 동일 선상일 때', '병렬 작업이 많을 때', '리베이스 후일 때', '충돌 발생 시', 37, 'Fast-forward 병합은 브랜치 간 이력이 직선으로 연결되어 있을 때 가능하다.'),
                                                                                                                           (1828, 'Git에서 리베이스(rebase)의 주요 목적은?', 2, 'high', '브랜치 삭제', '커밋 기록을 정리', '브랜치 연결 끊기', '브랜치 복제', 37, 'rebase는 커밋 히스토리를 깔끔하게 재구성하기 위해 사용된다.'),
                                                                                                                           (1829, 'rebase 중 충돌이 발생했을 때 해결 방법은?', 3, 'high', 'git abort', 'git reset', '충돌 해결 후 git rebase --continue', 'git merge', 37, '충돌을 해결한 후 git rebase --continue 명령어로 리베이스를 이어갈 수 있다.'),
                                                                                                                           (1830, 'Git 병합 전략 중, 커밋 히스토리를 깔끔하게 유지하는 방법은?', 3, 'high', 'merge', 'fast-forward', 'rebase', 'squash', 37, 'rebase는 히스토리를 선형으로 만들어 커밋 내역을 깔끔하게 유지할 수 있다.'),
                                                                                                                           (1831, 'GitHub에서 원격 저장소를 복제하는 명령어는?', 2, 'low', 'git pull', 'git clone', 'git fetch', 'git copy', 37, 'git clone 명령어는 원격 저장소를 복제하여 로컬 저장소를 생성한다.'),
                                                                                                                           (1832, '로컬 저장소를 원격 저장소에 연결하는 명령어는?', 3, 'low', 'git connect', 'git link', 'git remote add', 'git sync', 37, 'git remote add 명령어는 로컬 저장소와 원격 저장소를 연결할 때 사용된다.'),
                                                                                                                           (1833, '원격 저장소의 정보를 확인하는 명령어는?', 2, 'low', 'git info remote', 'git remote -v', 'git remote info', 'git check remote', 37, 'git remote -v 명령어는 연결된 원격 저장소의 URL 정보를 확인할 수 있다.'),
                                                                                                                           (1834, 'GitHub에 변경 사항을 업로드하는 명령어는?', 1, 'medium', 'git push', 'git upload', 'git send', 'git deploy', 37, 'git push는 로컬 저장소의 변경 사항을 원격 저장소로 전송하는 명령어이다.'),
                                                                                                                           (1835, '원격 저장소의 최신 변경 사항을 가져오는 명령어는?', 3, 'medium', 'git update', 'git fetch', 'git pull', 'git clone', 37, 'git pull은 원격 저장소의 변경 사항을 가져오고 자동으로 병합한다.'),
                                                                                                                           (1836, 'git fetch 후 로컬 브랜치에 적용하려면 어떤 명령어를 사용해야 하는가?', 3, 'medium', 'git rebase', 'git checkout', 'git merge', 'git switch', 37, 'git fetch는 변경 사항을 가져오기만 하므로 적용하려면 git merge를 사용해야 한다.'),
                                                                                                                           (1837, '원격 저장소를 삭제하는 명령어는?', 3, 'high', 'git remove remote', 'git remote delete', 'git remote rm', 'git delete origin', 37, 'git remote rm은 로컬에서 등록된 원격 저장소를 제거할 때 사용한다.'),
                                                                                                                           (1838, 'git push origin main 명령어의 의미는?', 2, 'high', 'main 브랜치를 로컬에 복제', 'main 브랜치를 원격 저장소에 업로드', 'main 브랜치를 삭제', 'main 브랜치 이름 변경', 37, '해당 명령어는 로컬의 main 브랜치를 원격 저장소(origin)에 업로드한다.'),
                                                                                                                           (1839, 'GitHub에서 포크(fork) 기능은 어떤 역할을 하는가?', 2, 'high', '프로젝트를 클론하는 것', '자신의 계정으로 프로젝트를 복사', '서버를 복제', '브랜치를 새로 만드는 것', 37, 'Fork는 다른 사용자의 저장소를 자신의 계정으로 복사하여 독립적으로 개발할 수 있게 해준다.'),
                                                                                                                           (1840, 'GitHub에서 저장소를 복제(clone)한 후 바로 개발할 수 있는 브랜치는?', 1, 'high', 'master/main', 'feature', 'develop', 'hotfix', 37, 'master 또는 main 브랜치는 기본 브랜치로, clone 후 기본 개발이 가능한 브랜치이다.'),
                                                                                                                           (1841, 'GitHub에서 협업 시 일반적으로 사용하는 요청 방식은?', 2, 'low', 'Push Request', 'Pull Request', 'Merge Request', 'Commit Request', 37, 'Pull Request는 자신의 변경 사항을 다른 사람의 저장소에 병합 요청하는 방식이다.'),
                                                                                                                           (1842, 'Pull Request를 생성할 때 필수적으로 지정해야 하는 것은?', 2, 'low', '리포지토리 이름', '베이스 브랜치와 비교 브랜치', '커밋 ID', '패치 URL', 37, 'Pull Request는 어떤 브랜치에 어떤 브랜치를 병합할 것인지 지정해야 한다.'),
                                                                                                                           (1843, 'GitHub 이슈(Issue)의 주요 목적은?', 2, 'low', '코드 수정', '버그 관리 및 기능 요청', '커밋 관리', '프로젝트 복제', 37, '이슈는 버그, 기능 개선 요청 등 협업 중 발생하는 작업 사항을 추적 관리하는 용도로 사용된다.'),
                                                                                                                           (1844, 'Pull Request에 리뷰어를 지정하는 목적은?', 2, 'medium', '자동 병합', '코드 검토 요청', '버그 수정', '브랜치 삭제', 37, '리뷰어는 변경 내용을 확인하고 코드 품질을 검토하기 위해 지정된다.'),
                                                                                                                           (1845, 'GitHub Actions는 무엇을 자동화하는 기능인가?', 2, 'medium', '이슈 생성', 'CI/CD 파이프라인', '브랜치 복제', '저장소 삭제', 37, 'GitHub Actions는 테스트, 빌드, 배포 등 개발 워크플로우를 자동화하는 기능이다.'),
                                                                                                                           (1846, 'Fork 후 Pull Request를 보내려면 먼저 해야 할 일은?', 2, 'medium', 'origin으로 직접 push', '포크한 저장소에 push', 'GitHub에서 Fork 취소', '새 브랜치 만들기', 37, '포크한 저장소에 변경 사항을 push한 후 원본 저장소로 Pull Request를 보낼 수 있다.'),
                                                                                                                           (1847, 'GitHub에서 커밋을 다른 사람과 연동할 때 필요한 것은?', 3, 'high', 'Email 등록', 'SSH 키 설정', 'GPG 서명 설정', 'Fork 설정', 37, 'GPG 서명은 커밋 작성자가 실제 본인임을 보장할 수 있게 한다.'),
                                                                                                                           (1848, 'GitHub 저장소를 비공개로 변경하려면 필요한 권한은?', 2, 'high', 'Contributor', 'Owner', 'Collaborator', 'Reviewer', 37, '비공개 설정은 저장소의 소유자(Owner)만이 변경할 수 있다.'),
                                                                                                                           (1849, 'GitHub 이슈 템플릿을 설정하는 파일 위치는?', 1, 'high', '.github/ISSUE_TEMPLATE/', 'docs/ISSUE/', 'src/issue_template/', 'config/issues/', 37, '이슈 템플릿은 .github/ISSUE_TEMPLATE/ 디렉토리에 위치시켜야 인식된다.'),
                                                                                                                           (1850, 'GitHub에서 squash merge를 선택하는 주요 이유는?', 1, 'high', '히스토리를 깔끔하게 유지하기 위해', '모든 브랜치를 삭제하기 위해', '병합 충돌을 강제 발생시키기 위해', '코드를 롤백하기 위해', 37, 'Squash merge는 여러 커밋을 하나로 합쳐 히스토리를 간결하게 만든다.'),
                                                                                                                           (1851, 'Git Hook은 언제 실행되는 스크립트인가?', 1, 'low', '커밋, 푸시 등의 이벤트 시점', 'Git 설치 시점', '브랜치 삭제 시점', '저장소 복제 시점', 38, 'Git Hook은 특정 Git 이벤트 발생 시 자동으로 실행되는 사용자 정의 스크립트이다.'),
                                                                                                                           (1852, 'Git Hook 스크립트는 기본적으로 어떤 언어로 작성되는가?', 2, 'low', 'Python', 'Shell Script', 'JavaScript', 'Ruby', 38, 'Git Hook은 기본적으로 쉘 스크립트(Shell Script)로 작성된다.'),
                                                                                                                           (1853, 'Git 기본 Hook 파일들이 위치하는 디렉토리는?', 1, 'low', '.git/hooks', '.hooks', 'hooks/', 'src/hooks', 38, '.git/hooks 디렉토리는 Git이 hook 스크립트를 자동으로 찾는 기본 위치이다.'),
                                                                                                                           (1854, '커밋 전에 코드 검사를 자동으로 실행하기 위해 사용하는 Hook은?', 2, 'medium', 'post-commit', 'pre-commit', 'pre-push', 'commit-msg', 38, 'pre-commit은 커밋 전에 실행되며 코드 스타일 검사나 테스트 실행에 주로 사용된다.'),
                                                                                                                           (1855, '커밋 메시지를 검증하는 데 사용되는 Git Hook은?', 3, 'medium', 'pre-push', 'pre-commit', 'commit-msg', 'post-merge', 38, 'commit-msg는 커밋 메시지가 형식에 맞는지 검사하는 데 사용되는 Hook이다.'),
                                                                                                                           (1856, 'Git Hook은 기본적으로 어떤 파일 형태로 제공되는가?', 2, 'medium', '활성화된 스크립트 파일', '비활성화된 샘플 파일', 'JSON 설정 파일', 'Markdown 문서', 38, 'Git 설치 시 Hook 스크립트는 샘플 형태로 비활성화된 상태로 제공된다.'),
                                                                                                                           (1857, 'Git Hook을 전역(global)으로 설정할 수 있는 방법은?', 2, 'high', 'global-hooks 디렉토리 지정', 'git config --global core.hooksPath', 'git global hook', 'hooksPath 설정파일 추가', 38, 'Git은 core.hooksPath 옵션을 통해 전역 hook 디렉토리를 설정할 수 있다.'),
                                                                                                                           (1858, 'Git Hook 중 push가 되기 전에 마지막으로 실행되는 Hook은?', 2, 'high', 'post-commit', 'pre-push', 'commit-msg', 'post-merge', 38, 'pre-push는 원격 저장소로 데이터를 전송하기 전에 실행되는 마지막 Hook이다.'),
                                                                                                                           (1859, 'Git Hook을 이용해 push를 차단할 수 있는 방법은?', 3, 'high', 'pre-commit 실패', 'commit-msg 실패', 'pre-push 실패', 'merge-fail', 38, 'pre-push 스크립트가 실패하면 해당 push는 차단된다.'),
                                                                                                                           (1860, 'Git Hook을 통해 코드 품질 관리를 하는 이유는?', 2, 'high', '개발 속도 향상', '코드 일관성 유지', '브랜치 보호', '리포지토리 용량 감소', 38, 'Hook을 통해 자동화된 검사로 코드 스타일 및 품질 일관성을 유지할 수 있다.'),
                                                                                                                           (1861, 'Husky의 주요 목적은 무엇인가?', 1, 'low', 'Git Hook 관리 자동화', 'Git 리포지토리 복제', '브랜치 자동 생성', '코드 리뷰 자동화', 38, 'Husky는 Git Hook을 보다 쉽게 관리하고 자동화하기 위한 도구로, 커밋 전 코드 검사나 테스트 실행 등의 자동화를 지원한다.'),
                                                                                                                           (1862, 'Husky를 설치하는 기본 명령어는?', 1, 'low', 'npm install husky', 'npm add git-hooks', 'npm install hooker', 'npm husky-setup', 38, 'Husky는 일반적인 NPM 패키지로 제공되므로, 설치는 "npm install husky" 명령어로 수행된다.'),
                                                                                                                           (1863, 'Husky를 활성화하기 위해 필요한 명령어는?', 1, 'low', 'npx husky install', 'npx husky start', 'npx git-hook', 'npm init husky', 38, '설치 후 활성화를 위해 "npx husky install" 명령어로 Git Hook 디렉토리를 초기화해야 한다.'),
                                                                                                                           (1864, 'Husky 설치 후 설정을 추가하는 파일은?', 2, 'low', '.huskyrc', '.husky/', '.git/hooks', '.huskyconfig', 38, 'Husky는 .husky/ 디렉토리를 생성하여 각 Git Hook 파일을 배치하므로, 설정은 해당 디렉토리에 추가된다.'),
                                                                                                                           (1865, 'Husky를 통해 pre-commit Hook을 추가할 때 사용하는 명령어는?', 1, 'medium', 'npx husky add .husky/pre-commit \'npm test\'', 'husky create pre-commit', 'git add pre-commit', 'npm run hook-add', 38, '"npx husky add" 명령어를 사용하여 특정 hook 파일에 실행 명령을 추가할 수 있다.'),
                                                                                                                           (1866, 'Husky 설치 시 .gitignore에 추가되지 않는 디렉토리는?', 1, 'medium', '.husky', 'node_modules', 'hooks', 'build', 38, '.husky 디렉토리는 Git Hook 기능이 동작하기 위해 Git의 추적이 필요하므로 .gitignore에 포함되지 않는다.'),
                                                                                                                           (1867, 'Husky를 package.json scripts에 등록하는 이유는?', 2, 'medium', '테스트 실행', '자동 설치 보장', '버전 업데이트', 'gitignore 무시', 38, 'scripts에 등록하면 프로젝트 clone 후 npm install 시 자동으로 husky install이 실행되어 Git Hook이 활성화된다.'),
                                                                                                                           (1868, 'Husky를 설치 후 Git Hook이 정상 동작하지 않는 경우 우선 확인할 사항은?', 1, 'high', '.git/hooks 디렉토리 존재 여부', 'npm 버전', 'Prettier 설치 여부', '프로젝트 크기', 38, 'Git Hook은 .git/hooks 디렉토리에 존재해야 실행되므로 해당 디렉토리가 존재하는지 먼저 확인해야 한다.'),
                                                                                                                           (1869, 'Husky를 제거할 때 사용해야 하는 명령어는?', 1, 'high', 'npm uninstall husky', 'npm remove git-hook', 'npm husky-remove', 'npx husky delete', 38, 'Husky는 npm 패키지로 설치되므로 제거 시 "npm uninstall husky"를 사용한다.'),
                                                                                                                           (1870, 'Husky 설치 시 Git Hook을 적용하기 위해 반드시 필요한 것은?', 2, 'high', 'package-lock.json', 'git 초기화 (.git 존재)', 'node_modules 재설치', '브랜치 생성', 38, 'Husky는 Git Hook 시스템을 활용하므로 Git이 초기화되어 있어야 (.git 폴더) 동작할 수 있다.'),
                                                                                                                           (1871, 'Husky로 pre-commit Hook을 추가하려면 필요한 명령어는?', 2, 'low', 'husky create pre-commit', 'npx husky add .husky/pre-commit', 'git init hook', 'npm install hooker', 38, '"npx husky add .husky/pre-commit"을 통해 pre-commit Hook 파일을 생성하고 명령어를 지정할 수 있다.'),
                                                                                                                           (1872, 'Husky를 사용하여 pre-push Hook을 설정할 때 경로는?', 1, 'low', '.husky/pre-push', '.git/pre-push', 'hooks/pre-push', '.husky/hooks/pre-push', 38, 'Husky는 Git Hook 스크립트를 .husky/ 디렉토리에 위치시키므로 pre-push는 ".husky/pre-push"에 작성한다.'),
                                                                                                                           (1873, 'Husky Hook 파일에서 실행할 명령어를 작성하는 파일은?', 2, 'low', 'package.json', 'Hook script 파일', '.huskyrc', 'hooks-config.js', 38, '각 Hook 파일 자체가 실행 파일이므로, 그 안에 bash 스크립트로 원하는 명령어를 직접 작성한다.'),
                                                                                                                           (1874, 'Husky로 생성된 Hook 스크립트의 첫 번째 줄은 무엇이어야 하는가?', 2, 'medium', '#!/usr/bin/env husky', '#!/bin/bash', '#!node', '#!/usr/bin/env node', 38, 'Shell 스크립트로 실행되므로 "#!/bin/bash"로 시작해야 커밋 시 명령어가 정상 실행된다.'),
                                                                                                                           (1875, 'Husky의 pre-commit Hook에서 실패할 경우 결과는?', 2, 'medium', '커밋이 진행된다', '커밋이 차단된다', '푸시가 진행된다', '브랜치가 변경된다', 38, 'pre-commit Hook이 실패하면 커밋이 차단되어 코드 검사를 통과하지 않은 커밋이 방지된다.'),
                                                                                                                           (1876, 'Husky pre-push Hook에서 실패하면 어떤 일이 발생하는가?', 2, 'medium', 'push가 정상적으로 완료된다', 'push가 차단된다', 'pull이 시작된다', 'merge conflict 발생', 38, 'pre-push Hook은 push 전에 실행되며 실패 시 push가 중단된다.'),
                                                                                                                           (1877, 'Husky로 여러 명령어를 pre-commit에 실행할 때 사용하는 방법은?', 2, 'high', '쉼표로 구분', '&& 연산자 사용', '파이프(|) 사용', 'AND 명령어 사용', 38, '여러 명령어를 순차 실행하려면 쉘의 "&&" 연산자를 사용한다.'),
                                                                                                                           (1878, 'Husky 설정 후 git commit 시 pre-commit이 동작하지 않는 경우 우선 확인할 것은?', 2, 'high', 'node_modules 삭제 여부', '.husky 디렉토리 여부', 'npm 버전', 'yarn.lock 존재 여부', 38, '.husky 디렉토리가 없으면 Hook이 실행되지 않으므로 가장 먼저 확인해야 한다.'),
                                                                                                                           (1879, 'Husky hook 파일에 명령어를 추가하는 기본 방법은?', 2, 'high', 'scripts 항목 수정', '직접 shell script 수정', 'npm script 작성', 'git config 수정', 38, '각 hook 파일은 실제 쉘 스크립트이므로 해당 파일 내에 명령어를 직접 작성해야 한다.'),
                                                                                                                           (1880, 'Husky를 통해 pre-commit에서 lint 검사를 실행할 때 가장 일반적인 방법은?', 2, 'high', 'npm test', 'npm run lint', 'npm run build', 'npm install lint', 38, '"npm run lint"는 일반적으로 lint 검사를 수행하는 표준 명령어로 Hook에 자주 사용된다.'),
                                                                                                                           (1881, 'lint-staged의 주요 목적은 무엇인가?', 2, 'low', '전체 코드 linting', '스테이징된 파일만 linting', '빌드 최적화', '버전 관리', 38, 'lint-staged는 Git stage에 있는 파일만 lint 작업을 수행해 효율적으로 검사한다.'),
                                                                                                                           (1882, 'lint-staged를 설치하는 명령어는?', 1, 'low', 'npm install lint-staged', 'npm install lint-stage', 'npm add staged-lint', 'npm install pre-lint', 38, '"npm install lint-staged"가 공식 설치 명령어다.'),
                                                                                                                           (1883, 'lint-staged 설정을 추가할 수 있는 파일은?', 2, 'low', '.lintstagedrc', 'package.json', '.lintstage', '.stagedlint', 38, '.lintstagedrc와 package.json은 lint-staged 설정을 정의할 수 있는 공식 위치다.'),
                                                                                                                           (1884, 'lint-staged를 사용할 때 파일 패턴을 설정하는 이유는?', 2, 'medium', '전체 파일 적용', '변경된 파일만 지정 작업 적용', 'Git 히스토리 추적', '버전 롤백', 38, 'Git에 stage된 변경 파일에만 linting을 적용하기 위해 패턴 지정이 필요하다.'),
                                                                                                                           (1885, 'lint-staged 설정에서 JavaScript 파일에 ESLint를 적용하려면 어떻게 작성하는가?', 1, 'medium', '"*.js": "eslint"', '"*.js": "prettier"', '"*.js": "node"', '"*.js": "test"', 38, '"eslint"는 JS 파일에 린트 적용 시 사용되며, lint-staged 설정은 JSON 형식으로 작성된다.'),
                                                                                                                           (1886, 'lint-staged가 적용되는 파일 범위는?', 2, 'medium', 'Git에 커밋된 모든 파일', '스테이지된 파일', '로컬 디렉토리 전체', '리포지토리 전체', 38, 'lint-staged는 Git Stage 영역의 파일만 대상으로 하여 빠르고 효율적이다.'),
                                                                                                                           (1887, 'lint-staged에서 여러 명령어를 실행하려면 어떻게 설정하는가?', 2, 'high', '쉼표로 구분', '배열로 설정', '공백으로 구분', '세미콜론으로 구분', 38, '여러 명령어를 실행하려면 배열 형태로 설정해 각각 순차적으로 실행되도록 한다.'),
                                                                                                                           (1888, 'lint-staged를 통해 commit 전에 파일 포맷팅을 적용하려면 사용하는 명령어는?', 1, 'high', 'prettier --write', 'eslint --fix', 'lint --stage', 'node --format', 38, 'Prettier를 사용하여 파일을 자동 포맷팅할 때는 "prettier --write"를 사용한다.'),
                                                                                                                           (1889, 'lint-staged 설정을 .lintstagedrc로 분리하는 이유는?', 1, 'high', '설정 관리 편의성', 'CI/CD 통합', '성능 향상', 'Git Hook 자동화', 38, '설정을 별도로 관리함으로써 프로젝트의 구성 요소를 명확히 분리하고 유지보수를 용이하게 할 수 있다.'),
                                                                                                                           (1890, 'lint-staged를 사용할 때 실패한 파일이 있을 경우 커밋은 어떻게 되는가?', 2, 'high', '커밋 진행', '커밋 차단', '푸시 차단', '브랜치 변경', 38, 'lint-staged에서 실패한 파일이 있으면 커밋이 차단되어 코드 품질을 유지할 수 있다.'),
                                                                                                                           (1891, 'Husky와 lint-staged를 함께 사용하는 주된 이유는?', 2, 'low', '전체 파일에 lint 적용', '스테이징된 파일에만 lint 및 포맷 적용', '브랜치 보호', '리포지토리 삭제', 38, 'lint-staged는 스테이징된 파일에만 적용되며, Husky는 이를 pre-commit Hook에서 실행해 커밋 전에 코드 품질을 자동 검증하게 한다.'),
                                                                                                                           (1892, 'lint-staged를 실행하는 위치로 가장 적합한 Git Hook은?', 3, 'low', 'post-merge', 'pre-push', 'pre-commit', 'post-commit', 38, 'lint-staged는 커밋 직전에 실행되어야 하므로 pre-commit Hook이 가장 적합하다.'),
                                                                                                                           (1893, 'Husky로 lint-staged를 pre-commit에 연결하는 방법은?', 2, 'low', 'npm script 등록', 'npx husky add .husky/pre-commit \'npx lint-staged\'', 'git push 설정', 'prettier 설정', 38, '해당 명령은 pre-commit Hook에 lint-staged를 연결해 커밋 시 자동으로 실행되도록 설정한다.'),
                                                                                                                           (1894, 'lint-staged 실행 실패 시 커밋은 어떻게 되는가?', 2, 'medium', '커밋 진행', '커밋 차단', '브랜치 변경', 'push 진행', 38, 'lint-staged가 실패하면 pre-commit Hook에서 커밋이 중단되어 문제 있는 코드가 저장소에 반영되지 않도록 한다.'),
                                                                                                                           (1895, 'lint-staged 설정 파일에 여러 명령어를 적용할 때 사용하는 자료형은?', 2, 'medium', 'Object', 'Array', 'String', 'Number', 38, '하나의 파일 패턴에 여러 명령어를 적용할 때 배열(Array)을 사용해 순차적으로 실행한다.'),
                                                                                                                           (1896, 'Husky 설정 없이 lint-staged만 설치했을 경우 발생하는 문제는?', 1, 'medium', 'Hook이 작동하지 않음', '빌드 실패', '버전 충돌', '리포지토리 삭제', 38, 'lint-staged는 Git Hook에서 실행되어야 하므로 Husky 같은 Hook 실행 도구가 없으면 동작하지 않는다.'),
                                                                                                                           (1897, 'lint-staged의 실행 명령어를 npx를 통해 바로 실행하려면 필요한 것은?', 2, 'high', 'package.json scripts', 'npx lint-staged', 'git lint', 'npm run lint-stage', 38, '"npx lint-staged" 명령어로 직접 lint-staged를 실행할 수 있다.'),
                                                                                                                           (1898, 'Husky의 pre-commit Hook 스크립트에서 lint-staged를 호출할 때 기본 사용 방법은?', 2, 'high', 'npm run lint', 'npx lint-staged', 'eslint staged', 'prettier staged', 38, '"npx lint-staged"를 pre-commit Hook에 추가하면 스테이징된 파일만 lint 처리를 하도록 설정된다.'),
                                                                                                                           (1899, 'lint-staged가 처리하는 파일은 기본적으로 어떤 상태인가?', 2, 'high', 'untracked', 'staged', 'committed', 'ignored', 38, 'lint-staged는 Git stage에 있는 파일만 대상으로 하여 작업한다.'),
                                                                                                                           (1900, 'Husky + lint-staged 통합 설정이 잘 작동하면 어떤 이점이 있는가?', 2, 'high', '커밋 속도 향상', '코드 품질 유지와 일관성 확보', '브랜치 삭제 자동화', '파일 무결성 검사', 38, '커밋 전에 코드 검사와 포맷팅이 자동화되어 코드 품질을 유지하고 팀의 스타일 가이드를 강제할 수 있다.'),
                                                                                                                           (1901, 'Java에서 정수형 기본 타입으로 올바른 것은?', 1, 'low', 'int', 'Integer', 'float', 'char', 39, 'Java에서 정수형 기본 타입은 int이며, Integer는 해당 기본형의 래퍼 클래스이다.'),
                                                                                                                           (1902, 'Java에서 문자를 저장하는 자료형은?', 1, 'low', 'char', 'String', 'int', 'boolean', 39, 'char는 유니코드 문자 하나를 저장하는 Java의 기본 자료형이다.'),
                                                                                                                           (1903, 'Java 프로그램의 시작점이 되는 메서드는?', 1, 'low', 'main', 'start', 'run', 'launch', 39, 'Java 프로그램은 main 메서드에서 시작되며, public static void main(String[] args) 형태로 정의된다.'),
                                                                                                                           (1904, '다음 중 Java에서 기본형 타입이 아닌 것은?', 3, 'medium', 'boolean', 'double', 'String', 'char', 39, 'String은 참조형이며, 나머지는 Java의 기본형 타입이다.'),
                                                                                                                           (1905, '기본형 타입과 매핑되는 래퍼 클래스가 틀린 것은?', 4, 'medium', 'int - Integer', 'boolean - Boolean', 'double - Double', 'char - Characterized', 39, 'char의 래퍼 클래스는 Character이며, Characterized는 잘못된 클래스명이다.'),
                                                                                                                           (1906, 'Java에서 long 타입 리터럴을 올바르게 표기한 것은?', 3, 'medium', '1000', '1000l', '1000L', '1000.0', 39, '정수형 리터럴을 long 타입으로 명시하려면 대문자 L을 사용하는 것이 일반적이다.'),
                                                                                                                           (1907, '다음 중 char 타입 리터럴로 유효하지 않은 것은?', 4, 'high', '\'A\'', '\'\u0041\'', '\'\n\'', '"A"', 39, 'char 리터럴은 작은 따옴표를 사용하며, "A"는 문자열(String)로 간주되어 char로는 유효하지 않다.'),
                                                                                                                           (1908, 'byte와 관련된 설명으로 틀린 것은?', 4, 'high', '-128 ~ 127 범위', '8비트 크기', '기본값은 0', '음수를 저장할 수 없다', 39, 'byte는 음수 포함 가능하므로 "음수를 저장할 수 없다"는 설명은 잘못되었다.'),
                                                                                                                           (1909, '다음 중 자동 형변환이 발생하는 경우는?', 2, 'high', 'int → byte', 'char → int', 'double → float', 'long → int', 39, 'char는 int보다 크기가 작아 자동 형변환이 가능하며, 반대 방향은 명시적 캐스팅이 필요하다.'),
                                                                                                                           (1910, 'Java에서 변수를 선언할 수 없는 예는?', 2, 'high', 'int _val;', 'float %rate;', 'double value1;', 'char letter;', 39, '% 기호는 변수명으로 사용할 수 없어 두 번째 예는 컴파일 오류를 발생시킨다.'),
                                                                                                                           (1911, 'Java에서 while문과 do-while문의 차이로 옳은 것은?', 3, 'low', '둘 다 조건이 앞에 온다', 'while은 한 번은 반드시 실행된다', 'do-while은 조건이 뒤에 온다', 'do-while은 조건 없이 반복된다', 39, 'do-while은 조건을 나중에 검사하기 때문에 최소 한 번은 실행되며 조건이 뒤에 위치한다.'),
                                                                                                                           (1912, 'for문에서 조건이 false일 경우 어떻게 되는가?', 3, 'low', '무한 루프에 빠진다', '한 번은 실행된다', '아예 실행되지 않는다', '예외가 발생한다', 39, 'for문의 조건이 처음부터 false이면 루프 본문은 한 번도 실행되지 않는다.'),
                                                                                                                           (1913, '다음 중 break문의 올바른 사용 목적은?', 1, 'low', '루프를 중단한다', '조건문을 생략한다', '예외 처리를 한다', '다음 루프로 건너뛴다', 39, 'break문은 루프 또는 switch문을 즉시 종료할 때 사용된다.'),
                                                                                                                           (1914, 'continue 문을 사용하면 어떻게 되는가?', 2, 'medium', '루프를 종료한다', '해당 루프의 나머지를 건너뛴다', '조건문을 무시한다', '에러가 발생한다', 39, 'continue는 루프 내에서 다음 반복으로 건너뛰도록 하며, 이후 조건 평가로 이동한다.'),
                                                                                                                           (1915, '다음 중 조건문으로만 사용되는 것은?', 3, 'medium', 'for', 'while', 'if', 'switch', 39, 'if문은 조건 판단을 위한 문장으로 루프 기능은 없으며, 조건문으로만 사용된다.'),
                                                                                                                           (1916, 'switch문에서 case 다음에 올 수 없는 타입은?', 3, 'medium', 'int', 'char', 'boolean', 'String', 39, 'switch문의 case는 boolean 값을 허용하지 않으며, boolean은 조건문 if에서만 사용 가능하다.'),
                                                                                                                           (1917, '중첩 for문을 사용할 때 고려해야 할 사항은?', 3, 'high', '무조건 속도가 빨라진다', '루프가 독립적으로 실행된다', '전체 반복 횟수 증가', '조건문을 생략할 수 있다', 39, '중첩 루프는 외부 루프와 곱해져 전체 반복 횟수가 증가하므로 성능에 주의해야 한다.'),
                                                                                                                           (1918, 'Java의 향상된 for문은 어떤 컬렉션에 사용 가능한가?', 4, 'high', '배열', 'List', 'Set', '모두 가능', 39, '향상된 for문은 Iterable을 구현한 모든 객체와 배열에 사용 가능하므로 모두 해당된다.'),
                                                                                                                           (1919, '다음 중 무한 루프를 만드는 코드로 올바른 것은?', 4, 'high', 'for(;;)', 'while(true)', 'do{}while(true)', '모두 가능', 39, '모든 예시는 종료 조건이 없거나 항상 참이므로 무한 루프를 만드는 방법이다.'),
                                                                                                                           (1920, 'if-else if-else 구조에서 else는 언제 실행되는가?', 3, 'high', '항상 실행된다', '조건이 true일 때 실행', '모든 조건이 false일 때', '처음 조건이 false일 때', 39, 'else 블록은 이전의 모든 조건이 false일 경우 실행된다.'),
                                                                                                                           (1921, '객체 지향 프로그래밍의 4대 특징 중 하나가 아닌 것은?', 4, 'low', '상속', '추상화', '캡슐화', '동기화', 39, '동기화는 병렬 처리와 관련된 개념이며, 객체지향의 4대 특성(상속, 추상화, 캡슐화, 다형성)에 포함되지 않는다.'),
                                                                                                                           (1922, '클래스와 객체의 관계로 올바른 것은?', 1, 'low', '객체는 클래스의 인스턴스이다', '클래스는 객체의 결과물이다', '객체는 설계도이다', '클래스는 객체의 조합이다', 39, '클래스는 설계도이고, 객체는 그 설계도로부터 생성된 실체로 클래스의 인스턴스이다.'),
                                                                                                                           (1923, '생성자의 특징으로 틀린 것은?', 2, 'low', '클래스 이름과 동일', '리턴 타입이 있다', '객체 생성 시 호출', '오버로딩 가능', 39, '생성자는 리턴 타입을 명시하지 않으며, 명시하면 컴파일 오류가 발생한다.'),
                                                                                                                           (1924, '오버로딩의 조건으로 올바른 것은?', 1, 'medium', '매개변수 개수 또는 타입이 달라야 한다', '리턴 타입만 다르면 된다', '메서드 이름과 타입 모두 달라야 한다', '같은 이름, 같은 매개변수', 39, '오버로딩은 같은 이름의 메서드가 매개변수의 개수나 타입만 다르면 허용된다.'),
                                                                                                                           (1925, '오버라이딩의 특징은?', 1, 'medium', '동일한 이름과 시그니처를 사용', '다른 이름을 사용', '다른 리턴 타입 사용', 'private 메서드 가능', 39, '오버라이딩은 부모 클래스의 메서드와 이름, 매개변수, 리턴 타입까지 동일하게 재정의하는 것을 말한다.'),
                                                                                                                           (1926, 'abstract 키워드를 사용할 수 없는 곳은?', 3, 'medium', '클래스', '메서드', '필드', '인터페이스', 39, 'abstract는 클래스와 메서드에는 사용할 수 있지만 필드에는 사용할 수 없다.'),
                                                                                                                           (1927, '인터페이스의 특징은?', 1, 'high', '다중 구현 가능', '필드를 가질 수 있다', '생성자를 가질 수 있다', '메서드 구현 필수', 39, '인터페이스는 다중 구현을 지원하며, 필드와 생성자는 가질 수 없다.'),
                                                                                                                           (1928, 'final 클래스의 특징은?', 3, 'high', '상속 가능', '객체 생성 불가', '상속 불가', '변수로만 사용', 39, 'final 클래스는 상속이 불가능하며, 이를 통해 클래스 확장을 막을 수 있다.'),
                                                                                                                           (1929, 'super 키워드는 무엇을 참조하는가?', 2, 'high', '현재 클래스', '부모 클래스', '자식 클래스', '추상 클래스', 39, 'super는 부모 클래스의 멤버에 접근하거나 생성자를 호출할 때 사용된다.'),
                                                                                                                           (1930, 'this 키워드의 역할은?', 3, 'high', '클래스 이름 참조', '정적 변수 참조', '현재 객체 참조', '부모 객체 참조', 39, 'this는 현재 클래스의 인스턴스 자신을 참조할 때 사용한다.'),
                                                                                                                           (1931, 'List의 특징으로 올바른 것은?', 3, 'low', '중복 불가', '순서 없음', '중복 허용', '정렬 필수', 39, 'List는 요소의 중복을 허용하며, 요소의 순서를 유지하는 컬렉션이다.'),
                                                                                                                           (1932, 'Set의 특징으로 올바른 것은?', 3, 'low', '중복 허용', '순서 보장', '중복 불허', '키-값 저장', 39, 'Set은 중복을 허용하지 않는 컬렉션으로 순서도 보장하지 않는다.'),
                                                                                                                           (1933, 'Map은 어떤 구조인가?', 1, 'low', 'key-value', 'index-value', 'key-key', 'value-value', 39, 'Map은 키와 값의 쌍으로 데이터를 저장하는 자료 구조이다.'),
                                                                                                                           (1934, '다음 중 List를 구현하지 않는 것은?', 4, 'medium', 'ArrayList', 'LinkedList', 'Vector', 'HashMap', 39, 'HashMap은 Map 인터페이스를 구현하며, List와는 관련이 없다.'),
                                                                                                                           (1935, 'HashMap과 TreeMap의 차이는?', 2, 'medium', 'HashMap은 정렬된다', 'TreeMap은 정렬 지원', '둘 다 정렬된다', 'TreeMap은 중복 허용', 39, 'TreeMap은 키 기준으로 정렬된 상태를 유지하고, HashMap은 순서를 보장하지 않는다.'),
                                                                                                                           (1936, '제네릭을 사용하는 이유는?', 2, 'medium', '코드 축소', '타입 안정성 확보', '메모리 절약', '속도 향상', 39, '제네릭은 컴파일 시 타입을 체크하여 형 변환 오류를 줄이고 타입 안정성을 제공한다.'),
                                                                                                                           (1937, '다음 중 제네릭 타입 선언이 올바른 것은?', 2, 'high', 'List<int>', 'List<Object>', 'List<>', 'List{String}', 39, 'Java의 제네릭은 참조형 타입만 사용할 수 있으므로 List<Object>는 올바른 선언이다.'),
                                                                                                                           (1938, 'Iterator의 주요 기능은?', 2, 'high', '요소 정렬', '요소 반복', '요소 삭제', '요소 추가', 39, 'Iterator는 컬렉션의 요소를 순차적으로 접근할 수 있도록 도와준다.'),
                                                                                                                           (1939, 'List에서 요소를 삽입할 수 있는 메서드는?', 1, 'high', 'add()', 'put()', 'insert()', 'append()', 39, 'List는 요소 추가를 위해 add() 메서드를 제공하며, put()은 Map에서 사용된다.'),
                                                                                                                           (1940, 'HashSet은 어떤 특성을 가진가?', 3, 'high', '순서 보장', '중복 허용', '중복 제거', '키-값 구조', 39, 'HashSet은 Set의 구현체로 중복된 값을 허용하지 않는다.'),
                                                                                                                           (1941, 'IOException은 어떤 예외인가?', 1, 'low', 'Checked 예외', 'Unchecked 예외', '컴파일 오류', '논리 오류', 39, 'IOException은 컴파일 시 예외 처리 코드를 강제하는 Checked 예외이다.'),
                                                                                                                           (1942, 'try-catch-finally에서 finally 블록은 언제 실행되는가?', 1, 'low', '항상', 'catch 실행 시', '예외 없을 때만', '조건부 실행', 39, 'finally 블록은 예외 발생 여부와 관계없이 항상 실행된다.'),
                                                                                                                           (1943, 'throws 키워드는 무엇을 의미하는가?', 2, 'low', '예외 발생', '예외 전달', '예외 제거', '예외 종료', 39, 'throws는 메서드 선언부에 사용되어 호출자에게 예외 처리를 위임한다는 의미이다.'),
                                                                                                                           (1944, 'catch 블록은 무엇을 처리하는가?', 2, 'medium', '정상 종료', '예외 처리', '오류 출력', '파일 쓰기', 39, 'catch 블록은 try 블록에서 발생한 예외를 처리하기 위해 사용된다.'),
                                                                                                                           (1945, '예외 발생 없이도 finally가 실행되는가?', 1, 'medium', '예', '아니오', '조건에 따라 다름', '컴파일러가 결정', 39, 'finally는 예외 발생 여부와 관계없이 항상 실행되는 블록이다.'),
                                                                                                                           (1946, '예외 클래스의 최상위 클래스는?', 1, 'medium', 'Throwable', 'Exception', 'RuntimeException', 'Error', 39, 'Throwable은 Exception과 Error를 모두 포함하는 최상위 예외 클래스이다.'),
                                                                                                                           (1947, 'FileReader는 어떤 스트림에 속하는가?', 1, 'high', '입력 스트림', '출력 스트림', '버퍼 스트림', '바이트 스트림', 39, 'FileReader는 문자 기반의 입력 스트림이며, 파일로부터 문자를 읽어들이는 데 사용된다.'),
                                                                                                                           (1948, '파일에 내용을 쓰는 스트림은?', 2, 'high', 'FileInputStream', 'FileOutputStream', 'BufferedReader', 'Scanner', 39, 'FileOutputStream은 파일에 데이터를 바이트 단위로 출력하는 데 사용된다.'),
                                                                                                                           (1949, 'BufferedReader의 주요 기능은?', 2, 'high', '파일 쓰기', '라인 단위 읽기', '바이트 읽기', '객체 직렬화', 39, 'BufferedReader는 문자를 줄 단위로 읽을 수 있도록 버퍼링 기능을 제공한다.'),
                                                                                                                           (1950, '예외 처리에서 다중 catch를 사용하면?', 3, 'high', '모든 예외가 무시됨', '하나의 예외만 처리 가능', '여러 예외를 개별 처리', 'finally가 생략됨', 39, '다중 catch 블록을 사용하면 서로 다른 예외를 개별적으로 처리할 수 있다.'),
                                                                                                                           (1951, 'Python에서 변수 이름으로 사용할 수 없는 것은?', 3, 'low', '_value', 'value1', '1value', 'value_1', 40, '변수명은 숫자로 시작할 수 없으므로 "1value"는 유효한 변수명이 아니다.'),
                                                                                                                           (1952, '다음 중 Python에서 문자열을 나타내는 것은?', 4, 'low', "'''Hello'''", '"World"', "str('Test')", 'All of the above', 40, '세 가지 모두 문자열을 생성하는 표현이므로 모두 문자열을 나타낸다.'),
                                                                                                                           (1953, '다음 중 숫자형에 해당하지 않는 것은?', 3, 'low', 'int', 'float', 'str', 'complex', 40, 'str은 문자열 타입이며 숫자형이 아니다.'),
                                                                                                                           (1954, 'float 자료형의 기본 특징으로 올바른 것은?', 2, 'medium', '정수만 저장', '소수점 표현 가능', '문자 저장 가능', '참/거짓만 저장', 40, 'float는 실수를 표현하는 자료형으로 소수점이 있는 숫자를 저장할 수 있다.'),
                                                                                                                           (1955, '불리언(Boolean) 타입의 기본값이 아닌 것은?', 3, 'medium', 'True', 'False', 'None', '0 == 1', 40, 'None은 불리언이 아닌 특별한 NoneType 객체이며 Boolean 기본값이 아니다.'),
                                                                                                                           (1956, '다음 중 type(5.0)의 반환 값은?', 2, 'medium', "<class 'int'>", "<class 'float'>", "<type 'double'>", "<class 'complex'>", 40, '5.0은 소수점이 있으므로 float 타입이며, type()은 "<class \'float\'>"를 반환한다.'),
                                                                                                                           (1957, '문자열 여러 줄을 표현할 수 있는 구문은?', 3, 'high', "''''''문자열''''''", '"""문자열"""', '모두 해당', "'''문자열'''", 40, '여러 줄 문자열은 작은따옴표 3개나 큰따옴표 3개로 표현할 수 있으므로 모두 해당된다.'),
                                                                                                                           (1958, 'Python에서 자료형 확인 시 사용하는 함수는?', 2, 'high', 'typeof()', 'type()', 'data()', 'kind()', 40, 'type() 함수는 객체의 자료형을 확인하는 내장 함수이다.'),
                                                                                                                           (1959, '다음 중 유효한 정수 리터럴 표기는?', 2, 'high', '0123', '0b1010', '0x1G', '10.0', 40, '0b1010은 2진수 정수 리터럴이며, 나머지는 오류를 발생시키거나 실수 타입이다.'),
                                                                                                                           (1960, '다음 중 Python에서 기본 제공되는 자료형은?', 4, 'high', 'bool', 'int', 'float', '모두 해당', 40, 'bool, int, float 모두 Python의 기본 내장 자료형이다.'),
                                                                                                                           (1961, 'Python에서 if 조건문을 끝내는 구문은?', 3, 'low', 'endif', 'fi', '콜론(:)', 'done', 40, 'Python에서는 조건문 뒤에 콜론(:)을 사용하여 블록의 시작을 나타낸다.'),
                                                                                                                           (1962, 'Python에서 반복을 위해 사용되는 키워드는?', 3, 'low', 'repeat', 'loop', 'for', 'next', 40, 'for는 Python에서 반복(iteration)을 수행하기 위한 기본 키워드이다.'),
                                                                                                                           (1963, '다음 중 조건문으로 올바른 것은?', 3, 'low', 'if x > 0 then', 'if (x > 0)', 'if x > 0:', 'x > 0 if', 40, 'Python의 if 조건문은 조건 뒤에 콜론(:)이 필수이며 괄호는 생략 가능하다.'),
                                                                                                                           (1964, 'while 문에서 조건이 False이면?', 3, 'medium', '무한 반복된다', '한 번은 실행된다', '실행되지 않는다', '오류 발생', 40, 'while 조건이 처음부터 False이면 루프는 한 번도 실행되지 않는다.'),
                                                                                                                           (1965, 'range(3)의 결과는?', 2, 'medium', '[1, 2, 3]', '[0, 1, 2]', '[0, 1, 2, 3]', '[3]', 40, 'range(3)은 0부터 시작해 3 미만까지의 정수 시퀀스를 생성한다.'),
                                                                                                                           (1966, 'continue 문을 사용할 경우 어떻게 되는가?', 3, 'medium', '루프가 종료됨', '루프가 중단됨', '현재 반복만 건너뜀', '에러 발생', 40, 'continue는 현재 반복을 건너뛰고 다음 반복으로 진행한다.'),
                                                                                                                           (1967, 'for 문에서 변수명을 정의할 수 없는 경우는?', 2, 'high', 'for x in range(5):', 'for 1x in range(5):', 'for _ in range(5):', 'for item in items:', 40, '변수명은 숫자로 시작할 수 없기 때문에 "1x"는 유효하지 않다.'),
                                                                                                                           (1968, '다음 중 중첩 조건문을 작성한 코드로 올바른 것은?', 1, 'high', 'if x > 1:  if y > 1:', 'if x > 1: if y > 1', 'if (x > 1) then if (y > 1)', 'if x > 1, if y > 1:', 40, 'Python의 중첩 조건문은 들여쓰기를 포함한 블록 구조를 사용하며 콜론(:)이 필요하다.'),
                                                                                                                           (1969, 'break 문은 어떤 상황에서 사용되는가?', 3, 'high', '변수를 종료할 때', '조건을 변경할 때', '루프를 즉시 종료할 때', '코드를 생략할 때', 40, 'break 문은 반복문 내에서 루프를 즉시 빠져나갈 때 사용한다.'),
                                                                                                                           (1970, 'while 루프에서 무한 루프를 만드는 구문은?', 2, 'high', 'while (True):', 'while True:', 'while \'yes\':', 'while 1==1:', 40, 'while True:는 항상 참이므로 무한 루프를 만든다. 괄호는 필요하지 않다.'),
                                                                                                                           (1971, 'Python에서 함수를 정의할 때 사용하는 키워드는?', 2, 'low', 'function', 'def', 'define', 'lambda', 40, 'Python에서 함수를 정의할 때는 def 키워드를 사용한다.'),
                                                                                                                           (1972, '기본 매개변수를 사용하는 함수 정의는?', 3, 'low', 'def func(x: 1):', 'def func[x=1]:', 'def func(x=1):', 'func = def(x=1)', 40, 'def func(x=1):은 기본값을 가지는 매개변수를 정의하는 올바른 문법이다.'),
                                                                                                                           (1973, '값을 반환하는 함수는 어떤 키워드를 사용하는가?', 1, 'low', 'return', 'yield', 'output', 'send', 40, 'return은 함수에서 값을 반환할 때 사용하는 표준 키워드이다.'),
                                                                                                                           (1974, '모듈을 불러올 때 사용하는 키워드는?', 3, 'medium', 'include', 'require', 'import', 'load', 40, 'Python에서는 import 키워드를 사용하여 외부 모듈을 불러온다.'),
                                                                                                                           (1975, 'math 모듈의 sqrt 함수는 무엇을 반환하는가?', 2, 'medium', '제곱', '제곱근', '2배', '로그값', 40, 'math.sqrt 함수는 전달된 수의 제곱근 값을 반환한다.'),
                                                                                                                           (1976, '모듈의 일부 함수만 가져오고 싶을 때 사용하는 문법은?', 2, 'medium', 'include function from module', 'from module import function', 'require module.function', 'get module::function', 40, '"from module import function" 구문은 모듈의 특정 함수만 가져올 때 사용된다.'),
                                                                                                                           (1977, 'lambda 함수의 특징은?', 3, 'high', '여러 줄 가능', '반복문 포함 가능', '익명 함수', '모듈 전용', 40, 'lambda는 이름 없는 함수를 한 줄로 정의할 수 있는 익명 함수이다.'),
                                                                                                                           (1978, '함수 내에서 전역 변수 사용 시 필요한 키워드는?', 3, 'high', 'this', 'var', 'global', 'globalize', 40, 'global 키워드는 함수 내에서 전역 변수에 접근하고 수정할 때 사용된다.'),
                                                                                                                           (1979, '파이썬 표준 내장 함수가 아닌 것은?', 4, 'high', 'len()', 'sum()', 'map()', 'sqrt()', 40, 'sqrt()는 math 모듈에 포함되어 있으며, 표준 내장 함수는 아니다.'),
                                                                                                                           (1980, '패키지를 가져올 때 사용하는 폴더 기준 파일은?', 3, 'high', '__main__.py', 'package.py', '__init__.py', 'module.py', 40, '__init__.py 파일은 해당 디렉토리를 패키지로 인식하게 하는 역할을 한다.'),
                                                                                                                           (1981, '리스트의 기본 특징은?', 3, 'low', '중복 불가', '정렬 자동', '순서 보장', '딕셔너리와 동일', 40, '리스트는 요소의 순서를 유지하며 인덱스를 통해 접근할 수 있는 순서형 컬렉션이다.'),
                                                                                                                           (1982, '다음 중 튜플의 특징으로 옳은 것은?', 3, 'low', '수정 가능', '중복 불가', '불변(immutable)', 'key-value 저장', 40, '튜플은 생성된 이후 값을 변경할 수 없는 불변(immutable) 자료형이다.'),
                                                                                                                           (1983, '세트(set)의 주요 특징은?', 3, 'low', '중복 허용', '정렬 유지', '중복 제거', '순서 유지', 40, 'set은 중복된 값을 허용하지 않으며 자동으로 중복을 제거한다.'),
                                                                                                                           (1984, '딕셔너리(dictionary)의 키로 사용할 수 없는 것은?', 3, 'medium', 'int', 'str', 'list', 'tuple', 40, 'list는 변경 가능한 자료형이기 때문에 딕셔너리의 키로 사용할 수 없다.'),
                                                                                                                           (1985, '리스트에서 요소 추가 시 사용하는 메서드는?', 3, 'medium', 'add()', 'insert()', 'append()', 'push()', 40, 'append()는 리스트의 맨 뒤에 요소를 추가하는 기본 메서드이다.'),
                                                                                                                           (1986, '리스트에서 슬라이싱을 통해 2개 요소를 추출하는 문법은?', 2, 'medium', 'list(1:3)', 'list[1:3]', 'list(1,3)', 'list{1:3}', 40, '리스트에서 특정 범위의 요소를 추출하려면 대괄호와 콜론(:)을 사용하는 list[1:3] 문법을 사용한다.'),
                                                                                                                           (1987, '다음 중 세트 연산에 해당하는 기호는?', 2, 'high', '+', '&', '*', '-', 40, '&는 두 set의 교집합을 구하는 연산자이다.'),
                                                                                                                           (1988, '딕셔너리에서 키와 값을 모두 가져오는 메서드는?', 3, 'high', 'keys()', 'values()', 'items()', 'get()', 40, 'items()는 딕셔너리의 (key, value) 쌍을 튜플 형태로 반환한다.'),
                                                                                                                           (1989, '튜플의 요소를 수정하려 하면?', 2, 'high', '가능하다', '에러 발생', '삭제만 가능', '빈 튜플만 수정 가능', 40, '튜플은 불변 자료형이므로 요소를 수정하려 하면 TypeError가 발생한다.'),
                                                                                                                           (1990, '딕셔너리에서 존재하지 않는 키 접근 시 사용하는 메서드는?', 2, 'high', 'access()', 'get()', 'search()', 'query()', 40, 'get()은 존재하지 않는 키를 조회해도 None을 반환하며 오류가 발생하지 않는다.'),
                                                                                                                           (1991, '파일을 읽기 모드로 열기 위한 코드는?', 1, 'low', "open('file.txt', 'r')", "open('file.txt', 'w')", "read('file.txt')", "file('file.txt')", 40, "'r' 모드는 읽기 전용으로 파일을 여는 방식이다."),
                                                                                                                           (1992, '텍스트 파일에 데이터를 쓰는 함수는?', 1, 'low', 'write()', 'print()', 'input()', 'append()', 40, 'write()는 텍스트 파일에 데이터를 문자열 형태로 기록하는 함수이다.'),
                                                                                                                           (1993, '파일을 다 연 후 반드시 해야 할 작업은?', 3, 'low', 'save()', 'exit()', 'close()', 'quit()', 40, '파일을 사용한 후에는 자원 누수를 방지하기 위해 반드시 close()를 호출해야 한다.'),
                                                                                                                           (1994, '예외 처리에서 사용하는 기본 구문은?', 2, 'medium', 'try-catch', 'try-except', 'do-catch', 'if-error', 40, 'Python에서는 try-except 구문을 사용하여 예외를 처리한다.'),
                                                                                                                           (1995, '다음 중 IOError를 발생시킬 수 있는 상황은?', 2, 'medium', '문법 오류', '파일 없음', '변수 없음', '리스트 인덱스 초과', 40, '존재하지 않는 파일을 열려고 할 때 IOError가 발생한다.'),
                                                                                                                           (1996, 'finally 블록의 역할은?', 3, 'medium', '예외가 발생했을 때만 실행', '예외가 없을 때만 실행', '항상 실행', '조건에 따라 실행', 40, 'finally 블록은 예외 발생 여부와 관계없이 항상 실행된다.'),
                                                                                                                           (1997, '파일을 한 줄씩 읽는 함수는?', 2, 'high', 'read()', 'readline()', 'readlines()', 'nextline()', 40, 'readline() 함수는 파일에서 한 줄씩 읽어 들일 때 사용된다.'),
                                                                                                                           (1998, '파일을 한꺼번에 읽어 리스트로 반환하는 함수는?', 3, 'high', 'read()', 'readline()', 'readlines()', 'lines()', 40, 'readlines()는 파일의 모든 줄을 읽어 리스트 형태로 반환한다.'),
                                                                                                                           (1999, '예외 객체를 변수로 받는 방법은?', 4, 'high', 'except e:', 'except as e:', 'except Exception:', 'except Exception as e:', 40, 'except Exception as e: 구문은 예외 객체를 e라는 변수로 참조하게 해준다.'),
                                                                                                                           (2000, '파일을 안전하게 열고 자동으로 닫는 방법은?', 1, 'high', 'with open() as f:', 'safe open()', 'file auto()', 'open+close()', 40, 'with open() 구문은 파일을 자동으로 닫아주는 컨텍스트 매니저를 활용한 방식이다.'),
                                                                                                                           (2001, 'JavaScript에서 변수를 선언할 수 없는 키워드는?', 4, 'low', 'let', 'const', 'var', 'define', 41, 'define은 JavaScript의 변수 선언 키워드가 아니며, 함수나 모듈 로딩에서 사용되는 다른 문맥의 예약어다.'),
                                                                                                                           (2002, '다음 중 JavaScript의 숫자형 타입은?', 1, 'low', 'Number', 'Int', 'Float', 'Decimal', 41, 'JavaScript는 모든 숫자를 Number 타입으로 처리하며 Int, Float은 존재하지 않는다.'),
                                                                                                                           (2003, '문자열을 나타내는 방법으로 올바르지 않은 것은?', 4, 'low', "'''Hello'''", '"Hello"', '`Hello`', '<Hello>', 41, '<Hello>는 문자열이 아닌 HTML 태그 형식으로 문자열 리터럴이 아니다.'),
                                                                                                                           (2004, 'undefined와 null의 차이에 대한 설명으로 옳은 것은?', 2, 'medium', '둘 다 같은 의미이다', 'undefined는 값이 할당되지 않음', 'null은 정의되지 않음', 'undefined는 명시적 초기화', 41, 'undefined는 변수가 선언되었지만 값이 할당되지 않았을 때를 의미한다.'),
                                                                                                                           (2005, 'typeof null의 결과는?', 1, 'medium', 'object', 'null', 'undefined', 'string', 41, 'typeof null은 JavaScript의 오래된 버그로 인해 "object"를 반환한다.'),
                                                                                                                           (2006, 'JavaScript에서 템플릿 리터럴은 무엇으로 묶는가?', 3, 'medium', "'''", '"', '`', '~', 41, '템플릿 리터럴은 백틱(`)으로 묶으며 문자열 내 변수 삽입이 가능하다.'),
                                                                                                                           (2007, 'NaN은 어떤 상황에서 발생하는가?', 1, 'high', '숫자 나누기 문자', '0 나누기 0', '문자 더하기 숫자', 'undefined와 연산', 41, '숫자와 문자의 연산 등에서 숫자로 변환할 수 없을 때 NaN이 발생한다.'),
                                                                                                                           (2008, 'const로 선언된 변수는 어떤 특징이 있는가?', 3, 'high', '재선언 가능', '값 변경 가능', '블록 스코프', '자동 초기화', 41, 'const는 블록 스코프를 가지며 재할당이 불가능하다.'),
                                                                                                                           (2009, '다음 중 falsy 값이 아닌 것은?', 4, 'high', '0', "''", 'false', "'false'", 41, '"false"는 문자열이기 때문에 truthy 값으로 평가된다.'),
                                                                                                                           (2010, 'JavaScript에서 세미콜론(;)은 언제 필수인가?', 3, 'high', '항상', '절대로 필요 없음', '문장 끝', '객체 안에서', 41, '세미콜론은 문장을 구분하기 위해 일반적으로 문장 끝에 사용된다.'),
                                                                                                                           (2011, 'JavaScript에서 조건문 if를 작성할 때 사용하는 키워드는?', 2, 'low', 'when', 'if', 'cond', 'case', 41, '"if"는 조건문을 정의할 때 사용하는 JavaScript의 기본 키워드이다.'),
                                                                                                                           (2012, '조건문에서 여러 조건을 연결하는 연산자는?', 3, 'low', '&', '|', '&&', '==', 41, '"&&"는 AND 조건을 의미하며, 여러 조건이 모두 참일 때만 실행된다.'),
                                                                                                                           (2013, 'switch 문에서 각 조건을 나타내는 키워드는?', 1, 'low', 'case', 'when', 'option', 'check', 41, 'JavaScript의 switch 문에서 각 조건 분기를 위해 "case" 키워드를 사용한다.'),
                                                                                                                           (2014, 'for 루프를 종료하는 키워드는?', 4, 'medium', 'skip', 'stop', 'continue', 'break', 41, '"break"는 반복문을 즉시 종료시키는 키워드이다.'),
                                                                                                                           (2015, '반복문의 조건을 건너뛰고 다음 반복으로 이동하는 키워드는?', 3, 'medium', 'skip', 'next', 'continue', 'redo', 41, '"continue"는 현재 반복을 건너뛰고 다음 반복으로 진행하도록 한다.'),
                                                                                                                           (2016, 'while 반복문의 조건이 false이면?', 3, 'medium', '무한 반복', '한 번 실행', '실행 안 됨', '오류 발생', 41, 'while 루프는 조건이 false일 경우 실행되지 않는다.'),
                                                                                                                           (2017, 'do...while 루프의 특징으로 옳은 것은?', 3, 'high', '조건을 먼저 검사', '조건이 true면 반복 안 함', '무조건 한 번 실행', '사용 불가', 41, 'do...while 문은 조건 확인 전에 코드 블록을 먼저 실행하므로 최소 한 번은 실행된다.'),
                                                                                                                           (2018, 'switch 문에서 break를 생략하면?', 3, 'high', '에러 발생', '기본값 실행', '다음 case까지 실행', '루프 종료', 41, 'break를 생략하면 조건에 맞는 case부터 이후 case들이 연속 실행된다.'),
                                                                                                                           (2019, '다음 중 삼항 연산자의 형식으로 올바른 것은?', 1, 'high', '조건 ? 참 : 거짓', '조건 : 참 ? 거짓', '조건 ? 거짓 : 참', 'if ? then : else', 41, '삼항 연산자는 "조건 ? 참 : 거짓"의 형식으로 조건에 따라 값을 선택한다.'),
                                                                                                                           (2020, 'for (let i = 0; i < 5; i++)에서 i++의 의미는?', 2, 'high', 'i를 1로 설정', 'i를 1씩 증가', 'i를 출력', 'i를 감소', 41, '"i++"는 i 값을 1씩 증가시키는 연산자이다.'),
                                                                                                                           (2021, 'JavaScript에서 함수를 선언하는 키워드는?', 2, 'low', 'method', 'function', 'define', 'func', 41, '"function"은 JavaScript에서 함수를 선언할 때 사용하는 키워드이다.'),
                                                                                                                           (2022, '함수를 실행하려면 어떻게 해야 하는가?', 3, 'low', 'call()', 'invoke()', '함수명()', 'do()', 41, '함수명 뒤에 괄호를 붙여 호출하면 함수가 실행된다.'),
                                                                                                                           (2023, '함수 내에서 사용된 변수는 기본적으로 어떤 스코프를 가지는가?', 2, 'low', '전역', '지역', '블록', '클래스', 41, '함수 내에서 선언된 변수는 기본적으로 함수 내부에만 유효한 지역 스코프를 가진다.'),
                                                                                                                           (2024, '화살표 함수의 기본 형태로 올바른 것은?', 2, 'medium', 'function => {}', '() => {}', '-> {}', '{} => ()', 41, '"() => {}"는 화살표 함수의 가장 기본적인 선언 형태이다.'),
                                                                                                                           (2025, '함수 표현식은 어떤 변수 키워드와 함께 자주 사용되는가?', 4, 'medium', 'let', 'const', 'var', '모두 해당', 41, '함수 표현식은 let, const, var 모두와 함께 사용 가능하다.'),
                                                                                                                           (2026, 'return 키워드의 기능은?', 2, 'medium', '함수를 종료', '값을 반환', '다음 반복으로 이동', '코드를 건너뜀', 41, '"return"은 함수를 종료하고 호출 지점으로 값을 반환하는 데 사용된다.'),
                                                                                                                           (2027, '화살표 함수에서 this는 무엇을 참조하는가?', 4, 'high', '전역 객체', '함수 자신', '호출 컨텍스트', '화살표 함수는 this를 가지지 않음', 41, '화살표 함수는 고유한 this를 가지지 않으며, 외부 스코프의 this를 그대로 사용한다.'),
                                                                                                                           (2028, '즉시 실행 함수(IIFE)의 형식으로 맞는 것은?', 3, 'high', 'function(){}', '() => {}', '(function() {})()', '{}();', 41, '즉시 실행 함수는 정의와 동시에 실행되며 일반적으로 괄호로 감싸고 마지막에 ()를 붙인다.'),
                                                                                                                           (2029, '함수에서 매개변수를 생략하면?', 2, 'high', '에러 발생', 'undefined로 처리', '0으로 초기화', 'null로 초기화', 41, '매개변수를 전달하지 않으면 자동으로 undefined로 처리된다.'),
                                                                                                                           (2030, '함수 내부에서 정의된 함수는 어떤 범위를 가지는가?', 3, 'high', '전역', '함수 외부', '지역', 'DOM', 41, '함수 내부에서 선언된 함수는 해당 함수 내부에서만 접근 가능한 지역 범위를 가진다.'),
                                                                                                                           (2031, 'JavaScript에서 배열을 생성하는 방법으로 옳은 것은?', 1, 'low', 'var a = [];', 'var a = {};', 'var a = ()', 'var a = <>;', 41, '대괄호([])를 사용하면 배열을 생성할 수 있다.'),
                                                                                                                           (2032, '객체에서 속성에 접근하는 방법은?', 2, 'low', 'obj->key', 'obj.key', 'obj-key', 'obj:key', 41, 'obj.key 문법은 객체의 속성에 접근하는 가장 일반적인 방식이다.'),
                                                                                                                           (2033, '다음 중 배열에 요소를 추가하는 메서드는?', 1, 'low', 'push()', 'pop()', 'shift()', 'splice()', 41, 'push()는 배열의 마지막에 요소를 추가하는 메서드이다.'),
                                                                                                                           (2034, '객체의 속성 값을 삭제하는 키워드는?', 2, 'medium', 'remove', 'delete', 'clear', 'drop', 41, 'delete 키워드는 객체에서 속성을 제거할 때 사용된다.'),
                                                                                                                           (2035, '배열의 모든 요소에 대해 반복 실행하는 메서드는?', 2, 'medium', 'map()', 'forEach()', 'filter()', 'reduce()', 41, 'forEach()는 배열의 각 요소에 대해 콜백 함수를 실행한다.'),
                                                                                                                           (2036, '객체의 모든 키를 배열로 반환하는 메서드는?', 2, 'medium', 'Object.values()', 'Object.keys()', 'Object.entries()', 'Object.map()', 41, 'Object.keys()는 객체의 모든 속성 이름을 배열로 반환한다.'),
                                                                                                                           (2037, '배열에서 요소를 제거하는 pop()은 어느 쪽 요소를 제거하는가?', 3, 'high', '처음', '중간', '마지막', '랜덤', 41, 'pop()은 배열의 마지막 요소를 제거하고 반환하는 메서드이다.'),
                                                                                                                           (2038, '배열의 길이를 반환하는 속성은?', 3, 'high', 'size', 'count', 'length', 'items', 41, 'length 속성은 배열의 요소 개수를 반환한다.'),
                                                                                                                           (2039, '객체의 속성과 값을 모두 배열 형태로 반환하는 메서드는?', 3, 'high', 'Object.keys()', 'Object.values()', 'Object.entries()', 'Object.toArray()', 41, 'Object.entries()는 [key, value] 쌍을 배열의 형태로 반환한다.'),
                                                                                                                           (2040, '배열의 복사를 위한 메서드로 적절한 것은?', 1, 'high', 'slice()', 'splice()', 'pop()', 'map()', 41, 'slice()는 원본 배열을 변경하지 않고 복사본을 생성하는 데 사용된다.'),
                                                                                                                           (2041, 'HTML 요소를 JavaScript로 가져올 때 사용하는 메서드는?', 3, 'low', 'getElement()', 'query()', 'getElementById()', 'fetchElement()', 41, 'getElementById()는 HTML 요소 중 id 속성으로 요소를 선택할 수 있는 대표적인 DOM API 메서드이다.'),
                                                                                                                           (2042, '다음 중 이벤트 리스너 등록 메서드는?', 3, 'low', 'addEvent()', 'setEvent()', 'addEventListener()', 'eventListen()', 41, 'addEventListener()는 이벤트 타입과 콜백 함수를 지정하여 이벤트를 감지하고 처리할 수 있게 해준다.'),
                                                                                                                           (2043, '버튼 클릭 시 실행되는 이벤트 타입은?', 3, 'low', 'hover', 'mousedown', 'click', 'submit', 41, 'click 이벤트는 사용자가 버튼을 클릭했을 때 발생하는 표준 이벤트 타입이다.'),
                                                                                                                           (2044, '다음 중 innerText와 유사한 속성은?', 3, 'medium', 'textValue', 'htmlText', 'textContent', 'innerHTML', 41, 'textContent는 요소의 텍스트 콘텐츠를 반환하며, innerText와 유사하게 작동한다.'),
                                                                                                                           (2045, '이벤트 객체에서 발생한 요소를 참조하는 속성은?', 1, 'medium', 'target', 'source', 'caller', 'element', 41, '이벤트 객체의 target 속성은 이벤트가 발생한 요소를 참조할 때 사용된다.'),
                                                                                                                           (2046, '이벤트 전파를 막는 메서드는?', 2, 'medium', 'preventDefault()', 'stopPropagation()', 'cancelEvent()', 'blockEvent()', 41, 'stopPropagation()은 이벤트가 상위 요소로 전파되는 것을 막는다.'),
                                                                                                                           (2047, 'DOMContentLoaded 이벤트는 언제 발생하는가?', 3, 'high', '페이지 로딩 시작 시', '스크립트 로딩 완료 시', 'DOM 트리 완성 시', '이미지 로딩 완료 시', 41, 'DOMContentLoaded는 HTML 문서의 DOM 트리가 완성되었을 때 발생한다.'),
                                                                                                                           (2048, 'innerHTML 속성의 특징으로 옳은 것은?', 3, 'high', '보안에 강함', '텍스트만 출력', 'HTML 태그 포함 출력', '읽기 전용', 41, 'innerHTML은 요소 내부에 HTML 태그를 포함한 문자열을 삽입하거나 가져올 수 있다.'),
                                                                                                                           (2049, 'HTML 요소 클래스 추가 시 사용하는 메서드는?', 4, 'high', 'addClass()', 'appendClass()', 'classAdd()', 'classList.add()', 41, 'classList.add()는 요소에 하나 이상의 클래스를 추가할 수 있는 DOM API 메서드이다.'),
                                                                                                                           (2050, '폼 제출 시 기본 동작을 막으려면?', 2, 'high', 'event.stopPropagation()', 'event.preventDefault()', 'return false', 'event.block()', 41, 'preventDefault()는 기본 이벤트 동작(예: form 제출)을 방지하는 데 사용된다.'),
                                                                                                                           (2051, 'Kotlin에서 변수를 선언하는 키워드로 올바른 것은?', 1, 'low', 'var', 'val', 'let', '변수', 42, 'Kotlin에서는 var 키워드를 사용하여 변경 가능한 변수를 선언한다.'),
                                                                                                                           (2052, '값을 변경할 수 없는 변수 선언 키워드는?', 1, 'low', 'val', 'var', 'let', 'const', 42, 'val 키워드는 한 번 초기화되면 값을 변경할 수 없는 읽기 전용 변수 선언에 사용된다.'),
                                                                                                                           (2053, 'Kotlin에서 문자열을 나타내는 타입은?', 2, 'low', 'Char', 'String', 'Text', 'str', 42, 'String은 Kotlin에서 문자열을 표현하기 위한 표준 타입이다.'),
                                                                                                                           (2054, 'Kotlin에서 자료형을 명시적으로 지정하려면?', 1, 'medium', 'x: Int = 10', 'Int x = 10', 'x := 10', 'x = Int(10)', 42, 'Kotlin은 변수명 다음에 콜론(:)을 사용하여 자료형을 명시한다.'),
                                                                                                                           (2055, 'Kotlin에서 여러 줄 문자열을 표현할 때 사용하는 기호는?', 1, 'medium', '"""', "''''''", '###', '"', 42, '""" (triple quotes)는 여러 줄의 문자열을 표현할 수 있게 해주는 Kotlin의 문법이다.'),
                                                                                                                           (2056, 'val로 선언된 변수의 특징은?', 2, 'medium', '재할당 가능', '값 변경 불가', '타입 미지정 불가', '모든 경우에 final', 42, 'val로 선언된 변수는 초기화 이후 값 변경이 불가능하다.'),
                                                                                                                           (2057, '다음 중 올바른 변수 선언은?', 2, 'high', 'var 1name = "John"', 'val age = 25', 'val true = 1', 'var %value = 10', 42, '변수명은 숫자로 시작할 수 없고, 예약어나 특수문자는 사용할 수 없으므로 val age = 25만 올바르다.'),
                                                                                                                           (2058, 'Kotlin에서 자료형을 자동으로 추론하는 기능은?', 4, 'high', 'inference', 'autoType', 'smart cast', 'type inference', 42, 'Kotlin은 type inference를 통해 변수의 타입을 컴파일러가 자동으로 추론한다.'),
                                                                                                                           (2059, 'Kotlin에서 백틱(`)을 사용하는 경우는?', 3, 'high', '문자열 템플릿', '람다식', '함수명에 예약어 사용', '주석 처리', 42, '예약어를 식별자로 사용해야 할 경우 이름을 백틱(`)으로 감싸면 된다.'),
                                                                                                                           (2060, 'Kotlin에서 문자열 템플릿을 사용하는 구문은?', 2, 'high', '\${변수}', '${변수}', '%{변수}', '&{변수}', 42, '문자열 템플릿은 큰따옴표 안에서 ${변수} 형식으로 표현할 수 있다.'),
                                                                                                                           (2061, 'Kotlin에서 조건문 if는 어떤 값을 반환할 수 있는가?', 3, 'low', '문자만', '값을 반환하지 않음', '표현식으로 사용 가능', '함수로만 사용 가능', 42, 'Kotlin의 if는 표현식으로 사용 가능하여 값을 반환할 수 있다.'),
                                                                                                                           (2062, 'Kotlin의 when 문은 어떤 역할을 하는가?', 2, 'low', '루프', 'switch 문과 유사', '함수 호출', '클래스 정의', 42, 'when 문은 Java의 switch 문과 유사한 다중 조건 분기문이다.'),
                                                                                                                           (2063, 'while 루프의 조건이 false이면?', 3, 'low', '무한 반복', '에러 발생', '실행되지 않음', '무조건 한 번 실행', 42, '조건이 처음부터 false이면 while 루프는 한 번도 실행되지 않는다.'),
                                                                                                                           (2064, 'Kotlin에서 do...while 루프는 어떤 특징이 있는가?', 2, 'medium', '조건이 먼저 평가됨', '조건이 false여도 한 번은 실행', '조건 없이 반복', '무한 루프 전용', 42, 'do...while 루프는 조건 평가 전에 본문을 최소 한 번 실행하는 특징이 있다.'),
                                                                                                                           (2065, '반복문에서 continue 키워드의 역할은?', 2, 'medium', '루프 종료', '현재 반복을 건너뜀', '반복 시작', '조건 무시', 42, 'continue는 반복문의 현재 반복을 건너뛰고 다음 반복으로 이동하게 한다.'),
                                                                                                                           (2066, 'for 루프에서 in 키워드는 무엇을 의미하는가?', 1, 'medium', '범위 반복', '조건식', '함수 호출', 'null 체크', 42, 'in은 지정된 범위나 컬렉션에 대해 순회할 때 사용된다.'),
                                                                                                                           (2067, 'when 문에서 else는 어떤 의미인가?', 2, 'high', '예외 발생', '기본 케이스', '루프 종료', '조건 생략', 42, 'else는 모든 조건에 해당하지 않을 때 실행되는 기본 분기이다.'),
                                                                                                                           (2068, 'Kotlin의 반복문에서 인덱스를 함께 얻는 함수는?', 1, 'high', 'withIndex()', 'withCount()', 'indexed()', 'zip()', 42, 'withIndex()는 컬렉션을 순회할 때 인덱스와 값을 함께 반환한다.'),
                                                                                                                           (2069, 'Kotlin에서 step을 사용하는 경우는?', 2, 'high', '무한 루프', '스텝 수 지정', '조건 생략', '중첩 반복문', 42, 'step은 반복의 증가 폭을 지정할 때 사용된다.'),
                                                                                                                           (2070, '반복문의 범위 지정 시 .. 연산자의 의미는?', 3, 'high', '제외 범위', '오름차순 반복', '포함 범위', '무한 반복', 42, '.. 연산자는 시작값과 끝값을 포함하는 범위를 생성한다.'),
                                                                                                                           (2071, 'Kotlin에서 함수를 정의할 때 사용하는 키워드는?', 2, 'low', 'define', 'fun', 'method', 'function', 42, 'Kotlin에서는 fun 키워드를 사용하여 함수를 정의한다.'),
                                                                                                                           (2072, 'Kotlin의 람다 표현식은 어떤 기호로 시작하는가?', 2, 'low', '->', '{ }', 'lambda', '=>', 42, 'Kotlin의 람다식은 중괄호 { }로 감싸며 내부에 -> 기호를 사용하여 매개변수와 본문을 구분한다.'),
                                                                                                                           (2073, '기본값이 있는 함수 매개변수를 선언할 때 사용하는 문법은?', 1, 'low', 'param: Int = 0', 'Int param = 0', 'param = Int(0)', 'param = 0 : Int', 42, 'Kotlin에서는 매개변수 뒤에 타입과 기본값을 명시하여 기본 인자를 설정할 수 있다.'),
                                                                                                                           (2074, 'Unit은 어떤 함수의 반환 타입인가?', 3, 'medium', '정수 반환', '문자열 반환', '반환값 없음', '예외 반환', 42, 'Unit은 Java의 void와 유사하게 반환값이 없는 함수의 타입이다.'),
                                                                                                                           (2075, '람다식에서 it 키워드는 어떤 의미인가?', 2, 'medium', '반복자', '첫 번째 매개변수', '문자열', '클래스명', 42, '매개변수가 하나뿐인 람다식에서는 it 키워드로 해당 인자를 암시적으로 참조할 수 있다.'),
                                                                                                                           (2076, '고차 함수란?', 4, 'medium', '클래스를 반환하는 함수', '람다만 사용 가능한 함수', '다형성 함수', '함수를 인자로 받거나 반환하는 함수', 42, '고차 함수는 다른 함수를 인자로 받거나 함수를 반환하는 함수이다.'),
                                                                                                                           (2077, '람다를 명시적으로 변수에 저장할 때 타입은?', 2, 'high', 'Lambda', '() -> Unit', 'void', 'Func', 42, '() -> Unit은 매개변수가 없고 반환값도 없는 람다 표현식의 타입이다.'),
                                                                                                                           (2078, '기본 매개변수와 이름 있는 인자를 함께 사용할 수 있는가?', 1, 'high', '가능하다', '불가능하다', '경고 발생', '에러 발생', 42, 'Kotlin은 기본값 매개변수와 이름 있는 인자를 함께 사용할 수 있어 함수 호출 시 유연성을 제공한다.'),
                                                                                                                           (2079, '람다식에서 명시적으로 반환값을 지정하려면?', 3, 'high', 'return 사용', 'it 키워드 사용', 'last 표현식 사용', 'result 사용', 42, '람다식에서 마지막 줄의 표현식이 반환값으로 사용된다.'),
                                                                                                                           (2080, '람다에서 여러 줄을 사용할 때 마지막 줄의 의미는?', 3, 'high', '무시됨', '예외 발생', '반환값으로 사용', '출력만 됨', 42, 'Kotlin의 람다식에서는 마지막 표현식이 해당 람다의 반환값이 된다.'),
                                                                                                                           (2081, 'Kotlin에서 클래스를 정의할 때 사용하는 키워드는?', 3, 'low', 'object', 'define', 'class', 'type', 42, 'Kotlin에서는 class 키워드를 사용하여 클래스를 정의한다.'),
                                                                                                                           (2082, '객체 생성 시 사용하는 키워드는?', 4, 'low', 'instantiate', 'object', 'new', '없음', 42, 'Kotlin에서는 new 키워드 없이 클래스 이름만으로 객체를 생성할 수 있다.'),
                                                                                                                           (2083, '클래스에 기본 생성자를 선언하려면?', 1, 'low', 'constructor()', 'fun()', 'init()', 'class {}', 42, '기본 생성자는 클래스 헤더에 constructor 키워드로 정의하거나 생략 가능하다.'),
                                                                                                                           (2084, 'init 블록은 언제 실행되는가?', 3, 'medium', '프로그램 시작 시', '클래스 로드 시', '객체 생성 시', '컴파일 시', 42, 'init 블록은 생성자가 호출된 후 즉시 실행되며 객체 초기화에 사용된다.'),
                                                                                                                           (2085, '프로퍼티의 getter/setter를 자동 생성하려면?', 2, 'medium', '변수를 private으로', 'val/var 선언', '함수 정의', '데이터 클래스 사용', 42, 'Kotlin은 val 또는 var 선언만으로 기본 getter/setter를 자동 생성해준다.'),
                                                                                                                           (2086, 'data class의 주요 목적은?', 3, 'medium', '함수 집합', 'UI 구성', '데이터 보관', '예외 처리', 42, 'data class는 데이터 보관을 위한 클래스로 equals(), hashCode(), toString() 등을 자동 생성한다.'),
                                                                                                                           (2087, '상속을 허용하려면 클래스 앞에 붙여야 하는 키워드는?', 1, 'high', 'open', 'public', 'override', 'super', 42, '기본적으로 Kotlin 클래스는 final이므로 상속하려면 open 키워드를 명시해야 한다.'),
                                                                                                                           (2088, '인터페이스 구현 시 사용하는 키워드는?', 4, 'high', 'include', 'inherit', 'implement', 'override', 42, 'Kotlin에서는 인터페이스의 멤버를 구현할 때 override 키워드를 사용한다.'),
                                                                                                                           (2089, '싱글톤 객체 생성을 위한 키워드는?', 2, 'high', 'new', 'object', 'this', 'static', 42, 'object 키워드는 Kotlin에서 싱글톤 객체 생성을 위한 키워드이다.'),
                                                                                                                           (2090, 'this 키워드는 무엇을 가리키는가?', 3, 'high', '상속 클래스', '부모 클래스', '현재 인스턴스', '외부 클래스', 42, 'this는 현재 클래스의 인스턴스를 참조할 때 사용된다.'),
                                                                                                                           (2091, '널 값을 허용하는 타입은 어떻게 표현하는가?', 1, 'low', 'Int?', 'Int!', 'Int*', 'nullable Int', 42, '타입 뒤에 ?를 붙이면 해당 변수는 null을 가질 수 있다.'),
                                                                                                                           (2092, '리스트를 생성하는 기본 함수는?', 3, 'low', 'list()', 'arrayList()', 'listOf()', 'new List()', 42, 'listOf()는 변경 불가능한 리스트를 생성하는 Kotlin 표준 함수이다.'),
                                                                                                                           (2093, '널 안정성을 위한 연산자는?', 2, 'low', '!!', '?.', '::', '?=', 42, '?. 연산자는 객체가 null인지 확인하고 null이 아니면 접근하는 안전 호출 연산자이다.'),
                                                                                                                           (2094, '!! 연산자의 의미는?', 3, 'medium', 'null 허용', 'null 안전 호출', 'null 아님 단언', 'null 값 대입', 42, '!!는 해당 값이 null이 아님을 단언하고 null이면 예외를 발생시킨다.'),
                                                                                                                           (2095, 'Kotlin에서 컬렉션을 변경 불가능하게 생성하려면?', 2, 'medium', 'mutableListOf()', 'listOf()', 'setOf()', 'mapOf()', 42, 'listOf()는 읽기 전용(immutable) 리스트를 생성하는 함수이다.'),
                                                                                                                           (2096, 'Map의 값을 가져오는 연산은?', 2, 'medium', 'map.get(key)', 'map[key]', 'map.value(key)', 'map->key', 42, 'map[key] 구문은 Kotlin에서 Map에서 값을 가져오는 간결한 방식이다.'),
                                                                                                                           (2097, '널 안정성 체크 후 기본값을 설정하려면 사용하는 연산자는?', 1, 'high', '?:', '::', '!!', '&=', 42, '?:는 엘비스 연산자로, 좌측이 null일 경우 우측의 기본값을 사용한다.'),
                                                                                                                           (2098, 'filter 함수는 어떤 컬렉션 연산인가?', 3, 'high', '정렬', '요소 제거', '조건에 맞는 요소 추출', '전체 복사', 42, 'filter는 주어진 조건을 만족하는 요소만 추출하는 함수이다.'),
                                                                                                                           (2099, 'Kotlin에서 안전 호출 연산자를 사용할 수 없는 곳은?', 4, 'high', '변수', '함수 호출', '프로퍼티 접근', '클래스 정의', 42, '클래스 정의에서는 안전 호출 연산자(?.)를 사용할 수 없다.'),
                                                                                                                           (2100, '컬렉션 요소를 모두 순회하는 함수는?', 1, 'high', 'forEach', 'loop', 'iterate', 'each()', 42, 'forEach는 컬렉션의 모든 요소를 순회하며 람다를 실행하는 함수이다.'),
                                                                                                                           (2101, 'SQL에서 데이터를 조회할 때 사용하는 명령어는?', 2, 'low', 'MERGE', 'SELECT', 'DROP', 'INSERT', 43, 'SELECT는 SQL에서 데이터를 조회할 때 사용하는 기본 명령어이다.'),
                                                                                                                           (2102, '특정 조건을 만족하는 행만 출력할 때 사용하는 SQL 키워드는?', 1, 'low', 'WHERE', 'GROUP BY', 'HAVING', 'ORDER BY', 43, 'WHERE는 조건에 맞는 행만 필터링하여 조회할 때 사용된다.'),
                                                                                                                           (2103, '테이블에서 중복된 값을 제거하여 출력할 때 사용하는 키워드는?', 2, 'medium', 'FILTER', 'DISTINCT', 'UNIQUE', 'NO_DUP', 43, 'DISTINCT는 SELECT 결과에서 중복된 값을 제거하는 데 사용된다.'),
                                                                                                                           (2104, 'SQL에서 컬럼 값을 기준으로 오름차순 정렬할 때 사용하는 명령어는?', 3, 'medium', 'SORT column', 'SORT BY column ASC', 'ORDER BY column ASC', 'ORDER ASC', 43, 'ORDER BY column ASC는 컬럼을 오름차순으로 정렬하기 위한 올바른 SQL 문법이다.'),
                                                                                                                           (2105, '두 테이블을 조인할 때 공통된 키를 기준으로 결합하는 방식은?', 2, 'medium', 'CROSS FILTER', 'INNER JOIN', 'UNION', 'OUTER JOIN', 43, 'INNER JOIN은 공통된 키 값을 기준으로 두 테이블을 결합하는 기본적인 조인 방식이다.'),
                                                                                                                           (2106, 'SQL에서 NULL 값을 검사할 때 사용하는 조건은?', 4, 'medium', 'IS VOID', 'IS EMPTY', '= NULL', 'IS NULL', 43, 'NULL 여부는 IS NULL을 사용해 검사하며, = NULL은 사용할 수 없다.'),
                                                                                                                           (2107, '여러 행의 평균 값을 구하는 SQL 함수는?', 1, 'low', 'AVG()', 'COUNT()', 'SUM()', 'MEAN()', 43, 'AVG() 함수는 열의 평균 값을 계산하는 SQL 집계 함수이다.'),
                                                                                                                           (2108, 'SQL에서 데이터를 삽입할 때 사용하는 명령은?', 2, 'low', 'ADD ROW', 'INSERT INTO', 'PUSH VALUE', 'NEW ENTRY', 43, 'INSERT INTO는 테이블에 새 데이터를 추가할 때 사용하는 명령어이다.'),
                                                                                                                           (2109, 'GROUP BY 절과 함께 사용되어 그룹 조건을 필터링하는 키워드는?', 2, 'high', 'LIMIT', 'HAVING', 'ORDER', 'WHERE', 43, 'HAVING은 GROUP BY로 그룹화된 결과에 조건을 걸 때 사용된다.'),
                                                                                                                           (2110, '테이블에서 특정 컬럼에만 인덱스를 생성하는 명령은?', 4, 'high', 'ALTER TABLE', 'ADD PRIMARY', 'INSERT INDEX', 'CREATE INDEX', 43, 'CREATE INDEX는 특정 컬럼에 인덱스를 생성할 때 사용하는 명령어이다.'),
                                                                                                                           (2111, 'SQL에서 조건에 맞는 최대값을 찾을 때 사용하는 함수는?', 3, 'medium', 'LIMIT()', 'TOP()', 'MAX()', 'HIGH()', 43, 'MAX() 함수는 컬럼에서 가장 큰 값을 반환한다.'),
                                                                                                                           (2112, 'WHERE 절에서 여러 조건을 결합할 때 사용하는 연산자는?', 1, 'low', 'AND', 'UNION', 'JOIN', 'WITH', 43, 'AND는 두 조건이 모두 참일 때만 참으로 판단되도록 결합한다.'),
                                                                                                                           (2113, 'SQL에서 BETWEEN 연산자의 역할은?', 4, 'medium', '조건을 무시한다', '두 테이블을 연결한다', 'NULL 값을 제거한다', '범위 내 값을 찾는다', 43, 'BETWEEN은 특정 범위 안에 있는 값을 조건으로 검색할 때 사용된다.'),
                                                                                                                           (2114, 'LIKE 연산자에서 와일드카드 %의 의미는?', 2, 'medium', '빈 문자열', '임의의 문자열', '정확히 한 글자', '숫자만 포함', 43, '%는 길이에 상관없이 임의의 문자열을 의미하는 와일드카드이다.'),
                                                                                                                           (2115, 'SQL에서 서브쿼리를 사용할 수 없는 곳은?', 3, 'high', 'FROM 절', 'WHERE 절', 'GROUP BY 절', 'SELECT 절', 43, 'GROUP BY 절에서는 서브쿼리를 사용할 수 없다.'),
                                                                                                                           (2116, 'PRIMARY KEY 제약 조건의 특징은?', 1, 'medium', '중복 불가 + NULL 불가', '중복 허용 + NULL 허용', '외래키 대상', '정렬 기준', 43, 'PRIMARY KEY는 고유성과 NOT NULL 제약을 모두 가진다.'),
                                                                                                                           (2117, 'DEFAULT 제약 조건은 어떤 역할인가?', 3, 'low', '외래키 설정', '고정된 상수 삽입', '값이 없을 때 기본값 설정', '항상 NULL 유지', 43, 'DEFAULT는 INSERT 시 값이 없을 경우 기본값을 자동으로 지정한다.'),
                                                                                                                           (2118, 'SQL에서 UPDATE 문의 목적은?', 1, 'low', '기존 데이터를 수정한다', '뷰를 생성한다', '테이블을 삭제한다', '새 테이블을 만든다', 43, 'UPDATE는 기존 테이블의 특정 값을 수정할 때 사용된다.'),
                                                                                                                           (2119, 'DELETE 명령과 TRUNCATE 명령의 차이점은?', 3, 'high', 'DELETE는 뷰 삭제', 'DELETE는 무조건 전체 삭제', 'TRUNCATE는 로그 없이 전체 삭제', 'TRUNCATE는 SELECT 전용', 43, 'TRUNCATE는 모든 데이터를 빠르게 삭제하지만 로그를 남기지 않기 때문에 복구가 어렵다.'),
                                                                                                                           (2120, 'FOREIGN KEY의 주 역할은?', 3, 'high', '테이블 간 자동 정렬', '값을 무작위 삽입', '다른 테이블의 레코드 참조', '인덱스 성능 향상', 43, 'FOREIGN KEY는 다른 테이블의 기본 키를 참조하여 관계를 유지한다.'),
                                                                                                                           (2121, 'SQL에서 GROUP BY와 함께 집계 함수가 아닌 것은?', 2, 'medium', 'AVG()', 'FORMAT()', 'COUNT()', 'SUM()', 43, 'FORMAT()은 숫자 또는 날짜 형식을 지정하는 함수이며 집계 함수는 아니다.'),
                                                                                                                           (2122, 'SQL에서 여러 조건 중 하나만 만족하면 참이 되는 연산자는?', 3, 'low', 'EXISTS', 'LIKE', 'OR', 'AND', 43, 'OR는 여러 조건 중 하나만 참이면 전체 조건을 참으로 처리한다.'),
                                                                                                                           (2123, 'NULL 값을 가진 행을 제외하고 집계하려면 어떤 함수가 적절한가?', 2, 'high', 'COUNT(ALL)', 'COUNT(column)', 'SUM(*)', 'COUNT(*)', 43, 'COUNT(column)은 NULL을 제외하고 값이 있는 행만 세기 때문에 NULL 필터링에 유리하다.'),
                                                                                                                           (2124, 'SQL에서 IN 연산자의 기능은?', 3, 'medium', '외래키 정의', '정렬 방식 지정', '여러 값 중 포함 여부 판단', '트랜잭션 시작', 43, 'IN 연산자는 여러 값 중 특정 값이 포함되는지를 조건으로 사용할 때 쓰인다.'),
                                                                                                                           (2125, 'DDL 명령어에 해당하지 않는 것은?', 4, 'medium', 'CREATE', 'ALTER', 'DROP', 'SELECT', 43, 'SELECT는 데이터를 조회하는 DML 명령어이며, DDL에는 포함되지 않는다.'),
                                                                                                                           (2126, 'SQL에서 CREATE TABLE 구문에서 정의할 수 없는 것은?', 4, 'low', '데이터 타입', '제약 조건', '컬럼 이름', '데이터 삽입값', 43, 'CREATE TABLE 구문은 테이블 구조를 정의할 뿐, 데이터를 삽입하지 않는다.'),
                                                                                                                           (2127, '테이블에서 컬럼을 제거하려면 사용하는 명령어는?', 1, 'high', 'ALTER TABLE ... DROP COLUMN', 'DROP TABLE ... COLUMN', 'REMOVE COLUMN', 'DELETE COLUMN ...', 43, 'ALTER TABLE에 DROP COLUMN을 사용하면 기존 테이블에서 컬럼을 제거할 수 있다.'),
                                                                                                                           (2128, '두 개의 SELECT 결과를 합쳐 중복 없이 반환하는 연산자는?', 2, 'medium', 'JOIN', 'UNION', 'INTERSECT', 'CONNECT', 43, 'UNION은 두 SELECT 결과를 병합하고 자동으로 중복된 행은 제거한다.'),
                                                                                                                           (2129, 'SQL에서 임시로 생성되어 사용 후 사라지는 객체는?', 1, 'high', '뷰(View)', '인덱스(Index)', '저장 프로시저(Procedure)', '트리거(Trigger)', 43, '뷰는 가상 테이블로서 임시로 정의되고 물리적인 데이터는 저장하지 않는다.'),
                                                                                                                           (2130, 'WHERE 절에 서브쿼리를 사용할 때 대표적인 키워드는?', 3, 'low', 'UPDATE', 'ORDER', 'IN', 'SET', 43, 'IN은 WHERE 절에서 서브쿼리 결과에 특정 값이 포함되는지를 확인할 때 사용된다.'),
                                                                                                                           (2131, 'SQL에서 테이블을 완전히 삭제할 때 사용하는 명령어는?', 4, 'low', 'ERASE TABLE', 'DELETE TABLE', 'REMOVE TABLE', 'DROP TABLE', 43, 'DROP TABLE은 테이블의 구조와 데이터를 모두 삭제하며 복구할 수 없다.'),
                                                                                                                           (2132, 'SQL에서 컬럼의 데이터 타입을 변경할 때 사용하는 명령어는?', 2, 'high', 'CHANGE COLUMN', 'ALTER TABLE ... MODIFY', 'EDIT TABLE', 'UPDATE TYPE', 43, 'ALTER TABLE ... MODIFY를 사용하면 기존 컬럼의 데이터 타입을 변경할 수 있다.'),
                                                                                                                           (2133, 'SQL에서 UNIQUE 제약 조건의 목적은?', 3, 'medium', '기본값 설정', '외래키 지정', '중복 방지', '정렬 유지', 43, 'UNIQUE 제약 조건은 특정 컬럼에 대해 중복된 값을 허용하지 않도록 한다.'),
                                                                                                                           (2134, '다중 테이블에서 동일한 이름의 컬럼을 사용할 때 충돌을 피하는 방법은?', 2, 'medium', 'AS로 바꾸기', '테이블명.컬럼명', '컬럼만 사용', 'USING 절 사용', 43, '테이블명.컬럼명 형식을 사용하면 테이블 간 컬럼 충돌을 방지할 수 있다.'),
                                                                                                                           (2135, 'SQL에서 결과 행의 수를 제한할 때 사용하는 키워드는?', 4, 'low', 'COUNT', 'MAX', 'TOP', 'LIMIT', 43, 'LIMIT 키워드는 결과로 출력할 행의 수를 제한할 때 사용된다.'),
                                                                                                                           (2136, 'SQL에서 데이터베이스의 현재 상태를 취소하고 이전 상태로 되돌리는 명령은?', 1, 'high', 'ROLLBACK', 'COMMIT', 'CANCEL', 'UNDO', 43, 'ROLLBACK은 트랜잭션을 취소하고 마지막 COMMIT 이전 상태로 되돌린다.'),
                                                                                                                           (2137, 'INSERT 문에서 특정 컬럼만 지정해 값을 삽입할 수 있는가?', 1, 'low', '가능하다', '모든 컬럼 필요', '불가능하다', '제약 조건 위반', 43, 'INSERT 문에서 명시한 컬럼에만 값을 지정해 삽입하는 것이 가능하다.'),
                                                                                                                           (2138, 'SQL에서 AUTO_INCREMENT를 사용하는 주 목적은?', 2, 'medium', '인덱스 자동 생성', '자동 증가 키 생성', '문자열 자동 채움', '날짜 포맷 지정', 43, 'AUTO_INCREMENT는 새로운 레코드 삽입 시 자동으로 증가하는 기본 키를 생성할 때 사용된다.'),
                                                                                                                           (2139, 'SQL에서 외래키가 참조하는 테이블을 삭제할 수 없게 하려면?', 4, 'high', 'ON DELETE CASCADE', 'ON UPDATE SET NULL', 'ON INSERT BLOCK', 'ON DELETE RESTRICT', 43, 'ON DELETE RESTRICT는 외래키가 참조 중인 경우 부모 테이블 삭제를 막는다.'),
                                                                                                                           (2140, 'SQL 표준 언어 구분에서 SELECT, INSERT는 어떤 범주인가?', 2, 'medium', 'TCL', 'DML (데이터 조작 언어)', 'DDL', 'DCL', 43, 'DML은 SELECT, INSERT, UPDATE, DELETE 등 데이터를 조작하는 명령어를 포함한다.'),
                                                                                                                           (2141, 'SQL에서 테이블을 생성하는 명령어는?', 4, 'low', 'INIT TABLE', 'NEW TABLE', 'MAKE TABLE', 'CREATE TABLE', 43, 'CREATE TABLE은 새로운 테이블을 생성하는 SQL 명령어이다.'),
                                                                                                                           (2142, '데이터베이스 트랜잭션에서 COMMIT의 의미는?', 4, 'medium', '트랜잭션 중단', '변경사항 초기화', '인덱스 재구성', '변경사항 저장', 43, 'COMMIT은 트랜잭션의 변경사항을 영구적으로 저장한다.'),
                                                                                                                           (2143, 'SQL에서 컬럼의 기본값을 설정할 때 사용하는 키워드는?', 4, 'medium', 'VALUE_SET', 'START WITH', 'INITVALUE', 'DEFAULT', 43, 'DEFAULT는 컬럼에 기본값을 설정할 때 사용하는 키워드이다.'),
                                                                                                                           (2144, '서브쿼리를 SELECT절에 사용할 경우 어떤 값이 반환되는가?', 4, 'high', '전체 테이블', '다중 행', '에러', '스칼라값', 43, 'SELECT 절의 서브쿼리는 하나의 스칼라값(단일 값)을 반환해야 한다.'),
                                                                                                                           (2145, 'SQL에서 EXISTS 조건문의 주된 기능은?', 2, 'high', '인덱스 제거', '서브쿼리 존재 여부 확인', '값 대체', '컬럼 재정의', 43, 'EXISTS는 서브쿼리의 결과가 존재하는지 여부를 조건으로 판단한다.'),
                                                                                                                           (2146, 'SQL에서 테이블 간 데이터 삽입 시 사용되는 구문은?', 3, 'high', 'COPY FROM', 'PUSH SELECT', 'INSERT INTO ... SELECT', 'JOIN INTO', 43, 'INSERT INTO ... SELECT 구문은 한 테이블의 데이터를 다른 테이블로 삽입할 때 사용된다.'),
                                                                                                                           (2147, 'SQL에서 ORDER BY는 기본적으로 어떤 순서를 따르는가?', 2, 'low', '내림차순', '오름차순', '알파벳 순', '인덱스 순', 43, 'ORDER BY는 명시하지 않으면 기본적으로 오름차순(ASC)으로 정렬된다.'),
                                                                                                                           (2148, 'SQL에서 COUNT(*)는 무엇을 계산하는가?', 4, 'low', 'NULL 제외 수', '테이블 용량', 'PK 수', '전체 행 수', 43, 'COUNT(*)는 NULL을 포함한 전체 행의 수를 계산한다.'),
                                                                                                                           (2149, 'SQL에서 제약 조건을 나중에 추가할 때 사용하는 구문은?', 3, 'medium', 'CONSTRAINT MODIFY', 'SET KEY', 'ALTER TABLE ... ADD CONSTRAINT', 'CREATE CONSTRAINT', 43, 'ALTER TABLE ... ADD CONSTRAINT를 사용하여 기존 테이블에 제약 조건을 추가할 수 있다.'),
                                                                                                                           (2150, 'SQL에서 트랜잭션이 종료되지 않았을 때 영향을 주는 명령은?', 1, 'high', 'ROLLBACK', 'GRANT', 'UNION', 'DROP', 43, 'ROLLBACK은 트랜잭션 내의 변경사항을 취소할 때 사용된다.'),
                                                                                                                           (2151, '관계형 데이터베이스(RDB)에서 데이터를 구조화하는 기본 단위는 무엇인가?', 3, 'low', '컬렉션', '도큐먼트', '테이블', '키-값 쌍', 44, '테이블은 RDB에서 데이터를 행과 열로 구성하여 구조화하는 기본 단위이다.'),
                                                                                                                           (2152, 'SQL에서 데이터를 조회할 때 사용하는 기본 명령어는?', 4, 'low', 'PULL', 'FIND', 'GET', 'SELECT', 44, 'SELECT는 SQL에서 데이터를 조회하는 기본 명령어이다.'),
                                                                                                                           (2153, 'RDB에서 각 행을 유일하게 식별하기 위해 사용하는 키는?', 3, 'low', 'Foreign Key', 'Index', 'Primary Key', 'Row ID', 44, 'Primary Key는 각 행을 고유하게 식별하기 위해 사용되는 제약 조건이다.'),
                                                                                                                           (2154, '정규화의 목적은 무엇인가?', 3, 'medium', '데이터를 중복 저장하여 성능 향상', '테이블을 무작위로 분리', '데이터 중복을 줄이고 무결성을 유지', 'SQL 쿼리를 단순화', 44, '정규화는 데이터 중복을 줄이고 무결성을 보장하여 데이터베이스의 효율을 높이는 방법이다.'),
                                                                                                                           (2155, '다음 중 외래 키(Foreign Key)에 대한 설명으로 올바른 것은?', 2, 'medium', '중복된 값을 허용하지 않는다', '다른 테이블의 기본 키를 참조한다', '같은 테이블 내에서만 사용된다', '데이터를 암호화한다', 44, '외래 키는 참조 무결성을 유지하기 위해 다른 테이블의 기본 키를 참조한다.'),
                                                                                                                           (2156, 'ACID 속성 중 ''일관성(Consistency)''은 어떤 의미인가?', 3, 'medium', '모든 트랜잭션은 동시에 실행되어야 한다', '모든 데이터는 암호화되어야 한다', '트랜잭션 수행 전후에 데이터의 무결성이 보장된다', '항상 최신 데이터를 반환한다', 44, 'Consistency는 트랜잭션 실행 전후 데이터베이스가 일관된 상태를 유지함을 의미한다.'),
                                                                                                                           (2157, 'RDBMS에서 트랜잭션이 실패했을 때 이전 상태로 되돌리는 작업은?', 2, 'high', 'COMMIT', 'ROLLBACK', 'SELECT', 'RESTORE', 44, 'ROLLBACK은 트랜잭션 실패 시 데이터를 원래 상태로 되돌린다.'),
                                                                                                                           (2158, '인덱스(Index)를 생성하는 주된 목적은?', 3, 'high', '데이터를 암호화하기 위해', '데이터를 자동으로 백업하기 위해', '데이터 접근 속도를 향상시키기 위해', '데이터 정렬 순서를 바꾸기 위해', 44, '인덱스는 테이블 검색 성능을 향상시키기 위해 사용된다.'),
                                                                                                                           (2159, 'RDB의 트랜잭션 처리에서 ''격리성(Isolation)''이 낮으면 발생할 수 있는 현상은?', 2, 'high', '데이터 누락', '동시성 문제', '성능 저하', '무결성 위반', 44, '격리성이 낮으면 트랜잭션 간 충돌로 인해 동시성 문제가 발생할 수 있다.'),
                                                                                                                           (2160, '관계형 데이터베이스에서 정규화 1NF는 무엇을 의미하는가?', 1, 'high', '모든 데이터가 원자값으로 구성되어야 함', '중복 데이터 허용', '각 테이블은 하나의 기본 키만 가져야 함', '테이블 간 연결을 금지함', 44, '1NF는 테이블의 각 컬럼이 원자값(더 이상 분해되지 않는 값)으로 구성되어야 함을 의미한다.'),
                                                                                                                           (2161, 'MySQL의 대표적인 장점은 무엇인가?', 2, 'low', '그래프 데이터 처리', '오픈소스 기반', '객체지향 설계', 'NoSQL 호환성', 44, 'MySQL은 오픈소스 기반으로 누구나 자유롭게 사용할 수 있는 점이 큰 장점이다.'),
                                                                                                                           (2162, 'PostgreSQL의 특징으로 옳은 것은?', 3, 'low', 'ACID 지원 미비', 'JSON 미지원', '확장성 강점', '비정형 데이터에 특화됨', 44, 'PostgreSQL은 확장성과 표준 SQL 지원에 강점을 가진 오픈소스 RDBMS이다.'),
                                                                                                                           (2163, 'SQLite는 어떤 상황에 적합한가?', 2, 'low', '대규모 트랜잭션 처리', '모바일 로컬 저장소', '분산 클러스터 구성', 'NoSQL 연동', 44, 'SQLite는 가볍고 설치가 필요 없어 모바일 로컬 DB로 적합하다.'),
                                                                                                                           (2164, 'Oracle DB는 주로 어떤 기업 환경에서 사용되는가?', 2, 'medium', '스타트업', '대기업 및 금융', '교육 기관', '오픈소스 커뮤니티', 44, 'Oracle DB는 고성능과 안정성을 필요로 하는 대기업과 금융권에서 많이 사용된다.'),
                                                                                                                           (2165, 'MariaDB는 어떤 데이터베이스에서 파생되었는가?', 3, 'medium', 'Oracle', 'MongoDB', 'MySQL', 'PostgreSQL', 44, 'MariaDB는 MySQL의 오픈소스 분기(fork)로 개발된 데이터베이스이다.'),
                                                                                                                           (2166, 'RDB 중 ''서브쿼리와 복잡한 조인''에 강점을 가진 것은?', 3, 'medium', 'MySQL', 'MongoDB', 'PostgreSQL', 'Redis', 44, 'PostgreSQL은 복잡한 쿼리 처리에 최적화된 고성능 관계형 데이터베이스이다.'),
                                                                                                                           (2167, '다음 중 오픈소스가 아닌 상용 RDB는?', 2, 'high', 'MySQL', 'Oracle', 'PostgreSQL', 'MariaDB', 44, 'Oracle은 상용 RDBMS이며 라이선스 비용이 필요한 제품이다.'),
                                                                                                                           (2168, 'PostgreSQL의 MVCC는 어떤 문제를 해결하기 위한 기술인가?', 3, 'high', '데이터 정렬', '보안성 강화', '동시성 제어', '문자 인코딩', 44, 'MVCC는 다중 사용자 환경에서의 동시성 문제를 해결하는 기술이다.'),
                                                                                                                           (2169, 'MySQL의 InnoDB 엔진의 특징은?', 3, 'high', '트랜잭션 미지원', '풀텍스트 검색 특화', 'ACID 지원', '클러스터 미지원', 44, 'InnoDB는 트랜잭션, 외래 키, ACID 특성을 지원하는 MySQL의 기본 저장 엔진이다.'),
                                                                                                                           (2170, 'SQL 표준 준수율이 가장 높은 DB는?', 2, 'high', 'MySQL', 'PostgreSQL', 'SQLite', 'Redis', 44, 'PostgreSQL은 다양한 SQL 표준을 충실히 따르는 데이터베이스로 평가받는다.'),
                                                                                                                           (2171, 'NoSQL의 주요 특징 중 하나는?', 3, 'low', '스키마 엄격함', '관계형 조인 강화', '유연한 구조', 'SQL 강제 사용', 44, 'NoSQL은 고정된 스키마 없이 유연하게 데이터를 저장할 수 있다.'),
                                                                                                                           (2172, 'NoSQL이 처음 주목받게 된 이유는?', 3, 'low', '모바일 호환성', '고성능 게임 서버', '웹 확장성과 대용량 처리', '스키마 고정성', 44, 'NoSQL은 웹 서비스 확장성과 대량의 비정형 데이터 처리에 유리하여 주목받게 되었다.'),
                                                                                                                           (2173, 'NoSQL의 4가지 대표 유형에 속하지 않는 것은?', 3, 'low', '키-값 저장소', '문서 지향', '객체 지향', '열 지향', 44, '객체 지향은 NoSQL의 대표적 유형이 아니며, 일반적으로는 4가지(키-값, 문서, 열, 그래프)로 분류된다.'),
                                                                                                                           (2174, '문서 지향 DB의 대표적인 예는?', 2, 'medium', 'Redis', 'MongoDB', 'Cassandra', 'MySQL', 44, 'MongoDB는 JSON과 유사한 문서(Document) 단위로 데이터를 저장하는 문서 지향 DB이다.'),
                                                                                                                           (2175, 'Column 기반 NoSQL DB는?', 3, 'medium', 'DynamoDB', 'Redis', 'Cassandra', 'MongoDB', 44, 'Cassandra는 열(Column) 기반의 분산형 NoSQL 데이터베이스이다.'),
                                                                                                                           (2176, '그래프 기반 NoSQL의 예시는?', 1, 'medium', 'Neo4j', 'MongoDB', 'MySQL', 'Elasticsearch', 44, 'Neo4j는 그래프 데이터 모델을 기반으로 관계형 데이터를 처리하는 DB이다.'),
                                                                                                                           (2177, 'BASE 속성 중 A는 무엇을 의미하는가?', 2, 'high', 'Access', 'Available', 'Atom', 'Array', 44, 'BASE의 A는 Available로, 일부 장애 상황에서도 부분적으로 사용할 수 있음을 의미한다.'),
                                                                                                                           (2178, 'NoSQL에서 스키마리스란?', 3, 'high', '데이터 무결성 강화', '정해진 테이블 구조 사용', '구조 없이 저장 가능', 'SQL 의무 사용', 44, '스키마리스(Schemaless)는 고정된 테이블 구조 없이 자유롭게 데이터를 저장할 수 있는 특징이다.'),
                                                                                                                           (2179, 'NoSQL이 관계형 DB에 비해 약한 점은?', 2, 'high', '확장성', '조인 기능', '처리 속도', '보안 기능', 44, 'NoSQL은 유연한 구조를 제공하지만 관계형 데이터 간의 조인 처리에는 약점을 가진다.'),
                                                                                                                           (2180, 'CAP 이론의 세 요소 중 일치하지 않는 것은?', 4, 'high', 'Consistency', 'Availability', 'Partition Tolerance', 'Atomicity', 44, 'Atomicity는 트랜잭션의 성질이며, CAP 이론의 요소는 아니다.'),
                                                                                                                           (2181, 'MongoDB에서 데이터를 저장하는 단위는?', 2, 'low', 'Row', 'Document', 'Tuple', 'Entity', 44, 'MongoDB는 JSON 기반의 Document 단위로 데이터를 저장한다.'),
                                                                                                                           (2182, 'Redis는 어떤 방식으로 데이터를 저장하는가?', 2, 'low', '문서 지향', '키-값', '열 기반', '트리 기반', 44, 'Redis는 빠른 조회를 위해 메모리에서 키-값 형태로 데이터를 저장한다.'),
                                                                                                                           (2183, 'Firebase는 어떤 용도로 자주 사용되는가?', 2, 'low', '정적 페이지', '서버리스 백엔드', 'BI 분석', '대용량 로그 분석', 44, 'Firebase는 모바일 앱 개발 시 서버리스 백엔드로 활용되며 인증, 실시간 DB 등을 제공한다.'),
                                                                                                                           (2184, 'Elasticsearch는 어떤 특성의 DB인가?', 2, 'medium', '키-값 저장소', '문서 기반 검색 엔진', '그래프 DB', 'SQL DB', 44, 'Elasticsearch는 문서 기반 데이터에 대한 고속 검색 기능을 제공하는 검색 엔진이다.'),
                                                                                                                           (2185, 'Cassandra는 어떤 구조 기반인가?', 3, 'medium', '키-값', '문서', '열 기반', '파일 기반', 44, 'Cassandra는 대용량 분산 처리를 위한 열 기반(Column-oriented) NoSQL DB이다.'),
                                                                                                                           (2186, 'Redis는 어떤 데이터 구조를 지원하지 않는가?', 3, 'medium', '리스트', '셋', '그래프', '해시', 44, 'Redis는 다양한 구조를 지원하지만 그래프 구조는 기본적으로 제공하지 않는다.'),
                                                                                                                           (2187, 'MongoDB의 데이터 저장 구조는 무엇을 따르는가?', 2, 'high', 'RDF 트리', 'BSON', 'CSV', 'YAML', 44, 'MongoDB는 Binary JSON(BSON) 형식으로 데이터를 저장한다.'),
                                                                                                                           (2188, 'Redis는 어떤 특성을 가지고 있는가?', 3, 'high', '디스크 기반', '비동기 처리 미지원', '인메모리 저장소', 'BLOB 저장 특화', 44, 'Redis는 모든 데이터를 메모리에서 처리하여 빠른 응답을 제공하는 인메모리 데이터베이스이다.'),
                                                                                                                           (2189, 'Cassandra는 어떤 일관성 모델을 따르는가?', 2, 'high', '강한 일관성', '약한 일관성', '혼합 일관성', '일관성 없음', 44, 'Cassandra는 높은 가용성을 위해 기본적으로 약한 일관성을 채택하고 있다.'),
                                                                                                                           (2190, '다음 중 Elasticsearch의 주된 사용 목적은?', 2, 'high', '트랜잭션 처리', '검색 최적화', '트리거 이벤트 처리', '세션 저장소', 44, 'Elasticsearch는 텍스트 기반 데이터에 대한 고속 검색과 분석을 위한 검색 최적화 DB이다.'),
                                                                                                                           (2191, '로그 데이터 저장에 가장 적합한 DB 유형은?', 3, 'low', '관계형 DB', '문서 지향 DB', '열 기반 DB', '그래프 DB', 44, '열 기반 DB는 동일 컬럼 데이터를 연속적으로 저장하여 로그처럼 대량 쓰기 및 분석 처리에 적합하다.'),
                                                                                                                           (2192, '사용자 인증과 같은 정형 데이터를 저장할 DB는?', 3, 'low', 'MongoDB', 'Redis', 'MySQL', 'Cassandra', 44, 'MySQL은 정형화된 스키마 구조를 가진 관계형 DB로 사용자 인증 데이터와 같은 구조적 데이터 저장에 적합하다.'),
                                                                                                                           (2193, '소셜 그래프 구조를 저장할 때 적합한 DB는?', 1, 'low', 'Neo4j', 'PostgreSQL', 'DynamoDB', 'Elasticsearch', 44, 'Neo4j는 그래프 DB로, 노드와 간선으로 표현되는 관계 중심 데이터(소셜 그래프)에 최적화되어 있다.'),
                                                                                                                           (2194, '단기 캐시 데이터 저장용으로 적합한 DB는?', 1, 'medium', 'Redis', 'MySQL', 'MongoDB', 'SQLite', 44, 'Redis는 인메모리 기반 키-값 저장소로, 빠른 접근이 필요한 캐시용 데이터에 적합하다.'),
                                                                                                                           (2195, '모바일 앱에서 로컬 데이터 저장용으로 적합한 DB는?', 3, 'medium', 'Oracle', 'MongoDB', 'SQLite', 'Cassandra', 44, 'SQLite는 경량형 관계형 DB로 설치 없이 파일 기반으로 작동하여 모바일 앱에 적합하다.'),
                                                                                                                           (2196, '다양한 포맷의 비정형 데이터를 저장하기 좋은 DB는?', 2, 'medium', 'MySQL', 'MongoDB', 'PostgreSQL', 'Redis', 44, 'MongoDB는 BSON 형태로 다양한 구조의 데이터를 유연하게 저장할 수 있는 문서지향 DB이다.'),
                                                                                                                           (2197, '실시간 분석과 빠른 쓰기가 필요한 경우 적합한 DB는?', 2, 'high', 'Elasticsearch', 'Redis', 'Oracle', 'Neo4j', 44, 'Redis는 메모리 기반 구조로 매우 빠른 읽기/쓰기가 가능해 실시간 처리에 적합하다.'),
                                                                                                                           (2198, '데이터 간의 관계가 복잡하게 연결된 경우 적합한 DB는?', 2, 'high', 'MySQL', 'Neo4j', 'Elasticsearch', 'DynamoDB', 44, 'Neo4j는 관계형 데이터 탐색에 최적화된 그래프 DB로, 복잡한 관계 구조에 유리하다.'),
                                                                                                                           (2199, '확장성과 장애 허용성이 중요한 경우 선택할 DB는?', 3, 'high', 'Redis', 'PostgreSQL', 'Cassandra', 'SQLite', 44, 'Cassandra는 분산 구조 기반으로 높은 확장성과 장애 허용성을 제공한다.'),
                                                                                                                           (2200, '대규모 사용자 기반의 채팅 앱에서 상태 저장에 적합한 DB는?', 1, 'high', 'Redis', 'MySQL', 'Neo4j', 'Elasticsearch', 44, 'Redis는 빠른 접근 속도와 Pub/Sub 기능으로 실시간 상태 정보 처리에 적합하다.'),
                                                                                                                           (2201, 'SQL에서 실행 계획을 분석할 수 있도록 해주는 명령어는?', 2, 'low', 'SHOW CREATE TABLE', 'EXPLAIN', 'DESCRIBE', 'ANALYZE', 45, 'EXPLAIN은 SQL 쿼리의 실행 계획을 보여주어 성능 분석에 활용된다.'),
                                                                                                                           (2202, 'SQL 옵티마이저(Optimizer)의 역할은 무엇인가?', 2, 'low', '데이터 백업', '최적 실행 계획 선택', '스키마 정리', '사용자 인증', 45, '옵티마이저는 다양한 실행 경로 중 비용이 가장 적은 쿼리 실행 계획을 선택한다.'),
                                                                                                                           (2203, 'SELECT * 대신 컬럼을 명시하는 것이 성능에 좋은 이유는?', 3, 'low', '트랜잭션 보호', '데이터 무결성 보장', '불필요한 데이터 조회 방지', '쿼리 결과를 암호화', 45, '명시적 컬럼 지정은 필요한 데이터만 조회하여 불필요한 I/O를 줄인다.'),
                                                                                                                           (2204, '다음 중 SQL 실행 순서가 올바른 것은?', 2, 'medium', 'SELECT → FROM → WHERE', 'FROM → WHERE → SELECT', 'WHERE → SELECT → FROM', 'GROUP BY → FROM → SELECT', 45, 'SQL 실행은 FROM → WHERE → SELECT 순으로 처리된다.'),
                                                                                                                           (2205, '다음 중 실행 계획에서 ''Full Table Scan''이 발생하는 이유가 아닌 것은?', 3, 'medium', '인덱스가 없음', 'WHERE 조건이 항상 TRUE', 'ORDER BY가 존재함', '함수 적용된 WHERE 조건', 45, 'ORDER BY는 인덱스 유무와 무관하게 발생하며 Full Table Scan의 직접 원인은 아니다.'),
                                                                                                                           (2206, '오라클의 실행 계획 도구인 ''AUTOTRACE''의 기능은?', 3, 'medium', '인덱스 생성', '쿼리 결과 수정', '실행 계획과 통계 정보 제공', '데이터를 외부로 내보냄', 45, 'AUTOTRACE는 쿼리 실행 계획과 관련 통계 정보를 출력해 성능 분석에 유용하다.'),
                                                                                                                           (2207, '다음 중 옵티마이저가 쿼리 실행 계획을 세울 때 고려하지 않는 요소는?', 3, 'high', '테이블 통계 정보', '인덱스 존재 여부', '서버의 RAM 용량', '조인 방식', 45, '서버의 RAM 용량은 실행 환경 요소이며 실행 계획 자체에는 영향을 주지 않는다.'),
                                                                                                                           (2208, '쿼리 튜닝 시 옵티마이저 힌트(Hint)의 역할은?', 3, 'high', '쿼리 실행을 차단함', '테이블을 삭제함', '옵티마이저에게 힌트를 제공하여 실행 방식을 유도함', 'SQL 구문을 자동 완성함', 45, '힌트는 옵티마이저에 특정 인덱스 사용이나 조인 방식을 권유하는 역할을 한다.'),
                                                                                                                           (2209, '다음 중 Cost-Based Optimizer(CBO)의 특징은?', 3, 'high', '하드코딩된 규칙만 사용', '쿼리 구조만 고려', '통계 정보를 기반으로 비용을 계산함', '항상 빠른 쿼리를 선택함', 45, 'CBO는 통계 기반으로 실행 비용을 계산하여 최적의 계획을 선택한다.'),
                                                                                                                           (2210, '실행 계획에서 Nested Loop Join은 어떤 상황에서 적합한가?', 2, 'high', '두 테이블 모두 대용량일 때', '조인 대상이 모두 인덱스일 때', '정렬이 필요한 경우', '서브쿼리가 있을 때', 45, 'Nested Loop Join은 소량 데이터 + 인덱스가 있을 때 효율적으로 작동한다.'),
                                                                                                                           (2211, '인덱스를 사용하면 가장 크게 기대할 수 있는 효과는?', 3, 'low', '데이터 보안 강화', '데이터 중복 제거', '조회 성능 향상', '스토리지 감소', 45, '인덱스는 조건 검색 속도를 높여 전체 조회 성능을 향상시킨다.'),
                                                                                                                           (2212, '다음 중 RDB에서 가장 일반적으로 사용되는 인덱스 구조는?', 1, 'low', 'B-Tree', '해시맵', 'Linked List', 'R-Tree', 45, 'B-Tree는 범위 검색이 가능한 기본 인덱스 구조로 대부분의 RDB에서 사용된다.'),
                                                                                                                           (2213, 'WHERE 절에 사용되는 컬럼에 인덱스를 걸면 좋은 이유는?', 3, 'low', '쿼리 실행 순서를 바꾸기 위해', 'GROUP BY 연산을 빠르게 하려고', '조건 검색 속도를 향상시키기 위해', '트랜잭션을 줄이기 위해', 45, '인덱스는 WHERE 조건에 빠르게 접근 가능하여 조회 성능을 높인다.'),
                                                                                                                           (2214, '다음 중 인덱스를 사용해도 효과가 떨어지는 상황은?', 4, 'medium', 'LIKE ‘A%’ 조건', '정렬된 숫자 검색', '범위 조건 사용', 'LIKE ‘%A’ 조건', 45, 'LIKE ‘%A’는 와일드카드가 앞에 있어 인덱스 탐색을 사용할 수 없다.'),
                                                                                                                           (2215, '복합 인덱스 A, B가 있을 때 A만 WHERE 조건에 쓰면?', 2, 'medium', '인덱스 사용 안 됨', '효과적으로 인덱스 사용됨', '에러 발생', '인덱스를 무조건 재구성해야 함', 45, '선두 컬럼인 A만 사용해도 인덱스의 범위 검색이 가능하다.'),
                                                                                                                           (2216, '해시 인덱스는 어떤 작업에 적합한가?', 3, 'medium', '범위 검색', '정렬', '정확한 키 검색', 'JOIN 연산', 45, '해시 인덱스는 정확한 키 값 탐색에 매우 빠른 성능을 보인다.'),
                                                                                                                           (2217, 'Covering Index의 주요 특징은?', 2, 'high', '모든 값을 복사해 저장', '인덱스만으로 결과를 반환할 수 있음', '쓰기 성능이 향상됨', '컬럼 순서를 무시함', 45, 'Covering Index는 테이블 접근 없이 인덱스만으로 결과 반환이 가능하다.'),
                                                                                                                           (2218, '다음 중 인덱스 사용률을 높이는 SQL 스타일은?', 3, 'high', '함수 안에 컬럼을 넣기', '가공된 값을 조건으로 비교', '컬럼 그대로 WHERE 절에서 사용', 'DISTINCT를 다수 사용', 45, '컬럼 가공 없이 그대로 WHERE에 사용하는 것이 인덱스 활용에 유리하다.'),
                                                                                                                           (2219, '다음 중 클러스터형 인덱스(Clustered Index)에 대한 설명으로 옳은 것은?', 3, 'high', '데이터 정렬과 무관하게 저장', '인덱스가 따로 존재하며 별도로 관리됨', '데이터 자체가 인덱스 구조로 정렬됨', '조회 시 항상 느리다', 45, '클러스터형 인덱스는 데이터가 인덱스 순서대로 물리적으로 저장된다.'),
                                                                                                                           (2220, '다음 중 인덱스를 사용하는데 가장 방해가 되는 요소는?', 3, 'high', 'ORDER BY 절', 'GROUP BY 절', 'WHERE 조건에 함수 사용', 'LIMIT 절', 45, 'WHERE 절에 함수가 포함되면 인덱스를 사용할 수 없게 되어 성능이 저하된다.'),
                                                                                                                           (2221, '다음 중 쿼리 성능을 가장 직접적으로 향상시킬 수 있는 작업은?', 2, 'low', 'SELECT * 사용', '인덱스 설계', 'JOIN 순서 무작위 변경', '쿼리 이름 지정', 45, '인덱스를 적절히 설계하면 데이터 검색 속도를 획기적으로 개선할 수 있으므로 성능에 가장 직접적인 영향을 준다.'),
                                                                                                                           (2222, '서브쿼리를 사용했을 때의 단점은?', 2, 'low', '가독성 향상', '성능 저하 가능성', '데이터 정합성 증가', '보안 강화', 45, '서브쿼리는 중첩 구조로 인해 실행 계획이 복잡해지고 성능이 저하될 가능성이 있다.'),
                                                                                                                           (2223, '다음 중 쿼리 리팩토링의 효과가 아닌 것은?', 2, 'low', '유지보수 편의성 향상', '결과 정확도 감소', '성능 향상 가능성', '가독성 향상', 45, '쿼리 리팩토링은 성능과 가독성을 향상시키는 작업이며, 결과 정확도는 감소하지 않는다.'),
                                                                                                                           (2224, '다음 중 INNER JOIN과 성능 차이가 가장 클 수 있는 JOIN 방식은?', 3, 'medium', 'LEFT JOIN', 'RIGHT JOIN', 'OUTER JOIN', 'SELF JOIN', 45, 'OUTER JOIN은 NULL을 포함한 결과를 반환하므로 처리 비용이 높아져 INNER JOIN과 성능 차이가 클 수 있다.'),
                                                                                                                           (2225, '다음 중 LIMIT 구문의 사용 목적은?', 2, 'medium', '테이블 잠금', '결과 데이터의 수 제한', '데이터 중복 제거', '쿼리 실행 중지', 45, 'LIMIT은 쿼리 결과의 행 수를 제한하여 불필요한 데이터 조회를 방지한다.'),
                                                                                                                           (2226, '다음 중 COUNT(*)의 성능 개선 방법으로 적절한 것은?', 3, 'medium', '서브쿼리로 COUNT 분리', 'WHERE 조건 제거', '별도 통계 테이블 유지', 'DISTINCT 사용', 45, 'COUNT 연산은 전체 스캔을 유발할 수 있으므로 별도의 통계 테이블을 유지하여 성능을 개선할 수 있다.'),
                                                                                                                           (2227, '다음 중 인덱스를 사용하지 못하도록 만드는 조건은?', 3, 'high', 'WHERE id = 10', 'WHERE name LIKE ''A%''', 'WHERE UPPER(name) = ''A''', 'WHERE age BETWEEN 20 AND 30', 45, '함수(예: UPPER)를 사용하면 인덱스를 무시하고 전체 스캔을 하게 되어 성능이 저하된다.'),
                                                                                                                           (2228, '다음 중 서브쿼리를 JOIN으로 바꾸는 이유로 적절하지 않은 것은?', 1, 'high', '결과 정확도 향상', '성능 향상', '가독성 향상', '옵티마이저의 최적화 가능성 증가', 45, 'JOIN으로 변경해도 결과 정확도가 향상되는 것은 아니며, 주로 성능이나 최적화를 위해 변경한다.'),
                                                                                                                           (2229, '다음 중 EXISTS와 IN의 주요 차이는?', 3, 'high', 'EXISTS는 정렬함', 'IN은 항상 빠름', 'EXISTS는 조건 만족 시 바로 종료함', 'IN은 조건을 하나씩 수행함', 45, 'EXISTS는 조건을 만족하는 즉시 실행을 종료하기 때문에 IN보다 효율적인 경우가 많다.'),
                                                                                                                           (2230, '다음 중 성능 테스트 시 주의할 점으로 옳지 않은 것은?', 3, 'high', '캐시 초기화 상태 확인', '데이터량에 따른 실행 시간 측정', '최초 실행 시간만 기준으로 판단', '실행 계획 비교', 45, '최초 실행 시간만으로 판단하면 캐시 등의 영향을 무시하므로 정확한 성능 분석이 어렵다.'),
                                                                                                                           (2231, '정규화의 주요 목적은 무엇인가?', 3, 'low', '데이터 중복 증가', '데이터 정렬', '데이터 무결성 유지', '조회 성능 저하', 45, '정규화는 데이터의 중복을 제거하고 무결성을 유지하기 위해 수행된다.'),
                                                                                                                           (2232, '1NF(제1정규형)의 핵심 조건은?', 2, 'low', '모든 컬럼은 기본 키에 종속되어야 함', '원자값만 저장', '이행적 종속 제거', '다대다 관계 제거', 45, '1NF는 각 컬럼이 더 이상 나눌 수 없는 원자값을 저장해야 한다는 원칙이다.'),
                                                                                                                           (2233, '2NF를 만족하려면 무엇을 제거해야 하는가?', 1, 'low', '부분적 함수 종속', '이행적 종속', '후보 키', '기본 키', 45, '2NF는 기본 키의 일부분에만 종속된 속성(부분 종속)을 제거하여야 만족된다.'),
                                                                                                                           (2234, '제3정규형(3NF)은 어떤 종속을 제거하는가?', 2, 'medium', '부분 종속', '이행적 종속', '다치 종속', '후보키 종속', 45, '3NF는 기본 키가 아닌 속성이 다른 비기본 속성에 종속되는 이행적 종속을 제거한다.'),
                                                                                                                           (2235, '다음 중 정규화를 적용했을 때 기대되는 효과는?', 3, 'medium', '데이터 정합성 저하', '쿼리 복잡도 감소', '데이터 중복 감소', '성능 저하', 45, '정규화를 하면 데이터의 중복이 줄어들고 정합성이 높아진다.'),
                                                                                                                           (2236, '정규화된 테이블을 비정규화할 때의 이점은?', 3, 'medium', '관리 복잡도 증가', '관계도 증가', '조회 성능 향상', '정합성 강화', 45, '비정규화는 테이블 간 JOIN을 줄여 조회 속도를 향상시킬 수 있다.'),
                                                                                                                           (2237, '다음 중 비정규화의 단점은?', 1, 'high', '데이터 중복 증가', '정규화보다 더 많은 테이블', '조회 성능 저하', '무결성 자동 보장', 45, '비정규화는 동일 데이터를 여러 테이블에 저장하게 되어 중복이 증가한다.'),
                                                                                                                           (2238, '정규화와 비정규화를 결정할 때 가장 중요하게 고려해야 할 것은?', 3, 'high', '쿼리 최적화 방식', '시스템의 메모리 크기', '데이터 정합성과 성능의 균형', '트리거 개수', 45, '정규화와 비정규화는 데이터 정합성과 성능 간의 트레이드오프를 고려해 결정해야 한다.'),
                                                                                                                           (2239, 'BCNF는 어떤 상황에서 필요해지는가?', 1, 'high', '3NF보다 더 높은 무결성이 필요할 때', '2NF를 만족할 때', '모든 키가 기본 키일 때', '후보 키가 하나일 때', 45, 'BCNF는 결정자가 후보 키가 아닐 때 발생하는 이상을 제거하여 무결성을 강화한다.'),
                                                                                                                           (2240, '다음 중 정규화된 모델보다 비정규화된 모델이 유리한 경우는?', 3, 'high', '데이터 변경이 자주 일어날 때', '데이터 정합성이 가장 중요할 때', '읽기 성능이 매우 중요할 때', '데이터 중복을 피해야 할 때', 45, '읽기 성능이 중요한 경우 비정규화를 통해 JOIN을 줄이고 조회 속도를 높일 수 있다.'),
                                                                                                                           (2241, '다음 중 데이터베이스 성능 저하의 일반적인 원인은?', 3, 'low', '정규화 완료', '인덱스 과다 사용', '인덱스 미사용', '쿼리 캐시 사용', 45, '인덱스를 사용하지 않으면 테이블 전체를 스캔하게 되어 성능이 저하된다.'),
                                                                                                                           (2242, 'DB 서버에 병목 현상이 발생하는 주요 원인이 아닌 것은?', 3, 'low', '디스크 I/O 과다', '네트워크 지연', '불필요한 인덱스 제거', '동시 접속 증가', 45, '불필요한 인덱스 제거는 오히려 성능 최적화에 도움이 되므로 병목 원인이 아니다.'),
                                                                                                                           (2243, '실시간으로 대용량 데이터를 빠르게 처리하고자 할 때 적절한 전략은?', 2, 'low', '정규화 수행', '비정규화 및 파티셔닝', '뷰(view) 사용', '모든 데이터를 캐싱', 45, '비정규화와 파티셔닝은 데이터 분산과 조회 성능을 높이는 데 유리하다.'),
                                                                                                                           (2244, '수직 파티셔닝은 어떤 기준으로 테이블을 나누는가?', 2, 'medium', '행(Row)', '컬럼(Column)', '데이터 타입', '사용자 그룹', 45, '수직 파티셔닝은 테이블을 컬럼 단위로 나누어 I/O 성능을 개선한다.'),
                                                                                                                           (2245, '데이터를 파티셔닝하는 주요 목적은?', 3, 'medium', '데이터 정렬', '보안 향상', '성능 향상 및 확장성 확보', '데이터 중복', 45, '파티셔닝은 대용량 데이터를 효율적으로 분산시켜 성능과 확장성을 높인다.'),
                                                                                                                           (2246, '다음 중 파티셔닝을 적용하기 좋은 상황은?', 3, 'medium', '소규모 정적 데이터 처리', '읽기보다 쓰기가 많은 데이터', '시간에 따라 분리되는 대용량 로그', '서브쿼리 많은 상황', 45, '시간에 따라 분리되는 로그 데이터는 파티셔닝을 통해 효율적으로 관리할 수 있다.'),
                                                                                                                           (2247, '데이터베이스 성능 모니터링 도구가 수집하지 않는 정보는?', 4, 'high', 'CPU 사용률', '네트워크 대역폭', '쿼리 실행 시간', '개발자 수', 45, '개발자 수는 DB 성능과 직접적인 관련이 없으며, 모니터링 도구의 수집 대상도 아니다.'),
                                                                                                                           (2248, '실시간 대시보드에서 성능을 높이기 위한 전략은?', 2, 'high', '정규화된 테이블 조인', '최소 쿼리 요청, 캐시 활용', '모든 쿼리 서버 측 실행', '복잡한 집계 로직 도입', 45, '실시간 성능을 위해서는 쿼리 수를 줄이고 캐시를 적극 활용하는 것이 효과적이다.'),
                                                                                                                           (2249, '읽기 부하가 큰 서비스에서 효과적인 구조는?', 2, 'high', '쓰기 전용 인스턴스', '읽기 전용 복제본(Read Replica) 구성', '트리거 사용 증가', '정규화 강화', 45, '읽기 전용 복제본은 읽기 요청을 분산시켜 주 인스턴스의 부담을 줄여준다.'),
                                                                                                                           (2250, '분산 DB 시스템에서 데이터 일관성보다 가용성을 우선할 때의 전략은?', 3, 'high', 'CAP 중 C 보장', 'ACID 보장 강화', 'Eventually Consistent 모델 사용', '동기식 복제만 사용', 45, 'Eventually Consistent는 즉시 일관성 대신 고가용성을 확보하는 분산 DB 전략이다.'),
                                                                                                                           (2251, 'Java에서 클래스가 객체로 생성되기 위해 사용하는 키워드는?', 3, 'low', 'define', 'instanceof', 'new', 'object', 46, 'Java에서 객체를 생성할 때 사용하는 키워드는 new이며, 이는 클래스의 인스턴스를 생성하는 데 사용된다.'),
                                                                                                                           (2252, 'Spring에서 IoC(제어의 역전)가 의미하는 것은?', 3, 'low', '개발자가 직접 객체를 관리', '사용자 요청을 직접 제어', '객체의 제어를 컨테이너가 담당', '데이터를 하드코딩으로 처리', 46, 'IoC는 객체의 생성과 의존성 관리를 Spring 컨테이너에 위임하는 개념으로, 개발자가 아닌 컨테이너가 객체를 관리한다.'),
                                                                                                                           (2253, '다음 중 Spring에서 의존성 주입(DI)을 구현할 수 있는 방법이 아닌 것은?', 4, 'low', '생성자 주입', '세터 주입', '필드 주입', '상속 주입', 46, '상속은 객체 간 의존성을 해결하는 방법이 아니므로 DI 방식으로 사용되지 않는다.'),
                                                                                                                           (2254, 'Java의 접근 제어자 중 같은 클래스에서만 접근 가능한 것은?', 1, 'medium', 'private', 'protected', 'public', 'default', 46, 'private은 선언된 클래스 내부에서만 접근할 수 있어, 같은 클래스에서만 접근 가능하다.'),
                                                                                                                           (2255, '@SpringBootApplication 어노테이션은 무엇을 포함하는가?', 2, 'medium', '@Entity, @Bean', '@Configuration, @EnableAutoConfiguration, @ComponentScan', '@RestController, @Autowired', '@Service, @Repository', 46, '@SpringBootApplication은 Spring Boot의 자동 설정과 컴포넌트 스캔 기능을 포함하는 주요 어노테이션들을 종합한 것이다.'),
                                                                                                                           (2256, 'Java에서 오버라이딩(Overriding)은 어떤 경우 사용하는가?', 2, 'medium', '같은 클래스에서 같은 이름의 메서드 정의', '부모 클래스의 메서드를 자식 클래스에서 재정의', '같은 클래스에서 메서드명을 바꿔 재정의', 'static 메서드를 변경', 46, '오버라이딩은 상속 관계에서 부모 클래스의 메서드를 자식 클래스에서 재정의할 때 사용된다.'),
                                                                                                                           (2257, 'Spring에서 Bean을 생성하고 관리하는 핵심 컨테이너는?', 3, 'medium', 'HttpSession', 'ServletContext', 'ApplicationContext', 'WebSocketContext', 46, 'ApplicationContext는 Bean의 생성, 주입, 생명주기 등을 관리하는 Spring의 핵심 컨테이너이다.'),
                                                                                                                           (2258, 'Java에서 null을 반환할 수 있는 메서드를 대체하기 위한 클래스는?', 3, 'high', 'Void', 'Nullable', 'Optional', 'Maybe', 46, 'Optional은 값이 존재할 수도 있고 없을 수도 있는 상황을 명시적으로 표현할 수 있어 null 반환을 대체한다.'),
                                                                                                                           (2259, 'Spring에서 Bean의 라이프사이클 중 객체가 생성된 후 초기화를 위한 메서드는?', 1, 'high', '@PostConstruct', '@InitBinder', '@Autowired', '@PreDestroy', 46, '@PostConstruct는 Bean 생성 후 초기화 작업을 수행할 수 있도록 지정하는 어노테이션이다.'),
                                                                                                                           (2260, '다음 중 Java의 예외(Exception) 처리 방식으로 올바른 것은?', 1, 'high', 'try-catch-finally', 'assert-try-catch', 'if-throw-catch', 'try-return', 46, 'Java의 표준 예외 처리 방식은 try-catch-finally 블록을 사용하는 구조이다.'),
                                                                                                                           (2261, '3계층 아키텍처에서 Controller의 주요 역할은?', 3, 'low', '비즈니스 로직을 처리', '데이터베이스 쿼리를 직접 실행', '사용자의 요청을 받아 Service에 전달', 'Entity를 직접 리턴', 46, 'Controller는 사용자 요청을 받아 Service 계층에 전달하고 결과를 반환하는 역할을 한다.'),
                                                                                                                           (2262, 'Service 계층의 주요 책임은?', 3, 'low', 'HTML 응답을 구성한다', '데이터를 화면에 표시한다', '비즈니스 로직을 수행한다', '파일 시스템과 통신한다', 46, 'Service 계층은 Controller에서 받은 요청을 처리하며 실제 비즈니스 로직을 수행하는 핵심 계층이다.'),
                                                                                                                           (2263, 'DTO의 주요 목적은?', 2, 'low', 'JPA 쿼리 최적화', '계층 간 필요한 데이터만 전달', '데이터베이스 매핑', '보안 설정 구성', 46, 'DTO는 계층 간에 필요한 데이터만 전송하여 의존성을 줄이고 효율적인 데이터 전달을 가능하게 한다.'),
                                                                                                                           (2264, 'Entity와 VO(Value Object)의 주요 차이는?', 3, 'medium', 'Entity는 값을 비교하고, VO는 참조를 비교한다', 'VO는 식별자가 있고, Entity는 없다', 'Entity는 식별자를 가지며 VO는 값 자체로 동등성 판단', 'VO는 DB에 저장되며 Entity는 캐시에 저장된다', 46, 'Entity는 식별자를 기반으로 관리되며 VO는 불변 객체로 값 자체로 동등성을 판단한다.'),
                                                                                                                           (2265, 'Repository의 책임으로 올바른 것은?', 1, 'medium', '데이터 접근 및 조작', '사용자 요청 처리', '에러 로그 기록', 'API 응답 캐싱', 46, 'Repository는 DB에 접근하고 데이터를 조회 및 조작하는 역할을 맡는다.'),
                                                                                                                           (2266, 'Spring의 의존성 주입(DI)을 통해 얻을 수 있는 효과는?', 3, 'medium', '코드 실행 속도 향상', '컴파일 타임 단축', '결합도 감소 및 테스트 용이성 향상', 'JVM 메모리 최적화', 46, 'DI는 객체 간 결합도를 낮추고 테스트를 쉽게 하며 유지보수를 개선하는 효과가 있다.'),
                                                                                                                           (2267, '다음 중 계층 구조를 따르지 않을 때 발생할 수 있는 문제는?', 2, 'high', '보안 강화', '단일 책임 원칙 위반', '응답 속도 향상', '캐시 히트율 증가', 46, '계층 구조를 무시하면 각 계층의 역할이 흐려져 단일 책임 원칙이 위반될 수 있다.'),
                                                                                                                           (2268, '다음 중 VO(Value Object)의 특성으로 적절한 것은?', 2, 'high', '식별자를 기반으로 관리', '불변 객체로 사용', 'JPA Repository로 관리', '비즈니스 로직 수행', 46, 'VO는 값 자체로 의미가 있으며 불변성을 유지하여 동일성보다는 동등성 비교를 중시한다.'),
                                                                                                                           (2269, 'DTO를 Entity로 변환하는 방법으로 가장 적절한 것은?', 2, 'high', '컨트롤러에서 직접 Entity 생성', 'Service 계층에서 변환 로직 구현', 'Repository에서 자동 변환', 'HTML 템플릿에서 처리', 46, 'DTO → Entity 변환은 비즈니스 로직에 속하므로 Service 계층에서 수행하는 것이 적절하다.'),
                                                                                                                           (2270, '계층 구조 설계의 가장 큰 장점 중 하나는?', 3, 'high', '코드 길이 단축', '정렬 속도 향상', '유지보수성과 테스트 용이성', '화면 렌더링 속도 향상', 46, '계층 구조는 역할 분리와 의존성 최소화로 유지보수성과 테스트 용이성을 높여준다.'),
                                                                                                                           (2271, '@Entity 어노테이션은 어떤 클래스를 대상으로 사용되는가?', 2, 'low', '컨트롤러 클래스', '데이터베이스 테이블과 매핑되는 클래스', 'DTO 클래스', '뷰(View) 클래스', 46, '@Entity는 JPA에서 DB 테이블과 매핑되는 클래스에 선언하는 어노테이션이다.'),
                                                                                                                           (2272, 'JPA에서 기본 키 생성을 위한 어노테이션은?', 4, 'low', '@Primary', '@Generated', '@Id', '@GeneratedValue', 46, '@GeneratedValue는 기본 키 값을 자동으로 생성할 때 사용하는 어노테이션이다.'),
                                                                                                                           (2273, 'Spring Data JPA에서 findById() 메서드가 반환하는 타입은?', 2, 'low', 'Entity', 'Optional<Entity>', 'List<Entity>', 'void', 46, 'findById는 결과가 없을 수 있으므로 Optional로 감싸 null 처리를 유연하게 할 수 있다.'),
                                                                                                                           (2274, 'JPA의 영속성 컨텍스트(Persistence Context)의 주요 역할은?', 3, 'medium', '트랜잭션을 종료한다', 'DB 커넥션을 유지한다', '엔티티 객체를 1차 캐시에 저장하고 관리한다', 'SQL 쿼리를 자동 분석한다', 46, '영속성 컨텍스트는 엔티티를 메모리에 저장하여 동일성을 유지하고 성능을 최적화한다.'),
                                                                                                                           (2275, 'Spring에서 @Transactional을 사용하는 이유는?', 3, 'medium', 'HTTP 요청 처리를 위해', '서버 부하 분산', '트랜잭션 단위로 작업을 처리하기 위해', 'Entity를 자동 생성하기 위해', 46, '@Transactional은 데이터 일관성을 보장하기 위해 트랜잭션 단위로 작업을 처리하는 데 사용된다.'),
                                                                                                                           (2276, '@Query 어노테이션은 언제 사용하는가?', 2, 'medium', 'DTO를 생성할 때', '기본 메서드로 처리 불가능한 쿼리를 직접 작성할 때', 'API 요청을 받을 때', 'Entity 클래스를 정의할 때', 46, '@Query는 JPQL 또는 SQL을 직접 정의하여 복잡한 조회 쿼리를 작성할 때 사용된다.'),
                                                                                                                           (2277, 'JPA에서 연관 관계를 정의할 때 사용하는 어노테이션은?', 3, 'high', '@Relationship', '@RelationMapping', '@OneToMany / @ManyToOne', '@EntityJoin', 46, 'JPA에서는 연관 관계 매핑을 위해 @OneToMany, @ManyToOne, @OneToOne 등의 어노테이션을 사용한다.'),
                                                                                                                           (2278, '트랜잭션의 전파 속성 중 Propagation.REQUIRES_NEW의 의미는?', 2, 'high', '기존 트랜잭션이 있으면 참여', '기존 트랜잭션이 있으면 종료하고 새 트랜잭션 시작', '항상 기존 트랜잭션에 참여', '트랜잭션을 비활성화', 46, 'REQUIRES_NEW는 현재 트랜잭션이 있어도 새 트랜잭션을 시작하고 기존 트랜잭션과 별도로 동작한다.'),
                                                                                                                           (2279, 'JPA에서 Lazy Loading의 특징은?', 3, 'high', '즉시 모든 연관 데이터를 로딩', '쿼리 실행 시 연관 객체를 모두 미리 로딩', '필요할 때 연관 객체를 조회', '데이터를 캐시에 저장하지 않음', 46, 'Lazy Loading은 실제 객체 사용 시점에 연관 데이터를 조회하여 성능을 최적화한다.'),
                                                                                                                           (2280, '트랜잭션 격리 수준 중 가장 높은 단계는?', 4, 'high', 'READ UNCOMMITTED', 'READ COMMITTED', 'REPEATABLE READ', 'SERIALIZABLE', 46, 'SERIALIZABLE은 가장 높은 트랜잭션 격리 수준으로, 동시성 문제를 방지하지만 성능 비용이 크다.'),
                                                                                                                           (2281, 'Spring Security의 가장 핵심 기능은 무엇인가?', 3, 'low', '데이터베이스 관리', 'API 속도 최적화', '웹 애플리케이션의 인증과 인가 처리', 'HTML 템플릿 렌더링', 46, 'Spring Security는 웹 애플리케이션의 보안을 위한 프레임워크로, 인증(Authentication)과 인가(Authorization)가 핵심 기능이다.'),
                                                                                                                           (2282, 'Spring Security에서 인증(Authentication)은 무엇을 의미하는가?', 2, 'low', '요청 데이터를 검증하는 과정', '사용자의 신원을 확인하는 과정', '비밀번호 암호화 처리', '로그 기록 저장', 46, '인증은 사용자가 누구인지를 확인하는 과정으로, 주로 사용자명과 비밀번호를 이용한다.'),
                                                                                                                           (2283, '@PreAuthorize 어노테이션은 어떤 용도로 사용되는가?', 3, 'low', 'API 문서 생성을 위해', '데이터베이스 연결 설정', '메서드 실행 전에 권한 검사 수행', '클래스 로딩을 지연시킴', 46, '@PreAuthorize는 메서드 실행 전에 권한을 검사하여 접근 제어를 수행할 수 있도록 해준다.'),
                                                                                                                           (2284, 'JWT에서 Access Token이 하는 역할은?', 2, 'medium', '비밀번호 저장', '사용자의 인증 정보를 포함한 토큰으로 요청 시 사용', '쿠키를 암호화하는 방식', 'DB 세션 관리를 위한 키', 46, 'Access Token은 사용자의 인증 정보를 포함하고 있어, 인증된 사용자인지를 확인하기 위해 서버에 전송된다.'),
                                                                                                                           (2285, 'Spring Security에서 필터 기반 인증 구조의 시작점은?', 3, 'medium', 'UserDetailsService', 'SecurityConfig', 'UsernamePasswordAuthenticationFilter', 'PasswordEncoder', 46, 'UsernamePasswordAuthenticationFilter는 인증 과정을 수행하는 필터로, 필터 체인의 시작점에 해당한다.'),
                                                                                                                           (2286, 'Swagger의 주요 기능은?', 2, 'medium', '보안 토큰 암호화', 'API 명세서 자동 생성 및 테스트 지원', 'JPA 쿼리 자동 생성', 'Java 코드 컴파일', 46, 'Swagger는 API 명세를 자동으로 문서화하고, 테스트 기능을 제공해 개발 생산성을 높인다.'),
                                                                                                                           (2287, 'Swagger UI의 기본 접근 경로는?', 3, 'medium', '/swagger-ui', '/docs', '/swagger-ui.html', '/api/swagger', 46, '기본 설정 시 Swagger UI는 /swagger-ui.html 경로로 접근할 수 있다.'),
                                                                                                                           (2288, 'Spring Security에서 UserDetailsService는 어떤 역할을 하는가?', 3, 'high', '토큰 유효성 검사', '비밀번호 암호화 설정', '사용자 인증 정보를 DB에서 로드', 'API 응답 형식 지정', 46, 'UserDetailsService는 DB에서 사용자 정보를 불러와 인증에 활용하는 핵심 컴포넌트이다.'),
                                                                                                                           (2289, 'Swagger 문서에서 메서드 설명을 추가할 때 사용하는 어노테이션은?', 2, 'high', '@ApiParam', '@ApiOperation', '@DocField', '@ApiInfo', 46, '@ApiOperation은 Swagger 문서에서 특정 API 메서드의 설명을 추가하는 데 사용된다.'),
                                                                                                                           (2290, 'JWT 기반 인증 시스템의 장점으로 옳은 것은?', 1, 'high', '세션 유지 없이 상태 기반 인증 구현 가능', '서버에 세션 저장 공간이 필요하다', '매 요청마다 DB 조회가 필수다', 'CSRF 보호가 기본 내장되어 있다', 46, 'JWT는 서버가 세션을 저장하지 않고도 인증 정보를 유지할 수 있는 무상태(stateless) 인증을 제공한다.'),
                                                                                                                           (2291, 'Kotlin Coroutine의 가장 큰 특징은?', 2, 'low', '동기적으로 실행된다', '스레드 블로킹 없이 비동기 처리를 가능하게 한다', 'JVM에서 실행되지 않는다', '항상 새로운 스레드를 생성한다', 46, 'Coroutine은 비동기 처리를 스레드 블로킹 없이 처리할 수 있어 효율적인 병렬 처리를 가능하게 한다.'),
                                                                                                                           (2292, 'Spring에서 @Async를 사용하면 어떤 효과가 있는가?', 3, 'low', 'API 문서화', '동기 실행 보장', '비동기 메서드 실행', 'Entity 자동 매핑', 46, '@Async는 메서드를 별도 스레드에서 실행되도록 하여 비동기 처리를 가능하게 한다.'),
                                                                                                                           (2293, 'JPA에서 N+1 문제 해결을 위한 방법으로 적절한 것은?', 3, 'low', '별도의 쿼리 파일 분리', 'DTO로 엔티티 반환', 'Fetch Join 사용', '트랜잭션 제거', 46, 'Fetch Join은 연관된 엔티티를 한 번의 쿼리로 가져올 수 있어 N+1 문제를 해결할 수 있다.'),
                                                                                                                           (2294, '다음 중 Redis를 사용한 캐싱에서 TTL(Time To Live)의 역할은?', 2, 'medium', '데이터 업데이트 트리거', '캐시 데이터의 유효 기간 설정', '쿼리 실행 순서 설정', '데이터 정렬 기준 설정', 46, 'TTL은 Redis에서 저장된 데이터가 자동으로 만료되도록 유효 기간을 설정하는 기능이다.'),
                                                                                                                           (2295, 'Spring Security + JWT 기반 인증에서 토큰 발급 객체는?', 2, 'medium', 'AuthenticationEntryPoint', 'TokenProvider 또는 JwtUtil', 'OAuth2User', 'WebSecurityConfigurer', 46, 'TokenProvider 또는 JwtUtil 클래스는 JWT 토큰을 생성하고 검증하는 역할을 한다.'),
                                                                                                                           (2296, 'OAuth2 로그인 시 리디렉션 URI는 어떤 역할을 하는가?', 3, 'medium', '사용자 ID 확인', '리소스 서버 요청을 중단', '인가 서버가 인증 후 리다이렉트할 클라이언트 주소', 'JWT 발급을 담당', 46, '리디렉션 URI는 OAuth2 인증이 완료된 후 사용자를 다시 클라이언트 애플리케이션으로 돌려보낼 주소이다.'),
                                                                                                                           (2297, 'JPA Auditing에서 생성 시간을 자동으로 기록하는 어노테이션은?', 3, 'high', '@CreatedTime', '@ModifiedDate', '@CreatedDate', '@Timestamp', 46, '@CreatedDate는 엔티티가 최초 저장될 때의 생성 시간을 자동으로 기록해준다.'),
                                                                                                                           (2298, 'Spring Boot 멀티 모듈 프로젝트의 주요 장점은?', 2, 'high', '전체 모듈이 하나의 빌드로만 운영됨', '서로 다른 관심사를 모듈로 분리해 관리 가능', '코드 중복 증가', '디버깅이 어려움', 46, '멀티 모듈은 기능별로 분리되어 유지보수성과 개발 효율성을 높일 수 있다.'),
                                                                                                                           (2299, 'CI/CD 구성에서 GitHub Actions의 주된 용도는?', 3, 'high', '로그 저장', '서버 모니터링', '자동 빌드 및 테스트, 배포 트리거', 'HTML 렌더링', 46, 'GitHub Actions는 코드 푸시 시 자동으로 빌드, 테스트, 배포 등의 워크플로우를 실행할 수 있도록 해준다.'),
                                                                                                                           (2300, '헥사고날 아키텍처의 핵심 아이디어는?', 2, 'high', '계층 구조를 제거한다', '도메인과 외부 의존성을 철저히 분리', '엔티티 중심으로만 개발', 'DB 종속적인 코드 구성', 46, '헥사고날 아키텍처는 도메인 로직을 외부 시스템과 독립적으로 설계할 수 있도록 구조화된 방식이다.'),
                                                                                                                           (2301, 'Node.js의 가장 큰 특징 중 하나는?', 3, 'low', '스레드 기반 동기 처리', 'JavaScript를 브라우저에서만 실행', '이벤트 기반 비동기 처리', 'PHP 기반으로 동작', 47, 'Node.js는 이벤트 루프 기반 비동기 처리로 I/O 작업을 효율적으로 처리한다.'),
                                                                                                                           (2302, 'Node.js에서 외부 패키지를 설치하고 관리할 수 있는 도구는?', 2, 'low', 'GIT', 'NPM', 'SQL', 'VIM', 47, 'NPM(Node Package Manager)은 Node.js의 패키지 관리 도구로, 외부 라이브러리 설치에 사용된다.'),
                                                                                                                           (2303, '다음 중 Node.js에서 모듈을 불러오는 문법으로 알맞은 것은?', 2, 'low', 'import.module(''fs'')', 'require(''fs'')', 'load(''fs'')', 'get(''fs'')', 47, 'Node.js에서는 CommonJS 방식으로 require()를 사용하여 모듈을 불러온다.'),
                                                                                                                           (2304, 'Node.js에서 비동기 처리를 가능하게 해주는 구조는?', 3, 'medium', '블로킹 큐', '멀티 스레드 큐', '이벤트 루프', '데이터 플로우 트리', 47, '이벤트 루프는 Node.js의 핵심으로, 비동기 I/O 작업을 효율적으로 처리하는 구조이다.'),
                                                                                                                           (2305, 'Node.js에서 파일 시스템 작업을 제공하는 내장 모듈은?', 4, 'medium', 'net', 'http', 'os', 'fs', 47, 'fs(File System) 모듈은 파일 읽기, 쓰기 등 파일 시스템 관련 기능을 제공한다.'),
                                                                                                                           (2306, 'npm init 명령어를 실행하면 생성되는 파일은?', 3, 'medium', 'package.js', 'server.json', 'package.json', 'config.yaml', 47, 'package.json은 프로젝트의 메타 정보를 담는 파일로, 의존성 관리와 실행 스크립트를 정의한다.'),
                                                                                                                           (2307, 'require() 함수를 통해 불러온 모듈이 리턴하는 것은?', 3, 'medium', 'HTML 파일', '라우팅 객체', '모듈에서 exports한 객체 또는 함수', 'Java 클래스', 47, 'require()는 모듈 내에서 exports한 객체나 함수를 반환한다.'),
                                                                                                                           (2308, 'Node.js에서 동기 함수와 비교하여 비동기 함수의 장점은?', 4, 'high', '코드 작성이 쉽다', '모든 요청을 직렬로 처리', '처리 속도가 느리다', '다수의 요청을 효율적으로 처리 가능', 47, '비동기 함수는 블로킹 없이 여러 요청을 동시에 처리할 수 있어 성능상 유리하다.'),
                                                                                                                           (2309, '다음 중 CommonJS 방식의 모듈 정의법으로 옳은 것은?', 3, 'high', 'export default {}', 'exports = {}', 'module.exports = {}', 'define(() => {})', 47, 'CommonJS 방식에서는 module.exports를 사용하여 모듈을 정의한다.'),
                                                                                                                           (2310, 'Node.js가 싱글 스레드임에도 고성능을 내는 이유는?', 3, 'high', '코드를 순차적으로 실행하기 때문', '멀티 프로세스를 기본으로 하기 때문', '이벤트 루프와 비동기 처리를 통해 I/O 병목을 줄이기 때문', '매 요청마다 서버를 재시작하기 때문', 47, 'Node.js는 이벤트 루프와 비동기 방식으로 I/O 작업을 효율적으로 처리하여 고성능을 낼 수 있다.'),
                                                                                                                           (2311, 'Express.js는 어떤 목적으로 사용되는 Node.js 프레임워크인가?', 3, 'low', '데스크탑 애플리케이션 개발', '파일 시스템 처리', '웹 서버 및 API 구축', 'CLI 툴 개발', 47, 'Express.js는 Node.js 환경에서 웹 서버 및 RESTful API를 쉽게 구축할 수 있도록 도와주는 경량 프레임워크이다.'),
                                                                                                                           (2312, 'Express에서 라우팅을 정의할 때 사용하는 메서드는?', 1, 'low', 'get(), post(), put(), delete()', 'select(), update(), remove()', 'listen(), connect(), init()', 'path(), query(), route()', 47, 'Express에서는 HTTP 요청 메서드와 URL 경로에 따라 라우팅을 정의할 수 있으며, 주로 get(), post(), put(), delete()를 사용한다.'),
                                                                                                                           (2313, 'REST API 설계에서 ''GET'' 메서드는 어떤 목적에 사용되는가?', 3, 'low', '데이터 생성', '데이터 삭제', '데이터 조회', '데이터 갱신', 47, 'GET 메서드는 서버로부터 데이터를 조회하는 데 사용되며, 서버 상태를 변경하지 않는다.'),
                                                                                                                           (2314, '다음 중 RESTful URI 설계로 가장 적절한 것은?', 3, 'medium', '/getUserById?id=1', '/user?id=1', '/user/1', '/fetch/user/1', 47, 'RESTful 설계에서는 명사 중심의 URI와 자원의 ID를 경로에 포함시키는 방식인 /user/1과 같은 형태가 권장된다.'),
                                                                                                                           (2315, 'Express.js의 미들웨어는 언제 실행되는가?', 1, 'medium', '라우터가 실행된 후 결과를 보내기 전에', '서버가 시작되기 전에만', '라우터에 도달하지 않고 무조건 건너뜀', '응답을 브라우저에 보낸 후', 47, '미들웨어는 라우터 실행 전후에 위치해 요청 처리 과정 중간에 실행되며, 주로 인증, 로깅, 파싱 등에 사용된다.'),
                                                                                                                           (2316, '다음 중 Express의 기본 구조에서 올바른 요청 처리 흐름은?', 3, 'medium', 'Controller → Middleware → Route', 'Route → Middleware → Response', 'Request → Middleware → Route Handler → Response', 'Middleware → DB → Controller', 47, 'Express의 요청 처리 흐름은 클라이언트 요청이 미들웨어를 거쳐 라우트 핸들러로 전달되고, 응답을 반환하는 방식이다.'),
                                                                                                                           (2317, '다음 중 Express에서 미들웨어를 정의하는 기본 문법은?', 2, 'medium', 'app.route(''/'', callback)', 'app.use((req, res, next) => {})', 'app.get((req, res) => {})', 'use.app((req, res, next) => {})', 47, 'app.use()는 전역 또는 특정 경로에 미들웨어를 등록하는 데 사용하는 기본 메서드이다.'),
                                                                                                                           (2318, 'REST API의 리소스를 표현하는 올바른 방식은?', 3, 'high', '동사 기반 URI', '복잡한 쿼리 문자열 중심', '명확한 명사 기반 URI', 'HTML 태그 기반 URI', 47, 'REST는 자원을 명사로 표현하고, 행위는 HTTP 메서드로 구분하므로 URI는 명사 중심으로 작성해야 한다.'),
                                                                                                                           (2319, 'Express에서 에러 처리 미들웨어의 인자는 몇 개인가?', 3, 'high', '2개', '3개', '4개', '5개', 47, 'Express의 에러 처리 미들웨어는 (err, req, res, next)의 4개 인자를 받아야 한다.'),
                                                                                                                           (2320, 'REST API에서 PUT과 PATCH의 가장 큰 차이점은?', 2, 'high', '둘 다 삭제 요청이다', 'PUT은 전체 업데이트, PATCH는 일부 업데이트', 'PATCH는 새 리소스 생성용이다', 'PUT은 조회 요청이다', 47, 'PUT은 전체 리소스를 교체하고, PATCH는 일부 속성만 수정하는 데 사용된다.'),
                                                                                                                           (2321, '환경 변수 파일(.env)을 Node.js 프로젝트에서 사용할 수 있도록 도와주는 패키지는?', 2, 'low', 'config.js', 'dotenv', 'env-loader', 'envParser', 47, 'dotenv는 .env 파일에 정의된 환경 변수를 Node.js에서 사용할 수 있도록 로딩해주는 패키지이다.'),
                                                                                                                           (2322, '환경에 따라 설정을 분기 처리할 때 사용하는 Node.js 전역 변수는?', 3, 'low', 'NODE_MODE', 'NODE_TYPE', 'NODE_ENV', 'ENV_STAGE', 47, 'NODE_ENV는 실행 환경(개발, 운영 등)에 따라 조건 분기를 설정할 때 사용되는 표준 전역 변수이다.'),
                                                                                                                           (2323, 'JWT의 구성 요소는 다음 중 어떤 형태인가?', 1, 'low', 'Header.Payload.Signature', 'Key.Value.Secret', 'Token.Passcode.ID', 'UserID.Time.Secret', 47, 'JWT는 헤더, 페이로드, 서명으로 구성되어 있으며, 이를 점(.)으로 구분해 인코딩된다.'),
                                                                                                                           (2324, '다음 중 Access Token과 Refresh Token을 동시에 사용하는 이유는?', 2, 'medium', '로그인을 두 번 하기 위해', '보안 강화를 위해 짧은 만료와 재발급 구조 분리', '속도 향상을 위해 캐싱 구조 사용', '프론트엔드와 연동을 단순화하기 위해', 47, 'Access Token은 짧은 유효 기간을 갖고, Refresh Token은 재발급을 위한 장기 저장으로 보안성과 사용자 편의성을 동시에 확보한다.'),
                                                                                                                           (2325, '다음 중 전역 에러 처리 미들웨어에서 반드시 포함되어야 하는 인자 개수는?', 3, 'medium', '2', '3', '4', '5', 47, 'Express 전역 에러 핸들러는 4개의 인자(err, req, res, next)를 반드시 포함해야 실행된다.'),
                                                                                                                           (2326, '유효성 검사 라이브러리인 express-validator에서 validationResult를 사용하는 목적은?', 3, 'medium', 'DB 연결 확인', 'JWT 토큰 파싱', '검증 실패 항목 추출', '라우터 매핑 처리', 47, 'validationResult는 요청 객체의 유효성 검사 결과를 확인하고, 오류 정보를 추출하는 데 사용된다.'),
                                                                                                                           (2327, 'Joi 라이브러리의 주요 용도는?', 3, 'medium', '파일 시스템 접근', '환경 변수 주입', '데이터 유효성 스키마 기반 검사', '로그 기록', 47, 'Joi는 객체 스키마를 정의하고, 해당 스키마에 따라 데이터의 유효성을 검사하는 데 사용된다.'),
                                                                                                                           (2328, 'JWT 토큰을 검증할 때 필요한 값은?', 1, 'high', '암호화 키 (Secret)', '사용자 비밀번호', 'DB 연결 문자열', 'Access ID', 47, 'JWT는 서명을 통해 변조 여부를 확인하므로, 검증 시 발급 시 사용한 Secret 키가 반드시 필요하다.'),
                                                                                                                           (2329, '다음 중 전역 에러 핸들러가 처리하지 못하는 것은?', 2, 'high', '라우팅 실패', '비동기 함수 내 throw 에러 (await 없이)', 'express-validator 오류', '동기 실행 중 예외', 47, 'await 없이 throw된 에러는 비동기 컨텍스트 밖에서 발생하므로 Express의 전역 에러 핸들러가 잡을 수 없다.'),
                                                                                                                           (2330, 'HTTP 요청 시 인증이 필요한 API 라우터에 적용해야 하는 미들웨어의 역할은?', 3, 'high', '로그를 기록한다', '데이터를 암호화한다', 'JWT를 해석하고 유효한지 검증한다', '라우터 경로를 캐싱한다', 47, 'JWT 인증 미들웨어는 클라이언트 요청의 JWT를 검증하여 유효한 사용자 요청인지를 확인한다.'),
                                                                                                                           (2331, 'Mongoose는 어떤 데이터베이스를 위한 ODM(Object Document Mapper)인가?', 2, 'low', 'PostgreSQL', 'MongoDB', 'MySQL', 'Redis', 47, 'Mongoose는 MongoDB를 위한 ODM으로, JavaScript 객체를 MongoDB 문서로 매핑하는 기능을 제공한다.'),
                                                                                                                           (2332, 'Sequelize는 어떤 종류의 ORM인가?', 3, 'low', 'GraphQL 기반 ORM', 'Document 기반 ORM', 'SQL 기반 ORM', '파일 기반 ORM', 47, 'Sequelize는 다양한 SQL 기반 DB(MySQL, PostgreSQL 등)를 지원하는 ORM이다.'),
                                                                                                                           (2333, '다음 중 Prisma의 주요 특징으로 올바른 것은?', 2, 'low', 'MongoDB 전용 ORM', 'SQL Schema 기반 타입 안전성 제공', 'NoSQL 전용 쿼리만 지원', '테스트 도구와 통합 불가', 47, 'Prisma는 SQL 스키마 기반으로 작동하며, 정적 타입을 지원해 개발 중 오류를 줄일 수 있다.'),
                                                                                                                           (2334, 'Postman의 주요 사용 목적은?', 3, 'medium', 'JWT 암호화', 'MongoDB 백업', 'API 요청 시뮬레이션 및 테스트', '로컬 호스팅', 47, 'Postman은 REST API 테스트를 시뮬레이션하고 응답을 확인하는 데 유용한 툴이다.'),
                                                                                                                           (2335, 'Mongoose에서 findOne() 함수의 역할은?', 2, 'medium', '모든 문서 삭제', '단일 문서를 검색', '컬렉션 생성', '스키마 정의', 47, 'findOne()은 MongoDB에서 조건에 일치하는 단일 문서를 검색할 때 사용된다.'),
                                                                                                                           (2336, 'Sequelize에서 테이블을 정의하기 위한 객체는?', 3, 'medium', 'Client', 'Schema', 'Model', 'Repository', 47, 'Sequelize에서 Model은 테이블을 정의하고 데이터베이스의 행과 객체를 매핑하는 단위이다.'),
                                                                                                                           (2337, 'Prisma에서 DB 마이그레이션을 적용하기 위한 명령어는?', 1, 'medium', 'npx prisma migrate deploy', 'prisma update-db', 'npm run sync-schema', 'prisma reset', 47, 'npx prisma migrate deploy 명령어는 Prisma에서 정의한 스키마 변경을 실제 DB에 반영한다.'),
                                                                                                                           (2338, 'Postman에서 변수 설정을 통해 얻을 수 있는 이점은?', 2, 'high', 'JWT 생성 자동화', '요청 경로와 파라미터 재사용성 향상', '데이터베이스 직접 수정', '브라우저에서 실행 가능', 47, '변수 설정을 사용하면 여러 요청에서 동일한 값을 쉽게 재사용할 수 있어 테스트의 유연성이 증가한다.'),
                                                                                                                           (2339, 'Jest 테스트 도구의 특징 중 하나는?', 2, 'high', 'HTML 테스트 전용', 'Node.js 환경 전용 단위 테스트 지원', 'Swagger UI 기반 실행', 'MySQL 쿼리 전용 분석기', 47, 'Jest는 Node.js 환경에서 작동하며, 단위 테스트 및 목(mock) 기능을 지원한다.'),
                                                                                                                           (2340, '다음 중 통합 테스트에 적합한 도구는?', 1, 'high', 'supertest', 'dotenv', 'mongoose', 'bcrypt', 47, 'supertest는 실제 서버와 유사한 방식으로 HTTP 요청을 보내며, 통합 테스트에 적합하다.'),
                                                                                                                           (2341, '마이크로서비스 아키텍처의 장점은?', 2, 'low', '한 번에 전체 시스템을 배포할 수 있다', '각 서비스가 독립적으로 배포 및 확장 가능하다', '하나의 DB만 사용 가능하다', '코드 재사용이 불가능하다', 47, '마이크로서비스는 각 서비스가 독립적으로 배포 및 확장 가능하다는 점에서 유연성과 확장성이 크다.'),
                                                                                                                           (2342, 'Redis는 어떤 용도로 주로 사용되는가?', 3, 'low', '정적 파일 전송', 'UI 컴포넌트 렌더링', '메모리 기반 캐시 및 세션 저장', 'SSL 인증 처리', 47, 'Redis는 인메모리 데이터 저장소로, 빠른 속도를 활용하여 캐시 및 세션 저장 등에 주로 사용된다.'),
                                                                                                                           (2343, 'RabbitMQ와 Kafka는 어떤 시스템에 속하는가?', 2, 'low', '파일 처리 라이브러리', '이벤트 기반 메시징 큐 시스템', '암호화 엔진', '웹 서버 프레임워크', 47, 'RabbitMQ와 Kafka는 이벤트 기반의 비동기 메시징 시스템으로, 메시지 큐 시스템에 해당한다.'),
                                                                                                                           (2344, 'AWS S3는 어떤 목적에 사용되는 서비스인가?', 2, 'medium', '웹 서버 관리', '정적 파일 저장 및 전송', 'API Gateway 역할 수행', 'DB 트랜잭션 처리', 47, 'S3는 정적 파일(이미지, HTML 등)을 저장하고 전송하는 데 최적화된 오브젝트 스토리지 서비스다.'),
                                                                                                                           (2345, 'OAuth2의 Authorization Code Flow는 주로 어떤 앱에 사용되는가?', 2, 'medium', '클라이언트 시크릿을 보호할 수 없는 앱', '서버-클라이언트 구조에서 높은 보안이 필요한 앱', '토큰 없는 오프라인 앱', '데스크탑용 게임', 47, 'Authorization Code Flow는 서버-클라이언트 구조에서 보안을 강화할 수 있어 민감한 정보 보호가 필요한 앱에 적합하다.'),
                                                                                                                           (2346, 'Helmet 미들웨어의 주요 목적은?', 2, 'medium', '라우팅을 간결하게 만든다', '응답 헤더를 조작해 보안을 강화한다', '에러 메시지를 JSON으로 출력한다', '서버에 로그를 저장한다', 47, 'Helmet은 Express.js에서 응답 헤더를 설정해 보안을 강화하는 데 사용된다.'),
                                                                                                                           (2347, 'Node.js에서 다중 프로세스를 통해 성능을 높일 수 있는 모드는?', 3, 'high', 'Standalone Mode', 'Parallel Mode', 'Cluster Mode', 'Linear Mode', 47, 'Cluster Mode는 여러 프로세스를 통해 CPU 코어를 활용하여 성능을 향상시킬 수 있다.'),
                                                                                                                           (2348, '다음 중 유닛 테스트 프레임워크로 알맞은 것은?', 2, 'high', 'Postman', 'Jest', 'Docker', 'Redis', 47, 'Jest는 JavaScript 기반의 유닛 테스트 프레임워크로 테스트 자동화에 사용된다.'),
                                                                                                                           (2349, 'GitHub Actions의 주요 역할은?', 3, 'high', '코드 에디터 기능 제공', '리포지토리 삭제', 'CI/CD 자동화 파이프라인 구성', '브라우저 렌더링 최적화', 47, 'GitHub Actions는 코드 변경 시 자동으로 빌드, 테스트, 배포하는 CI/CD 도구다.'),
                                                                                                                           (2350, 'GraphQL의 장점 중 하나는?', 2, 'high', 'REST보다 항상 빠르다', '요청자가 필요한 데이터만 선택적으로 요청할 수 있다', '서버에서 URI를 자동 생성한다', 'NoSQL 전용으로만 사용할 수 있다', 47, 'GraphQL은 클라이언트가 필요한 데이터만 선택적으로 요청할 수 있어 효율적인 데이터 통신이 가능하다.'),
                                                                                                                           (2351, 'Django에서 새로운 프로젝트를 시작하는 명령어는?', 2, 'low', 'python createproject mysite', 'django-admin startproject mysite', 'django startproject mysite', 'django-admin create mysite', 48, 'django-admin startproject 명령어는 새로운 Django 프로젝트의 디렉토리와 기본 구조를 생성한다.'),
                                                                                                                           (2352, 'Django에서 앱을 생성할 때 사용하는 명령어는?', 3, 'low', 'django startapp blog', 'python manage.py initapp blog', 'python manage.py startapp blog', 'django-admin createapp blog', 48, 'python manage.py startapp은 Django 프로젝트 내에 새로운 앱을 생성하는 표준 명령어다.'),
                                                                                                                           (2353, 'Django에서 URL과 뷰 함수를 연결할 때 사용하는 함수는?', 4, 'low', 'include()', 'render()', 'connect()', 'path()', 48, 'path() 함수는 URL 경로와 해당 경로에 매핑될 뷰 함수를 연결하는 데 사용된다.'),
                                                                                                                           (2354, '뷰 함수에서 HTTP 응답을 반환하기 위해 사용하는 함수는?', 1, 'medium', 'HttpResponse()', 'response()', 'returnView()', 'HttpRender()', 48, 'HttpResponse()는 Django에서 클라이언트에게 응답을 반환하는 기본 함수다.'),
                                                                                                                           (2355, '템플릿에서 정적 파일(css/js 등)을 로드하기 위해 템플릿 상단에 사용하는 태그는?', 3, 'low', '{% include static %}', '{{ static load }}', '{% load static %}', '{% static load %}', 48, '정적 파일을 사용하기 위해 템플릿 상단에 {% load static %} 태그를 추가해야 한다.'),
                                                                                                                           (2356, '템플릿에서 context로 넘긴 ''username''을 출력하려면 어떻게 해야 하나?', 2, 'low', '{% username %}', '{{ username }}', '<%= username %>', '${ username }', 48, '{{ username }} 구문은 템플릿에서 변수 값을 출력할 때 사용하는 Django의 문법이다.'),
                                                                                                                           (2357, 'Django 모델에서 기본키(primary key)를 명시하지 않으면 자동으로 생성되는 필드는?', 3, 'medium', 'AutoIDField', 'models.IDField()', 'models.AutoField(primary_key=True)', 'models.IntegerField(auto=True)', 48, 'Django는 기본적으로 models.AutoField(primary_key=True)를 생성하여 기본키 역할을 수행한다.'),
                                                                                                                           (2358, 'ORM에서 모델 인스턴스를 저장하기 위해 사용하는 메서드는?', 4, 'medium', 'update()', 'persist()', 'commit()', 'save()', 48, 'save() 메서드는 Django 모델 인스턴스를 DB에 저장할 때 사용된다.'),
                                                                                                                           (2359, 'Django에서 사용자의 로그인 상태를 확인할 수 있는 내장 변수는?', 3, 'medium', 'request.login_status', 'request.authenticated', 'request.user.is_authenticated', 'user.session.active', 48, 'request.user.is_authenticated는 사용자의 로그인 상태를 불린 값으로 제공한다.'),
                                                                                                                           (2360, '폼에서 필드 자동 유효성 검사 기능이 제공되는 클래스는?', 2, 'medium', 'forms.BaseForm', 'forms.ModelForm', 'forms.FormGroup', 'forms.SimpleForm', 48, 'ModelForm은 모델과 연결되어 있으며 필드 자동 생성과 유효성 검사가 제공된다.'),
                                                                                                                           (2361, 'Django 프로젝트에서 설정 파일이 위치한 기본 디렉토리는?', 2, 'medium', 'settings/', 'mysite/settings/', 'config/', 'project/', 48, 'Django는 기본적으로 프로젝트명/settings/ 디렉토리에 설정 파일을 생성한다.'),
                                                                                                                           (2362, 'Django에서 디버그 모드를 설정하는 변수는?', 3, 'medium', 'DEBUG_MODE', 'IS_DEBUG', 'DEBUG', 'DEV_MODE', 48, 'Django에서 DEBUG 변수는 True/False 값을 통해 디버그 모드를 설정한다.'),
                                                                                                                           (2363, 'URLconf에서 다른 URLconf 모듈을 포함시킬 때 사용하는 함수는?', 3, 'medium', 'redirect()', 'path()', 'include()', 'add_url()', 48, 'include() 함수는 다른 앱의 URLconf를 현재 URLconf에 포함시키는 데 사용된다.'),
                                                                                                                           (2364, 'Django에서 템플릿 파일 기본 확장자는?', 2, 'low', '.tpl', '.html', '.django', '.template', 48, 'Django 템플릿 파일은 일반적으로 .html 확장자를 사용한다.'),
                                                                                                                           (2365, '템플릿에서 if 조건문을 사용할 때의 구문은?', 3, 'medium', '{% if username != '''' %}', '{{ if username }}', '{% if username %}', '<% if username %>', 48, '{% if username %} 구문은 템플릿에서 조건문을 작성할 때 사용된다.'),
                                                                                                                           (2366, 'Django 모델에서 하나의 모델이 다른 모델과 1:N 관계를 가질 때 사용하는 필드는?', 3, 'medium', 'OneToOneField', 'ManyToManyField', 'ForeignKey', 'RelationField', 48, 'ForeignKey는 한 모델이 다른 모델의 여러 인스턴스를 참조할 수 있는 1:N 관계를 구성한다.'),
                                                                                                                           (2367, '모델 클래스에 대한 DB 테이블 이름을 지정할 때 사용하는 내부 클래스는?', 3, 'medium', 'Class Meta', 'ModelOptions', 'Meta', 'Options', 48, 'Meta 내부 클래스는 모델에 대한 추가 옵션을 설정하는 데 사용되며, db_table 등을 지정할 수 있다.'),
                                                                                                                           (2368, '로그인한 사용자의 정보를 뷰 함수에서 가져올 때 사용하는 객체는?', 2, 'low', 'request.auth', 'request.user', 'user.session', 'auth.current_user', 48, 'request.user 객체는 현재 로그인한 사용자 정보를 포함하고 있다.'),
                                                                                                                           (2369, 'Django의 폼 시스템에서 사용자 입력 데이터를 검증하려면 어떤 메서드를 호출해야 하나?', 1, 'medium', 'is_valid()', 'validate()', 'check()', 'form_validate()', 48, 'is_valid() 메서드는 폼에 입력된 데이터의 유효성을 검사한다.'),
                                                                                                                           (2370, '폼의 필드를 커스터마이징할 때 사용하는 속성 중 하나는?', 3, 'medium', 'attrs', 'fields', 'widgets', 'style', 48, 'widgets 속성을 사용하면 입력 필드의 HTML 속성 등을 세부적으로 조정할 수 있다.'),
                                                                                                                           (2371, 'Django REST framework를 설치하기 위한 pip 명령어는?', 1, 'low', 'pip install djangorestframework', 'pip install django-rest', 'pip install django-api', 'pip install restframework', 48, 'Django REST framework를 설치하려면 공식 패키지 이름인 djangorestframework를 pip으로 설치해야 한다.'),
                                                                                                                           (2372, 'DRF에서 APIView 클래스를 상속받아 뷰를 작성할 때 사용되는 모듈은?', 2, 'medium', 'django.views.generic', 'rest_framework.views', 'rest_framework.generics', 'django.api.views', 48, 'APIView 클래스는 rest_framework.views 모듈에서 제공되므로 해당 모듈을 import해야 한다.'),
                                                                                                                           (2373, 'DRF에서 직렬화에 사용되는 클래스는?', 3, 'low', 'FormSerializer', 'ModelForm', 'ModelSerializer', 'DataSerializer', 48, 'ModelSerializer는 Django 모델을 기반으로 데이터를 JSON 등으로 직렬화하는 데 사용된다.'),
                                                                                                                           (2374, 'APIView에서 GET 요청을 처리하는 메서드는?', 2, 'low', 'get_request()', 'get()', 'retrieve()', 'handle_get()', 48, 'APIView에서는 HTTP GET 요청을 처리할 때 get() 메서드를 오버라이딩하여 사용한다.'),
                                                                                                                           (2375, 'DRF에서 다양한 응답 형식을 처리하는 클래스는?', 3, 'medium', 'HttpResponse', 'JsonResponse', 'Response', 'APIResponse', 48, 'DRF의 Response 클래스는 JSON을 포함한 다양한 응답 포맷을 처리할 수 있도록 설계되어 있다.'),
                                                                                                                           (2376, 'Serializer 클래스에서 필드를 정의할 때 사용하는 모듈은?', 3, 'medium', 'rest_framework.models', 'rest_framework.fields', 'rest_framework.serializers', 'django.forms.fields', 48, 'Serializer 클래스와 관련된 모든 기능은 rest_framework.serializers 모듈에서 정의된다.'),
                                                                                                                           (2377, 'DRF에서 클래스 기반 뷰를 더 간단히 작성할 수 있게 도와주는 뷰는?', 1, 'medium', 'GenericAPIView', 'APIViewLite', 'BaseAPIView', 'AutoView', 48, 'GenericAPIView는 공통 로직을 제공하여 클래스 기반 뷰의 중복을 줄일 수 있도록 돕는다.'),
                                                                                                                           (2378, 'DRF의 ViewSet을 URL에 연결하기 위해 사용하는 객체는?', 2, 'medium', 'UrlDispatcher', 'Router', 'PathBinder', 'ApiConnector', 48, 'DRF의 Router 객체는 ViewSet을 URLconf에 자동으로 매핑해주는 기능을 제공한다.'),
                                                                                                                           (2379, 'ModelSerializer를 사용할 때 모델과 필드를 지정하는 내부 클래스는?', 2, 'low', 'SerializerMeta', 'Meta', 'Options', 'Config', 48, 'Meta 클래스는 직렬화 대상 모델과 포함할 필드 목록 등을 정의하는 내부 설정 클래스이다.'),
                                                                                                                           (2380, 'DRF에서 인증(authentication)을 설정하기 위한 설정 키는?', 4, 'medium', 'AUTH_CLASSES', 'DRF_AUTH', 'DEFAULT_AUTH_CLASSES', 'DEFAULT_AUTHENTICATION_CLASSES', 48, 'DEFAULT_AUTHENTICATION_CLASSES는 DRF에서 인증 방식을 설정하기 위한 공식 설정 키이다.'),
                                                                                                                           (2381, 'Django에서 settings.py에 앱을 등록할 때 사용하는 설정 항목은?', 2, 'low', 'APP_LIST', 'INSTALLED_APPS', 'ACTIVE_APPS', 'REGISTERED_APPS', 48, 'INSTALLED_APPS는 Django 프로젝트에 포함될 앱을 정의하는 기본 설정 항목이다.'),
                                                                                                                           (2382, 'Django에서 URLconf 모듈을 연결할 때 사용하는 함수는?', 3, 'medium', 'connect()', 'url()', 'include()', 'redirect()', 48, 'include() 함수는 다른 앱의 URLconf를 현재 URLconf에 연결할 때 사용된다.'),
                                                                                                                           (2383, '템플릿에서 조건문을 사용할 때 올바른 구문은?', 1, 'low', '{% if user.is_authenticated %} ... {% endif %}', '{{ if user.is_authenticated }} ... {{ endif }}', '{% if user.is_authenticated %} ... {{ endif }}', '{% if user.is_authenticated %} ... {% end %}', 48, 'Django 템플릿에서는 {% if %}와 {% endif %} 블록을 사용하여 조건문을 작성한다.'),
                                                                                                                           (2384, 'Django 모델에서 필드에 고유값 제약 조건을 주려면?', 1, 'low', 'unique=True', 'primary_key=True', 'null=False', 'indexed=True', 48, 'unique=True 속성은 해당 필드 값이 데이터베이스에서 유일하도록 제약을 건다.'),
                                                                                                                           (2385, 'Django의 User 모델에 password를 설정할 때 사용하는 메서드는?', 1, 'medium', 'set_password()', 'create_password()', 'hash_password()', 'set_encrypted_password()', 48, 'set_password() 메서드는 입력된 비밀번호를 해시 처리하여 안전하게 저장하는 기능을 수행한다.'),
                                                                                                                           (2386, 'DRF에서 `@api_view([''GET''])` 데코레이터는 어떤 종류의 뷰에 사용되는가?', 3, 'low', '클래스 기반 뷰', '제너릭 뷰', '함수형 뷰', 'ViewSet', 48, '@api_view 데코레이터는 함수형 뷰에 HTTP 메서드를 지정하여 사용한다.'),
                                                                                                                           (2387, 'DRF에서 status 코드로 HTTP 404를 반환할 때 사용하는 상수는?', 1, 'medium', 'status.HTTP_404_NOT_FOUND', 'status.NOT_FOUND', 'HTTP.NOT_FOUND', 'status.HTTP_NOT_FOUND', 48, 'status.HTTP_404_NOT_FOUND는 DRF에서 HTTP 404 응답을 의미하는 표준 상수이다.'),
                                                                                                                           (2388, 'DRF ViewSet에서 리스트 조회 기능을 위한 메서드는?', 3, 'medium', 'retrieve()', 'get()', 'list()', 'get_all()', 48, 'ViewSet 클래스에서 list() 메서드는 여러 객체를 조회할 때 사용된다.'),
                                                                                                                           (2389, 'Django에서 모델을 생성한 후 데이터베이스에 반영하려면 어떤 명령어를 사용해야 하는가?', 1, 'low', 'python manage.py makemigrations → migrate', 'python manage.py db_create', 'python manage.py dbsync', 'python manage.py migrate_only', 48, 'makemigrations는 모델 변경사항을 마이그레이션 파일로 만들고, migrate로 DB에 반영한다.'),
                                                                                                                           (2390, 'Django의 `get_object_or_404()` 함수의 주요 목적은?', 3, 'medium', '객체를 생성하고 저장한다', '404 응답 없이 객체를 가져온다', '객체가 없으면 404 오류를 반환한다', '모든 객체를 조회한다', 48, 'get_object_or_404()는 지정된 조건의 객체가 없을 경우 자동으로 404 오류를 발생시킨다.'),
                                                                                                                           (2391, '템플릿에서 HTML을 안전하게 출력하려면 어떤 필터를 사용할 수 있는가?', 2, 'medium', '|escape', '|safe', '|html', '|print', 48, '|safe 필터는 HTML 이스케이프를 하지 않고 원문 그대로 출력하므로 의도된 HTML을 표시할 수 있다.'),
                                                                                                                           (2392, '장고에서 `ModelForm`의 주요 목적은?', 3, 'medium', 'HTML 직접 작성', '모델을 자동으로 저장하지 않음', '모델 기반 폼 자동 생성', '폼 유효성 검사 생략', 48, 'ModelForm은 모델 기반으로 입력 폼을 자동 생성하고 유효성 검사를 처리해준다.'),
                                                                                                                           (2393, 'Django REST Framework에서 serializer의 역할은?', 3, 'low', 'HTML 템플릿을 렌더링한다', '클래스 기반 뷰를 관리한다', '데이터를 JSON 등으로 변환한다', 'url 패턴을 등록한다', 48, 'Serializer는 Python 객체를 JSON 등으로 변환하거나 역직렬화하는 기능을 한다.'),
                                                                                                                           (2394, 'DRF에서 특정 필드를 읽기 전용으로 만들고 싶을 때 사용하는 옵션은?', 3, 'medium', 'editable=False', 'readonly=True', 'read_only=True', 'non_writable=True', 48, 'read_only=True 속성은 직렬화 시 해당 필드를 읽기 전용으로 설정하는 데 사용된다.'),
                                                                                                                           (2395, 'Django에서 QuerySet의 `filter()` 메서드는 어떤 역할을 하는가?', 2, 'low', '모든 데이터를 가져온다', '지정한 조건에 맞는 데이터를 조회한다', '데이터를 삭제한다', '조건 없이 정렬한다', 48, 'filter()는 조건을 만족하는 객체만 QuerySet으로 반환하는 메서드이다.'),
                                                                                                                           (2396, 'DRF에서 `serializer.is_valid()` 호출 후 접근 가능한 속성은?', 2, 'medium', 'serializer.cleaned_data', 'serializer.validated_data', 'serializer.cleaned_fields', 'serializer.form_data', 48, 'serializer.validated_data는 유효성 검사를 통과한 데이터에 접근할 때 사용된다.'),
                                                                                                                           (2397, 'Django에서 프로젝트를 생성하면 자동으로 생성되는 파일 중, 명령어 관리를 담당하는 파일은?', 3, 'low', 'apps.py', 'wsgi.py', 'manage.py', 'urls.py', 48, 'manage.py는 Django 명령어를 실행할 수 있도록 돕는 프로젝트 루트 스크립트 파일이다.'),
                                                                                                                           (2398, 'Django에서 특정 URL 요청이 어떤 view 함수로 연결될지를 지정할 때 사용하는 함수는?', 3, 'low', 'include()', 'render()', 'path()', 'urljoin()', 48, 'path() 함수는 URL 경로와 해당 경로에 매핑될 뷰 함수를 연결하는 데 사용된다.'),
                                                                                                                           (2399, 'Django 템플릿에서 변수를 출력하기 위해 사용하는 구문은?', 2, 'low', '{% variable %}', '{{ variable }}', '[[ variable ]]', '( variable )', 48, '{{ variable }} 구문은 템플릿에서 변수의 값을 출력할 때 사용하는 표준 문법이다.'),
                                                                                                                           (2400, 'Django 모델 클래스에 __str__ 메서드를 정의하는 이유는?', 2, 'medium', '객체 생성 시 자동으로 호출되도록 하기 위해', '모델 객체를 문자열로 보기 좋게 표현하기 위해', '데이터베이스 테이블 이름을 지정하기 위해', '모델 필드에 기본값을 설정하기 위해', 48, '__str__ 메서드는 admin 페이지나 쉘에서 객체를 사람이 읽기 좋은 문자열로 표시하기 위해 사용된다.'),
                                                                                                                           (2401, 'Flask에서 애플리케이션을 생성할 때 사용되는 객체는?', 1, 'low', 'app', 'FlaskApp', 'FlaskInstance', 'application', 49, "'Flask(__name__)'을 호출하여 생성된 객체가 보통 'app' 변수에 할당되어 사용되기 때문이다."),
                                                                                                                           (2402, 'Flask에서 특정 URL로 요청을 받을 수 있게 하는 데코레이터는 무엇인가?', 1, 'low', '@app.route()', '@url.route()', '@app.view()', '@request.route()', 49, "'@app.route()'는 Flask에서 URL과 함수(View)를 연결하기 위해 사용하는 기본적인 라우팅 데코레이터이다."),
                                                                                                                           (2403, 'Flask에서 뷰 함수가 반환하는 기본값은 무엇인가?', 3, 'medium', 'HTML', 'JSON', 'Response 객체', 'String', 49, "Flask의 뷰 함수는 내부적으로 문자열이나 다른 반환값을 Response 객체로 래핑하여 반환한다."),
                                                                                                                           (2404, 'Jinja2 템플릿에서 상속을 사용하기 위한 구문은 무엇인가?', 2, 'medium', '{% include ''base.html'' %}', '{% extends ''base.html'' %}', '{% block content %}', '{% inherit ''base.html'' %}', 49, "'extends'는 템플릿 상속을 위해 사용되는 키워드로, 기본 레이아웃을 상속받을 때 사용된다."),
                                                                                                                           (2405, 'Flask-SQLAlchemy에서 모델 간 관계를 설정할 때 사용하는 키워드는?', 1, 'medium', 'ForeignKey', 'RelationalKey', 'Relationship', 'KeyRelation', 49, "'ForeignKey'는 다른 테이블의 기본 키와 연결되어 관계를 설정할 때 사용된다."),
                                                                                                                           (2406, 'Flask에서 폼 데이터를 처리할 때 사용하는 `POST` 방식의 데이터를 가져오는 방법은 무엇인가?', 1, 'low', 'request.form', 'request.body', 'request.json', 'request.args', 49, "'request.form'은 HTML 폼을 통해 POST 방식으로 전달된 데이터를 접근할 때 사용된다."),
                                                                                                                           (2407, 'Flask 애플리케이션에서 세션을 사용하기 위해 필요한 객체는 무엇인가?', 1, 'medium', 'session', 'cookies', 'request', 'state', 49, "'session'은 Flask에서 사용자별 데이터를 임시로 저장하는 데 사용하는 객체이다."),
                                                                                                                           (2408, 'Flask에서 SQLAlchemy를 사용하여 CRUD 기능을 구현할 때, 데이터를 추가하기 위한 메서드는 무엇인가?', 4, 'medium', 'db.add()', 'db.insert()', 'db.create()', 'db.session.add()', 49, "'db.session.add()'는 SQLAlchemy에서 새 객체를 세션에 추가하여 INSERT를 준비할 때 사용된다."),
                                                                                                                           (2409, 'Flask에서 서버를 로컬 환경에서 디버그 모드로 실행할 때 사용하는 코드는 무엇인가?', 1, 'low', 'app.run(debug=True)', 'app.run(debug=False)', 'flask run --debug', 'run_server(debug=True)', 49, "'app.run(debug=True)'는 서버를 디버그 모드로 실행해 코드 변경 시 자동으로 재시작된다."),
                                                                                                                           (2410, 'Flask에서 CORS(Cross-Origin Resource Sharing) 문제를 해결하기 위한 확장 모듈은 무엇인가?', 2, 'medium', 'Flask-Session', 'Flask-CORS', 'Flask-SQLAlchemy', 'Flask-Security', 49, "'Flask-CORS'는 Flask 애플리케이션에서 CORS를 간단하게 설정할 수 있도록 지원하는 확장이다."),
                                                                                                                           (2411, 'Flask에서 REST API를 개발하기 위해 사용하는 확장 모듈은 무엇인가?', 1, 'medium', 'Flask-RESTful', 'Flask-API', 'Flask-REST', 'Flask-Json', 49, "'Flask-RESTful'은 Flask에 RESTful API를 쉽게 구축할 수 있는 기능을 제공하는 확장이다."),
                                                                                                                           (2412, 'Flask에서 HTML 폼을 처리할 때, 사용자가 입력한 데이터를 확인하는 방법은 무엇인가?', 1, 'low', "request.form.get('key')", "request.json.get('key')", "request.data('key')", "request.args('key')", 49, "'request.form.get('key')'는 사용자가 제출한 HTML 폼의 값을 안전하게 조회할 때 사용된다."),
                                                                                                                           (2413, 'Flask에서 URL 매핑을 동적으로 처리하기 위한 방법은 무엇인가?', 1, 'medium', "app.route('/user/<username>')", "app.route('/user/:username')", "app.route('/user/{username}')", "app.route('/user?username')", 49, "'<>' 문법을 사용하여 동적 URL 파라미터를 정의하는 것이 Flask의 기본 방식이다."),
                                                                                                                           (2414, 'Flask에서 사용자의 세션을 종료하는 함수는 무엇인가?', 2, 'medium', 'session.remove()', 'session.clear()', 'session.pop()', 'session.end()', 49, "'session.clear()'는 현재 세션에 저장된 모든 데이터를 삭제하여 로그아웃 효과를 준다."),
                                                                                                                           (2415, 'Flask에서 Jinja2 템플릿에서 조건문을 사용하는 구문은 무엇인가?', 1, 'low', "{% if condition %} ... {% endif %}", "{% if condition == true %} ... {% end_if %}", "{% condition if %} ... {% endif_condition %}", "{% check condition %} ... {% end_check %}", 49, "Jinja2에서는 Python과 유사한 조건문 표현인 'if ~ endif' 구문을 사용한다."),
                                                                                                                           (2416, 'Flask에서 `url_for()` 함수는 무엇을 위해 사용되는가?', 1, 'low', 'URL 경로를 동적으로 생성하는 데 사용된다.', 'HTTP 요청을 보낼 때 URL을 생성한다.', '서버 주소를 반환하는 함수이다.', 'HTTP 응답을 생성하는 함수이다.', 49, "'url_for()'는 뷰 함수 이름을 기반으로 동적으로 URL을 생성해준다."),
                                                                                                                           (2417, 'Flask에서 데이터베이스 모델을 정의할 때 사용하는 ORM 클래스는 무엇인가?', 1, 'medium', 'db.Model', 'db.Schema', 'db.Entity', 'db.Table', 49, "'db.Model'은 SQLAlchemy에서 모델 클래스를 정의할 때 상속하는 기본 클래스이다."),
                                                                                                                           (2418, 'Flask에서 사용자가 요청을 보낼 때, 요청한 데이터를 JSON 형식으로 받기 위해 사용하는 메서드는 무엇인가?', 3, 'medium', 'request.form', 'request.args', 'request.json', 'request.body', 49, "'request.json'은 요청 본문에 포함된 JSON 데이터를 파싱하여 사용할 수 있게 해준다."),
                                                                                                                           (2419, 'Flask에서 `Flask-SQLAlchemy`를 사용하여 모델 간 관계를 설정할 때 `backref`는 무엇을 의미하는가?', 2, 'medium', '한 방향의 관계를 쉽게 쿼리할 수 있도록 해준다.', '양방향 관계를 쉽게 쿼리할 수 있도록 해준다.', 'ForeignKey를 설정하는 데 사용된다.', '정렬 조건을 추가하는 데 사용된다.', 49, "'backref'는 관계를 정의할 때 반대 방향에서도 참조할 수 있게 해준다."),
                                                                                                                           (2420, 'Flask 애플리케이션을 Docker로 컨테이너화하기 위해 사용할 수 있는 기본적인 파일은 무엇인가?', 1, 'medium', 'Dockerfile', 'flaskfile', 'docker-compose.yml', 'app.yaml', 49, "'Dockerfile'은 애플리케이션 이미지를 생성하기 위한 기본 정의 파일이다."),
                                                                                                                           (2421, 'Flask에서 `app.run(debug=True)`를 사용하면 어떤 기능이 활성화되는가?', 1, 'low', '자동으로 코드 변경 시 서버가 재시작된다.', '디버깅 정보가 브라우저에 출력된다.', '코드 에러 발생 시 사용자에게 오류 메시지를 제공한다.', '배포 모드로 실행된다.', 49, "'debug=True'는 개발 중 코드 변경 시 자동 재시작 기능과 디버깅 기능을 제공한다."),
                                                                                                                           (2422, 'Flask에서 `@app.before_request()` 데코레이터는 무엇을 위해 사용되는가?', 2, 'medium', '응답 전후에 추가 작업을 실행한다.', 'HTTP 요청이 처리되기 전에 실행된다.', '라우팅 전에 실행되어 URL 경로를 변경한다.', '세션 종료 후 로그아웃 처리를 한다.', 49, "'@app.before_request()'는 요청이 처리되기 전에 실행될 콜백을 등록할 때 사용된다."),
                                                                                                                           (2423, 'Flask에서 REST API 응답으로 JSON 데이터를 보내기 위해 사용하는 함수는 무엇인가?', 1, 'low', 'jsonify()', 'render_template()', 'send_json()', 'make_response()', 49, "'jsonify()'는 파이썬 딕셔너리 등을 JSON 형식으로 응답할 수 있도록 변환해준다."),
                                                                                                                           (2424, 'Flask에서 JWT(Json Web Token) 인증을 구현할 때 사용하는 확장 모듈은 무엇인가?', 1, 'medium', 'Flask-JWT-Extended', 'Flask-Security', 'Flask-Auth', 'Flask-OAuth', 49, "'Flask-JWT-Extended'는 JWT 기반 인증 기능을 Flask에서 쉽게 구현할 수 있도록 도와주는 확장 모듈이다."),
                                                                                                                           (2425, 'Flask에서 `url_for()` 함수는 어떤 데이터를 반환하는가?', 2, 'medium', 'HTTP 요청을 위한 URL 경로', '서버 주소와 경로를 포함한 URL', '요청의 쿼리 문자열', 'URL에 대한 인증 토큰', 49, "'url_for()'는 뷰 함수명을 기반으로 전체 URL 경로를 반환한다."),
                                                                                                                           (2426, 'Flask에서 웹 페이지 리다이렉션을 구현할 때 사용하는 함수는 무엇인가?', 1, 'low', 'redirect()', 'send_redirect()', 'move_to()', 'url_redirect()', 49, "'redirect()'는 다른 URL로 HTTP 응답을 보낼 때 사용된다."),
                                                                                                                           (2427, 'Flask에서 `Flask-SQLAlchemy`를 사용할 때 모델 정의 시 사용하는 필드 유형 중 날짜를 처리하는 필드는 무엇인가?', 1, 'medium', 'db.DateTime', 'db.Date', 'db.Timestamp', 'db.Time', 49, "'db.DateTime'은 날짜 및 시간 정보를 저장하기 위해 사용되는 필드 타입이다."),
                                                                                                                           (2428, 'Flask에서 클라이언트로부터 보내는 쿠키를 설정하려면 어떤 함수를 사용해야 하는가?', 1, 'low', 'response.set_cookie()', 'request.set_cookie()', 'session.set_cookie()', 'make_response.set_cookie()', 49, "'response.set_cookie()'는 HTTP 응답에 쿠키를 설정할 때 사용된다."),
                                                                                                                           (2429, 'Flask에서 세션 데이터를 서버에 저장하려면 어떤 방식이 기본적으로 사용되는가?', 3, 'medium', '서버의 파일 시스템에 저장', '서버의 메모리에 저장', '클라이언트의 쿠키에 저장', '데이터베이스에 저장', 49, "Flask는 기본적으로 세션 정보를 클라이언트 쿠키에 저장하고 서명하여 검증한다."),
                                                                                                                           (2430, 'Flask에서 여러 기능을 모듈화하여 관리할 때 사용하는 구조는 무엇인가?', 1, 'medium', 'Blueprint', 'Module', 'Package', 'Component', 49, "'Blueprint'는 Flask 애플리케이션을 모듈 단위로 구성할 수 있게 도와주는 기능이다."),
                                                                                                                           (2431, 'Flask에서 `Flask-SQLAlchemy`를 사용하여 모델을 정의할 때, 기본적으로 데이터베이스 테이블의 이름은 무엇으로 설정되는가?', 1, 'medium', '클래스 이름의 소문자 형태', '클래스 이름의 대문자 형태', '설정 파일에 정의된 이름', '자동으로 생성된 UUID', 49, "Flask-SQLAlchemy는 기본적으로 클래스 이름을 소문자로 변환하여 테이블 이름으로 사용한다."),
                                                                                                                           (2432, 'Flask에서 특정 뷰 함수가 호출될 때, `request.args`와 `request.form`의 차이는 무엇인가?', 1, 'medium', '`request.args`는 URL 쿼리 파라미터, `request.form`은 HTML 폼 데이터', '`request.args`는 헤더에 포함된 데이터, `request.form`은 서버에서 생성된 데이터', '`request.args`는 JSON 형식의 데이터, `request.form`은 텍스트 형식의 데이터', '`request.args`와 `request.form`은 동일한 데이터를 처리한다.', 49, "`request.args`는 GET 방식의 URL 파라미터, `request.form`은 POST 방식의 폼 데이터를 처리한다."),
                                                                                                                           (2433, 'Flask에서 `Flask-WTF`를 사용하여 폼 유효성 검사를 처리할 때, 필수 항목을 지정하려면 어떤 옵션을 사용해야 하는가?', 1, 'medium', 'validators=[DataRequired()]', 'required=True', 'mandatory=True', 'field_required=True', 49, "'validators=[DataRequired()]'는 필드가 비어있지 않도록 하는 Flask-WTF의 유효성 검사 옵션이다."),
                                                                                                                           (2434, 'Flask에서 `Blueprint`를 사용하여 애플리케이션을 구조화하는 이유는 무엇인가?', 1, 'medium', '코드의 재사용과 모듈화를 위해', '앱을 디버깅할 때 속도 향상을 위해', '보안을 강화하기 위해', '애플리케이션을 다국어 지원하도록 설정하기 위해', 49, "'Blueprint'는 애플리케이션을 기능별로 나누어 유지보수와 재사용성을 높인다."),
                                                                                                                           (2435, 'Flask에서 `Flask-Login`을 사용하여 세션을 관리할 때, 사용자의 로그인 상태를 확인하는 함수는 무엇인가?', 1, 'medium', 'current_user.is_authenticated', 'session.is_logged_in', 'user.check_session()', 'flask_login.check_login()', 49, "'current_user.is_authenticated'는 현재 사용자가 인증된 상태인지 확인하는 속성이다."),
                                                                                                                           (2436, 'Flask에서 애플리케이션을 배포할 때, Nginx와 gunicorn을 사용할 때 gunicorn의 역할은 무엇인가?', 1, 'medium', '애플리케이션을 실행하고 요청을 처리한다.', '정적 파일을 제공한다.', '애플리케이션의 데이터베이스를 관리한다.', '요청을 Nginx로 라우팅한다.', 49, "Gunicorn은 WSGI 서버로, Flask 애플리케이션을 실행하고 요청을 처리하는 역할을 한다."),
                                                                                                                           (2437, 'Flask에서 `@app.errorhandler(404)` 데코레이터를 사용하면 어떤 일이 일어나는가?', 1, 'low', '404 오류가 발생했을 때 호출되는 함수가 정의된다.', '404 오류가 발생하면 자동으로 로그인 페이지로 리다이렉트된다.', '서버가 종료된다.', '404 오류가 발생했을 때 응답을 반환한다.', 49, "'@app.errorhandler(404)'는 404 오류 발생 시 호출할 사용자 정의 핸들러를 등록하는 데 사용된다."),
                                                                                                                           (2438, 'Flask에서 `app.config.from_object()` 메서드는 무엇을 위해 사용되는가?', 1, 'medium', '애플리케이션 설정을 외부 객체에서 로드하기 위해', '애플리케이션의 라우팅을 설정하기 위해', '애플리케이션의 템플릿 경로를 설정하기 위해', '애플리케이션의 데이터베이스 연결을 설정하기 위해', 49, "'from_object()'는 클래스 또는 객체에서 설정값을 로드하는 데 사용된다."),
                                                                                                                           (2439, 'Flask에서 `make_response()` 함수는 무엇을 반환하는가?', 1, 'low', '응답 객체(Response object)', 'HTML 템플릿을 렌더링한 문자열', '서버의 로그 객체', '클라이언트의 요청 객체', 49, "'make_response()'는 커스터마이징 가능한 응답 객체를 생성할 때 사용된다."),
                                                                                                                           (2440, 'Flask에서 `flask_sqlalchemy.SQLAlchemy` 객체를 사용하여 데이터베이스 모델을 정의할 때, 관계 설정을 할 수 있는 필드는 무엇인가?', 1, 'medium', 'relationship', 'link', 'connect', 'assoc', 49, "'relationship'은 SQLAlchemy에서 테이블 간의 관계를 설정할 때 사용하는 필드이다."),
                                                                                                                           (2441, 'Flask에서 `url_for()` 함수는 어떤 용도로 사용되는가?', 1, 'medium', 'URL을 생성하여 리다이렉트하는 데 사용된다.', '현재 URL을 반환하는 데 사용된다.', 'HTML 폼 데이터를 서버로 전송하는 데 사용된다.', '템플릿을 렌더링하는 데 사용된다.', 49, "'url_for()'는 라우팅된 함수명을 기반으로 해당 URL을 동적으로 생성한다."),
                                                                                                                           (2442, 'Flask에서 `render_template()` 함수는 무엇을 하는가?', 1, 'low', '템플릿 파일을 읽어 HTML 응답을 반환한다.', 'HTML을 서버에 전송한다.', '사용자 입력 데이터를 필터링한다.', 'HTML 폼을 처리한다.', 49, "'render_template()'는 Jinja2 템플릿을 렌더링하여 HTML을 생성한다."),
                                                                                                                           (2443, 'Flask에서 `app.run(debug=True)`을 사용하면 어떤 효과가 있는가?', 1, 'low', '서버를 디버그 모드로 실행하여 에러가 발생할 때 상세 정보를 제공한다.', '서버를 배포 모드로 실행하여 성능을 최적화한다.', '서버를 자동으로 종료시킨다.', '사용자의 요청을 로그로 기록한다.', 49, "'debug=True'는 디버깅을 용이하게 하기 위해 예외 메시지를 브라우저에 출력한다."),
                                                                                                                           (2444, 'Flask에서 `@app.before_request` 데코레이터는 어떤 용도로 사용되는가?', 1, 'medium', '요청이 들어오기 전에 실행되는 함수를 정의한다.', '응답이 반환되기 전에 실행되는 함수를 정의한다.', '응답이 오류일 때 실행되는 함수를 정의한다.', '클라이언트 요청을 기록하는 데 사용된다.', 49, "'@app.before_request'는 요청을 처리하기 전에 실행될 로직을 정의하는 데 사용된다."),
                                                                                                                           (2445, 'Flask에서 `session` 객체는 무엇을 관리하는 데 사용되는가?', 1, 'medium', '사용자별 데이터를 세션 간에 유지한다.', 'HTTP 요청을 처리하는 데 사용된다.', '웹 애플리케이션의 서버 측 세션을 관리한다.', '사용자 인증 정보를 관리한다.', 49, "'session'은 클라이언트에 저장되는 쿠키 기반으로 사용자 데이터를 유지할 수 있게 해준다."),
                                                                                                                           (2446, 'Flask에서 `abort()` 함수의 역할은 무엇인가?', 1, 'medium', 'HTTP 요청을 종료하고 특정 상태 코드와 메시지를 반환한다.', '특정 URL로 리다이렉션을 처리한다.', '서버를 재시작한다.', '요청 헤더를 수정한다.', 49, "'abort()'는 예외를 발생시켜 지정된 HTTP 상태 코드를 클라이언트에 반환한다."),
                                                                                                                           (2447, 'Flask에서 `request.json`을 사용하여 접근할 수 있는 데이터는 무엇인가?', 1, 'low', 'JSON 형식으로 전송된 요청 본문 데이터', '쿼리 파라미터', '폼 데이터', '헤더 정보', 49, "'request.json'은 클라이언트에서 JSON 형식으로 전송한 데이터를 파싱하여 반환한다."),
                                                                                                                           (2448, 'Flask에서 `app.config.from_pyfile()`은 어떤 용도로 사용되는가?', 1, 'medium', '외부 설정 파일에서 설정을 로드하는 데 사용된다.', 'Flask 애플리케이션을 실행하는 데 사용된다.', '데이터베이스를 초기화하는 데 사용된다.', '플랫폼 정보를 반환하는 데 사용된다.', 49, "'from_pyfile()'은 파이썬 설정 파일(.py)로부터 설정을 불러오기 위한 함수이다."),
                                                                                                                           (2449, 'Flask에서 `url_for()`를 사용하여 템플릿에서 URL을 동적으로 생성할 때, 해당 함수에 넘겨야 할 인자는 무엇인가?', 1, 'medium', '뷰 함수의 이름과 해당 뷰 함수의 인자들', 'URL 경로와 HTTP 메소드', '사용자 인증 정보', '데이터베이스 연결 정보', 49, "'url_for()'는 라우팅된 함수 이름과 해당 함수에 필요한 파라미터를 기반으로 URL을 생성한다."),
                                                                                                                           (2450, 'Flask에서 `Flask-SQLAlchemy`를 사용하여 관계형 데이터베이스를 사용할 때, 기본적으로 사용하는 데이터베이스는 무엇인가?', 1, 'low', 'SQLite', 'MySQL', 'PostgreSQL', 'MongoDB', 49, "Flask-SQLAlchemy는 기본적으로 내장형 SQLite 데이터베이스를 사용하여 설정이 간편하다."),
                                                                                                                           (2451, 'Spring Boot에서 Kotlin을 사용할 때 가장 기본이 되는 클래스 선언 방식은?', 2, 'low', 'public static void main', 'fun main(args: Array<String>)', 'startApp(args: List<String>)', 'main(args: String[])', 50, "Kotlin의 기본 진입점은 'fun main(args: Array<String>)' 함수로 정의된다."),
                                                                                                                           (2452, 'Kotlin에서 Bean 주입을 생성자 방식으로 처리하기 위해 사용하는 키워드는?', 3, 'low', 'open', 'init', 'constructor', 'val', 50, "'constructor'는 클래스의 주 생성자를 명시적으로 정의할 때 사용된다."),
                                                                                                                           (2453, 'Spring Boot 애플리케이션의 진입점 클래스에 필요한 애노테이션은?', 2, 'low', '@EnableSpring', '@SpringBootApplication', '@RestApp', '@AutoScan', 50, "'@SpringBootApplication'은 컴포넌트 스캔과 자동 설정을 포함한 진입점 애노테이션이다."),
                                                                                                                           (2454, 'Spring에서 Kotlin을 사용할 때 자주 마주치는 특징은?', 3, 'medium', '변수는 반드시 null 가능해야 함', '모든 클래스는 추상 클래스여야 함', '기본적으로 모든 변수는 non-null로 설계됨', '클래스 이름은 대문자로 시작할 수 없음', 50, "Kotlin에서는 변수는 기본적으로 non-null이며, nullable로 지정하려면 명시적으로 ?를 붙여야 한다."),
                                                                                                                           (2455, 'Spring에서 Kotlin을 사용할 때 생성자에 `val` 또는 `var` 키워드를 붙이는 이유는?', 2, 'medium', '자동으로 Bean으로 등록되기 위해', '클래스 내부에 멤버 변수로 선언되기 위해', '코드가 Java로 변환되기 위해', '데이터 클래스로 강제되기 위해', 50, "'val' 또는 'var'를 붙이면 생성자 매개변수가 클래스의 멤버 변수로 자동 선언된다."),
                                                                                                                           (2456, 'Spring에서 Kotlin을 사용할 때 클래스에 반드시 필요한 키워드는?', 2, 'medium', 'abstract', 'open', 'final', 'static', 50, "Kotlin에서는 클래스나 메서드는 기본적으로 final이며 상속 또는 오버라이드를 위해 'open' 키워드를 사용해야 한다."),
                                                                                                                           (2457, 'Kotlin 기반 Spring 애플리케이션에서 Component Scan 대상은 기본적으로 어디부터 시작되는가?', 3, 'medium', 'src/main/kotlin/', '프로젝트 루트 디렉토리', '@SpringBootApplication이 위치한 패키지 이하', 'resource 폴더 경로 기준', 50, "'@SpringBootApplication'이 위치한 패키지 이하가 컴포넌트 스캔의 기본 시작 지점이다."),
                                                                                                                           (2458, 'Spring Boot에서 Kotlin의 `data class`를 Bean으로 사용할 때 주의할 점은?', 3, 'high', '기본 생성자를 가지지 않아야 함', '모든 필드는 반드시 null 허용해야 함', '필드를 val로 선언하면 변경이 불가하므로 의도에 맞게 설계해야 함', 'data class는 Bean으로 등록되지 않음', 50, "val로 선언된 필드는 불변이기 때문에 변경이 필요한 경우 주의해서 설계해야 한다."),
                                                                                                                           (2459, '다음 중 Spring과 Kotlin을 함께 사용할 때 DI가 실패할 수 있는 상황은?', 1, 'high', '클래스가 open으로 선언되지 않음', '생성자에 val을 쓰지 않음', 'Kotlin 버전이 1.3 이상일 때', '패키지 명이 중복될 때', 50, "Kotlin 클래스는 기본적으로 final이므로 프록시 기반 DI가 동작하려면 'open'으로 선언해야 한다."),
                                                                                                                           (2460, 'Spring Boot에서 Kotlin을 사용할 때 자주 사용하는 확장 함수 개념을 잘 설명한 것은?', 1, 'high', '외부 클래스에 메서드를 추가하는 방식으로 재정의 가능', '스프링 빈에 직접 주입되는 메서드', '모든 메서드가 오버라이딩되는 것', '코루틴과 함께 작동할 수 없음', 50, "확장 함수는 기존 클래스의 코드를 변경하지 않고 기능을 추가할 수 있게 해준다."),
                                                                                                                           (2461, 'Spring에서 REST API를 만들 때 Kotlin과 함께 가장 기본적으로 사용하는 애노테이션은?', 3, 'low', '@Controller', '@Service', '@RestController', '@Bean', 50, "'@RestController'는 RESTful 웹 서비스를 만들기 위해 사용되며, 응답을 JSON 형태로 반환하는 컨트롤러 클래스에 주로 사용된다."),
                                                                                                                           (2462, 'Kotlin에서 GET 요청을 처리할 때 사용하는 애노테이션은?', 2, 'low', '@PostMapping', '@GetMapping', '@RequestBody', '@PutMapping', 50, "'@GetMapping'은 HTTP GET 요청을 처리하는 메서드에 사용하는 Spring 애노테이션이다."),
                                                                                                                           (2463, 'Spring에서 `@RequestParam`은 어떤 경우에 사용되는가?', 2, 'low', 'JSON Body 파싱', '쿼리 파라미터 추출', '경로 변수 추출', '파일 업로드 처리', 50, "'@RequestParam'은 URL에 포함된 쿼리 파라미터 값을 메서드 인자로 주입할 때 사용된다."),
                                                                                                                           (2464, '경로 변수(`/users/{id}`)를 추출하기 위해 사용하는 애노테이션은?', 2, 'low', '@RequestParam', '@PathVariable', '@Param', '@RequestBody', 50, "'@PathVariable'은 URL 경로의 일부를 변수로 추출하여 메서드 파라미터에 바인딩한다."),
                                                                                                                           (2465, 'Spring에서 요청 본문(JSON 등)을 객체로 변환할 때 사용하는 애노테이션은?', 3, 'medium', '@RequestParam', '@PathVariable', '@RequestBody', '@Inject', 50, "'@RequestBody'는 HTTP 요청 본문을 자바 객체로 변환하기 위해 사용된다."),
                                                                                                                           (2466, '다음 중 Kotlin DSL 스타일의 라우팅 처리를 가장 잘 설명한 것은?', 2, 'medium', '조건문 기반으로 라우팅을 전환한다', '함수형 스타일로 HTTP 경로를 정의한다', '동적으로 컨트롤러를 주입한다', '데이터 클래스를 동적으로 생성한다', 50, "Kotlin DSL에서는 함수형 문법을 활용하여 HTTP 라우팅을 선언적으로 정의할 수 있다."),
                                                                                                                           (2467, '다음 중 Spring에서 Kotlin DSL을 통해 라우터를 정의할 때 사용하는 함수는?', 2, 'medium', 'route()', 'router { }', 'mapping()', 'controller { }', 50, "'router { }'는 Kotlin DSL에서 라우터 정의를 함수형 블록으로 구성할 수 있게 해준다."),
                                                                                                                           (2468, 'Kotlin에서 컨트롤러 메서드 반환 타입으로 가장 흔히 사용되는 것은?', 3, 'medium', 'View', 'String', 'ResponseEntity<T>', 'Any', 50, "'ResponseEntity<T>'는 HTTP 응답 코드와 바디를 함께 제어할 수 있어 실무에서 널리 사용된다."),
                                                                                                                           (2469, 'Kotlin과 Spring을 함께 사용할 때 유효성 검사를 위해 사용하는 애노테이션은?', 1, 'medium', '@Valid', '@Validated', '@Check', '@Verify', 50, "'@Valid'는 객체의 필드 유효성을 검사할 때 자주 사용하는 표준 JSR-303 애노테이션이다."),
                                                                                                                           (2470, 'Spring Boot와 Kotlin 조합에서 경량 라우팅 처리를 위한 라이브러리는?', 3, 'high', 'RestAssured', 'Spring WebFlux', 'Ktor', 'SpringWebMVC.kt', 50, "'Ktor'는 Kotlin으로 작성된 비동기 경량 서버 프레임워크로 REST API 라우팅에도 적합하다."),
                                                                                                                           (2471, 'Spring에서 Kotlin으로 서비스 계층 클래스를 정의할 때 자주 사용하는 애노테이션은?', 2, 'low', '@Repository', '@Service', '@Component', '@Entity', 50, "'@Service'는 비즈니스 로직을 처리하는 서비스 계층 클래스를 명확히 구분짓는 데 사용된다."),
                                                                                                                           (2472, 'Kotlin에서 생성자 기반 의존성 주입을 쉽게 하려면 어떤 접근 방식을 사용하는가?', 2, 'low', 'lateinit var + @Autowired', '생성자에 파라미터 추가 + constructor', '기본 생성자와 setter 조합', '생성자 내부에서 @Inject 사용', 50, "Kotlin에서는 생성자에 파라미터를 선언하고 constructor 키워드를 생략해도 생성자 주입이 가능하다."),
                                                                                                                           (2473, 'Service 클래스에서 예외를 던지고 싶을 때 사용하는 Kotlin 키워드는?', 2, 'low', 'catch', 'throw', 'raise', 'fail', 50, "'throw'는 예외를 발생시킬 때 사용하는 Kotlin 키워드이다."),
                                                                                                                           (2474, 'Kotlin에서는 사용자 정의 예외 클래스를 생성할 때 상속해야 하는 클래스는?', 2, 'medium', 'RuntimeException', 'Exception', 'Throwable', 'IllegalStateException', 50, "사용자 정의 예외는 일반적으로 'Exception' 클래스를 상속하여 생성한다."),
                                                                                                                           (2475, '다음 중 Kotlin답게 null을 활용한 예외 처리를 위한 구문은?', 2, 'medium', 'if (obj == null) throw Exception()', 'obj ?: throw IllegalArgumentException()', 'when (obj) { null -> throw }', 'obj?.run { } ?: fail()', 50, "'?:' 엘비스 연산자를 사용하면 null인 경우 예외를 던지는 간결한 코드 작성이 가능하다."),
                                                                                                                           (2476, 'Spring에서 전역 예외 처리용 클래스를 만들 때 사용하는 애노테이션은?', 3, 'medium', '@ErrorHandler', '@ExceptionMapper', '@ControllerAdvice', '@GlobalError', 50, "'@ControllerAdvice'는 전역적으로 컨트롤러의 예외를 처리할 수 있도록 하는 클래스에 사용된다."),
                                                                                                                           (2477, '@ExceptionHandler 애노테이션은 어떤 용도로 사용하는가?', 3, 'medium', '로그 기록', '요청 DTO 검증', '특정 예외 발생 시 처리 로직 실행', '정상 응답 반환', 50, "'@ExceptionHandler'는 특정 예외 발생 시 실행할 메서드를 정의할 때 사용된다."),
                                                                                                                           (2478, 'Kotlin에서 sealed class를 예외 처리에 활용할 수 있는 이유는?', 2, 'high', '무조건 에러가 발생하기 때문', '서브 클래스의 종류가 제한되어 패턴 매칭이 가능하기 때문', '코드를 간결하게 만들기 때문', '오직 싱글톤으로만 동작하기 때문', 50, "sealed class는 컴파일 타임에 서브 클래스가 제한되므로 when 구문으로 안전하게 분기 처리가 가능하다."),
                                                                                                                           (2479, 'Service 계층 테스트 시 Mock 객체를 만들기 위해 사용되는 Kotlin 라이브러리는?', 4, 'high', 'Mockito', 'Kotest', 'Kluent', 'MockK', 50, "'MockK'는 Kotlin에서 전용으로 만들어진 모킹 프레임워크로, Kotlin 특성을 잘 지원한다."),
                                                                                                                           (2480, '서비스 계층에서 여러 예외 케이스를 명확히 나누고자 할 때 가장 Kotlin스러운 방법은?', 3, 'high', 'Exception 메시지를 문자열로 다르게 줌', 'RuntimeException만 사용', 'sealed class로 예외 분기 + when으로 처리', '로그에 예외를 분기해서 기록', 50, "sealed class를 이용하면 각 예외 타입을 명확히 정의하고, when 문으로 타입별 처리 로직을 작성할 수 있다."),
                                                                                                                           (2481, 'Kotlin에서 JPA Entity 클래스를 정의할 때 가장 중요한 키워드는?', 3, 'low', '@Bean', '@Component', '@Entity', '@Table', 50, "'@Entity'는 해당 클래스가 JPA 엔티티임을 나타내기 위해 반드시 붙여야 한다."),
                                                                                                                           (2482, 'JPA에서 Entity 클래스에 반드시 선언해야 하는 필드는?', 4, 'low', 'String name', 'val type', 'Primary constructor', '식별자 필드(@Id)', 50, "'@Id'는 엔티티의 기본 키를 지정하기 위한 필수 애노테이션이다."),
                                                                                                                           (2483, 'Kotlin의 `val` 필드로 선언된 Entity 속성의 주의점은?', 1, 'medium', '수정이 불가능하여 setter가 생성되지 않음', '자동으로 데이터베이스와 동기화됨', '엔티티 매핑이 자동으로 생략됨', '모든 필드가 nullable이 됨', 50, "'val'은 불변이기 때문에 setter가 생성되지 않아 JPA에서 값 변경 시 문제가 발생할 수 있다."),
                                                                                                                           (2484, 'JPA에서 엔티티 필드가 `null`을 허용하도록 하려면 Kotlin에서 어떤 문법을 사용하는가?', 3, 'medium', 'lateinit', 'nullsafe', '?', '!!', 50, "Kotlin에서 '?'를 타입 뒤에 붙이면 해당 필드가 null을 허용하는 nullable 타입이 된다."),
                                                                                                                           (2485, 'Kotlin에서 JPA를 사용할 때 `data class`를 피해야 하는 이유는?', 1, 'medium', '자동 생성된 equals/hashCode가 프록시 객체와 충돌할 수 있음', '모든 필드가 자동으로 final이 되기 때문', 'JPA는 data class를 지원하지 않기 때문', 'data class는 Bean으로 등록되지 않기 때문', 50, "JPA는 프록시 객체를 사용하기 때문에 data class의 equals/hashCode 구현이 충돌할 수 있다."),
                                                                                                                           (2486, '엔티티 클래스가 `open` 키워드를 가져야 하는 주된 이유는?', 2, 'medium', 'Spring DevTools와 호환되기 위해', 'JPA가 프록시 생성을 위해 런타임에 상속 구조를 사용하기 때문', '엔티티를 View에 노출하기 위해', '모든 Bean이 open이어야 하기 때문', 50, "JPA는 엔티티를 프록시로 감싸기 위해 런타임에 클래스를 상속하므로 open이 필요하다."),
                                                                                                                           (2487, 'JPA에서 `@GeneratedValue`는 어떤 역할을 하는가?', 2, 'low', '필드에 기본값을 설정', 'ID 값을 자동으로 생성', '엔티티를 자동으로 저장', 'Entity를 불변으로 만듦', 50, "'@GeneratedValue'는 기본 키 값을 자동으로 생성하도록 설정할 때 사용된다."),
                                                                                                                           (2488, '코틀린에서 지연 로딩(LAZY)을 사용할 때 발생할 수 있는 문제는?', 3, 'high', '자동 저장 누락', '코루틴과 충돌', '프록시 초기화 시 NPE 발생 가능성', '동시성 충돌', 50, "지연 로딩된 객체가 실제 초기화되지 않은 상태에서 접근되면 null이 되어 NPE가 발생할 수 있다."),
                                                                                                                           (2489, '다음 중 Kotlin에서 JPA Entity를 작성할 때 권장되지 않는 설계 방식은?', 2, 'high', '기본 생성자 제공', '생성자 파라미터를 모두 val로 고정', 'nullable 필드에 기본값 설정', '엔티티 클래스에 open 키워드 사용', 50, "'val'로 고정된 필드는 변경이 불가능하여 JPA가 값을 주입하거나 변경할 때 문제가 발생할 수 있다."),
                                                                                                                           (2490, 'Spring Boot에서 JPA를 Kotlin과 함께 사용할 때 필수적인 gradle 플러그인은?', 4, 'high', 'kotlin-android', 'spring-boot-jpa', 'kotlin-jpa', 'kotlin-allopen', 50, "'kotlin-allopen'은 Kotlin 클래스에 open 키워드를 자동으로 추가해 JPA와 호환되도록 도와준다."),
                                                                                                                           (2491, 'Kotlin에서 코루틴을 선언하기 위해 사용하는 키워드는?', 3, 'low', 'launch', 'async', 'suspend', 'thread', 50, "'suspend' 키워드는 코루틴 함수임을 나타내며, 다른 suspend 함수를 호출하거나 일시 중단 가능한 처리를 가능하게 한다."),
                                                                                                                           (2492, 'Spring에서 Kotlin 코루틴을 지원하기 위한 종속성은?', 3, 'low', 'spring-boot-starter-reactor', 'spring-kotlin-coroutines', 'spring-boot-starter-webflux', 'spring-coroutines-support', 50, "'spring-boot-starter-webflux'는 코루틴을 포함한 비동기 논블로킹 처리를 위한 Spring 공식 스타터이다."),
                                                                                                                           (2493, '`@Async`를 사용하면 Spring에서 어떤 처리를 할 수 있는가?', 2, 'low', '자동으로 캐싱한다', '비동기적으로 메서드를 실행한다', '코루틴을 자동 생성한다', '애플리케이션을 종료한다', 50, "'@Async'는 별도의 스레드에서 메서드를 비동기로 실행할 수 있게 해주는 Spring의 애노테이션이다."),
                                                                                                                           (2494, '코루틴에서 `Deferred<T>`는 무엇을 의미하는가?', 3, 'medium', '비동기 흐름을 끊는 객체', 'Thread 대신 사용하는 객체', '비동기 작업의 결과를 담는 약속(Promise)', '예외를 모니터링하는 객체', 50, "'Deferred<T>'는 결과가 미래에 제공될 비동기 연산의 핸들을 의미하며, Java의 Future와 유사하다."),
                                                                                                                           (2495, 'Spring WebFlux와 코루틴을 함께 사용할 때 가장 적합한 반환 타입은?', 4, 'medium', 'Deferred<T>', 'ResponseEntity<T>', 'Mono<T>', 'suspend fun', 50, "'suspend fun'을 사용하면 코루틴 기반 함수에서 자연스럽게 논블로킹 처리를 구현할 수 있다."),
                                                                                                                           (2496, 'Kotlin 코루틴에서 I/O 작업에 최적화된 Dispatcher는?', 3, 'medium', 'Dispatchers.Default', 'Dispatchers.Main', 'Dispatchers.IO', 'Dispatchers.Unconfined', 50, "'Dispatchers.IO'는 파일, 네트워크 등 I/O 중심의 무거운 작업을 위한 최적화된 디스패처이다."),
                                                                                                                           (2497, 'Spring에서 `@EnableAsync`를 선언하지 않으면?', 3, 'medium', '스프링 컨테이너가 실행되지 않는다', '코루틴이 중단된다', '`@Async`가 무시된다', 'DI가 실패한다', 50, "'@EnableAsync'를 선언해야 Spring이 '@Async'를 인식하고 비동기 처리를 수행할 수 있다."),
                                                                                                                           (2498, 'Kotlin에서 비동기 흐름을 선언적으로 구성할 수 있는 라이브러리는?', 3, 'high', 'Ktor', 'RxJava', 'Flow', 'Stream', 50, "'Flow'는 Kotlin에서 cold stream 기반으로 선언적 비동기 데이터 흐름을 구성할 수 있게 해주는 라이브러리이다."),
                                                                                                                           (2499, 'suspend 함수 내에서 다른 suspend 함수를 호출할 수 있는 이유는?', 3, 'high', '컴파일 타임 최적화 때문', '동시에 실행되기 때문', '코루틴 컨텍스트를 공유하기 때문', 'suspend 함수는 블로킹을 허용하기 때문', 50, "suspend 함수는 같은 코루틴 컨텍스트 내에서 실행되기 때문에 다른 suspend 함수 호출이 가능하다."),
                                                                                                                           (2500, '다음 중 Spring + Kotlin 비동기 처리에서 피해야 할 잘못된 조합은?', 3, 'high', 'suspend fun + WebClient', 'suspend fun + ResponseEntity', 'suspend fun + @Async', 'suspend fun + Flow', 50, "'@Async'는 Java Future 기반 비동기 처리 방식이고, suspend는 코루틴 기반이기 때문에 함께 사용하면 충돌할 수 있다."),
                                                                                                                           (2501, 'Spring Data JPA에서 Repository 인터페이스를 만들기만 해도 쿼리가 작동하는 이유는?', 2, 'low', '자동 컴파일 기능 덕분', 'Spring이 내부적으로 SQL을 생성해주기 때문', 'JVM이 데이터를 추론하기 때문', 'Hibernate가 모든 쿼리를 캐싱하기 때문', 51, "Spring Data JPA는 메서드 이름을 분석해 적절한 JPQL 쿼리를 생성해주는 기능을 내장하고 있다."),
                                                                                                                           (2502, 'JPA에서 @Entity가 붙은 클래스의 의미는?', 2, 'low', '클래스를 HTTP 요청으로 사용한다는 뜻', '클래스를 DB 테이블과 매핑하겠다는 뜻', '클래스를 DTO로 사용하겠다는 뜻', '클래스를 static으로 만든다는 뜻', 51, "'@Entity'는 해당 클래스가 데이터베이스 테이블과 매핑된다는 것을 JPA에 알리는 애노테이션이다."),
                                                                                                                           (2503, 'Hibernate에서 ''영속성 컨텍스트''의 주요 기능은?', 2, 'medium', 'SQL 정렬 기능', '객체의 생명 주기를 관리하고 1차 캐시 제공', '웹 요청을 모니터링', '클래스 파일을 컴파일', 51, "영속성 컨텍스트는 엔티티 객체를 관리하고 중복 조회를 방지하는 1차 캐시 역할을 수행한다."),
                                                                                                                           (2504, 'QueryDSL의 가장 큰 장점은?', 2, 'medium', 'SQL이 필요 없다', '복잡한 쿼리를 자바 코드로 타입 안정성 있게 작성할 수 있다', '자동으로 API를 생성해준다', '로그를 출력하지 않는다', 51, "QueryDSL은 자바 코드 기반으로 쿼리를 구성할 수 있어 컴파일 시점에 문법 오류를 잡을 수 있다."),
                                                                                                                           (2505, '다음 중 MyBatis의 주요 특징은?', 1, 'medium', 'ORM 없이 SQL을 XML 또는 Annotation으로 직접 작성', 'JPA 기반 쿼리 추상화', '데이터 직렬화 전용 도구', '로그 분석 프레임워크', 51, "MyBatis는 SQL을 직접 작성하여 쿼리의 명확성과 제어를 높일 수 있는 SQL 매핑 프레임워크이다."),
                                                                                                                           (2506, 'Spring Data JPA에서 사용하는 @Query 어노테이션은 어떤 용도인가?', 2, 'medium', '객체 직렬화', '직접 JPQL 또는 SQL 쿼리를 작성하기 위해', '엔티티 필터링을 위한 어노테이션', 'JSON 변환 설정', 51, "'@Query'는 메서드 이름으로 정의하기 어려운 쿼리를 직접 JPQL 또는 native SQL로 작성할 수 있게 해준다."),
                                                                                                                           (2507, 'JPA의 Entity는 기본적으로 어떤 구조로 데이터를 관리하는가?', 2, 'high', '스키마리스 구조', '객체지향 매핑 구조', '이벤트 기반 구조', '키-값 저장 구조', 51, "JPA는 객체와 관계형 데이터베이스 간의 매핑을 지원하는 ORM이므로 객체지향 매핑 구조를 따른다."),
                                                                                                                           (2508, 'QueryDSL을 사용하려면 어떤 도구로 Q클래스를 생성해야 하는가?', 2, 'high', 'IntelliJ', 'Gradle Annotation Processor', 'Lombok', 'JVM', 51, "QueryDSL의 Q 클래스는 컴파일 타임에 Gradle의 annotation processor를 통해 자동 생성된다."),
                                                                                                                           (2509, 'MyBatis의 resultMap은 어떤 역할을 수행하는가?', 3, 'high', '로그 출력', '쿼리 자동 생성', 'SQL 결과를 Java 객체에 매핑', '의존성 주입', 51, "resultMap은 SQL 쿼리 결과를 자바 객체의 필드에 매핑하기 위한 MyBatis의 핵심 기능이다."),
                                                                                                                           (2510, 'JPA에서 fetch join을 사용할 때 주의할 점은?', 3, 'high', '로그 레벨을 바꿔야 한다', '사용하면 항상 지연 로딩이 된다', 'distinct 없이 join이 중복 결과를 만들 수 있다', '쿼리가 캐시되지 않는다', 51, "fetch join은 여러 테이블을 조인해 엔티티를 조회하지만, 중복 결과를 방지하려면 distinct가 필요할 수 있다."),
                                                                                                                           (2511, 'Spring Security의 기본 역할은 무엇인가?', 3, 'low', '데이터베이스 연결 관리', 'HTML 렌더링 최적화', '웹 애플리케이션의 인증 및 인가 처리', '프론트엔드 스타일링', 51, "Spring Security는 인증(Authentication)과 인가(Authorization)를 처리하기 위한 보안 프레임워크이다."),
                                                                                                                           (2512, 'JWT에서 토큰의 유효성을 검증하기 위해 필요한 요소는?', 3, 'low', '이메일', 'DB 연결 정보', '서명에 사용된 시크릿 키', '프론트엔드 라우터', 51, "JWT는 서명 기반 구조이므로 유효성 검사를 위해 시크릿 키(secret key)가 필요하다."),
                                                                                                                           (2513, '다음 중 javax.validation에서 사용되는 어노테이션은?', 3, 'low', '@ValidValue', '@Check', '@NotNull', '@EntityCheck', 51, "'@NotNull'은 javax.validation에서 널이 아닌 값을 요구할 때 사용하는 대표적인 유효성 검사 애노테이션이다."),
                                                                                                                           (2514, '@PreAuthorize 어노테이션의 주요 기능은?', 3, 'medium', 'API 호출 로깅', '요청 바디 유효성 검사', '메서드 실행 전에 권한 조건을 평가', '프론트엔드 라우팅을 정의', 51, "'@PreAuthorize'는 메서드 실행 전에 SpEL을 통해 권한을 평가하는 Spring Security 애노테이션이다."),
                                                                                                                           (2515, 'Spring Security에서 Authentication 객체는 어떤 정보를 담고 있는가?', 2, 'medium', 'DB 연결 설정', '인증된 사용자 정보 및 권한', 'View 템플릿 이름', 'API 문서 경로', 51, "Authentication 객체는 사용자 ID, 권한, 인증 상태 등의 정보를 포함한다."),
                                                                                                                           (2516, 'Validator를 커스터마이징하려면 구현해야 하는 인터페이스는?', 4, 'medium', 'ValidationEngine', 'javax.validation.Validator', 'SpringSecurityChecker', 'ConstraintValidator', 51, "'ConstraintValidator' 인터페이스를 구현하면 커스텀 유효성 검사 로직을 정의할 수 있다."),
                                                                                                                           (2517, 'JWT 토큰 기반 인증의 가장 큰 장점은?', 2, 'high', '모든 요청에 대해 DB를 통해 세션 조회', '상태를 서버에 저장하지 않아 확장성이 높음', '서버 부하가 항상 일정함', '응답 시간이 느림', 51, "JWT는 상태 비저장(stateless) 방식으로 서버에 세션을 저장하지 않기 때문에 수평 확장이 용이하다."),
                                                                                                                           (2518, 'Spring Security에서 필터 체인의 순서를 조정하려면 어디에 설정해야 하는가?', 2, 'high', 'application.yml', 'securityFilterChain Bean 등록 시', 'Controller 클래스 내부', 'Validator 클래스 내부', 51, "필터 체인의 순서는 securityFilterChain Bean 정의 시 설정할 수 있다."),
                                                                                                                           (2519, 'JSR-380은 어떤 기술과 관련 있는 명세인가?', 2, 'high', '자바스크립트 비동기 처리', 'Java의 Bean Validation (예: @NotNull 등)', '스프링 REST 템플릿', 'Gradle 빌드 최적화', 51, "JSR-380은 자바의 Bean Validation 2.0 스펙으로 @NotNull, @Size 등 유효성 검증을 위한 표준이다."),
                                                                                                                           (2520, 'Spring Security의 인증 실패 처리를 위한 기본 전략은?', 3, 'high', 'AccessDeniedHandler', 'AuthenticationSuccessHandler', 'AuthenticationFailureHandler', 'UnauthorizedException', 51, "'AuthenticationFailureHandler'는 인증 실패 시 호출되어 실패 원인에 따른 처리를 담당한다."),
                                                                                                                           (2521, 'Swagger의 주된 목적은 무엇인가?', 3, 'low', '보안 설정', 'API 요청을 암호화', 'API 명세서를 자동으로 생성하고 테스트 제공', '로그를 파일에 저장', 51, "Swagger는 API 문서를 자동으로 생성하고 테스트 UI를 제공하는 도구로, 개발자와 사용자 모두에게 편리함을 제공한다."),
                                                                                                                           (2522, 'Spring에서 Swagger UI 기본 접근 경로는?', 2, 'low', '/docs', '/swagger-ui.html', '/api-spec', '/open-api', 51, "'/swagger-ui.html'은 Springfox Swagger 사용 시 기본 제공되는 UI 접근 경로이다."),
                                                                                                                           (2523, 'Springdoc(OpenAPI)에서 자동 문서를 생성하기 위해 사용하는 주석은?', 3, 'low', '@ApiDoc', '@RestSchema', '@Operation', '@Describe', 51, "'@Operation'은 특정 API 메서드에 대한 설명을 붙일 수 있도록 도와주는 Springdoc OpenAPI 어노테이션이다."),
                                                                                                                           (2524, '다음 중 Java 객체를 JSON으로 직렬화할 때 사용하는 Jackson 어노테이션은?', 1, 'medium', '@JsonSerialize', '@JsonEntity', '@JsonJoin', '@JsonConvert', 51, "'@JsonSerialize'는 객체를 JSON으로 변환할 때 사용하는 Jackson 어노테이션이다."),
                                                                                                                           (2525, '직렬화란 무엇을 의미하는가?', 2, 'medium', 'SQL 쿼리를 정렬', '데이터를 JSON이나 XML 같은 형식으로 변환', '객체를 메모리에 적재', '코드를 자동 컴파일', 51, "직렬화는 객체를 네트워크 전송이나 저장이 가능하도록 문자열 형식으로 변환하는 과정이다."),
                                                                                                                           (2526, 'GSON 라이브러리의 주된 기능은?', 2, 'medium', 'REST API 보안', 'JSON 직렬화 및 역직렬화', '서버 간 메시지 전달', '스프링 컨텍스트 초기화', 51, "GSON은 Google에서 만든 JSON 처리 라이브러리로, 자바 객체와 JSON 간의 변환을 쉽게 처리한다."),
                                                                                                                           (2527, 'Swagger에서 각 API의 설명을 작성할 때 사용하는 어노테이션은?', 3, 'medium', '@ApiDescription', '@ApiInfo', '@ApiOperation', '@OpenApiSpec', 51, "'@ApiOperation'은 Swagger에서 API 엔드포인트에 대한 설명을 정의하는 데 사용된다."),
                                                                                                                           (2528, 'Jackson에서 특정 필드를 JSON 결과에 포함하지 않으려면 사용하는 어노테이션은?', 1, 'high', '@JsonIgnore', '@JsonExclude', '@SkipField', '@HideFromJson', 51, "'@JsonIgnore'는 직렬화 또는 역직렬화 과정에서 해당 필드를 무시하게 한다."),
                                                                                                                           (2529, 'Spring REST Docs의 특징으로 올바른 것은?', 1, 'high', '테스트 코드 기반으로 문서를 생성', 'Swagger UI를 기반으로 한다', 'MySQL 데이터 문서를 만든다', 'GraphQL 쿼리를 시각화한다', 51, "Spring REST Docs는 테스트 코드를 기반으로 신뢰성 있는 API 문서를 생성하는 데 중점을 둔 도구이다."),
                                                                                                                           (2530, 'API 문서화를 위한 Swagger 설정은 보통 어디에 정의하는가?', 3, 'high', 'DTO 클래스', 'application.yml', 'SwaggerConfig 클래스', 'Controller 내부', 51, "Swagger 관련 설정은 보통 전용 설정 클래스인 'SwaggerConfig'에 정의하여 모듈화한다."),
                                                                                                                           (2531, 'SLF4J는 어떤 역할을 하는 라이브러리인가?', 3, 'low', 'API 문서를 생성한다', 'SQL 쿼리를 최적화한다', '로깅의 추상화를 제공하여 구현체 교체를 유연하게 한다', '데이터베이스를 백업한다', 51, "SLF4J는 다양한 로깅 구현체(Logback, Log4j 등)를 추상화하여 자유롭게 교체 가능하게 한다."),
                                                                                                                           (2532, '다음 중 Logback에 대한 설명으로 올바른 것은?', 3, 'low', 'HTML 렌더링을 수행한다', 'SLF4J를 대체하는 웹 프레임워크이다', 'SLF4J의 구현체 중 하나로 로그를 파일, 콘솔 등으로 출력', '보안 필터링 도구이다', 51, "Logback은 SLF4J의 대표적인 구현체이며, 파일, 콘솔 등 다양한 출력 방식을 지원한다."),
                                                                                                                           (2533, 'Spring Cache를 사용하기 위해 메서드 위에 붙이는 어노테이션은?', 3, 'low', '@CachePut', '@CacheValue', '@Cacheable', '@EnableCache', 51, "'@Cacheable'은 메서드의 실행 결과를 캐시하고, 동일한 인자로 다시 호출되었을 때 캐시된 결과를 반환한다."),
                                                                                                                           (2534, 'Redis의 가장 큰 장점 중 하나는?', 3, 'medium', '데이터를 장기 보존할 수 있음', 'HTTP 요청을 처리함', '메모리 기반 캐싱으로 빠른 데이터 접근 가능', '파일 시스템과 연동이 뛰어남', 51, "Redis는 메모리 기반의 키-값 저장소로 매우 빠른 속도로 데이터 접근이 가능하다."),
                                                                                                                           (2535, 'Spring Batch에서 ''Job''이란 무엇을 의미하는가?', 3, 'medium', '하나의 API 요청', '하나의 트랜잭션 처리', '여러 Step으로 구성된 일괄 처리 단위', '하나의 SQL 쿼리', 51, "Job은 Spring Batch에서 하나 이상의 Step으로 구성된 전체 처리 흐름을 나타낸다."),
                                                                                                                           (2536, 'Spring Batch의 구성 요소 중 Step의 역할은?', 2, 'medium', '단위 테스트 실행', '하나의 작업 단계를 의미하며 Reader, Processor, Writer로 구성', '배포 설정을 관리', '에러를 처리', 51, "Step은 실제 데이터 처리를 수행하는 단위로 Reader → Processor → Writer 구조를 갖는다."),
                                                                                                                           (2537, '다음 중 Spring Batch에서 데이터를 읽는 역할을 수행하는 구성요소는?', 2, 'high', 'Job', 'ItemReader', 'ItemWriter', 'Tasklet', 51, "ItemReader는 외부 데이터(파일, DB 등)를 읽어오는 역할을 담당하는 컴포넌트이다."),
                                                                                                                           (2538, 'Spring에서 로그를 JSON 포맷으로 출력하려면 사용하는 설정은?', 2, 'high', 'logback-xml-transformer', 'logstash-logback-encoder', 'jackson-logger', 'slf4j-parser', 51, "'logstash-logback-encoder'는 로그 데이터를 JSON 형식으로 출력할 수 있도록 도와주는 Logback 확장이다."),
                                                                                                                           (2539, 'Spring Cache에서 캐시를 비우는 데 사용하는 어노테이션은?', 2, 'high', '@CacheClear', '@CacheEvict', '@CacheDrop', '@CacheReset', 51, "'@CacheEvict'는 캐시에 저장된 데이터를 제거하기 위해 사용하는 Spring 애노테이션이다."),
                                                                                                                           (2540, 'Spring Batch의 Reader, Processor, Writer 구조를 사용하는 이유는?', 3, 'high', '코드를 짧게 줄이기 위해', '병렬 처리를 방지하기 위해', '대량 데이터를 효율적으로 처리하기 위해', '네트워크 연결을 단절하기 위해', 51, "Reader, Processor, Writer는 대량 데이터를 순차적으로 처리하여 메모리 효율성과 성능을 높이기 위한 구조이다."),
                                                                                                                           (2541, 'JUnit5에서 테스트 메서드 위에 붙이는 기본 어노테이션은?', 3, 'low', '@Execute', '@Start', '@Test', '@Run', 51, "'@Test'는 테스트 메서드임을 JUnit5에 알리는 표준 어노테이션이다."),
                                                                                                                           (2542, 'Mockito의 주요 사용 목적은?', 2, 'low', '빌드 스크립트를 실행', '객체를 모킹하여 독립적인 테스트 수행', '실제 DB 연결 테스트', '배치 잡 실행을 예약', 51, "Mockito는 테스트 대상 객체와 의존 객체를 분리하기 위해 가짜(mock) 객체를 만들어 사용하는 프레임워크이다."),
                                                                                                                           (2543, 'Spring Boot에서 테스트 클래스에 붙이는 어노테이션은?', 4, 'low', '@SpringTest', '@MockTest', '@BootTest', '@SpringBootTest', 51, "'@SpringBootTest'는 전체 애플리케이션 컨텍스트를 로드하여 통합 테스트를 가능하게 해준다."),
                                                                                                                           (2544, 'Testcontainers의 가장 큰 장점은?', 1, 'medium', '실제 DB 환경과 동일한 조건으로 테스트 가능', '단위 테스트 속도 감소', '로컬 환경에서만 동작', 'JVM에서만 실행', 51, "Testcontainers는 Docker 기반의 테스트 환경을 구성해 실제 서비스와 동일한 조건으로 테스트할 수 있다."),
                                                                                                                           (2545, 'Mockito에서 특정 메서드 호출을 검증하려면 사용하는 함수는?', 2, 'medium', 'when()', 'verify()', 'assertThat()', 'doReturn()', 51, "'verify()'는 테스트 대상 객체의 메서드가 실제로 호출되었는지 확인할 때 사용된다."),
                                                                                                                           (2546, 'Gradle의 설정 파일 확장자는?', 1, 'medium', '.gradle', '.yaml', '.bat', '.conf', 51, "Gradle의 설정 파일은 일반적으로 'build.gradle' 형태로 정의되며, Groovy 또는 Kotlin DSL을 사용할 수 있다."),
                                                                                                                           (2547, 'Maven에서 의존성을 관리하는 기본 파일은?', 3, 'medium', 'pom.gradle', 'settings.gradle', 'pom.xml', 'maven.config', 51, "'pom.xml'은 Maven 프로젝트의 빌드 설정 및 의존성을 관리하는 핵심 구성 파일이다."),
                                                                                                                           (2548, 'JUnit 테스트에서 예외 발생을 테스트할 때 사용하는 어노테이션은?', 1, 'high', '@Test(expected = ...)', '@Throws', '@AssertException', '@Catch', 51, "'@Test(expected=Exception.class)'는 해당 테스트에서 특정 예외가 발생해야 성공하도록 설정하는 방식이다."),
                                                                                                                           (2549, 'Testcontainers는 어떤 기술을 기반으로 작동하는가?', 3, 'high', 'VMWare', 'Gradle Wrapper', 'Docker 컨테이너', 'Spring Devtools', 51, "Testcontainers는 Docker를 기반으로 컨테이너화된 테스트 환경을 제공하는 라이브러리이다."),
                                                                                                                           (2550, '빌드 도구 중 멀티 모듈 프로젝트에서 자주 사용되는 도구는?', 3, 'high', 'Logback', 'JUnit', 'Gradle 또는 Maven', 'Mockito', 51, "Gradle과 Maven은 멀티 모듈 구성과 의존성 관리에 강력한 기능을 제공하여 대규모 프로젝트에 적합하다."),
                                                                                                                           (2551, 'Spring Data JPA에서 Kotlin 데이터를 엔티티로 선언할 때 가장 적절한 키워드는?', 1, 'low', 'open class', 'sealed class', 'object', 'data class', 52, "JPA는 런타임 시 프록시 객체 생성을 위해 클래스를 상속해야 하므로 Kotlin에서는 'open class'를 사용해야 한다."),
                                                                                                                           (2552, 'Kotlin에서 JPA를 사용할 때 반드시 class를 open으로 선언하는 이유는?', 3, 'low', '컴파일 최적화를 위해', 'Spring Boot에서 자동으로 열어주기 때문', '프록시 생성을 위해 상속이 가능해야 하기 때문', '코드의 가독성을 높이기 위해', 52, "JPA는 프록시 객체를 생성해 엔티티를 감싸기 때문에 상속 가능한(open) 클래스가 필요하다."),
                                                                                                                           (2553, 'JPA에서 Kotlin의 data class를 엔티티로 직접 사용하지 않는 주된 이유는?', 4, 'medium', '생성자 파라미터가 자동 인식되지 않아서', 'Spring과 호환되지 않아서', '직렬화가 불가능해서', 'toString(), equals() 등이 자동 생성되어 문제가 생기기 쉬워서', 52, "data class는 자동 생성되는 메서드가 JPA의 프록시 및 동작 방식과 충돌할 수 있어 사용을 지양한다."),
                                                                                                                           (2554, 'QueryDSL을 Kotlin에서 사용하기 위해 필요한 추가 도구는?', 1, 'medium', 'KSP 또는 kapt를 통한 Q 클래스 생성', 'Spring Security 설정', 'Swagger 플러그인', 'Coroutine Dispatcher', 52, "QueryDSL의 Q 클래스 생성을 위해서는 KSP 또는 kapt와 같은 annotation processor가 필요하다."),
                                                                                                                           (2555, 'QueryDSL의 Q타입 클래스는 어떤 방식으로 생성되는가?', 3, 'medium', '런타임 리플렉션', 'JVM 컴파일러 자동 생성', '애노테이션 프로세서로 빌드 타임 생성', 'IDE 내부 캐시', 52, "Q 클래스는 빌드 시점에 annotation processor가 생성하며, 타입 안정성을 제공한다."),
                                                                                                                           (2556, 'JPA에서 @Id가 붙은 필드는 어떤 역할을 하는가?', 3, 'low', '로그 출력용', 'DB에 저장되는 파일 경로를 의미', '기본 키로 사용되어 엔티티를 구분', '캐시 처리를 위한 식별자', 52, "'@Id'는 엔티티의 기본 키를 지정하여 각 인스턴스를 식별하는 역할을 한다."),
                                                                                                                           (2557, 'Spring Data JPA에서 findByEmail 같은 메서드는 어떻게 동작하는가?', 1, 'medium', '런타임 시 매핑 정보에 따라 SQL이 직접 작성됨', '정적 HTML 문서를 생성', '서비스 레이어에 자동으로 주입됨', '정적 JSON 결과로 매핑', 52, "Spring Data JPA는 메서드 이름을 분석하여 자동으로 JPQL 쿼리를 생성하고 실행한다."),
                                                                                                                           (2558, 'QueryDSL에서 where 절을 Kotlin DSL 스타일로 연결할 때 사용하는 연산자는?', 3, 'high', '&&', 'plus()', 'and()', 'infix between()', 52, "'and()'는 조건들을 체이닝하여 가독성 높게 where 절을 구성할 수 있도록 하는 연산자이다."),
                                                                                                                           (2559, 'Spring JPA에서 native query를 Kotlin에서 사용할 때의 주의점은?', 1, 'high', 'nullable 처리 및 매핑 오류 방지', '문자열 연결 방식 제한', '로그 출력이 불가능함', '캐시 저장 불가능', 52, "native query 사용 시 결과가 정확히 매핑되지 않으면 NPE가 발생할 수 있어 null 처리에 주의해야 한다."),
                                                                                                                           (2560, 'Kotlin DSL 기반 QueryDSL의 가장 큰 장점은?', 2, 'high', '네이티브 쿼리 속도 향상', '가독성 높은 코드와 타입 안정성', '자동 테이블 생성', '모든 JPA 설정 생략 가능', 52, "Kotlin DSL로 작성된 QueryDSL은 코드가 간결하고 타입 안정성이 높아 유지보수에 유리하다."),
                                                                                                                           (2561, 'Spring Security의 기본 동작 목적은?', 3, 'low', '데이터 직렬화', '로그 포맷팅', '애플리케이션의 인증과 인가 처리', 'SQL 최적화', 52, "Spring Security는 사용자 인증(Authentication)과 권한 인가(Authorization)를 처리하는 보안 프레임워크이다."),
                                                                                                                           (2562, 'JWT 토큰의 구성 요소로 올바른 것은?', 3, 'low', 'Payload.Header.Signature', 'Token.Sign.Secret', 'Header.Payload.Signature', 'UserInfo.Token.Expiry', 52, "JWT는 Header, Payload, Signature의 세 부분으로 구성되어 있으며 각각 메타데이터, 사용자 정보, 서명을 담는다."),
                                                                                                                           (2563, 'Kotlin에서 Spring Security를 적용할 때 인증 정보를 가져오는 방식으로 가장 적절한 것은?', 1, 'low', 'SecurityContextHolder.getContext().authentication', 'Thread.currentThread()', 'ApplicationContext.getBean()', 'Kotlin Reflection', 52, "현재 로그인된 사용자의 인증 정보는 SecurityContextHolder를 통해 얻을 수 있다."),
                                                                                                                           (2564, 'JWT 토큰의 만료 시간을 설정하려면 어떤 claim을 사용해야 하는가?', 2, 'medium', 'sub', 'exp', 'auth', 'iss', 52, "'exp'(expiration)는 토큰의 만료 시점을 설정하는 표준 claim이다."),
                                                                                                                           (2565, 'Kotlin DSL을 활용한 유효성 검증 코드에서 자주 사용되는 구조는?', 3, 'medium', 'if-else 체인', 'try-catch 반복', 'require()와 check() 함수', 'println() 기반 분기', 52, "'require()'와 'check()'는 조건이 false일 경우 IllegalArgumentException 등을 발생시켜 검증에 활용된다."),
                                                                                                                           (2566, 'javax.validation에서 문자열이 비어 있지 않아야 할 때 사용하는 어노테이션은?', 2, 'medium', '@Nullable', '@NotBlank', '@Max', '@NotEmpty', 52, "'@NotBlank'는 null, 빈 문자열, 공백만 있는 문자열까지 모두 유효하지 않도록 검증한다."),
                                                                                                                           (2567, 'Spring Security에서 권한을 설정할 때 사용되는 클래스는?', 1, 'medium', 'HttpSecurity', 'RestTemplate', 'JwtEncoder', 'DataBinder', 52, "HttpSecurity는 경로별 접근 제어, 로그인/로그아웃 등 보안 설정을 구성하는 데 사용된다."),
                                                                                                                           (2568, 'JWT 기반 인증에서 토큰이 만료되었을 때 서버는 보통 어떻게 응답하는가?', 4, 'high', '403 Forbidden', '200 OK', '302 Redirect', '401 Unauthorized', 52, "유효하지 않거나 만료된 JWT는 인증 실패로 간주되어 401 Unauthorized를 응답한다."),
                                                                                                                           (2569, 'Spring Security 설정 시 요청 경로에 대한 접근 제한은 어디서 설정하는가?', 2, 'high', 'application.yml', 'SecurityFilterChain DSL 내부', 'Controller 내부', 'JWT Decoder', 52, "HttpSecurity를 정의하는 SecurityFilterChain 내부에서 경로별 접근 제한을 설정한다."),
                                                                                                                           (2570, 'Kotlin에서 사용자 입력에 대한 커스텀 유효성 검사를 구현하려면 어떤 인터페이스를 구현해야 하는가?', 1, 'high', 'Validator', 'Checker', 'RequestGuard', 'FieldFilter', 52, "javax.validation.Validator 또는 ConstraintValidator를 구현하여 사용자 정의 검증을 수행할 수 있다."),
                                                                                                                           (2571, 'Kotlin Coroutine의 가장 큰 장점 중 하나는?', 2, 'low', '멀티 쓰레드를 강제로 사용', '비동기 작업을 직관적이고 선언적으로 작성 가능', 'JVM에 직접 연동됨', '데이터베이스와만 사용됨', 52, "Coroutine은 비동기 로직을 순차적 코드처럼 작성할 수 있어 가독성과 유지보수성이 높다."),
                                                                                                                           (2572, 'WebClient는 어떤 구조의 HTTP 요청 처리 방식인가?', 3, 'low', '블로킹 방식', '동기식 처리', '논블로킹 방식', '모놀리식 통신', 52, "WebClient는 reactive 프로그래밍 기반으로 논블로킹 방식의 HTTP 요청을 처리할 수 있다."),
                                                                                                                           (2573, 'WebClient는 어떤 패키지에 포함되어 있는가?', 1, 'low', 'org.springframework.web.reactive.function.client', 'java.net.http', 'javax.servlet.client', 'org.springframework.web.client.blocking', 52, "WebClient는 Spring WebFlux에 포함되어 있으며, reactive function client 패키지에 속한다."),
                                                                                                                           (2574, '다음 중 Coroutine에서 비동기 작업을 실행하는 함수는?', 4, 'medium', 'delay()', 'launch{}', 'async{}', 'both launch{} and async{}', 52, "'launch{}'는 결과 없이 실행되고, 'async{}'는 결과를 반환하는 비동기 작업을 수행한다."),
                                                                                                                           (2575, 'WebClient를 사용할 때 비동기 결과를 받기 위해 사용하는 리턴 타입은?', 3, 'medium', 'String', 'Deferred<T>', 'Mono<T>', 'FutureTask<T>', 52, "WebClient는 Project Reactor 기반으로 동작하며, 응답 타입으로 Mono<T> 또는 Flux<T>를 사용한다."),
                                                                                                                           (2576, 'CoroutineScope를 명시적으로 지정하지 않고 사용하는 경우 어떤 문제가 발생할 수 있는가?', 3, 'medium', '성능 향상', '컴파일 에러', '코루틴 누수(leak) 발생', 'JPA가 초기화되지 않음', 52, "명시적인 CoroutineScope 없이 코루틴을 실행하면 종료되지 않아 누수가 발생할 수 있다."),
                                                                                                                           (2577, 'WebClient 설정 시 요청 timeout 설정은 어디에 적용하는가?', 2, 'high', 'WebClient 기본 생성자', 'HttpClient 옵션 설정', 'BaseUrl 설정', 'JPA Configuration', 52, "WebClient의 timeout은 내부적으로 사용하는 HttpClient 설정에서 지정해야 적용된다."),
                                                                                                                           (2578, 'Coroutine에서 실행 중 예외가 발생하면?', 3, 'high', '즉시 JVM이 종료된다', '모든 코루틴이 자동 정지된다', '해당 스코프 내 예외 처리 로직이 없으면 전파된다', '예외가 무시된다', 52, "Coroutine의 예외는 처리되지 않으면 상위 스코프로 전파되며, 전역 스코프에서는 앱 전체에 영향을 줄 수 있다."),
                                                                                                                           (2579, 'WebClient에서 헤더를 설정하려면 어떤 메서드를 사용하는가?', 2, 'high', 'addHeader()', 'header()', 'setHttpHeader()', 'withHeaders()', 52, "'header()' 메서드를 사용하여 WebClient 요청에 커스텀 헤더를 추가할 수 있다."),
                                                                                                                           (2580, 'Kotlin Coroutine을 사용하여 서버 응답 시간을 줄이기 위해 자주 사용하는 키워드는?', 2, 'high', 'runBlocking', 'withTimeout', 'awaitClose', 'yield', 52, "'withTimeout'은 일정 시간 내 작업이 완료되지 않으면 예외를 발생시켜 응답 지연을 방지할 수 있다."),
                                                                                                                           (2581, 'Springdoc-openapi의 주요 목적은?', 3, 'low', 'DB 연결을 자동화', 'API 요청을 캐싱', 'OpenAPI 3.0 명세 기반 문서 자동 생성', '로깅 레벨을 제어', 52, 'Springdoc-openapi는 OpenAPI 3.0 명세를 기반으로 API 문서를 자동 생성하는 데 목적이 있다.'),
                                                                                                                           (2582, 'Swagger UI는 주로 어떤 기능을 제공하는가?', 2, 'low', 'API 서버 간 연동', 'API를 시각적으로 테스트 및 문서화', 'SQL 쿼리 튜닝', '애플리케이션 모니터링', 52, 'Swagger UI는 API의 엔드포인트를 시각적으로 보여주고 테스트할 수 있도록 도와주는 도구다.'),
                                                                                                                           (2583, 'Kotlin Logging의 주요 특징은?', 3, 'low', 'JSP 로그만 지원', 'Spring 전용 로깅 도구', 'Kotlin에 최적화된 SLF4J 래퍼', 'Logback의 경쟁 도구', 52, 'KotlinLogging은 Kotlin 코드에 최적화된 SLF4J 래퍼로, 간결한 문법으로 로깅을 지원한다.'),
                                                                                                                           (2584, '다음 중 Spring Cache에서 사용되는 어노테이션은?', 1, 'medium', '@CachePut', '@CacheStore', '@EnableCache', '@StoreResult', 52, '@CachePut은 메서드의 실행 결과를 캐시에 저장하는 데 사용되는 Spring Cache 어노테이션이다.'),
                                                                                                                           (2585, 'Redis의 가장 큰 장점은?', 3, 'medium', '파일 기반 처리', '오라클 DB 통합', '인메모리 기반 고속 캐시 시스템', '스레드 안전성 없음', 52, 'Redis는 데이터를 메모리에 저장하기 때문에 매우 빠른 속도로 데이터를 읽고 쓸 수 있다.'),
                                                                                                                           (2586, 'Spring Cache를 활성화하기 위한 설정은?', 3, 'medium', '@EnableTransactionManagement', '@EnableScheduling', '@EnableCaching', '@EnableRedis', 52, '@EnableCaching은 Spring의 캐시 기능을 활성화할 때 사용하는 어노테이션이다.'),
                                                                                                                           (2587, 'Kotlin에서 로그를 출력하려면 KotlinLogging을 사용해 어떤 객체를 선언하는가?', 3, 'medium', 'val log = LoggerFactory.getLogger()', 'val log = LogManager.getLogger()', 'val log = KotlinLogging.logger {}', 'val log = System.out', 52, 'KotlinLogging에서는 KotlinLogging.logger {} 형식으로 로거를 생성한다.'),
                                                                                                                           (2588, 'Swagger에서 각 API 메서드를 설명할 때 사용하는 어노테이션은?', 2, 'high', '@ApiMethod', '@Operation', '@ApiAction', '@Endpoint', 52, '@Operation은 Swagger(OpenAPI) 문서에서 각 API 메서드에 대한 설명을 추가할 때 사용하는 어노테이션이다.'),
                                                                                                                           (2589, 'Spring Cache에서 조건부 캐시 적용 시 사용하는 속성은?', 1, 'high', 'unless', 'conditionOnly', 'onError', 'setIf', 52, 'unless는 조건이 true일 경우 캐시 저장을 하지 않도록 하는 속성이다.'),
                                                                                                                           (2590, '다음 중 캐시 무효화를 위해 사용하는 어노테이션은?', 3, 'high', '@CacheExpire', '@CacheInvalidate', '@CacheEvict', '@ClearCache', 52, '@CacheEvict는 캐시에서 데이터를 제거(무효화)할 때 사용하는 어노테이션이다.'),
                                                                                                                           (2591, 'Kotlin에서 테스트를 위한 대표적인 라이브러리로 올바른 것은?', 2, 'low', 'SpringTools', 'kotest', 'Postman', 'MockitoJVM', 52, 'kotest는 Kotlin 기반 테스트 프레임워크로, 다양한 테스트 스타일과 강력한 DSL을 제공한다.'),
                                                                                                                           (2592, 'mockk 라이브러리의 특징은?', 3, 'low', '자바 전용 목킹 라이브러리', 'Spring Boot 전용 문서화 도구', 'Kotlin에 최적화된 목(mock) 객체 생성 도구', '테스트 DB 자동 초기화 도구', 52, 'mockk는 Kotlin을 위한 목(mock) 객체 생성에 최적화된 테스트 라이브러리이다.'),
                                                                                                                           (2593, 'JUnit5의 기본 어노테이션은?', 4, 'low', '@TestCase', '@JUnitTest', '@RunTest', '@Test', 52, '@Test는 JUnit5에서 테스트 메서드를 나타내는 가장 기본적인 어노테이션이다.'),
                                                                                                                           (2594, 'Gradle Kotlin DSL의 빌드 스크립트 파일 확장자는?', 2, 'medium', '.gradlekts', '.kts', '.gradle', '.dslk', 52, 'Gradle Kotlin DSL은 .kts 확장자를 사용하는 Kotlin 스크립트 기반의 빌드 설정 파일이다.'),
                                                                                                                           (2595, 'Dockerfile에서 애플리케이션 실행을 위한 명령어는?', 3, 'medium', 'RUN', 'EXPOSE', 'CMD', 'COPY', 52, 'CMD는 컨테이너 실행 시 기본적으로 수행할 명령을 정의하는 Dockerfile 명령어이다.'),
                                                                                                                           (2596, 'GitHub Actions의 주요 목적은?', 3, 'medium', '코드 스니펫 저장', '브랜치 병합 제한', 'CI/CD 자동화 워크플로우 구성', 'Slack 연동', 52, 'GitHub Actions는 코드 푸시 시 CI/CD를 자동화할 수 있는 워크플로우를 구성하는 도구이다.'),
                                                                                                                           (2597, 'JUnit5에서 테스트 전후 실행되는 어노테이션은?', 1, 'medium', '@BeforeEach / @AfterEach', '@RunBefore / @RunAfter', '@PreTest / @PostTest', '@Start / @Stop', 52, '@BeforeEach와 @AfterEach는 각각 테스트 메서드 실행 전과 후에 실행되는 메서드를 정의할 때 사용된다.'),
                                                                                                                           (2598, 'mockk에서 특정 함수의 동작을 정의하려면 사용하는 함수는?', 3, 'high', 'runWith()', 'given()', 'every { ... }', 'whenever()', 52, 'mockk에서는 every { ... } 블록을 사용해 특정 함수의 동작을 정의한다.'),
                                                                                                                           (2599, 'Docker 이미지 빌드를 위해 가장 먼저 작성하는 파일은?', 3, 'high', 'build.gradle.kts', 'docker-compose.yml', 'Dockerfile', 'settings.gradle.kts', 52, 'Dockerfile은 Docker 이미지를 생성하기 위한 명령을 정의하는 가장 기본적인 파일이다.'),
                                                                                                                           (2600, 'GitHub Actions에서 워크플로우 실행 조건을 설정하는 파일은?', 4, 'high', 'ci.yaml', '.workflow.yml', 'main.yml', '.github/workflows/*.yml', 52, 'GitHub Actions는 .github/workflows/ 경로 아래의 YAML 파일을 기준으로 워크플로우를 정의하고 실행한다.'),
                                                                                                                           (2601, 'Spring Boot 애플리케이션을 실행하기 위해 일반적으로 사용하는 명령어는?', 3, 'low', 'java -compile app.jar', 'run app.jar', 'java -jar app.jar', 'spring start app.jar', 53, 'java -jar app.jar 명령어는 Spring Boot 애플리케이션을 실행할 때 가장 일반적으로 사용된다.'),
                                                                                                                           (2602, 'Spring에서 서로 다른 설정을 적용하기 위해 사용하는 개념은?', 2, 'medium', 'Environment', 'Profile', 'Context', 'PropertySource', 53, 'Profile은 개발/운영 환경 등 설정을 구분할 수 있도록 도와주는 Spring의 개념이다.'),
                                                                                                                           (2603, 'Spring Boot에서 활성화된 profile을 설정하는 방법으로 옳은 것은?', 3, 'medium', 'spring.run.profile=dev', 'set SPRING_PROFILE=dev', 'java -jar app.jar --spring.profiles.active=dev', 'profile=dev java -jar app.jar', 53, '명령줄 인자 --spring.profiles.active=dev 를 통해 실행 시 프로파일을 지정할 수 있다.'),
                                                                                                                           (2604, 'Spring Boot의 기본 내장 웹 서버는?', 1, 'low', 'Tomcat', 'Jetty', 'Undertow', 'Netty', 53, 'Spring Boot는 기본적으로 내장 톰캣 서버를 사용하여 실행된다.'),
                                                                                                                           (2605, '다음 중 Spring 애플리케이션 실행 시 로컬 환경 구분을 위한 올바른 프로퍼티 파일 이름은?', 2, 'low', 'application-local.json', 'application-local.properties', 'application@local.yml', 'local-application.properties', 53, 'Spring에서는 application-{profile}.properties 형식으로 프로파일별 설정을 구분한다.'),
                                                                                                                           (2606, 'Spring Boot에서 커스텀 포트를 설정하려면 어떤 속성을 사용해야 하나?', 3, 'low', 'server.custom.port', 'spring.port', 'server.port', 'web.port', 53, 'server.port는 Spring Boot에서 애플리케이션 포트를 변경할 때 사용하는 설정이다.'),
                                                                                                                           (2607, 'Spring Boot 프로젝트를 패키징할 때 jar 파일이 실행 가능하게 만들어지는 이유는?', 2, 'medium', 'Gradle이 zip으로 변환해서', 'Spring Boot Plugin이 main-class와 dependency를 병합하기 때문에', 'Tomcat이 내장되어 있기 때문에', 'JVM이 자동으로 클래스 경로를 탐색하기 때문에', 53, 'Spring Boot Plugin이 main-class와 모든 종속성을 하나의 실행 가능한 jar로 병합해 주기 때문이다.'),
                                                                                                                           (2608, 'Spring Boot에서 명시적으로 사용할 profile을 application.properties에 설정할 때 사용하는 키는?', 4, 'medium', 'spring.profile.default', 'spring.active', 'spring.application.profile', 'spring.profiles.active', 53, 'spring.profiles.active는 실행 시 사용할 Spring profile을 지정할 때 사용하는 키다.'),
                                                                                                                           (2609, '다음 중 Spring Boot 내장 서버가 아닌 것은?', 4, 'high', 'Tomcat', 'Jetty', 'Netty', 'GlassFish', 53, 'GlassFish는 Spring Boot의 내장 서버 옵션이 아니다. Java EE 기반 서버다.'),
                                                                                                                           (2610, 'Spring Boot 애플리케이션의 실행 진입점 클래스는 보통 어떤 어노테이션을 사용하나요?', 2, 'low', '@EnableAutoConfiguration', '@SpringBootApplication', '@Configuration', '@ComponentScan', 53, '@SpringBootApplication은 여러 주요 어노테이션을 포함한 복합 어노테이션으로, 실행 진입점 클래스에 사용된다.'),
                                                                                                                           (2611, 'Spring Boot 애플리케이션을 Docker 컨테이너로 빌드하기 위한 파일은?', 3, 'low', 'build.gradle', 'dockerfile', 'Dockerfile', 'settings.gradle', 53, 'Dockerfile은 Docker 이미지 생성을 위한 명령어들을 정의하는 표준 파일이다.'),
                                                                                                                           (2612, 'Nginx에서 다른 서버로 요청을 전달할 때 사용하는 지시어는?', 1, 'medium', 'proxy_pass', 'pass_request', 'redirect_to', 'reverse_pass', 53, 'proxy_pass는 Nginx가 백엔드 서버로 요청을 전달할 때 사용하는 주요 지시어이다.'),
                                                                                                                           (2613, 'Spring Boot Docker 이미지 빌드시 자주 사용하는 JDK 기반 경량 베이스 이미지로 적절한 것은?', 2, 'medium', 'ubuntu:latest', 'openjdk:17-alpine', 'java:11-full', 'springboot:base', 53, 'openjdk:17-alpine은 용량이 작고 실행 속도가 빠른 경량 이미지로 많이 사용된다.'),
                                                                                                                           (2614, 'Dockerfile에서 JAR 파일을 실행하는 명령으로 가장 적절한 것은?', 3, 'medium', 'CMD ["spring", "run", "app.jar"]', 'RUN app.jar', 'CMD ["java", "-jar", "app.jar"]', 'ENTRYPOINT app.jar', 53, 'CMD ["java", "-jar", "app.jar"]는 jar 파일을 실행할 때 자주 사용하는 Dockerfile 명령이다.'),
                                                                                                                           (2615, 'Spring Boot 애플리케이션을 Nginx와 함께 사용할 때 가장 일반적인 아키텍처는?', 1, 'low', 'Nginx가 프론트엔드 역할, Spring이 백엔드 역할', 'Spring이 요청을 받아 Nginx로 전달', 'Nginx가 DB 역할 수행', 'Spring Boot가 정적 리소스만 처리', 53, '일반적으로 Nginx는 정적 리소스를 처리하고, Spring Boot는 API 요청을 처리하는 백엔드 역할을 한다.'),
                                                                                                                           (2616, 'Docker Compose를 사용할 때 여러 컨테이너 간 네트워크 연결을 자동으로 해주는 기본 네트워크는?', 4, 'medium', 'external', 'host', 'bridge', 'default network', 53, 'Docker Compose는 서비스 정의 시 자동으로 default라는 사용자 정의 네트워크를 생성해 컨테이너를 연결한다.'),
                                                                                                                           (2617, 'HTTPS 통신을 위해 필요한 기본 요소는?', 3, 'medium', '리버스 프록시', 'Docker 이미지', 'SSL 인증서', 'Spring Profile', 53, 'HTTPS는 데이터를 암호화하기 위해 공개키 기반의 SSL 인증서를 필수적으로 사용한다.'),
                                                                                                                           (2618, 'Nginx 설정에서 443 포트를 사용하는 이유는?', 3, 'low', 'HTTP 요청을 전달하기 위해', 'Docker 컨테이너를 실행하기 위해', 'HTTPS 보안을 위해', 'Spring Boot 로깅을 위해', 53, '443 포트는 HTTPS 프로토콜의 기본 포트로, 암호화된 통신을 제공하기 위해 사용된다.'),
                                                                                                                           (2619, 'Spring Boot와 Nginx 연동 시 CORS 문제가 발생할 수 있는 주요 원인은?', 3, 'high', '포트 충돌', 'Docker 버전 불일치', '프록시 설정 누락', 'profile 설정 오류', 53, '프록시 설정이 누락되면 Origin이 다른 요청이 차단되며, CORS 에러가 발생한다.'),
                                                                                                                           (2620, 'Docker에서 build한 이미지로 컨테이너를 생성할 때 사용하는 명령은?', 1, 'low', 'docker run', 'docker build', 'docker start', 'docker exec', 53, 'docker run 명령어는 이미지를 기반으로 새로운 컨테이너를 생성하고 실행하는 명령이다.'),
                                                                                                                           (2621, 'Spring Boot에서 서로 다른 환경별 설정을 분리할 수 있도록 지원하는 기능은?', 3, 'low', 'Spring Actuator', 'Spring Security', 'Spring Profile', 'Spring JPA', 53, 'Spring Profile은 dev, prod 등의 설정을 분리해 환경별로 적용할 수 있게 해준다.'),
                                                                                                                           (2622, 'Spring Boot에서 기본 설정 파일 이름은?', 3, 'low', 'application.json', 'config.yml', 'application.yml', 'settings.xml', 53, 'Spring Boot는 기본적으로 application.yml 또는 application.properties 파일을 통해 설정을 로드한다.'),
                                                                                                                           (2623, 'Spring Profile을 통해 ''dev'', ''prod'' 설정을 나누었을 때 실행 시 적용할 Profile을 설정하는 방법은?', 2, 'medium', 'spring.profile.active', 'spring.profiles.active', 'spring.env.active', 'spring.profile.set', 53, 'spring.profiles.active는 실행 시 적용할 profile을 지정할 때 사용하는 설정 키다.'),
                                                                                                                           (2624, '.env 파일을 통해 환경 변수를 정의하고 Spring에서 사용하려면 어떤 라이브러리를 사용하는 것이 일반적인가?', 2, 'high', 'spring-boot-starter-data-jpa', 'dotenv-java', 'spring-cloud', 'spring-context-support', 53, 'dotenv-java는 .env 파일의 내용을 Java 애플리케이션에서 환경 변수로 읽을 수 있게 해주는 라이브러리이다.'),
                                                                                                                           (2625, 'application.yml에서 포트를 8081로 설정하려면 어떤 속성을 수정해야 하는가?', 3, 'low', 'server.host', 'spring.port', 'server.port', 'spring.application.port', 53, 'server.port 속성은 애플리케이션이 사용하는 포트를 지정하는 설정이다.'),
                                                                                                                           (2626, '다음 중 application.yml에서 profile 별로 설정을 나누는 방법으로 올바른 것은?', 4, 'medium', '---', '# dev config', '- profile: dev', '---\nspring:\n  profiles: dev', 53, 'YAML에서 --- 구분자를 사용하고 spring.profiles 키로 프로파일을 지정하여 설정을 나눌 수 있다.'),
                                                                                                                           (2627, '환경 변수로 DB 비밀번호를 설정하고 이를 application.yml에서 참조하려면 사용하는 문법은?', 1, 'medium', '${DB_PASSWORD}', '@DB_PASSWORD', '#DB_PASSWORD#', '{{ DB_PASSWORD }}', 53, '${...} 문법은 Spring에서 환경 변수나 프로퍼티 값을 참조할 때 사용된다.'),
                                                                                                                           (2628, '운영환경에서 민감 정보 노출을 피하기 위해 사용하는 설정 전략은?', 3, 'medium', '모든 설정을 하나의 파일에 저장', '소스코드에 직접 하드코딩', '환경 변수와 Profile 분리 사용', 'application.properties에 고정 저장', 53, '환경 변수와 Profile을 분리하면 민감 정보를 소스코드 외부에서 관리할 수 있어 보안이 강화된다.'),
                                                                                                                           (2629, 'application.properties 파일에서 사용하는 포맷은?', 3, 'low', 'JSON', 'YAML', 'key=value', 'INI', 53, 'application.properties 파일은 key=value 형식의 속성 설정 포맷을 사용한다.'),
                                                                                                                           (2630, 'Spring Boot에서 환경 변수 우선순위가 가장 높은 설정 방식은?', 3, 'high', 'application.yml', 'application.properties', '명령줄 인자', 'Profile 지정', 53, '명령줄 인자는 가장 높은 우선순위를 가지며, 실행 시 동적으로 값을 전달할 수 있다.'),
                                                                                                                           (2631, 'CI/CD에서 ''CI''는 무엇의 약자인가?', 2, 'low', 'Code Integration', 'Continuous Integration', 'Component Integration', 'Central Interface', 53, 'CI는 Continuous Integration의 약자로, 코드 변경 시마다 자동으로 통합하는 프로세스를 의미한다.'),
                                                                                                                           (2632, 'GitHub Actions에서 workflow 파일의 기본 경로는?', 3, 'low', '.git/workflows/', 'ci/config.yml', '.github/workflows/', 'docker/actions/', 53, 'GitHub Actions는 .github/workflows/ 폴더의 YAML 파일을 워크플로우 정의 파일로 사용한다.'),
                                                                                                                           (2633, 'GitHub Actions에서 Java 프로젝트의 빌드 도구로 Gradle을 사용할 때 기본 명령어는?', 1, 'low', './gradlew build', 'gradle run', 'java build', 'mvn compile', 53, './gradlew build는 Gradle Wrapper를 통해 프로젝트를 빌드하는 표준 명령어이다.'),
                                                                                                                           (2634, 'Spring Boot 프로젝트를 DockerHub에 배포하기 위한 Dockerfile에서 사용되는 기본 명령어는?', 2, 'medium', 'ENTRYPOINT', 'FROM', 'PUBLISH', 'STAGE', 53, 'FROM은 Dockerfile의 첫 줄에 사용되며, 베이스 이미지를 지정하는 필수 명령어이다.'),
                                                                                                                           (2635, 'GitHub Actions에서 workflow 실행 조건을 지정할 때 사용하는 키워드는?', 1, 'medium', 'on', 'run', 'if', 'trigger', 53, 'on 키워드는 push, pull_request 등 워크플로우 실행 조건을 정의할 때 사용된다.'),
                                                                                                                           (2636, 'DockerHub에 이미지를 푸시(push)할 때 필요한 인증 정보는?', 3, 'medium', 'API key', '액세스 토큰', 'username과 password/token', 'SSH key', 53, 'DockerHub에 푸시하려면 로그인 시 username과 password 또는 token이 필요하다.'),
                                                                                                                           (2637, 'Spring Boot 애플리케이션을 위한 GitHub Actions 워크플로우에서 테스트 단계를 실행하려면 어떤 명령어가 적절한가?', 2, 'low', './gradlew run', './gradlew test', 'mvn clean', 'java -jar app.jar', 53, './gradlew test는 JUnit 등 테스트 코드를 실행하는 데 사용되는 Gradle 명령어이다.'),
                                                                                                                           (2638, 'GitHub Actions에서 비공개 정보(예: DockerHub 토큰)를 저장하기 위한 공간은?', 3, 'low', 'Repository Settings > Webhooks', '.env 파일', 'Repository Settings > Secrets', 'Actions Cache', 53, 'GitHub Actions에서 보안이 필요한 정보는 Secrets에 저장하여 환경 변수처럼 사용한다.'),
                                                                                                                           (2639, 'Spring Boot 프로젝트에서 GitHub Actions로 CI/CD를 구성할 때, 주로 사용되는 Java 버전 지정 키는?', 4, 'medium', 'java_version', 'version', 'java.setup', 'java-version', 53, 'java-version은 GitHub Actions에서 Java의 설치 버전을 명시하는 표준 키이다.'),
                                                                                                                           (2640, 'GitHub Actions에서 여러 Job을 병렬로 실행하고 싶을 때 사용하는 키워드는?', 1, 'high', 'matrix', 'concurrent', 'parallel', 'multi', 53, 'matrix 전략은 여러 Job을 다양한 파라미터 조합으로 병렬 실행할 수 있게 해주는 기능이다.'),
                                                                                                                           (2641, 'Spring Boot 애플리케이션의 상태를 확인할 수 있는 라이브러리는?', 3, 'low', 'Spring Security', 'Spring Web', 'Spring Boot Actuator', 'Spring AOP', 53, 'Spring Boot Actuator는 애플리케이션의 헬스 체크, 메트릭 등 상태를 확인할 수 있는 기능을 제공하는 라이브러리다.'),
                                                                                                                           (2642, 'Spring Boot Actuator의 기본 엔드포인트 중 메트릭 정보를 제공하는 것은?', 2, 'low', '/actuator/loggers', '/actuator/metrics', '/actuator/info', '/actuator/env', 53, '/actuator/metrics 엔드포인트는 애플리케이션의 각종 성능 지표를 제공하는 Actuator의 주요 기능이다.'),
                                                                                                                           (2643, 'Spring Boot와 Micrometer를 함께 사용할 때 메트릭 데이터를 Prometheus로 수집하려면 어떤 의존성이 필요한가?', 1, 'medium', 'micrometer-registry-prometheus', 'micrometer-core', 'spring-boot-starter-security', 'spring-cloud-prometheus', 53, 'Prometheus로 메트릭을 전송하려면 micrometer-registry-prometheus 의존성이 필요하다.'),
                                                                                                                           (2644, 'Spring Boot에서 로깅 구성 시 application.yml 파일에서 설정할 수 있는 로깅 레벨은?', 1, 'low', 'ERROR, WARN, INFO, DEBUG, TRACE', 'CRITICAL, ALERT, DEBUG', 'HIGH, MEDIUM, LOW', 'ALL, NONE, CUSTOM', 53, 'Spring에서는 표준 로깅 레벨인 ERROR, WARN, INFO, DEBUG, TRACE 등을 application.yml로 설정할 수 있다.'),
                                                                                                                           (2645, '다음 중 로그를 구조화된 형태로 수집하고 시각화하는 도구 조합으로 가장 적절한 것은?', 3, 'medium', 'Nginx + Logrotate', 'Docker + Redis', 'ELK Stack (Elasticsearch, Logstash, Kibana)', 'Spring Cloud + Eureka', 53, 'ELK Stack은 로그 수집(Logstash), 저장(Elasticsearch), 시각화(Kibana)를 위한 도구 조합이다.'),
                                                                                                                           (2646, 'Micrometer를 사용할 때, 사용자 정의 커스텀 메트릭을 생성할 때 사용하는 메서드는?', 3, 'medium', 'Metrics.summary()', 'Metrics.custom()', 'Metrics.counter()', 'Metrics.metric()', 53, 'Metrics.counter()는 사용자 정의 카운터 메트릭을 생성할 때 사용하는 메서드다.'),
                                                                                                                           (2647, '다음 중 Grafana의 주요 역할은 무엇인가?', 3, 'low', '로그 수집', '메트릭 저장', '시각화 대시보드 제공', '애플리케이션 로깅', 53, 'Grafana는 다양한 데이터 소스를 기반으로 시각화된 대시보드를 제공하는 도구다.'),
                                                                                                                           (2648, 'Spring Boot에서 로거를 구성할 때 추천되는 Kotlin-friendly 로깅 라이브러리는?', 3, 'low', 'Java Logging', 'SLF4J', 'Kotlin Logging', 'Logrotate', 53, 'Kotlin Logging은 Kotlin에 최적화된 간단한 문법의 로깅 라이브러리로 SLF4J 위에서 동작한다.'),
                                                                                                                           (2649, 'Spring Boot Actuator에서 관리 기능(예: 종료, 로그레벨 변경 등)을 활성화하려면 어떤 설정이 필요한가?', 1, 'medium', 'management.endpoints.web.exposure.include=*', 'logging.level=DEBUG', 'server.shutdown.enabled=true', 'spring.lifecycle.timeout=30s', 53, 'management.endpoints.web.exposure.include=* 설정을 통해 모든 Actuator 엔드포인트를 외부에 노출할 수 있다.'),
                                                                                                                           (2650, '다음 중 로그 파일의 용량 제한 및 순환(rotate)을 위한 유틸리티는?', 2, 'medium', 'Sentry', 'Logrotate', 'Actuator', 'Micrometer', 53, 'Logrotate는 로그 파일의 크기를 제한하고 일정 주기로 새로운 파일로 교체하는 기능을 제공한다.'),
                                                                                                                           (2651, 'Node.js에서 파일 시스템을 제어하는 기본 모듈은?', 3, 'low', 'os', 'http', 'fs', 'net', 54, 'fs 모듈은 Node.js에서 파일 읽기, 쓰기, 삭제 등 파일 시스템 관련 작업을 수행할 수 있게 해준다.'),
                                                                                                                           (2652, 'Node.js에서 웹 서버를 생성하는 데 사용하는 모듈은?', 1, 'low', 'http', 'net', 'stream', 'url', 54, 'http 모듈은 Node.js에서 웹 서버를 생성하고 요청을 처리할 수 있도록 해주는 기본 모듈이다.'),
                                                                                                                           (2653, 'path.join() 함수의 주요 목적은?', 2, 'low', '파일 삭제', '경로 결합', '스트림 생성', 'URL 파싱', 54, 'path.join() 함수는 디렉토리와 파일명을 안전하게 연결하여 경로를 생성한다.'),
                                                                                                                           (2654, 'os 모듈로 할 수 있는 작업은?', 2, 'medium', '파일 생성', '메모리 정보 확인', '라우팅', '웹 요청 수신', 54, 'os 모듈은 CPU, 메모리 등의 시스템 정보를 확인할 수 있는 기능을 제공한다.'),
                                                                                                                           (2655, 'url.parse() 함수의 주요 역할은?', 2, 'medium', '경로 조작', 'URL 구성요소 추출', 'HTML 파싱', '요청 응답 처리', 54, 'url.parse() 함수는 주어진 URL을 protocol, host, pathname 등으로 분해하는 데 사용된다.'),
                                                                                                                           (2656, 'Buffer는 어떤 데이터를 처리하는 데 사용되는가?', 2, 'medium', '텍스트 데이터', '바이너리 데이터', 'JSON 데이터', '이미지 URL', 54, 'Buffer는 바이너리 데이터(파일, 이미지, 네트워크 패킷 등)를 직접 다룰 수 있도록 도와주는 객체이다.'),
                                                                                                                           (2657, 'stream 모듈의 주된 용도는?', 3, 'high', 'HTTP 라우팅', '이벤트 핸들링', '데이터 흐름 처리', '네트워크 소켓 연결', 54, 'stream 모듈은 큰 데이터를 조각으로 처리할 수 있게 해주는 데이터 흐름 API를 제공한다.'),
                                                                                                                           (2658, 'util.promisify()의 역할은?', 2, 'high', '동기화 실행', '콜백을 Promise로 변환', '파일 경로 병합', '서버 생성', 54, 'util.promisify()는 콜백 기반 함수를 Promise 기반으로 바꿔 async/await 문법을 사용할 수 있게 해준다.'),
                                                                                                                           (2659, 'crypto 모듈은 무엇을 위한 것인가?', 2, 'high', '네트워크 요청', '보안 해시 및 암호화', '디버깅', '서버 실행', 54, 'crypto 모듈은 암호화, 복호화, 해싱 등의 보안 기능을 제공한다.'),
                                                                                                                           (2660, 'Node.js에서 global 객체는 어떤 역할을 하는가?', 1, 'high', '전역 네임스페이스 제공', '모듈 임포트', '서버 생성', '파일 읽기', 54, 'global 객체는 Node.js 전역 범위에서 접근 가능한 객체와 함수를 제공한다.'),
                                                                                                                           (2661, 'Express.js에서 HTTP GET 요청을 처리하는 메서드는?', 2, 'low', 'app.fetch()', 'app.get()', 'app.receive()', 'app.post()', 54, 'app.get()은 특정 경로에 대한 HTTP GET 요청을 처리하는 Express의 메서드다.'),
                                                                                                                           (2662, 'Express에서 정적 파일을 제공할 때 사용하는 미들웨어는?', 1, 'low', 'express.static()', 'express.staticServe()', 'app.serve()', 'express.file()', 54, 'express.static()은 정적 파일(CSS, 이미지 등)을 서비스할 때 사용하는 Express 미들웨어이다.'),
                                                                                                                           (2663, '다음 중 Express.js에서 경로 파라미터를 정의하는 방식은?', 3, 'low', '/user/id', '/user?id=1', '/user/:id', '/user#id', 54, '/user/:id는 URL 경로에서 id 값을 파라미터로 받도록 정의하는 RESTful 방식이다.'),
                                                                                                                           (2664, 'Express에서 미들웨어는 어떤 역할을 하는가?', 2, 'medium', '데이터베이스 연결', '요청-응답 처리 사이 중간 로직', 'HTML 렌더링', '라우팅 생략', 54, '미들웨어는 요청과 응답 사이에 실행되며, 공통 처리 로직(로그, 인증 등)을 수행한다.'),
                                                                                                                           (2665, 'app.use()는 어떤 용도로 사용되는가?', 2, 'medium', '라우팅 정의', '미들웨어 등록', '서버 실행', '포트 설정', 54, 'app.use()는 Express 애플리케이션에서 전역 또는 특정 경로에 미들웨어를 등록하는 데 사용된다.'),
                                                                                                                           (2666, 'Express에서 JSON 파싱을 위해 사용하는 미들웨어는?', 1, 'medium', 'express.json()', 'app.bodyParser()', 'jsonParser()', 'express.body()', 54, 'express.json()은 들어오는 요청의 body를 JSON으로 파싱해주는 Express 미들웨어다.'),
                                                                                                                           (2667, '다음 중 라우터 인스턴스를 생성하는 방법은?', 3, 'high', 'express.newRouter()', 'new express.Router()', 'express.Router()', 'Router.create()', 54, 'express.Router()는 모듈화된 라우팅 기능을 제공하기 위해 Express에서 사용하는 메서드다.'),
                                                                                                                           (2668, '라우터를 app에 연결할 때 사용하는 메서드는?', 4, 'high', 'app.route()', 'app.getRouter()', 'app.bindRouter()', 'app.use()', 54, 'app.use()는 라우터 인스턴스를 애플리케이션에 연결할 때 사용하는 Express 메서드다.'),
                                                                                                                           (2669, 'Express에서 에러 핸들링 미들웨어는 몇 개의 인자를 가지는가?', 3, 'high', '2', '3', '4', '5', 54, '에러 핸들링 미들웨어는 (err, req, res, next) 형태로 총 4개의 인자를 받는다.'),
                                                                                                                           (2670, '라우팅 순서를 보장하려면 어떻게 해야 하는가?', 3, 'high', '이벤트 루프 사용', '미들웨어 체이닝', '정의 순서대로 선언', '라우팅 모듈화', 54, 'Express는 선언된 순서대로 라우팅을 처리하므로 라우트 정의 순서를 지켜야 순서가 보장된다.'),
                                                                                                                           (2671, 'Node.js에서 외부 패키지를 설치할 때 사용하는 명령어는?', 2, 'low', 'node install', 'npm install', 'npm add', 'npm get', 54, 'npm install 명령어는 Node.js 프로젝트에 외부 패키지를 설치할 때 사용되는 기본 명령어이다.'),
                                                                                                                           (2672, 'package.json 파일의 주된 목적은?', 3, 'low', '코드 설명', '서버 설정', '프로젝트 의존성 관리', 'HTML 빌드', 54, 'package.json은 프로젝트 메타데이터와 의존성 패키지 정보를 관리하는 파일이다.'),
                                                                                                                           (2673, 'Node.js에서 다른 파일의 기능을 가져올 때 사용하는 키워드는?', 2, 'low', 'import', 'require', 'include', 'use', 54, 'require는 CommonJS 모듈 시스템에서 외부 파일을 불러올 때 사용하는 키워드이다.'),
                                                                                                                           (2674, '로컬 의존성이 설치되는 기본 위치는?', 1, 'medium', 'node_modules/', '.npm/', 'lib/', 'packages/', 54, 'npm install로 설치된 로컬 패키지는 node_modules 디렉터리에 저장된다.'),
                                                                                                                           (2675, '버전 범위를 ^1.2.3 로 명시하면 허용되는 버전은?', 2, 'medium', '1.2.3 이상 1.3.0 미만', '1.2.3 이상 2.0.0 미만', '1.2.3 이상 1.2.4 미만', '정확히 1.2.3', 54, '^는 Major 버전 변경을 제외한 최신 Minor, Patch 버전을 허용한다.'),
                                                                                                                           (2676, 'package-lock.json 파일의 역할은?', 1, 'medium', '버전 고정 및 재현 가능성 제공', '개발자 정보 저장', '빌드 로그 저장', '서버 로그 기록', 54, 'package-lock.json은 의존성 버전을 고정시켜 동일한 환경에서 설치될 수 있도록 보장한다.'),
                                                                                                                           (2677, 'npm uninstall 명령어의 용도는?', 3, 'high', '프로젝트 제거', '노드 환경 삭제', '패키지 제거', '전체 초기화', 54, 'npm uninstall 명령어는 프로젝트에서 특정 패키지를 제거하는 데 사용된다.'),
                                                                                                                           (2678, '전역으로 패키지를 설치할 때 사용하는 옵션은?', 1, 'high', '-g', '-d', '--local', '--all', 54, 'npm install -g 명령은 전역(global) 설치를 의미하며, CLI 도구 등에 사용된다.'),
                                                                                                                           (2679, '모듈을 내보낼 때 사용하는 키워드는?', 3, 'high', 'export.module', 'require', 'module.exports', 'return module', 54, 'module.exports는 모듈 내 기능을 외부에서 사용할 수 있도록 내보낼 때 사용하는 키워드이다.'),
                                                                                                                           (2680, 'package.json 파일에서 실행 스크립트를 지정하는 필드는?', 2, 'high', 'commands', 'scripts', 'run', 'exec', 54, 'scripts 필드는 npm run으로 실행할 수 있는 사용자 정의 명령어를 설정할 때 사용된다.'),
                                                                                                                           (2681, 'Node.js는 어떤 모델을 기반으로 작동하는가?', 2, 'low', '멀티스레드', '싱글스레드 이벤트 루프', '프리엠티브', '블로킹 모델', 54, 'Node.js는 싱글스레드 기반 이벤트 루프 모델로 비동기 처리를 효율적으로 수행한다.'),
                                                                                                                           (2682, '비동기 처리를 위한 기본 함수는?', 3, 'low', 'for()', 'require()', 'setTimeout()', 'fetch()', 54, 'setTimeout은 지정한 시간이 지난 후 콜백 함수를 실행하는 비동기 함수이다.'),
                                                                                                                           (2683, '콜백 함수란?', 2, 'low', '에러를 리턴하는 함수', '다른 함수에 전달되어 실행되는 함수', '메서드 체이닝 함수', '이벤트 바인딩 함수', 54, '콜백 함수는 다른 함수에 인자로 전달되어 특정 시점에 실행되는 함수이다.'),
                                                                                                                           (2684, '이벤트 루프의 역할은?', 2, 'medium', '동기 코드 실행', '비동기 콜백 실행', '모듈 캐싱', '네임스페이스 생성', 54, '이벤트 루프는 비동기 작업의 콜백을 큐에서 꺼내 실행하는 역할을 한다.'),
                                                                                                                           (2685, 'Promise에서 성공 시 호출되는 메서드는?', 2, 'medium', 'catch()', 'then()', 'resolve()', 'finally()', 54, 'then()은 Promise가 성공적으로 이행되었을 때 실행할 콜백을 등록하는 메서드이다.'),
                                                                                                                           (2686, 'Promise를 async/await 문법으로 바꿨을 때 await는 어떤 역할을 하는가?', 4, 'medium', '즉시 실행', '지연 실행', '블로킹 대기', '비동기 완료까지 대기', 54, 'await는 Promise가 완료될 때까지 다음 줄 코드 실행을 일시 중단시킨다.'),
                                                                                                                           (2687, '이벤트를 등록하는 Node.js 메서드는?', 4, 'high', 'addListener()', 'on()', 'once()', '모두 해당', 54, 'Node.js에서는 addListener, on, once 모두 이벤트를 등록할 수 있는 메서드이다.'),
                                                                                                                           (2688, '이벤트 루프에서 작업 큐는 무엇을 저장하는가?', 2, 'high', '실행 중 함수', '예약된 콜백', '블로킹 코드', '모듈 캐시', 54, '작업 큐는 비동기 작업의 콜백 함수들을 저장해 이벤트 루프가 실행시킬 수 있게 한다.'),
                                                                                                                           (2689, '콜백 지옥의 주요 단점은?', 3, 'high', '성능 저하', '비동기 불가', '가독성 저하 및 에러 처리 어려움', '변수 충돌', 54, '콜백 지옥은 중첩된 콜백 구조로 인해 코드 가독성이 떨어지고 디버깅이 어려워진다.'),
                                                                                                                           (2690, '이벤트 기반 처리를 위해 사용하는 기본 모듈은?', 2, 'high', 'event', 'events', 'stream', 'process', 54, 'events 모듈은 Node.js의 기본 이벤트 기반 처리 기능을 제공하는 핵심 모듈이다.'),
                                                                                                                           (2691, 'Node.js에서 MongoDB와 연결하기 위한 대표적인 라이브러리는?', 1, 'low', 'mongoose', 'sequelize', 'pg', 'sqlite', 54, 'mongoose는 MongoDB와의 연결, 스키마 정의, CRUD 등을 쉽게 처리할 수 있는 ODM이다.'),
                                                                                                                           (2692, 'SQL 기반의 데이터베이스 연결에 사용하는 라이브러리는?', 2, 'low', 'mongoose', 'pg', 'mongo', 'redis', 54, 'pg는 PostgreSQL 등 SQL 기반 데이터베이스를 Node.js에서 연결하는 데 사용하는 라이브러리다.'),
                                                                                                                           (2693, 'MongoDB에서 컬렉션은 어떤 개념과 유사한가?', 1, 'low', '테이블', '열', '행', '스키마', 54, 'MongoDB에서 컬렉션은 RDB의 테이블에 해당하는 논리적 단위이다.'),
                                                                                                                           (2694, 'Mongoose에서 모델을 정의할 때 사용하는 함수는?', 3, 'medium', 'createModel()', 'define()', 'model()', 'schema()', 54, 'model() 함수는 정의한 스키마를 기반으로 데이터베이스와 연결된 모델을 생성한다.'),
                                                                                                                           (2695, 'MySQL을 Node.js에서 사용할 수 있도록 도와주는 패키지는?', 1, 'medium', 'mysql2', 'mysql-js', 'mysql-node', 'sql-node', 54, 'mysql2는 MySQL과의 연결 및 쿼리를 실행할 수 있는 Node.js용 패키지다.'),
                                                                                                                           (2696, 'mongoose.Schema는 어떤 역할을 하는가?', 1, 'medium', '데이터 검증', '라우팅', '비동기 처리', '이벤트 바인딩', 54, 'mongoose.Schema는 MongoDB 문서의 구조와 유효성 검사를 정의하는 데 사용된다.'),
                                                                                                                           (2697, 'MongoDB에서 데이터를 저장하는 단위는?', 1, 'high', 'Document', 'Table', 'Row', 'Field', 54, 'MongoDB는 데이터를 JSON 형태의 Document 단위로 저장한다.'),
                                                                                                                           (2698, 'sequelize는 어떤 ORM을 위한 라이브러리인가?', 2, 'high', 'NoSQL', 'SQL', 'JSON', 'REST', 54, 'sequelize는 MySQL, PostgreSQL 등 SQL 계열 DB를 위한 ORM 라이브러리이다.'),
                                                                                                                           (2699, 'mongoose의 find() 함수는 어떤 결과를 반환하는가?', 2, 'high', '하나의 객체', '배열', '문자열', '정수', 54, 'find() 함수는 조건에 맞는 여러 문서를 배열 형태로 반환한다.'),
                                                                                                                           (2700, 'MongoDB 연결 시 접속 문자열의 기본 포트는?', 1, 'high', '27017', '3306', '5432', '8080', 54, 'MongoDB는 기본적으로 27017 포트를 통해 클라이언트와 연결한다.'),
                                                                                                                           (2701, 'Node.js 애플리케이션을 프로세스 중단 없이 운영하기 위한 도구로 적절한 것은?', 3, 'low', 'Webpack', 'Nodemon', 'PM2', 'Nginx', 55, 'PM2는 Node.js 앱을 프로세스 중단 없이 운영하고 모니터링할 수 있게 도와주는 프로세스 매니저이다.'),
                                                                                                                           (2702, 'PM2로 Node.js 애플리케이션을 시작하는 명령어는?', 2, 'low', 'pm2 install app.js', 'pm2 start app.js', 'pm2 run app.js', 'pm2 launch app.js', 55, 'pm2 start app.js 명령어는 애플리케이션을 PM2로 실행하는 기본 명령이다.'),
                                                                                                                           (2703, 'Node.js 앱을 Docker로 배포할 때 가장 기본적인 구성 파일은?', 1, 'low', 'Dockerfile', 'docker.env', 'pm2.config.js', 'deploy.yaml', 55, 'Dockerfile은 Docker 컨테이너를 만들기 위한 모든 빌드 명령을 정의하는 기본 구성 파일이다.'),
                                                                                                                           (2704, 'Nginx를 통해 Node.js 서버로 요청을 전달하는 기능은?', 2, 'medium', 'Static Routing', 'Reverse Proxy', 'Load Balancing', 'DNS Forwarding', 55, 'Reverse Proxy는 클라이언트 요청을 백엔드 서버(Node.js 등)로 전달해주는 기능이다.'),
                                                                                                                           (2705, 'Node.js에서 환경변수를 `.env` 파일로 관리할 때 사용하는 패키지는?', 1, 'low', 'dotenv', 'env-loader', 'config.js', 'settings', 55, 'dotenv는 `.env` 파일의 환경 변수를 읽어 `process.env`로 주입해주는 라이브러리이다.'),
                                                                                                                           (2706, 'process.env.NODE_ENV 값으로 ''production''을 설정하는 이유는?', 2, 'medium', '개발 환경에서만 동작하게 하기 위해', '프로덕션 전용 설정을 로드하기 위해', '환경 변수를 비활성화하기 위해', 'Node.js를 종료시키기 위해', 55, 'production으로 설정하면 로깅 수준이나 캐싱 설정 등 프로덕션 최적화 설정이 적용된다.'),
                                                                                                                           (2707, 'GitHub Actions에서 `.yml` 파일 내에서 Docker 이미지를 빌드하려면 어떤 명령이 필요한가?', 3, 'medium', 'docker upload', 'docker deploy', 'docker build', 'docker init', 55, 'docker build 명령은 Dockerfile을 기반으로 이미지를 생성하는 기본 명령이다.'),
                                                                                                                           (2708, 'CI/CD에서 DockerHub에 이미지를 푸시하는 명령어는?', 3, 'low', 'docker transfer', 'docker upload', 'docker push', 'docker deploy', 55, 'docker push 명령어는 로컬에서 만든 Docker 이미지를 원격 저장소(DockerHub)로 전송한다.'),
                                                                                                                           (2709, 'Node.js에서 로그를 파일로 남기기 위해 가장 많이 쓰는 라이브러리는?', 3, 'low', 'log4js', 'Morgan', 'Winston', 'Bunyan', 55, 'Winston은 다양한 output 방식과 포맷 설정을 지원하는 강력한 로깅 라이브러리이다.'),
                                                                                                                           (2710, 'Sentry를 사용하는 주된 목적은?', 2, 'medium', '성능 개선', '에러 추적 및 알림', '파일 저장', 'API 문서화', 55, 'Sentry는 애플리케이션의 에러를 추적하고 알림을 통해 실시간 대응할 수 있게 도와준다.'),
                                                                                                                           (2711, 'PM2에서 애플리케이션을 재시작하는 명령어는?', 2, 'low', 'pm2 rerun app', 'pm2 restart app', 'pm2 reset app', 'pm2 relaunch app', 55, 'pm2 restart app 명령어는 실행 중인 프로세스를 재시작하는 데 사용된다.'),
                                                                                                                           (2712, 'PM2의 주요 기능이 아닌 것은?', 4, 'low', '프로세스 자동 재시작', '로드 밸런싱', '로그 기록', 'SQL 쿼리 최적화', 55, 'PM2는 애플리케이션 관리 도구이므로 SQL 쿼리 최적화 기능은 제공하지 않는다.'),
                                                                                                                           (2713, 'Node.js 앱이 비정상 종료되었을 때 PM2가 자동으로 재시작하도록 하는 설정은?', 1, 'medium', 'pm2 auto-restart', 'restart_on_fail', 'watch mode', 'forever mode', 55, 'pm2는 기본적으로 자동 재시작 기능이 내장되어 있으며 auto-restart 설정으로 조정 가능하다.'),
                                                                                                                           (2714, 'Docker를 사용할 때 Node.js 컨테이너에 Nginx를 연결하는 이유는?', 4, 'medium', 'DB와 연결하기 위해', '정적 파일을 자동 생성하기 위해', '보안 인증을 위해', 'Reverse Proxy 및 로드 밸런싱을 위해', 55, 'Nginx는 트래픽 분산과 리버스 프록시 기능을 제공해 Node.js 컨테이너 앞단에서 효과적으로 동작한다.'),
                                                                                                                           (2715, 'Dockerfile에서 Node.js 앱의 종속성을 설치하는 명령은?', 2, 'low', 'RUN node install', 'RUN npm install', 'RUN install dependencies', 'RUN yarn package', 55, 'RUN npm install 명령은 Node.js 프로젝트의 의존 패키지를 설치하는 기본 명령이다.'),
                                                                                                                           (2716, 'Nginx 설정에서 Node.js 서버로 트래픽을 전달하는 지시어는?', 1, 'medium', 'proxy_pass', 'forward_to', 'pass_traffic', 'connect_node', 55, 'proxy_pass는 Nginx가 외부 요청을 백엔드(Node.js)로 전달할 때 사용하는 지시어이다.'),
                                                                                                                           (2717, '.env 파일을 Node.js에서 읽어들이기 위한 적절한 순서는?', 3, 'low', 'require(''dotenv'').run()', 'require(''env'').load()', 'require(''dotenv'').config()', 'import dotenv from ''envfile''', 55, 'require(\'dotenv\').config()를 호출하면 .env 파일의 내용이 process.env에 주입된다.'),
                                                                                                                           (2718, '환경별 설정을 구분하여 관리하기 위한 방식으로 적절한 것은?', 2, 'medium', '하나의 .env 파일에 모두 작성', 'config.js에서 분기 처리', '패키지.json에 작성', 'app.js 상단에 직접 작성', 55, 'config.js에서 환경 변수에 따라 다른 설정을 로드하면 환경별 설정 관리가 용이하다.'),
                                                                                                                           (2719, 'CI/CD에서 테스트를 자동으로 실행하는 주요 목적은?', 3, 'medium', '배포 속도 향상', '보안 강화', '코드 품질 확보', '서버 비용 절감', 55, '자동 테스트는 배포 전 코드의 정상 동작을 확인하여 품질을 보장하는 역할을 한다.'),
                                                                                                                           (2720, 'GitHub Actions 워크플로우에서 main 브랜치에 push될 때만 작동하게 하려면 사용하는 키워드는?', 1, 'low', 'on: push', 'on: pull', 'on: commit', 'on: deploy', 55, 'on: push는 특정 브랜치에 push 이벤트가 발생했을 때 워크플로우가 실행되도록 한다.'),
                                                                                                                           (2721, 'GitHub Actions의 steps 내에서 쉘 명령어를 실행하려면 어떤 키워드를 사용해야 하나?', 2, 'low', 'shell', 'run', 'execute', 'command', 55, 'steps 아래 run 키워드를 사용하면 쉘 명령어를 실행할 수 있다.'),
                                                                                                                           (2722, 'Winston 로깅 라이브러리에서 로그 수준을 설정하는 기본 키워드는?', 1, 'low', 'level', 'severity', 'priority', 'logType', 55, 'level 키워드는 로그의 심각도를 설정할 때 사용되며, info, error 등의 수준이 있다.'),
                                                                                                                           (2723, 'Winston의 로그를 파일에 저장하려면 사용하는 transport는?', 2, 'medium', 'ConsoleTransport', 'FileTransport', 'StreamTransport', 'LogTransport', 55, 'FileTransport는 로그를 파일로 저장할 수 있도록 도와주는 Winston의 전송 도구이다.'),
                                                                                                                           (2724, '로그 파일의 용량이 커질 때 오래된 로그를 자동으로 제거해주는 도구는?', 1, 'medium', 'logrotate', 'filewatcher', 'winston-pruner', 'logclean', 55, 'logrotate는 로그 파일의 용량이 일정 기준을 넘을 때 자동으로 순환하고 제거하는 데 사용된다.'),
                                                                                                                           (2725, 'Sentry의 주요 기능은 다음 중 무엇인가?', 3, 'low', '로그 색인', '트래픽 분석', '에러 추적', '성능 테스트', 55, 'Sentry는 애플리케이션에서 발생하는 에러를 실시간으로 추적하고 분석하는 기능을 제공한다.'),
                                                                                                                           (2726, 'Sentry를 Node.js 프로젝트에 통합하려면 어떤 패키지를 설치해야 하나?', 1, 'low', '@sentry/node', 'sentry-js', 'node-sentry', 'sentry-logger', 55, '@sentry/node는 Node.js 환경에서 사용할 수 있는 공식 Sentry 클라이언트 패키지이다.'),
                                                                                                                           (2727, 'PM2에서 JSON 설정 파일을 사용하는 이유는?', 3, 'medium', '환경변수 암호화', '멀티 서버 연결', '앱 실행 설정을 자동화', 'Nginx 연동', 55, 'PM2는 JSON 파일로 여러 앱의 설정을 한 번에 관리하고 실행 자동화를 할 수 있다.'),
                                                                                                                           (2728, 'Docker에서 Node.js 앱이 사용하는 포트를 외부에 노출하는 방법은?', 1, 'medium', 'EXPOSE 지시어', 'ENV 설정', 'CMD 사용', 'COPY 포트', 55, 'EXPOSE 지시어는 컨테이너에서 사용하는 포트를 명시해 Docker가 외부 접근을 허용하도록 한다.'),
                                                                                                                           (2729, 'GitHub Actions에서 secret 값을 안전하게 사용하려면?', 3, 'medium', '환경 변수로 바로 입력', 'yml에 직접 작성', 'GitHub Secrets 사용', 'config 파일에 저장', 55, 'GitHub Secrets는 민감한 정보를 암호화된 상태로 안전하게 관리하고 워크플로우에서 사용할 수 있게 한다.'),
                                                                                                                           (2730, 'Node.js에서 운영 환경에서만 에러를 로깅하도록 하려면 조건문에 사용하는 값은?', 2, 'medium', 'process.env.LOG_LEVEL', 'process.env.NODE_ENV', 'process.env.MODE', 'process.env.DEBUG', 55, 'process.env.NODE_ENV는 현재 실행 중인 환경(dev, production 등)을 판단하는 기준으로 사용된다.'),
                                                                                                                           (2731, 'PM2에서 로그를 확인하는 명령어는?', 3, 'low', 'pm2 show logs', 'pm2 read logs', 'pm2 logs', 'pm2 status logs', 55, 'pm2 logs 명령어는 실행 중인 앱의 실시간 로그를 출력해주는 기본 명령어이다.'),
                                                                                                                           (2732, 'PM2의 process.json에서 실행할 스크립트를 정의하는 키는?', 2, 'medium', 'entry', 'script', 'exec', 'main', 55, 'script 키는 PM2에서 실행할 파일명을 지정할 때 사용된다.'),
                                                                                                                           (2733, 'PM2 프로세스를 영구적으로 등록해 서버 재부팅 후에도 실행하려면?', 1, 'medium', 'pm2 startup', 'pm2 persist', 'pm2 monitor', 'pm2 keepalive', 55, 'pm2 startup은 시스템 재시작 후에도 PM2 프로세스를 자동으로 실행되도록 설정한다.'),
                                                                                                                           (2734, 'Docker에서 Node.js 앱을 개발 모드로 실행하려면 어떤 명령이 유용한가?', 3, 'medium', 'docker build', 'docker compose dev', 'docker run -v', 'docker exec -it', 55, 'docker run -v는 호스트와 컨테이너 간 파일 변경을 실시간 반영하는 데 사용된다.'),
                                                                                                                           (2735, 'Nginx에서 정적 파일 서비스를 위한 디렉토리 설정 키워드는?', 2, 'medium', 'static_path', 'root', 'location', 'static_dir', 55, 'root는 location 블록 내에서 요청된 경로와 매핑되는 실제 파일 시스템 경로를 지정한다.'),
                                                                                                                           (2736, 'Dockerfile에서 애플리케이션의 실행 커맨드를 지정하는 지시어는?', 3, 'low', 'RUN', 'START', 'CMD', 'ENTRY', 55, 'CMD는 Docker 컨테이너 실행 시 기본으로 실행할 명령어를 지정하는 지시어이다.'),
                                                                                                                           (2737, 'Node.js에서 dotenv 라이브러리를 사용하는 주요 이유는?', 3, 'low', '파일 압축', '보안 검사', '환경 변수 로드', '모듈 번들링', 55, 'dotenv는 .env 파일의 내용을 process.env로 자동으로 불러와 사용할 수 있도록 한다.'),
                                                                                                                           (2738, '환경 설정 파일을 Git에 올리지 않기 위해 사용하는 파일은?', 3, 'low', 'git.config', '.env', '.gitignore', 'ignore.env', 55, '.gitignore 파일에 .env를 포함하면 환경 설정 파일이 Git에 업로드되지 않는다.'),
                                                                                                                           (2739, 'NODE_ENV를 ''production''으로 설정하는 이유는?', 2, 'medium', '앱이 자동으로 중단되기 위해', '운영 환경에 최적화된 동작을 위해', '테스트 스크립트를 실행하기 위해', '개발 서버를 우선 실행하기 위해', 55, 'production 환경에서는 캐시, 로깅, 보안 등의 설정이 최적화된다.'),
                                                                                                                           (2740, 'CI 파이프라인에서 ''build'' 단계가 실행되는 시점은?', 3, 'medium', '코드 작성 후', '테스트 실행 전', '코드가 push될 때', '릴리즈 후', 55, 'CI에서 build 단계는 일반적으로 코드가 저장소에 푸시될 때 트리거된다.'),
                                                                                                                           (2741, 'GitHub Actions에서 워크플로우 파일의 확장자는?', 2, 'low', '.js', '.yml', '.git', '.workflow', 55, 'GitHub Actions는 .yml 또는 .yaml 확장자를 사용하여 워크플로우를 정의한다.'),
                                                                                                                           (2742, 'CI/CD에서 ''deploy'' 단계의 목적은?', 2, 'low', '코드를 병합하는 것', '코드를 배포 환경에 전달하는 것', '코드를 테스트하는 것', '코드를 분석하는 것', 55, 'deploy 단계는 코드나 애플리케이션을 운영 환경이나 스테이징 서버 등에 배포하는 과정이다.'),
                                                                                                                           (2743, 'Winston에서 여러 로그 출력 방식을 정의하는 구성 요소는?', 3, 'medium', 'handler', 'exporter', 'transport', 'logger', 55, 'transport는 로그를 파일, 콘솔 등 다양한 대상으로 출력하도록 설정하는 구성 요소이다.'),
                                                                                                                           (2744, 'Sentry에서 에러를 수집하기 위해 가장 먼저 해야 할 작업은?', 3, 'medium', '코드에 에러 발생시키기', 'Sentry 계정 만들기', '코드에 DSN 설정', '환경변수 설정', 55, 'Sentry를 통해 에러를 수집하려면 DSN 키를 프로젝트에 설정해야 한다.'),
                                                                                                                           (2745, 'Sentry는 어떤 종류의 툴인가?', 2, 'low', '배포 자동화 툴', '에러 추적 및 로깅 툴', '코드 최적화 툴', 'DB 관리 툴', 55, 'Sentry는 애플리케이션의 에러를 추적하고 알림을 제공하는 모니터링 도구이다.'),
                                                                                                                           (2746, 'Node.js에서 Winston 로그 포맷을 설정할 때 사용하는 객체는?', 1, 'medium', 'format', 'template', 'style', 'layout', 55, 'format 객체를 통해 Winston에서 로그의 출력 형식을 정의할 수 있다.'),
                                                                                                                           (2747, 'GitHub Actions에서 여러 Job이 순서대로 실행되도록 하려면?', 3, 'medium', 'run-after', 'order-by', 'needs', 'depends', 55, 'needs 키워드는 특정 Job이 다른 Job 이후에 실행되도록 의존 관계를 정의한다.'),
                                                                                                                           (2748, 'PM2로 실행된 프로세스를 중단하려면 어떤 명령어를 사용할까?', 3, 'low', 'pm2 remove', 'pm2 pause', 'pm2 stop', 'pm2 down', 55, 'pm2 stop 명령어는 실행 중인 프로세스를 중단하는 데 사용된다.'),
                                                                                                                           (2749, 'Docker 이미지 빌드 시 캐시를 사용하지 않으려면 어떤 옵션을 사용하나?', 1, 'medium', '--no-cache', '--force', '--no-save', '--clear', 55, '--no-cache 옵션을 사용하면 Docker는 기존 캐시를 사용하지 않고 새롭게 이미지를 빌드한다.'),
                                                                                                                           (2750, '환경에 따라 설정 파일을 다르게 로드할 때 흔히 사용하는 node 패턴은?', 3, 'high', 'switch(process.env.MODE)', 'if (config.env === ''prod'')', 'require(''./config'')[process.env.NODE_ENV]', 'config.use(process.env.SETTING)', 55, 'process.env.NODE_ENV 값을 키로 하여 해당 환경의 설정 파일을 선택적으로 require하는 방식이 흔히 쓰인다.'),
                                                                                                                           (2751, 'Django 모델 클래스는 어떤 클래스를 상속받아야 하는가?', 3, 'low', 'BaseView', 'models.Base', 'models.Model', 'django.db.Model', 56, 'models.Model은 Django에서 모델 클래스를 정의할 때 반드시 상속받아야 하는 기본 클래스이다.'),
                                                                                                                           (2752, '다음 중 Django 모델에서 기본 키(primary key)를 자동으로 설정해주는 필드는?', 3, 'low', 'models.PrimaryField', 'models.CharField(primary=True)', 'models.AutoField(primary_key=True)', 'models.IDField', 56, 'AutoField는 기본 키로 자동 증가 값을 생성해주는 필드이며, primary_key=True로 설정한다.'),
                                                                                                                           (2753, '모델 인스턴스를 저장하려면 어떤 메서드를 호출해야 하는가?', 3, 'low', 'commit()', 'persist()', 'save()', 'apply()', 56, 'save() 메서드는 Django 모델 인스턴스를 DB에 저장할 때 사용하는 표준 메서드이다.'),
                                                                                                                           (2754, '모든 객체를 가져오는 기본 쿼리셋 메서드는?', 4, 'medium', 'Model.get_all()', 'Model.fetch()', 'Model.objects.get()', 'Model.objects.all()', 56, 'Model.objects.all()은 해당 모델의 모든 인스턴스를 가져오는 기본 쿼리셋 메서드이다.'),
                                                                                                                           (2755, 'Django 모델에서 ForeignKey 필드를 정의할 때 필요한 인자는?', 3, 'medium', 'related_name', 'to', 'on_delete', 'unique', 56, 'on_delete는 외래 키가 참조하는 객체가 삭제되었을 때의 동작을 정의하는 필수 인자이다.'),
                                                                                                                           (2756, 'Django의 Meta 클래스에서 db_table 옵션의 역할은?', 3, 'medium', '테이블 컬럼 이름 지정', '모델의 필드 순서를 지정', 'DB에 저장될 테이블 이름 지정', '모델 마이그레이션 방지', 56, 'db_table 옵션은 해당 모델이 DB에 생성할 실제 테이블의 이름을 명시적으로 설정할 때 사용된다.'),
                                                                                                                           (2757, '모델에서 __str__ 메서드를 재정의하는 이유는?', 3, 'medium', '객체의 ID를 바꾸기 위해', '객체를 JSON으로 직렬화하기 위해', '객체를 프린트할 때 의미 있는 문자열 반환', '쿼리 최적화를 위해', 56, '__str__ 메서드를 오버라이드하면 객체를 출력할 때 식별 가능한 문자열을 반환하도록 할 수 있다.'),
                                                                                                                           (2758, '다음 중 null=True가 의미하는 것은?', 3, 'high', '필드를 인덱싱한다', '필드를 DB에서 무시한다', 'DB에 NULL 값을 허용한다', '입력값을 항상 저장한다', 56, 'null=True는 해당 필드가 DB에서 NULL 값을 가질 수 있도록 허용하는 설정이다.'),
                                                                                                                           (2759, 'unique=True 옵션은 어떤 제약 조건을 부여하는가?', 3, 'high', '필수 입력 필드로 설정', '다른 테이블과 관계 설정', '같은 값을 가진 행이 DB에 존재할 수 없음', '입력 시 자동으로 생성', 56, 'unique=True는 해당 필드의 값이 DB 내에서 유일해야 함을 의미한다.'),
                                                                                                                           (2760, '쿼리셋에 조건을 적용하려면 어떤 메서드를 사용하는가?', 1, 'high', 'filter()', 'annotate()', 'exclude()', 'aggregate()', 56, 'filter()는 조건을 지정하여 특정 레코드만 조회하는 쿼리셋 메서드이다.'),
                                                                                                                           (2761, 'Django에서 기본 제공하는 인증 시스템은 어떤 앱에 포함되어 있는가?', 1, 'low', 'django.contrib.auth', 'django.core.auth', 'django.auth.system', 'django.user.manager', 56, 'Django는 기본적으로 django.contrib.auth 앱을 통해 사용자 인증과 권한 관리 기능을 제공한다.'),
                                                                                                                           (2762, 'DRF에서 인증되지 않은 사용자가 접근할 경우 반환되는 기본 응답 코드는?', 3, 'low', '200 OK', '403 Forbidden', '401 Unauthorized', '400 Bad Request', 56, 'DRF는 인증이 필요한 요청에서 인증 정보가 없으면 401 Unauthorized 응답을 반환한다.'),
                                                                                                                           (2763, 'Simple JWT에서 토큰을 발급받기 위해 사용하는 기본 엔드포인트는?', 2, 'low', '/auth/jwt/', '/api/token/', '/user/login/', '/jwt/token/get/', 56, 'Simple JWT는 기본적으로 /api/token/ 엔드포인트를 통해 access 및 refresh 토큰을 발급한다.'),
                                                                                                                           (2764, 'DRF 시리얼라이저에서 유효성 검사를 수동으로 수행하는 메서드는?', 4, 'medium', 'check_valid()', 'validate()', 'run_validation()', 'is_valid()', 56, 'is_valid() 메서드는 시리얼라이저 데이터의 유효성 검사를 수동으로 수행할 때 사용된다.'),
                                                                                                                           (2765, '시리얼라이저 필드에서 ''read_only=True''로 설정하면?', 2, 'medium', '필드를 DB에 저장하지 않음', '해당 필드는 응답에만 포함되고 요청에서 무시됨', '필드를 무조건 필수 입력으로 설정함', 'HTML 렌더링 전용', 56, 'read_only=True 설정은 해당 필드가 요청에서는 무시되고 응답에만 포함되도록 한다.'),
                                                                                                                           (2766, '시리얼라이저 필드에 custom validator를 적용하려면 어떤 매개변수를 사용하는가?', 3, 'medium', 'clean', 'validate_with', 'validators', 'check_field', 56, 'validators 매개변수는 커스텀 검증 로직을 적용할 때 사용하는 리스트형 인자이다.'),
                                                                                                                           (2767, 'DRF에서 사용자의 권한을 제어하는 클래스 기반 기능은?', 2, 'medium', 'ViewSet', 'Permission', 'Throttle', 'FieldLevelSecurity', 56, 'Permission 클래스는 사용자의 권한에 따라 요청 허용 여부를 제어하는 기능을 담당한다.'),
                                                                                                                           (2768, 'Simple JWT에서 access token과 refresh token의 차이는?', 3, 'high', 'access는 더 긴 만료시간을 가진다', 'refresh는 로그인 로그를 포함한다', 'access는 API 호출에 직접 사용되고 refresh는 재발급용', '둘 다 동일하게 사용된다', 56, 'access token은 API 호출에 직접 사용되고, refresh token은 access token을 재발급받을 때 사용된다.'),
                                                                                                                           (2769, 'DRF의 BasePermission 클래스를 상속하여 사용할 경우 반드시 구현해야 할 메서드는?', 2, 'high', 'check_user()', 'has_permission()', 'is_valid()', 'grant_access()', 56, 'has_permission()은 요청이 허용 가능한지 여부를 판단하는 필수 메서드이다.'),
                                                                                                                           (2770, '시리얼라이저에서 전체 객체 단위로 유효성을 검사할 때 사용하는 메서드는?', 3, 'high', 'validate_<field>()', 'check_valid()', 'validate()', 'full_clean()', 56, 'validate() 메서드는 전체 시리얼라이저 데이터에 대한 유효성 검사를 수행하는 데 사용된다.'),
                                                                                                                           (2771, 'Django REST Framework에서 CRUD 작업을 모두 처리하는 기본 클래스는?', 2, 'low', 'APIView', 'ViewSet', 'ListView', 'FormView', 56, 'ViewSet은 하나의 클래스에서 CRUD 작업을 모두 처리할 수 있도록 DRF가 제공하는 기본 클래스이다.'),
                                                                                                                           (2772, 'DRF에서 자동으로 URL 라우팅을 도와주는 도구는?', 3, 'low', 'PathResolver', 'UrlPatternBuilder', 'Router', 'LinkBinder', 56, 'Router는 ViewSet과 함께 사용되어 URL을 자동으로 생성하고 라우팅을 처리한다.'),
                                                                                                                           (2773, 'DRF의 ModelSerializer는 어떤 기능을 제공하는가?', 3, 'low', 'Form validation만 수행', '뷰 없이 HTML을 렌더링', '모델 필드를 자동으로 시리얼라이징', '자바스크립트 기반 REST API 구성', 56, 'ModelSerializer는 Django 모델을 기반으로 시리얼라이저 필드를 자동으로 생성해준다.'),
                                                                                                                           (2774, 'ListAPIView는 어떤 기능을 담당하는가?', 3, 'medium', 'POST 요청 처리', 'DELETE 요청 처리', '리스트 조회(GET)만 담당', 'HTML Form 처리', 56, 'ListAPIView는 리스트 데이터를 조회하는 GET 요청 전용 제네릭 뷰이다.'),
                                                                                                                           (2775, 'APIView와 GenericAPIView의 주요 차이점은?', 2, 'medium', 'APIView는 기능이 더 많다', 'GenericAPIView는 믹스인을 통해 공통 기능을 제공', 'APIView는 HTML 응답만 지원한다', 'GenericAPIView는 장고 폼에 특화되어 있다', 56, 'GenericAPIView는 믹스인을 통해 CRUD 기능을 쉽게 조합할 수 있는 확장형 APIView이다.'),
                                                                                                                           (2776, 'DRF에서 객체를 데이터로 직렬화하는 기본 단위는?', 3, 'medium', 'View', 'Model', 'Serializer', 'Router', 56, 'Serializer는 DRF에서 객체를 JSON 등의 형식으로 변환하거나 역직렬화하는 기본 구성 요소이다.'),
                                                                                                                           (2777, '다음 중 RetrieveAPIView가 처리하는 요청은?', 2, 'medium', '객체 삭제', '객체 단건 조회', '객체 리스트 조회', '객체 생성', 56, 'RetrieveAPIView는 단일 객체를 조회하는 GET 요청을 처리하는 제네릭 뷰이다.'),
                                                                                                                           (2778, 'ViewSet을 사용하면 어떤 점이 유리한가?', 3, 'high', '모델 정의 없이 API 구성 가능', '직렬화 없이 HTML 반환', 'CRUD API를 하나의 클래스에서 관리 가능', '로그인 페이지를 자동 생성', 56, 'ViewSet은 하나의 클래스에서 모든 CRUD 기능을 정의할 수 있어 코드 관리가 용이하다.'),
                                                                                                                           (2779, 'Serializer 클래스에서 create() 메서드의 목적은?', 2, 'high', '객체를 삭제한다', '새 객체를 생성하여 저장한다', '뷰를 렌더링한다', '폼을 유효성 검사한다', 56, 'create() 메서드는 시리얼라이저를 통해 validated_data를 기반으로 새 객체를 생성할 때 사용된다.'),
                                                                                                                           (2780, 'DRF에서 @action 데코레이터는 무엇을 위한 기능인가?', 3, 'high', '쿼리 최적화', 'Serializer 확장', '커스텀 라우팅 기능 추가', '폼 자동 생성', 56, '@action 데코레이터는 ViewSet 내에서 사용자 정의 라우트를 추가할 때 사용된다.'),
                                                                                                                           (2781, 'Django에서 기본적으로 제공하는 캐시 백엔드는?', 3, 'low', 'Memcached', 'Redis', 'LocMemCache', 'FileCache', 56, 'LocMemCache는 Django에서 기본적으로 제공하는 메모리 기반의 캐시 백엔드이다.'),
                                                                                                                           (2782, '다음 중 Celery의 주요 목적은?', 2, 'low', '정적 파일 서빙', '비동기 작업 처리', '템플릿 렌더링', 'DB 마이그레이션', 56, 'Celery는 비동기 작업 큐를 제공하여 장시간 실행되는 작업을 백그라운드에서 처리할 수 있게 한다.'),
                                                                                                                           (2783, 'Celery와 함께 주기적인 작업을 등록할 때 사용하는 패키지는?', 3, 'low', 'celery-scheduler', 'django-beat', 'django-celery-beat', 'crontab-plus', 56, 'django-celery-beat는 Celery 작업을 Django Admin에서 주기적으로 실행되도록 관리할 수 있게 해준다.'),
                                                                                                                           (2784, 'Redis를 Django 캐시로 사용할 때 필요한 설정 항목은?', 1, 'medium', 'CACHES[\'BACKEND\'] = \'django.core.cache.backends.redis.RedisCache\'', 'CACHES[\'ENGINE\'] = \'django.cache.redis\'', 'USE_REDIS = True', 'REDIS_MODE = \'cache\'', 56, 'Redis를 Django 캐시 백엔드로 사용하려면 BACKEND 키에 redis 캐시 엔진 경로를 지정해야 한다.'),
                                                                                                                           (2785, 'Django 로깅 설정에서 로그 파일 저장을 위해 설정해야 할 핸들러는?', 2, 'medium', 'console', 'file', 'email', 'stream', 56, 'file 핸들러는 로그를 파일에 저장하는 용도로 사용된다.'),
                                                                                                                           (2786, '로깅 레벨 중 가장 낮은 단계는?', 3, 'medium', 'WARNING', 'INFO', 'DEBUG', 'ERROR', 56, 'DEBUG는 가장 낮은 단계의 로깅 레벨로, 상세한 디버깅 정보를 기록할 수 있다.'),
                                                                                                                           (2787, 'Celery에서 task 함수로 등록하려면 어떤 데코레이터를 사용하는가?', 4, 'medium', '@background', '@task', '@celery_task', '@shared_task', 56, '@shared_task 데코레이터는 Celery에 태스크를 등록하고 실행할 수 있게 한다.'),
                                                                                                                           (2788, 'Sentry의 주요 역할은?', 3, 'high', 'DB 최적화', '정적 파일 관리', '서버 예외 추적 및 오류 모니터링', 'URL 라우팅', 56, 'Sentry는 실시간으로 서버나 프론트엔드에서 발생한 오류를 수집하고 추적할 수 있는 서비스이다.'),
                                                                                                                           (2789, 'Django에서 캐시 만료 시간을 설정하려면 어떤 속성을 사용해야 하는가?', 3, 'high', 'cache_age', 'max_age', 'timeout', 'expires_in', 56, 'timeout 속성은 캐시된 데이터가 유효한 시간을 초 단위로 설정하는 데 사용된다.'),
                                                                                                                           (2790, 'Celery worker를 실행하는 기본 명령어는?', 3, 'high', 'celery --run', 'celery -A project_name run', 'celery -A project_name worker', 'celery worker start', 56, 'celery -A project_name worker 명령어는 지정한 프로젝트의 태스크 워커를 실행하는 기본 명령이다.'),
                                                                                                                           (2791, 'pytest-django의 주요 기능은?', 2, 'low', '템플릿 렌더링 속도 향상', 'Django 프로젝트에서 pytest 기반 테스트 지원', 'API 자동 문서 생성', '뷰 캐싱 처리', 56, 'pytest-django는 Django 프로젝트에서 pytest 프레임워크를 사용할 수 있도록 통합 지원해주는 플러그인이다.'),
                                                                                                                           (2792, 'drf-yasg 라이브러리는 어떤 목적으로 사용되는가?', 3, 'low', '배포 자동화', 'JWT 토큰 발급', 'Swagger 기반 API 문서 자동 생성', 'URL 리다이렉션 처리', 56, 'drf-yasg는 Swagger UI 기반의 API 문서를 자동으로 생성하고 시각화하는 데 사용된다.'),
                                                                                                                           (2793, 'Gunicorn은 어떤 역할을 하는가?', 2, 'low', '정적 파일을 제공', 'WAS 역할의 Python WSGI HTTP 서버', '백엔드 인증 서버', '웹소켓 처리 서버', 56, 'Gunicorn은 WSGI 기반의 Python 애플리케이션을 실행해주는 고성능 HTTP 서버이다.'),
                                                                                                                           (2794, 'Dockerfile에서 Django 앱을 실행하는 명령은?', 3, 'medium', 'python start', 'python manage.py serve', 'python manage.py runserver 0.0.0.0:8000', 'python django start', 56, 'Django 앱을 Docker 컨테이너에서 외부 접근 가능하게 실행하려면 0.0.0.0 주소를 사용해야 한다.'),
                                                                                                                           (2795, 'pytest에서 테스트 파일 이름의 접두사는 일반적으로?', 1, 'medium', 'test_', 'check_', 'spec_', 'case_', 56, 'pytest는 기본적으로 test_ 접두사를 가진 파일만 테스트 대상으로 인식한다.'),
                                                                                                                           (2796, 'Django의 `collectstatic` 명령어는 어떤 기능을 수행하는가?', 3, 'medium', 'API 문서를 생성', '시리얼라이저를 캐싱', '정적 파일을 하나의 디렉토리로 모음', '마이그레이션을 실행', 56, '`collectstatic` 명령은 여러 앱의 정적 파일을 한곳으로 모아 배포에 적합하도록 준비한다.'),
                                                                                                                           (2797, 'drf-yasg에서 API 문서를 Swagger UI 형식으로 보려면 어떤 URL을 사용하는가?', 3, 'medium', '/docs/', '/openapi/', '/swagger/', '/schema/swagger/', 56, 'drf-yasg는 기본적으로 /swagger/ URL 경로에서 Swagger UI 문서를 제공한다.'),
                                                                                                                           (2798, 'Docker를 활용해 Django를 배포할 때 보통 함께 사용하는 WSGI 서버는?', 1, 'high', 'uWSGI 또는 Gunicorn', 'Apache', 'NGROK', 'FlaskServe', 56, 'Docker로 Django를 배포할 때 Gunicorn이나 uWSGI 같은 WSGI 서버와 함께 사용하는 것이 일반적이다.'),
                                                                                                                           (2799, 'Nginx가 Django 앱 앞에 위치하는 일반적인 역할은?', 3, 'high', 'ORM 처리', 'REST API 정의', '정적 파일 제공 및 리버스 프록시', '템플릿 렌더링', 56, 'Nginx는 정적 파일 서빙 및 Django 애플리케이션에 대한 리버스 프록시 역할을 수행한다.'),
                                                                                                                           (2800, 'pytest에서 Django 설정을 적용하려면 어떤 플러그인이 필요한가?', 3, 'high', 'pytest-setup', 'pytest-config', 'pytest-django', 'pytest-env', 56, 'pytest-django는 pytest 프레임워크에서 Django 환경 설정과 통합을 지원해주는 플러그인이다.'),
                                                                                                                           (2801, 'Django ORM에서 `filter()` 메서드는 무엇을 수행하는가?', 2, 'low', '데이터베이스에서 데이터를 삽입한다.', '조건에 맞는 객체들을 조회한다.', '모델의 데이터를 업데이트한다.', '객체를 삭제한다.', 57, '`filter()`는 조건을 만족하는 여러 객체들을 조회할 때 사용하는 ORM 메서드이다.'),
                                                                                                                           (2802, 'Django에서 인증된 사용자를 얻기 위해 사용하는 함수는 무엇인가?', 1, 'low', 'request.user', 'get_authenticated_user()', 'current_user()', 'get_user()', 57, 'request.user는 현재 요청을 보낸 사용자를 나타내며 인증 여부에 따라 AnonymousUser 또는 User 객체를 반환한다.'),
                                                                                                                           (2803, 'Django REST Framework에서 API 응답을 처리하는 클래스는 무엇인가?', 2, 'low', 'APIView', 'Response', 'HttpResponse', 'ApiResponse', 57, 'Response 클래스는 DRF에서 API 응답 객체를 생성하고 포맷팅하는 데 사용된다.'),
                                                                                                                           (2804, 'Django에서 API 문서를 Swagger 기반으로 자동 생성하는 라이브러리는 무엇인가?', 1, 'medium', 'drf-yasg', 'django-rest-swagger', 'drf-spectacular', 'swagger-django', 57, 'drf-yasg는 Swagger 형식의 문서를 자동 생성해주는 Django REST Framework 확장 라이브러리이다.'),
                                                                                                                           (2805, 'Django REST Framework의 serializer에서 `validate()` 메서드의 역할은 무엇인가?', 2, 'medium', '필드의 데이터를 필터링하여 반환한다.', '입력된 데이터를 유효성 검사한다.', '데이터베이스 모델을 업데이트한다.', '요청 데이터를 암호화한다.', 57, '`validate()`는 전체 데이터에 대한 유효성 검사 및 커스텀 검증 로직을 정의할 때 사용된다.'),
                                                                                                                           (2806, 'Django에서 Redis를 캐시 백엔드로 사용하려면 어떤 설정을 해야 하는가?', 2, 'medium', 'CACHE_BACKEND = ''redis''', 'CACHES = {''default'': {''BACKEND'': ''django_redis.cache.RedisCache''}}', 'CACHE_ENGINE = ''redis''', 'CACHE_TYPE = ''redis''', 57, 'Redis를 캐시로 사용하려면 django-redis 라이브러리의 RedisCache 경로를 BACKEND로 설정해야 한다.'),
                                                                                                                           (2807, 'Celery를 사용하여 주기적인 작업을 설정하기 위한 Django의 추가 라이브러리는 무엇인가?', 1, 'medium', 'django-celery-beat', 'django-celery-periodic', 'celery-tasks', 'django-tasks', 57, 'django-celery-beat는 Celery 태스크를 주기적으로 실행할 수 있도록 도와주는 Django 확장 라이브러리이다.'),
                                                                                                                           (2808, 'Django에서 로깅을 처리하기 위해 사용할 수 있는 외부 서비스는 무엇인가?', 4, 'medium', 'Sentry', 'New Relic', 'Loggly', 'All of the above', 57, 'Django의 로깅은 Sentry, New Relic, Loggly 등 다양한 외부 서비스를 통해 연동 및 확장할 수 있다.'),
                                                                                                                           (2809, 'Django 테스트에서 `pytest-django`를 사용하여 데이터베이스의 상태를 유지하려면 어떤 설정을 해야 하는가?', 1, 'medium', 'pytest.mark.django_db', 'pytest.db_setup()', 'pytest.enable_django_db()', 'pytest.db()', 57, '`pytest.mark.django_db` 데코레이터는 테스트 함수에서 DB 접근을 허용하는 설정이다.'),
                                                                                                                           (2810, 'Django에서 Gunicorn과 Nginx를 사용하여 애플리케이션을 배포할 때 필요한 설정 파일은 무엇인가?', 4, 'medium', 'nginx.conf', 'settings.py', 'docker-compose.yml', 'wsgi.py', 57, 'wsgi.py 파일은 WSGI 서버(Gunicorn 등)에서 Django 앱을 실행하기 위한 진입점 역할을 한다.'),
                                                                                                                           (2811, 'Django ORM에서 `all()` 메서드는 무엇을 수행하는가?', 2, 'low', '모든 객체를 삭제한다.', '모든 객체를 조회한다.', '객체를 업데이트한다.', '특정 객체를 조회한다.', 57, '`all()` 메서드는 쿼리셋에서 모든 레코드를 반환하는 표준 ORM 메서드이다.'),
                                                                                                                           (2812, 'Django ORM에서 `get()` 메서드를 사용할 때 발생할 수 있는 예외는 무엇인가?', 4, 'medium', 'MultipleObjectsReturned', 'ObjectDoesNotExist', 'FieldDoesNotExist', 'All of the above', 57, '`get()` 메서드는 객체가 없거나 두 개 이상 존재할 경우 예외를 발생시키며, 모든 경우에 대비해야 한다.'),
                                                                                                                           (2813, 'Django에서 유저를 로그인 시킬 때 사용하는 메서드는 무엇인가?', 1, 'low', 'login(request, user)', 'authenticate(request, user)', 'user.login()', 'authenticate_user(request)', 57, '`login(request, user)`는 인증된 사용자를 세션에 저장해 로그인 상태로 만든다.'),
                                                                                                                           (2814, 'Django의 기본 인증 시스템에서 사용자에게 JWT를 발급하려면 어떤 라이브러리를 사용해야 하는가?', 2, 'medium', 'django-jwt', 'simplejwt', 'djangorestframework-jwt', 'django-auth-token', 57, 'simplejwt는 Django REST Framework에 통합 가능한 JWT 인증 기능을 제공하는 공식 라이브러리이다.'),
                                                                                                                           (2815, 'DRF에서 요청된 데이터를 처리하는 함수 기반 뷰는 무엇인가?', 1, 'low', '@api_view', '@action', '@router', '@viewset', 57, '@api_view 데코레이터는 함수형 뷰에서 HTTP 메서드 매핑을 설정하는 데 사용된다.'),
                                                                                                                           (2816, 'DRF에서 `ModelSerializer`는 무엇을 위해 사용되는가?', 1, 'medium', '모델 인스턴스를 JSON으로 직렬화', '모델을 바탕으로 데이터를 유효성 검사', '모델을 업데이트', '모델을 삭제', 57, '`ModelSerializer`는 모델 필드를 기반으로 자동으로 직렬화 및 역직렬화를 수행한다.'),
                                                                                                                           (2817, '`drf-yasg`에서 API 문서에 자동으로 설명을 추가하려면 어떤 데코레이터를 사용해야 하는가?', 1, 'medium', '@swagger_auto_schema', '@api_view', '@doc', '@auto_docs', 57, '@swagger_auto_schema는 뷰 함수나 메서드에 문서 설명을 추가하는 데 사용된다.'),
                                                                                                                           (2818, '`drf-spectacular`에서 API 스키마를 자동으로 생성하는 설정을 활성화하려면 `settings.py`에서 어떤 설정을 해야 하는가?', 1, 'medium', 'SPECTACULAR_SETTINGS = {...}', 'SWAGGER_SETTINGS = {...}', 'DRF_SETTINGS = {...}', 'API_SETTINGS = {...}', 57, 'drf-spectacular은 SPECTACULAR_SETTINGS 설정을 통해 스키마 자동 생성을 구성한다.'),
                                                                                                                           (2819, 'DRF `Serializer`에서 `validators`를 사용하여 유효성 검사를 정의하려면 어떤 형식으로 사용해야 하는가?', 1, 'medium', 'validators = [SomeValidator()]', 'validate_field = SomeValidator()', 'custom_validation = SomeValidator()', 'field_validation = SomeValidator()', 57, '`validators` 속성은 필드 수준에서 커스텀 유효성 검사를 적용할 수 있게 해준다.'),
                                                                                                                           (2820, 'DRF에서 `CharField`의 길이를 제한하는 유효성 검사 옵션은 무엇인가?', 1, 'low', 'max_length', 'length', 'char_limit', 'max_size', 57, 'max_length는 CharField 필드에서 입력 가능한 최대 문자 수를 제한하는 옵션이다.'),
                                                                                                                           (2821, 'Django ORM에서 `exclude()` 메서드는 무엇을 수행하는가?', 2, 'medium', '조건에 맞는 객체를 조회한다.', '조건에 맞지 않는 객체를 조회한다.', '모든 객체를 업데이트한다.', '모든 객체를 삭제한다.', 57, 'exclude()는 특정 조건에 *맞지 않는* 객체를 필터링하는 데 사용된다. 반대로 filter()는 조건에 *맞는* 객체를 조회한다.'),
                                                                                                                           (2822, 'Django에서 사용자가 인증을 요구하는 페이지로 접근할 때, 로그인 페이지로 리디렉션하려면 어떤 설정을 사용해야 하는가?', 1, 'low', 'LOGIN_URL = \'/login/\'', 'REDIRECT_URL = \'/login/\'', 'LOGIN_REDIRECT_URL = \'/home/\'', 'AUTHENTICATED_URL = \'/login/\'', 57, 'LOGIN_URL은 인증되지 않은 사용자가 접근 시 이동할 로그인 페이지의 경로를 지정하는 설정이다.'),
                                                                                                                           (2823, 'Django REST Framework에서 API에서 데이터를 반환할 때 사용하는 기본 클래스는 무엇인가?', 2, 'low', 'APIView', 'Response', 'JsonResponse', 'HttpResponse', 57, 'Response는 Django REST Framework에서 데이터를 JSON 형태로 반환할 때 사용하는 기본 응답 객체이다.'),
                                                                                                                           (2824, 'Django에서 API 문서화를 위한 `drf-spectacular` 라이브러리에서, 어떤 설정을 통해 JSON 스키마를 생성할 수 있는가?', 1, 'medium', 'SPECTACULAR_SETTINGS = {...}', 'API_SETTINGS = {...}', 'DRF_SCHEMA_SETTINGS = {...}', 'SWAGGER_SETTINGS = {...}', 57, 'SPECTACULAR_SETTINGS는 drf-spectacular의 설정을 지정하는 데 사용되며, JSON 스키마 생성에 필수이다.'),
                                                                                                                           (2825, 'Django REST Framework의 `serializers.ModelSerializer`를 사용할 때, `Meta` 클래스의 `model` 속성은 무엇을 지정하는가?', 2, 'medium', '사용할 데이터베이스 테이블', '직렬화할 모델 클래스', '유효성 검사를 수행할 필드', '응답 데이터를 포맷할 방식', 57, 'model 속성은 직렬화의 대상이 되는 Django 모델 클래스를 지정한다.'),
                                                                                                                           (2826, 'Django에서 JWT 토큰을 생성하는 라이브러리 중 하나인 `SimpleJWT`에서 토큰의 만료 시간을 설정하는 방법은 무엇인가?', 1, 'medium', 'ACCESS_TOKEN_LIFETIME', 'TOKEN_LIFETIME', 'JWT_EXPIRATION_TIME', 'ACCESS_TOKEN_EXPIRE', 57, 'ACCESS_TOKEN_LIFETIME은 SimpleJWT에서 액세스 토큰의 만료 시간을 설정하는 데 사용된다.'),
                                                                                                                           (2827, 'Django ORM에서 `annotate()` 메서드를 사용하는 목적은 무엇인가?', 2, 'medium', '모델 객체를 업데이트하는데 사용된다.', '쿼리셋에 집계된 값을 추가하는데 사용된다.', '데이터베이스 테이블을 생성하는데 사용된다.', '필드 값을 필터링하는데 사용된다.', 57, 'annotate()는 집계 함수의 결과를 각 객체에 주석처럼 추가하여 반환한다.'),
                                                                                                                           (2828, 'Django에서 사용자 인증 후 JWT를 발급하려면 어떤 라이브러리를 사용하는가?', 3, 'medium', 'django-rest-framework-jwt', 'django-jwt-auth', 'simplejwt', 'django-auth-jwt', 57, 'simplejwt는 Django에서 JWT 인증을 구현하기 위해 널리 사용되는 라이브러리이다.'),
                                                                                                                           (2829, 'Django REST Framework에서 `APIView` 클래스에서 HTTP 메서드에 맞는 함수를 작성하려면 어떤 메서드를 사용해야 하는가?', 4, 'low', 'get()', 'post()', 'delete()', '모두 해당', 57, 'APIView는 HTTP 메서드에 따라 get(), post(), put(), delete() 등을 직접 정의해야 하므로 모두 해당된다.'),
                                                                                                                           (2830, 'Django REST Framework에서 `serializers.ValidationError`는 언제 발생하는가?', 1, 'medium', '데이터가 유효하지 않을 때 발생한다.', '모델 객체를 저장할 때 발생한다.', 'HTTP 요청에서 잘못된 파라미터를 받았을 때 발생한다.', '유효성 검사 후 잘못된 데이터가 있으면 발생한다.', 57, 'ValidationError는 입력된 데이터가 serializer의 유효성 검사 조건을 통과하지 못했을 때 발생한다.'),
                                                                                                                           (2831, 'Django ORM에서 `get()` 메서드를 사용할 때 발생할 수 있는 예외는 무엇인가?', 4, 'medium', 'ValueError', 'ObjectDoesNotExist', 'IntegrityError', 'DoesNotExist', 57, 'get()은 조건에 맞는 객체가 없을 경우 DoesNotExist 예외를 발생시킨다.'),
                                                                                                                           (2832, 'Django에서 JWT를 사용하여 인증된 사용자의 ID를 추출하려면 어떤 방법을 사용해야 하는가?', 2, 'medium', 'request.user.id', 'request.jwt_claims[\'user_id\']', 'request.token.user_id', 'request.data[\'user_id\']', 57, 'JWT 클레임에서 사용자 ID를 가져오려면 디코딩된 jwt_claims에서 user_id를 참조해야 한다.'),
                                                                                                                           (2833, 'Django REST Framework에서 `APIView` 클래스에서 `permission_classes` 속성은 무엇을 설정하는가?', 3, 'medium', 'HTTP 메서드를 설정한다.', '응답 포맷을 설정한다.', 'API에 대한 접근 권한을 설정한다.', '데이터를 직렬화하는 방법을 설정한다.', 57, 'permission_classes는 APIView에 접근할 수 있는 사용자의 권한을 제어한다.'),
                                                                                                                           (2834, 'Django에서 `drf-spectacular`를 사용하여 Swagger 문서를 생성할 때, 어떤 명령어로 스키마 파일을 생성할 수 있는가?', 3, 'medium', 'python manage.py drf_spectacular', 'python manage.py generate_swagger', 'python manage.py spectacular', 'python manage.py schema_generate', 57, 'drf-spectacular의 명령어는 `python manage.py spectacular`로 스키마 파일을 생성한다.'),
                                                                                                                           (2835, 'Django REST Framework에서 `serializers.Serializer` 클래스의 `validated_data`는 무엇을 의미하는가?', 1, 'low', '유효성 검사된 데이터', '데이터베이스에 저장된 데이터', '응답으로 반환될 데이터', '직렬화된 원본 데이터', 57, 'validated_data는 serializer의 is_valid() 호출 이후 검증된 데이터를 담고 있다.'),
                                                                                                                           (2836, 'Django에서 Redis 캐시를 설정할 때 `CACHES` 설정에서 `OPTIONS` 항목을 사용하는 이유는 무엇인가?', 2, 'medium', '캐시 데이터를 암호화하기 위해', 'Redis 서버의 연결 설정을 지정하기 위해', '캐시 데이터의 만료 시간을 설정하기 위해', '캐시에서 데이터를 압축하기 위해', 57, 'OPTIONS는 Redis 호스트, 포트, DB 번호 등의 연결 설정을 지정하기 위해 사용된다.'),
                                                                                                                           (2837, 'Celery에서 비동기 작업을 설정할 때 사용하는 메시지 브로커로 가장 많이 사용되는 것은 무엇인가?', 1, 'medium', 'RabbitMQ', 'Kafka', 'Redis', 'ActiveMQ', 57, 'RabbitMQ는 Celery와 함께 가장 널리 사용되는 메시지 브로커로 안정성과 호환성이 좋다.'),
                                                                                                                           (2838, 'Django에서 로깅을 설정할 때, `LOGGING` 설정에서 `handlers` 항목을 사용하는 이유는 무엇인가?', 1, 'medium', '로그 메시지를 출력할 위치를 설정하기 위해', '로그 파일의 형식을 설정하기 위해', '로그 레벨을 설정하기 위해', '로그를 비동기적으로 처리하기 위해', 57, 'handlers는 로그 메시지를 파일, 콘솔 등 어디에 출력할지를 정의한다.'),
                                                                                                                           (2839, 'Django에서 `pytest-django`를 사용하여 데이터베이스를 초기화하려면 어떤 설정을 추가해야 하는가?', 2, 'medium', 'pytest.mark.django_db_setup', 'pytest.mark.django_db', 'pytest.enable_db()', 'pytest.setup_db()', 57, 'pytest.mark.django_db는 테스트 함수에서 Django DB에 접근할 수 있게 해준다.'),
                                                                                                                           (2840, 'Django에서 Gunicorn을 사용하여 애플리케이션을 실행할 때, 기본적으로 몇 개의 워커 프로세스가 실행되는가?', 4, 'low', '1', '2', '4', '자동 설정(가용 CPU 수에 따라 다름)', 57, 'Gunicorn은 기본적으로 가용 CPU 수를 기준으로 워커 수를 자동 설정한다.'),
                                                                                                                           (2841, 'Django에서 `filter()` 메서드와 `exclude()` 메서드의 차이는 무엇인가?', 1, 'medium', 'filter()는 조건에 맞는 결과를 반환하고, exclude()는 조건에 맞지 않는 결과를 반환한다.', 'filter()는 모든 데이터를 반환하고, exclude()는 특정 필드를 제외한다.', 'filter()는 쿼리셋을 반환하고, exclude()는 리스트를 반환한다.', 'filter()와 exclude()는 동일한 역할을 한다.', 57, 'filter()는 조건을 만족하는 객체를 조회하고, exclude()는 조건을 만족하지 않는 객체를 조회한다.'),
                                                                                                                           (2842, 'Django에서 `SimpleJWT` 라이브러리를 사용하여 JWT 토큰을 생성할 때, 필요한 설정은 무엇인가?', 1, 'medium', 'AUTHENTICATION_CLASSES와 JWT_AUTH 설정을 추가한다.', 'JWT_SECRET_KEY와 JWT_ALGORITHM을 설정한다.', 'JWT_HEADER_NAME과 JWT_EXPIRATION_TIME을 설정한다.', 'JWT만으로 인증을 할 수 있다.', 57, 'SimpleJWT 사용 시 인증 클래스를 등록하고, 관련 JWT 설정을 추가해야 한다.'),
                                                                                                                           (2843, 'Django REST Framework에서 `Serializer` 클래스의 `create()` 메서드는 무엇을 수행하는가?', 2, 'medium', '직렬화된 데이터를 유효성 검사한다.', '새로운 인스턴스를 생성하고 데이터베이스에 저장한다.', '응답 데이터를 직렬화한다.', '요청 데이터를 암호화하여 저장한다.', 57, 'create()는 validated_data를 기반으로 모델 인스턴스를 생성하고 DB에 저장한다.'),
                                                                                                                           (2844, 'Django에서 `drf-spectacular` 라이브러리의 `SpectacularAPIView` 클래스는 무엇을 제공하는가?', 2, 'medium', 'API 문서를 HTML로 변환한다.', 'Swagger UI를 제공하고 API 문서를 자동으로 생성한다.', 'API 인증을 처리한다.', 'API 테스트를 자동으로 실행한다.', 57, 'SpectacularAPIView는 Swagger UI 기반의 API 문서를 자동으로 생성하고 제공한다.'),
                                                                                                                           (2845, 'Django REST Framework에서 `serializer.is_valid()` 메서드는 무엇을 확인하는가?', 1, 'low', '직렬화된 데이터가 유효한지 확인한다.', '모델 인스턴스가 유효한지 확인한다.', '입력 데이터를 데이터베이스에 저장할 수 있는지 확인한다.', '직렬화된 데이터를 다시 리스트로 변환할 수 있는지 확인한다.', 57, 'is_valid()는 입력된 데이터가 serializer의 조건을 충족하는지 유효성을 검사한다.'),
                                                                                                                           (2846, 'Django에서 Redis를 캐시 백엔드로 사용할 때, `CACHE_TTL` 설정은 무엇을 의미하는가?', 1, 'medium', '캐시된 데이터의 유효 기간을 설정한다.', 'Redis 서버의 연결 타임아웃을 설정한다.', 'Redis에 저장된 데이터의 크기를 설정한다.', '캐시를 압축하기 위한 설정이다.', 57, 'CACHE_TTL은 각 캐시 항목의 기본 만료 시간을 설정하는 데 사용된다.'),
                                                                                                                           (2847, 'Celery에서 주기적인 작업을 관리할 때 사용하는 Django 라이브러리는 무엇인가?', 1, 'medium', 'django-celery-beat', 'django-celery-scheduler', 'django-celery-tasks', 'django-periodic-tasks', 57, 'django-celery-beat는 주기적인 작업을 관리하기 위한 Django 전용 스케줄러이다.'),
                                                                                                                           (2848, 'Django에서 로깅 설정을 할 때, `LOGGING` 설정에서 `loggers` 항목은 무엇을 설정하는가?', 2, 'medium', '로그를 출력할 형식을 설정한다.', '어떤 로깅 기능을 사용할지 설정한다.', '로그 레벨을 설정한다.', '어떤 로그를 저장할지 설정한다.', 57, 'loggers는 어떤 이름의 로거가 어떤 핸들러를 사용하고 어떤 레벨의 로그를 출력할지 설정한다.'),
                                                                                                                           (2849, 'Django에서 `pytest-django` 라이브러리를 사용할 때, 테스트 데이터베이스는 기본적으로 어떻게 설정되는가?', 1, 'medium', '테스트 실행 전에 자동으로 새로 생성된다.', '기존 데이터베이스를 사용한다.', '매번 데이터를 삭제하고 새로 생성된다.', '테스트 데이터베이스는 수동으로 생성해야 한다.', 57, 'pytest-django는 테스트 시작 시 자동으로 임시 데이터베이스를 생성하고 테스트 후 삭제한다.'),
                                                                                                                           (2850, 'Django에서 Gunicorn을 사용할 때, 기본적으로 어떤 프로세스를 사용하여 요청을 처리하는가?', 1, 'low', 'Worker 프로세스', 'Thread 프로세스', 'Master 프로세스', 'Manager 프로세스', 57, 'Gunicorn은 요청을 처리하기 위해 Worker 프로세스를 기본적으로 사용한다.'),
                                                                                                                           (2851, 'Flask 애플리케이션의 핵심 객체는?', 3, 'low', 'FlaskApp', 'AppBuilder', 'Flask', 'Server', 58, 'Flask 클래스는 Flask 애플리케이션의 핵심 객체로, 인스턴스를 생성하여 라우팅, 설정 등을 관리한다.'),
                                                                                                                           (2852, 'Flask에서 라우트를 정의할 때 사용하는 데코레이터는?', 3, 'low', '@flask.route()', '@app.view()', '@app.route()', '@route.view()', 58, '@app.route()는 특정 URL 경로에 함수를 연결하기 위한 Flask의 기본 라우팅 데코레이터이다.'),
                                                                                                                           (2853, '다음 중 Flask의 디버그 모드를 활성화하기 위한 환경 변수는?', 1, 'low', 'FLASK_DEBUG', 'DEBUG_MODE', 'APP_DEBUG', 'FLASK_VERBOSE', 58, 'FLASK_DEBUG 환경 변수를 1로 설정하면 Flask 앱이 디버그 모드로 실행된다.'),
                                                                                                                           (2854, 'Flask에서 클라이언트의 GET 요청 데이터를 받기 위해 사용하는 객체는?', 2, 'medium', 'request.form', 'request.args', 'request.json', 'request.body', 58, 'request.args는 URL 쿼리 스트링에 포함된 GET 요청 데이터를 읽기 위해 사용된다.'),
                                                                                                                           (2855, 'Flask에서 404 Not Found 응답을 커스터마이징하려면?', 3, 'medium', '@app.route(\'/404\')', '@app.not_found()', '@app.errorhandler(404)', '@app.handler(404)', 58, '@app.errorhandler(404)는 404 에러 발생 시 사용자 정의 함수를 실행하도록 설정한다.'),
                                                                                                                           (2856, 'Flask에서 JSON 응답을 반환할 때 사용하는 함수는?', 2, 'medium', 'make_response()', 'jsonify()', 'render_template()', 'send_json()', 58, 'jsonify() 함수는 Python 딕셔너리를 JSON 응답으로 자동 변환해주는 Flask 유틸 함수이다.'),
                                                                                                                           (2857, 'Flask의 request 객체는 어디에서 가져오는가?', 4, 'medium', 'flask.http', 'flask.request', 'flask.web', 'flask', 58, 'request는 Flask 패키지의 루트에서 직접 import하여 사용한다.'),
                                                                                                                           (2858, 'Flask에서 템플릿을 사용할 때 주로 쓰는 함수는?', 3, 'high', 'render_json()', 'send_template()', 'render_template()', 'display_html()', 58, 'render_template() 함수는 Jinja2 템플릿 파일을 HTML로 렌더링하여 응답하는 데 사용된다.'),
                                                                                                                           (2859, 'Flask 애플리케이션의 실행 포트를 지정하려면 어떤 메서드 인자를 사용해야 하는가?', 2, 'high', 'app.listen(port=5000)', 'app.run(port=5000)', 'start_server(port=5000)', 'app.host(port=5000)', 58, 'app.run(port=5000)은 Flask 애플리케이션을 실행할 포트를 지정하는 공식적인 방법이다.'),
                                                                                                                           (2860, 'Flask의 라우트에서 동적 URL 파라미터를 지정할 때 사용하는 문법은?', 3, 'high', '/user[<id>]', '/user:<id>', '/user/<id>', '/user@id', 58, '/user/<id>와 같은 문법은 URL 경로에서 id 값을 동적으로 받기 위해 사용된다.'),
                                                                                                                           (2861, 'Flask에서 SQLAlchemy를 사용하려면 어떤 객체를 초기화해야 하는가?', 3, 'low', 'FlaskDB', 'SQLObject', 'SQLAlchemy(app)', 'ORMManager', 58, 'SQLAlchemy(app)은 Flask 앱과 SQLAlchemy를 연결해주는 객체 생성 방식이다.'),
                                                                                                                           (2862, 'Flask-SQLAlchemy에서 모델 클래스를 정의할 때 반드시 상속해야 하는 클래스는?', 2, 'low', 'Base', 'db.Model', 'app.Model', 'SQLAlchemy.Base', 58, 'db.Model을 상속하면 Flask-SQLAlchemy가 해당 클래스를 데이터베이스 모델로 인식한다.'),
                                                                                                                           (2863, 'Flask-Migrate는 주로 어떤 작업을 돕는 도구인가?', 2, 'low', '정적 파일 관리', '데이터베이스 마이그레이션', 'API 응답 포맷팅', '라우팅 최적화', 58, 'Flask-Migrate는 Alembic 기반으로 SQLAlchemy 모델 변경사항을 DB 스키마에 반영하는 마이그레이션 도구이다.'),
                                                                                                                           (2864, 'Flask-Login에서 로그인 여부를 확인할 때 사용하는 속성은?', 1, 'medium', 'current_user.is_authenticated', 'user.is_logged_in', 'session[\'logged\']', 'login_required(user)', 58, 'current_user.is_authenticated는 현재 사용자의 로그인 여부를 판단하는 속성이다.'),
                                                                                                                           (2865, 'Flask-Login을 사용하려면 사용자 모델에 반드시 구현해야 하는 메서드는?', 3, 'medium', 'get_user()', 'is_valid()', 'get_id()', 'check_password()', 58, 'get_id()는 Flask-Login이 세션을 통해 사용자를 식별할 수 있도록 사용자 고유 ID를 반환한다.'),
                                                                                                                           (2866, 'JWT 토큰을 발급하는 Flask-JWT-Extended 함수는?', 4, 'medium', 'encode_jwt()', 'create_token()', 'generate_token()', 'create_access_token()', 58, 'create_access_token()은 사용자 정보를 기반으로 JWT 액세스 토큰을 생성해주는 함수이다.'),
                                                                                                                           (2867, 'Flask-JWT-Extended에서 토큰이 필요한 라우트에 사용하는 데코레이터는?', 2, 'medium', '@requires_token', '@jwt_required()', '@login_required', '@auth_required', 58, '@jwt_required()는 해당 라우트 접근 시 JWT 토큰이 필요하다는 것을 명시한다.'),
                                                                                                                           (2868, 'Flask-Login의 login_user() 함수는 어떤 역할을 하는가?', 3, 'high', '비밀번호를 검증', '사용자를 DB에 추가', '세션에 사용자 로그인 상태를 기록', '새 토큰을 생성', 58, 'login_user()는 현재 사용자를 세션에 로그인된 상태로 등록하는 역할을 한다.'),
                                                                                                                           (2869, 'JWT의 주된 장점은?', 2, 'high', 'HTML 렌더링이 빠름', '서버 세션 없이 인증 상태 유지 가능', '브라우저 캐싱 최적화', 'OAuth2 자동 구현', 58, 'JWT는 클라이언트 측에 인증 상태를 저장함으로써 서버의 세션 저장소 없이도 인증 상태를 유지할 수 있다.'),
                                                                                                                           (2870, 'Flask-Migrate에서 마이그레이션 생성 명령어는?', 3, 'high', 'flask migrate init', 'flask db generate', 'flask db migrate', 'flask schema update', 58, 'flask db migrate 명령은 모델 변경 사항을 감지해 새로운 마이그레이션 파일을 생성한다.'),
                                                                                                                           (2871, 'Flask에서 API 경로를 구조적으로 분리할 때 사용하는 객체는?', 2, 'low', 'RouteGroup', 'Blueprint', 'APIMap', 'Namespace', 58, 'Blueprint는 Flask 애플리케이션의 라우트를 모듈 단위로 구성하기 위한 구조화 도구이다.'),
                                                                                                                           (2872, 'Flask에서 메서드별 처리를 위해 사용하는 클래스 기반 뷰는?', 3, 'low', 'ClassView', 'RouteView', 'MethodView', 'ActionView', 58, 'MethodView는 HTTP 메서드(get, post 등)에 따라 함수 동작을 분리할 수 있도록 도와주는 클래스 기반 뷰이다.'),
                                                                                                                           (2873, 'Flask-RESTful에서 리소스를 등록할 때 사용하는 메서드는?', 3, 'low', 'add_url()', 'register()', 'add_resource()', 'map_route()', 58, 'add_resource()는 Flask-RESTful에서 API 리소스를 라우트에 등록하는 공식 메서드이다.'),
                                                                                                                           (2874, 'Marshmallow는 어떤 기능을 제공하는가?', 3, 'medium', 'CSS 템플릿 처리', 'ORM 쿼리 최적화', '직렬화 및 유효성 검사', '웹소켓 처리', 58, 'Marshmallow는 Python 객체를 JSON으로 직렬화하고, 데이터 유효성 검사를 수행하는 라이브러리이다.'),
                                                                                                                           (2875, 'WTForms에서 Form 클래스를 상속받을 때 주로 선언하는 필드는?', 3, 'medium', 'validators', 'fields', 'StringField, IntegerField 등', 'FormDataField', 58, 'WTForms는 각 필드를 StringField, IntegerField 등으로 선언하여 폼 입력을 정의한다.'),
                                                                                                                           (2876, 'Marshmallow에서 필수 입력값을 지정하려면 사용하는 옵션은?', 3, 'medium', 'non_empty=True', 'must_exist=True', 'required=True', 'nullable=False', 58, 'required=True는 해당 필드가 반드시 입력되어야 함을 명시한다.'),
                                                                                                                           (2877, 'Flask-RESTful에서 POST 요청을 처리할 기본 메서드는?', 1, 'medium', 'post(self)', 'handle_post(self)', 'create(self)', 'save(self)', 58, 'POST 요청은 Flask-RESTful 리소스 클래스 내의 post(self) 메서드로 처리된다.'),
                                                                                                                           (2878, 'WTForms에서 문자열 필드 유효성 검사를 위한 validator는?', 2, 'high', 'RegexOnly()', 'Length()', 'NotNull()', 'RequiredText()', 58, 'Length() validator는 문자열 필드의 최소 및 최대 길이를 제한할 수 있다.'),
                                                                                                                           (2879, 'Marshmallow의 validate 인자에 사용할 수 없는 것은?', 4, 'high', 'validate.Range()', 'validate.Length()', 'validate.Email()', 'validate.Session()', 58, 'validate.Session()은 존재하지 않는 Marshmallow validator로, 사용할 수 없다.'),
                                                                                                                           (2880, 'Flask-RESTful에서 RequestParser를 사용하는 주요 목적은?', 3, 'high', '라우팅 분리', '정적 파일 제공', '요청 데이터 파싱 및 유효성 검사', '템플릿 렌더링', 58, 'RequestParser는 요청 데이터에서 파라미터를 추출하고 유효성을 검사하는 데 사용된다.'),
                                                                                                                           (2881, 'Flask에서 캐시 기능을 제공하기 위해 사용하는 확장 도구는?', 2, 'low', 'Flask-CacheLib', 'Flask-Caching', 'Flask-Redis', 'CachePlus', 58, 'Flask-Caching은 Flask에서 캐시 기능을 쉽게 구현할 수 있도록 도와주는 공식적인 확장 도구이다.'),
                                                                                                                           (2882, 'Flask-Caching에서 timeout 인자의 역할은?', 3, 'low', 'DB 연결을 끊는 시간', '템플릿 렌더링 제한 시간', '캐시 만료 시간(초 단위)', '로그 파일 생성 주기', 58, 'timeout은 캐시 데이터가 저장된 후 만료되기까지의 시간을 설정하는 인자이다.'),
                                                                                                                           (2883, '다음 중 캐시 백엔드로 설정 가능한 옵션은?', 4, 'low', 'redis', 'memcached', 'filesystem', '모두 가능', 58, 'Flask-Caching은 redis, memcached, filesystem 등 다양한 백엔드를 지원하므로 모두 설정 가능하다.'),
                                                                                                                           (2884, 'APScheduler의 주요 기능은?', 2, 'medium', 'JWT 발급 처리', '스케줄 기반 작업 실행', 'API 요청 캐싱', 'HTTP 세션 유지', 58, 'APScheduler는 시간 기반 스케줄러로, 특정 시간 또는 주기로 작업을 실행할 수 있게 해준다.'),
                                                                                                                           (2885, 'Flask에서 Celery를 사용할 때 가장 먼저 설정해야 할 항목은?', 3, 'medium', '뷰 함수 등록', '비동기 URL 생성', 'broker URL 설정', 'route name 지정', 58, 'Celery는 브로커를 통해 작업을 전달하므로, broker URL 설정이 가장 먼저 필요하다.'),
                                                                                                                           (2886, 'Celery에서 주기적인 작업을 설정하려면 사용하는 구성 요소는?', 2, 'medium', 'Flask-Beat', 'celery-beat', 'ScheduleJob', 'TaskManager', 58, 'celery-beat는 Celery에서 주기적 작업을 스케줄링하는 데 사용되는 확장이다.'),
                                                                                                                           (2887, 'Python의 기본 logging 모듈에서 로그 레벨 중 가장 낮은 단계는?', 1, 'medium', 'DEBUG', 'INFO', 'WARNING', 'ERROR', 58, 'DEBUG는 가장 낮은 수준의 로그 레벨로, 상세한 내부 상태를 출력할 때 사용된다.'),
                                                                                                                           (2888, 'Flask에서 로그 메시지를 파일에 저장하려면 설정해야 할 구성 요소는?', 1, 'high', 'logging.FileHandler', 'print()', 'app.logger.console()', 'log.save()', 58, 'logging.FileHandler는 로그 출력을 파일로 저장할 수 있도록 설정하는 핸들러이다.'),
                                                                                                                           (2889, 'Sentry는 Flask에서 어떤 용도로 주로 사용되는가?', 2, 'high', '배포 자동화', '에러 추적 및 로깅', '보안 인증', '정적 파일 관리', 58, 'Sentry는 Flask 애플리케이션에서 발생하는 오류를 실시간으로 추적하고 보고할 수 있는 도구이다.'),
                                                                                                                           (2890, 'Celery 작업을 백그라운드에서 실행하는 명령은?', 3, 'high', 'celery start', 'celery -A app run', 'celery -A app worker', 'celery launch', 58, 'celery -A app worker는 워커 프로세스를 실행하여 백그라운드에서 작업을 처리한다.'),
                                                                                                                           (2891, 'pytest에서 테스트 함수 이름은 보통 어떤 접두사로 시작해야 인식되는가?', 3, 'low', 'check_', 'run_', 'test_', 'case_', 58, 'pytest는 test_로 시작하는 함수명을 자동으로 테스트 함수로 인식한다.'),
                                                                                                                           (2892, 'Flask-Testing에서 기본 테스트 클래스는 무엇을 상속해야 하는가?', 1, 'low', 'TestCase', 'FlaskTestClient', 'LiveServerTestCase', 'FlaskTestCase', 58, 'Flask-Testing에서는 unittest의 TestCase를 기본 테스트 클래스로 상속받아 사용한다.'),
                                                                                                                           (2893, 'Flask에서 테스트 클라이언트를 생성하는 방법은?', 1, 'low', 'app.test_client()', 'TestClient(app)', 'flask.create_client()', 'run_tests(app)', 58, 'app.test_client()는 테스트 환경에서 Flask 앱에 HTTP 요청을 보내는 데 사용된다.'),
                                                                                                                           (2894, 'Gunicorn은 어떤 역할을 하는가?', 2, 'medium', '캐시 저장소 역할', 'Flask 앱을 WSGI 서버로 실행', '테스트 케이스 실행', '정적 파일을 제공', 58, 'Gunicorn은 WSGI 서버로서 Flask 앱을 프로덕션 환경에서 실행시켜주는 도구이다.'),
                                                                                                                           (2895, 'Dockerfile에서 Flask 앱을 실행하는 명령은 보통 무엇인가?', 2, 'medium', 'CMD ["python", "run.py"]', 'CMD ["gunicorn", "app:app"]', 'RUN flask start', 'ENTRYPOINT ["flask"]', 58, 'CMD ["gunicorn", "app:app"]는 Flask 앱을 Gunicorn으로 실행하기 위한 일반적인 Docker 명령이다.'),
                                                                                                                           (2896, 'Flask 앱을 Elastic Beanstalk에 배포하려면 프로젝트 루트에 있어야 할 파일은?', 3, 'medium', 'start.sh', 'Dockerfile', 'requirements.txt', '.ebextensions/config.yml', 58, 'requirements.txt는 Elastic Beanstalk가 필요한 Python 패키지를 설치하는 기준 파일이다.'),
                                                                                                                           (2897, 'pytest에서 특정 에러가 발생하는지 확인하려면 사용하는 구문은?', 3, 'high', 'assert error', 'with expect():', 'with pytest.raises():', 'try: assert False', 58, 'with pytest.raises(): 구문은 특정 예외가 발생하는지 테스트하는 데 사용된다.'),
                                                                                                                           (2898, 'Elastic Beanstalk에서 환경 설정은 어떤 폴더 아래 구성하는가?', 3, 'high', '.aws/', '.ebconfig/', '.ebextensions/', 'eb-settings/', 58, '.ebextensions/는 Elastic Beanstalk 환경 설정 파일들을 포함하는 디렉터리이다.'),
                                                                                                                           (2899, 'Docker에서 Flask 앱이 사용하는 포트를 열려면 사용하는 명령은?', 1, 'high', 'EXPOSE 80', 'OPEN PORT 5000', 'FLASK_PORT 8000', 'NETWORK enable', 58, 'EXPOSE 80은 Dockerfile에서 컨테이너가 사용할 포트를 외부에 노출시키는 명령이다.'),
                                                                                                                           (2900, 'Docker로 Flask 앱을 실행할 때 컨테이너를 백그라운드에서 돌리려면 사용하는 옵션은?', 2, 'high', '-v', '-d', '--live', '--fg', 58, '-d 옵션은 Docker 컨테이너를 백그라운드 모드로 실행하기 위해 사용된다.'),
                                                                                                                           (2901, 'Flask 애플리케이션을 프로덕션 환경에서 실행하기 위한 WSGI 서버는 무엇인가?', 2, 'low', 'Flask run', 'Waitress', 'Werkzeug', 'debugger', 59, 'Waitress는 Windows에서도 안정적으로 동작하는 WSGI 서버이며 프로덕션 환경에서도 사용할 수 있다.'),
                                                                                                                           (2902, '`flask run` 명령어의 주요 용도는 무엇인가?', 3, 'low', '운영 서버 배포', '테스트 코드 실행', '개발 서버 실행', 'Docker 빌드', 59, 'flask run은 개발 환경에서 애플리케이션을 실행할 때 사용되는 기본 명령어이다.'),
                                                                                                                           (2903, 'Flask 애플리케이션을 Nginx와 함께 배포할 때 사용하는 포워딩 설정은 어떤 포트가 일반적인가?', 2, 'medium', '5000', '80', '3000', '8000', 59, 'Nginx는 보통 외부에서 접근 가능한 기본 HTTP 포트인 80번 포트를 사용한다.'),
                                                                                                                           (2904, 'Dockerfile에서 Flask 앱 실행을 위해 자주 사용하는 명령은?', 3, 'medium', 'flask serve', 'python run.py', 'gunicorn app:app', 'nginx -g \'daemon off;\'', 59, 'gunicorn app:app은 Flask 앱을 WSGI 서버인 Gunicorn을 통해 실행하는 명령이다.'),
    (2905, 'Flask에서 환경 설정을 외부 파일로 관리하려면 사용하는 메서드는?', 4, 'medium', 'app.config.set_default()', 'app.set_env()', 'app.load_env()', 'app.config.from_envvar()', 59, 'app.config.from_envvar()는 환경 변수로부터 설정 파일 경로를 받아 설정을 불러오는 데 사용된다.'),
    (2906, 'Flask 애플리케이션에서 `.env` 파일을 읽어들이기 위해 사용하는 라이브러리는?', 4, 'low', 'flask-dotenv', 'python-decouple', 'dotenv', 'python-dotenv', 59, 'python-dotenv는 .env 파일에 정의된 환경 변수를 자동으로 로드해주는 Python 라이브러리이다.'),
    (2907, 'GitHub Actions에서 CI를 위해 작성하는 파일의 기본 위치는?', 2, 'low', '.github/ci.yml', '.github/workflows/ci.yml', 'ci/github.yml', 'workflows/.github.yml', 59, '.github/workflows/ci.yml은 GitHub Actions에서 CI/CD 워크플로우 파일을 저장하는 공식 위치이다.'),
    (2908, 'CI/CD에서 DockerHub와 GitHub Actions를 연동하기 위해 필요한 인증 정보는?', 3, 'medium', 'GITHUB_TOKEN', 'DOCKER_PASS', 'DOCKERHUB_USERNAME / DOCKERHUB_TOKEN', 'FLASK_SECRET', 59, 'DockerHub에 이미지를 푸시하기 위해서는 DOCKERHUB_USERNAME과 DOCKERHUB_TOKEN이 필요하다.'),
    (2909, '정적파일을 S3로 서빙할 경우, Flask에서 해당 URL을 설정할 키는?', 3, 'medium', 'STATIC_FOLDER_URL', 'S3_BUCKET', 'STATIC_URL', 'S3_STATIC_PATH', 59, 'STATIC_URL은 정적 파일의 접근 경로를 지정하는 데 사용되며, S3 URL로도 설정할 수 있다.'),
    (2910, 'Flask에서 로깅을 파일로 남기려면 설정해야 하는 기본 로깅 레벨은?', 1, 'low', 'logging.INFO', 'logging.DEBUG', 'logging.ERROR', 'logging.WARNING', 59, 'logging.INFO는 일반적인 운영 로그에 적합한 수준으로, 파일 로깅에 기본적으로 많이 사용된다.'),
    (2911, 'Flask에서 Gunicorn을 사용할 때 사용하는 기본 WSGI 진입점은?', 3, 'medium', 'run.py', 'app.py', 'wsgi.py', 'entrypoint.sh', 59, 'wsgi.py는 Flask 애플리케이션을 WSGI 서버(Gunicorn)에서 실행할 수 있도록 entry point로 구성하는 것이 일반적이다.'),
    (2912, 'Waitress는 어떤 환경에서 주로 사용되는 Flask 서버인가?', 1, 'medium', 'Windows 운영환경', 'Linux 운영환경', 'macOS 운영환경', 'Kubernetes 환경', 59, 'Waitress는 Windows 환경에서도 안정적으로 작동하는 WSGI 서버로 널리 사용된다.'),
    (2913, 'Flask + Gunicorn + Nginx 아키텍처에서 클라이언트의 요청을 처음 받는 컴포넌트는?', 3, 'low', 'Flask', 'Gunicorn', 'Nginx', 'Docker', 59, 'Nginx는 웹 서버로서 클라이언트 요청을 가장 먼저 받아 내부 애플리케이션 서버(Gunicorn)로 전달한다.'),
    (2914, 'Docker에서 Flask 애플리케이션을 자동으로 재빌드하고 배포하려면 필요한 CI/CD 도구는?', 4, 'medium', 'GitHub Actions', 'Jenkins', 'Travis CI', 'All of the above', 59, 'Docker 기반 애플리케이션을 자동 배포할 수 있는 CI/CD 도구는 GitHub Actions, Jenkins, Travis CI 모두 가능하다.'),
    (2915, 'Flask 설정에서 `.env`의 값을 코드에서 가져오기 위해 사용하는 Python 표준 라이브러리는?', 1, 'low', 'os', 'sys', 'dotenv', 'envlib', 59, 'os.environ을 통해 환경 변수로 등록된 .env 값을 Python 코드에서 가져올 수 있다.'),
    (2916, 'Flask 앱에서 Sentry를 연동하여 사용하는 목적은?', 2, 'low', '트래픽 분산', '오류 추적 및 알림', '정적파일 서빙', '서버 실행 속도 향상', 59, 'Sentry는 예외 발생 시 해당 정보를 실시간으로 수집하고 알림을 제공하는 도구이다.'),
    (2917, 'Flask Exporter를 Prometheus와 함께 사용할 때 주로 수집하는 정보는?', 2, 'medium', 'HTML 구조', '서버 부하와 요청 수', '클라이언트 쿠키', 'Flask 버전', 59, 'Prometheus Exporter는 서버의 부하, 요청 수 등의 메트릭 데이터를 수집해 모니터링할 수 있게 해준다.'),
    (2918, 'Flask에서 `.env`를 자동으로 로드하기 위해 애플리케이션 시작 시 호출해야 하는 함수는?', 2, 'low', 'load_env_file()', 'dotenv.load_dotenv()', 'app.env.load()', 'os.loadenv()', 59, 'dotenv.load_dotenv()는 .env 파일의 내용을 읽어 환경 변수로 등록하는 함수이다.'),
    (2919, 'GitHub Actions에서 Docker 이미지 빌드 후 푸시를 수행하는 단계 이름은?', 1, 'medium', 'build-and-push', 'docker-compile', 'image-updater', 'docker-release', 59, 'Docker 이미지 빌드와 푸시를 수행하는 단계의 이름은 보통 build-and-push로 작성된다.'),
    (2920, 'Flask에서 정적파일을 직접 서빙하지 않고 S3를 사용하는 이유는?', 4, 'medium', '보안 향상', '서버 부하 감소', '요청 처리 속도 향상', '모든 항목', 59, 'S3는 고가용성과 확장성을 제공하며 정적 리소스 요청에 대한 서버 부하를 줄이고 응답 속도를 높일 수 있다.'),
    (2921, 'Gunicorn에서 worker 프로세스를 지정하려면 어떤 옵션을 사용해야 하나?', 2, 'medium', '-p', '-w', '--port', '--concurrency', 59, '-w는 Gunicorn 실행 시 워커 프로세스 수를 지정하는 명령줄 옵션이다.'),
    (2922, 'Waitress 서버의 주요 특징은?', 3, 'medium', '멀티 스레딩 불가', '비동기 지원', 'Windows 친화적 WSGI 서버', 'HTTPS 내장', 59, 'Waitress는 Windows 환경에서도 안정적으로 동작하며 간편하게 사용할 수 있는 WSGI 서버이다.'),
    (2923, 'Flask 애플리케이션을 Docker로 배포할 때, 가장 먼저 작성해야 하는 파일은?', 2, 'low', 'requirements.txt', 'Dockerfile', 'entrypoint.sh', 'nginx.conf', 59, 'Dockerfile은 컨테이너 이미지를 정의하는 가장 기본적인 설정 파일이다.'),
    (2924, 'Nginx에서 Flask의 5000번 포트로 요청을 프록시할 때 사용하는 지시는?', 3, 'medium', 'proxy_url', 'forward_pass', 'proxy_pass', 'location_pass', 59, 'proxy_pass는 Nginx에서 요청을 다른 서버로 전달하는 데 사용하는 지시어이다.'),
    (2925, '`.env` 파일의 일반적인 위치는 어디인가?', 3, 'low', 'static 폴더', 'templates 폴더', '프로젝트 루트 디렉토리', 'venv 폴더', 59, '.env 파일은 보통 프로젝트의 루트 디렉토리에 위치시켜 관리한다.'),
    (2926, 'Flask 설정에서 `DEBUG=True`는 어떤 환경을 의미하나?', 2, 'low', '운영 환경', '로컬 개발 환경', '테스트 환경', '배포 전 환경', 59, 'DEBUG=True는 코드 변경 시 자동 재시작과 상세 오류 메시지를 제공하는 로컬 개발 환경에서 사용된다.'),
    (2927, 'GitHub Actions의 `.yml` 파일에서 사용하는 문법은?', 2, 'low', 'JSON', 'YAML', 'INI', 'XML', 59, 'GitHub Actions는 YAML 문법 기반의 설정 파일로 동작을 정의한다.'),
    (2928, 'CI에서 테스트가 실패했을 때 다음 단계로 넘어가지 않게 하려면?', 4, 'medium', 'continue-on-error: true', 'if: failure()', 'exit-on-fail: true', 'continue-on-error: false', 59, 'continue-on-error: false는 오류 발생 시 워크플로우가 다음 단계로 진행되지 않도록 막아준다.'),
    (2929, 'S3에 정적파일을 업로드할 때 사용하는 CLI 명령어는?', 2, 'medium', 'aws upload-file', 'aws s3 cp', 'aws s3 move', 'aws deploy', 59, 'aws s3 cp 명령어는 S3 버킷에 파일을 복사하거나 업로드하는 데 사용된다.'),
    (2930, 'Flask에서 기본 로깅 설정 없이도 로그를 남기기 위한 모듈은?', 2, 'low', 'loguru', 'logging', 'flask_logger', 'logfile', 59, 'logging 모듈은 Python 표준 라이브러리로, 별도 설정 없이도 기본 로그 출력이 가능하다.'),
    (2931, 'Gunicorn의 worker 타입 중 async I/O 기반으로 많이 쓰이는 것은?', 2, 'medium', 'sync', 'gevent', 'eventlet', 'thread', 59, 'gevent는 비동기 I/O를 지원하며 많은 연결을 효율적으로 처리할 수 있어 자주 사용된다.'),
    (2932, 'Nginx 설정에서 CORS 허용을 위해 설정해야 할 헤더는?', 1, 'medium', 'Access-Control-Allow-Origin', 'Allow-Origin', 'CORS-Enabled', 'Cross-Origin-Allow', 59, 'Access-Control-Allow-Origin 헤더는 CORS 허용 도메인을 설정하는 표준 헤더이다.'),
    (2933, 'Flask에서 환경 변수로 비밀 키를 설정하는 가장 안전한 방법은?', 3, 'low', '코드에 하드코딩', 'config.py에 저장', '환경 변수로 분리하여 관리', '.gitignore에 추가', 59, '민감한 설정은 코드와 분리된 환경 변수로 관리하는 것이 보안상 가장 안전하다.'),
    (2934, 'GitHub Actions에서 특정 브랜치에만 CI가 실행되게 하려면 어떤 키워드를 사용하는가?', 1, 'medium', 'branches', 'trigger', 'on-push', 'runs-on', 59, 'branches 키워드는 CI가 실행될 브랜치를 지정할 때 사용된다.'),
    (2935, 'DockerHub에 자동 푸시되도록 하려면 GitHub Actions에서 필요한 단계는?', 3, 'medium', 'setup-python', 'build', 'login to DockerHub', 'nginx-reload', 59, 'DockerHub에 이미지를 푸시하기 위해서는 먼저 login to DockerHub 단계가 필요하다.'),
    (2936, 'Flask에서 Prometheus Exporter를 사용할 때 가장 많이 쓰는 경로는?', 1, 'medium', '/metrics', '/status', '/monitor', '/health', 59, 'Prometheus Exporter는 보통 /metrics 경로를 통해 메트릭 데이터를 제공한다.'),
    (2937, 'Sentry에서 Flask 에러를 추적하려면 어떤 방식으로 연동하는가?', 1, 'low', 'Flask extension으로 추가', 'REST API로 직접 호출', 'HTML 템플릿에 삽입', 'S3에서 불러오기', 59, 'Sentry는 Flask 확장으로 연동되어 예외 발생 시 자동으로 오류 정보를 전송한다.'),
    (2938, '`.env`에서 값을 가져올 때 발생할 수 있는 예외는?', 3, 'medium', 'KeyNotFoundError', 'ValueMissingException', 'KeyError', 'FileAccessError', 59, 'KeyError는 존재하지 않는 환경 변수에 접근할 때 발생하는 Python 표준 예외이다.'),
    (2939, 'Nginx 설정에서 정적파일 경로를 지정할 때 사용하는 지시어는?', 2, 'medium', 'static_url', 'location', 'directory', 'static_pass', 59, 'location 지시어는 특정 URL 경로에 대한 동작을 정의할 때 사용되며, 정적 파일 경로 설정에도 사용된다.'),
    (2940, 'DockerHub에 이미지를 푸시할 때 사용하는 명령은?', 2, 'low', 'docker send', 'docker push', 'docker deploy', 'docker post', 59, 'docker push 명령은 로컬 이미지 태그를 DockerHub 저장소에 업로드하는 데 사용된다.'),
    (2941, 'Flask 서버를 Gunicorn으로 실행할 때 권장되는 명령어는?', 3, 'low', 'python app.py', 'flask run', 'gunicorn app:app', 'waitress-serve app:app', 59, 'gunicorn app:app 명령어는 Flask 앱을 WSGI 서버인 Gunicorn으로 실행하는 가장 일반적인 방법이다.'),
    (2942, 'Docker에서 Flask 앱이 변경될 때마다 자동으로 재시작하려면 어떤 옵션을 사용해야 하나?', 4, 'medium', '--no-cache', '--watch', 'volumes', 'bind mount', 59, 'bind mount를 사용하면 호스트의 파일 변경사항이 컨테이너에 즉시 반영되어 자동 재시작에 활용할 수 있다.'),
    (2943, 'Flask 앱 설정에서 `app.config.from_envvar()`의 목적은?', 2, 'medium', '환경변수로 로깅 설정', '환경 변수에서 설정 파일 경로를 받아 설정', '환경 변수로 디버그 여부 설정', '환경 변수에 설정 저장', 59, 'app.config.from_envvar()는 환경 변수로 전달된 파일 경로에서 설정 값을 로드하는 데 사용된다.'),
    (2944, 'GitHub Actions의 Job 단계 중 가장 먼저 수행되는 단계는?', 3, 'medium', 'build', 'name', 'runs-on', 'steps', 59, 'runs-on은 워크플로우가 실행될 환경을 정의하며 Job 내에서 가장 먼저 처리되는 필수 단계이다.'),
    (2945, 'Flask에서 로깅 수준을 DEBUG로 설정하려면 어떤 코드가 필요한가?', 2, 'medium', 'logging.level = DEBUG', 'app.logger.setLevel(logging.DEBUG)', 'logger.debug = True', 'app.log_mode(\'debug\')', 59, 'app.logger.setLevel(logging.DEBUG)는 Flask 로거의 로그 레벨을 DEBUG로 설정하는 방법이다.'),
    (2946, 'Waitress를 사용하여 Windows 환경에서 Flask를 실행하려면?', 1, 'medium', 'waitress-serve --call \'app:create_app\'', 'gunicorn app:app', 'flask run --windows', 'uwsgi --http app:app', 59, 'waitress-serve --call \'app:create_app\'는 Windows에서 Waitress 서버를 통해 Flask 앱을 실행하는 권장 명령어이다.'),
    (2947, 'Dockerfile에서 Python 패키지를 설치할 때 보통 사용하는 명령어는?', 3, 'low', 'RUN install -r requirements.txt', 'RUN pip install requirements.txt', 'RUN pip install -r requirements.txt', 'RUN apt-get requirements.txt', 59, 'RUN pip install -r requirements.txt는 Dockerfile에서 의존성 패키지를 설치하는 일반적인 방법이다.'),
    (2948, 'Flask config에서 설정 값을 불러오는 방법 중 올바른 것은?', 1, 'low', 'app.config[\'DEBUG\']', 'app.settings.debug', 'app.env.DEBUG', 'app[\'DEBUG\']', 59, 'Flask 설정 값은 app.config 딕셔너리를 통해 접근할 수 있다.'),
    (2949, 'GitHub Actions에서 비밀 정보를 안전하게 사용하는 방법은?', 3, 'low', '코드에 직접 입력', '환경변수에 저장', 'secrets에 저장하고 `${{ secrets.KEY }}`로 접근', '브랜치에 하드코딩', 59, 'GitHub Actions의 secrets 기능을 활용하면 민감 정보를 안전하게 저장하고 사용할 수 있다.'),
    (2950, 'Sentry에서 에러 발생 시 수집되는 정보가 아닌 것은?', 3, 'medium', 'stack trace', '브라우저 버전', '사용자 비밀번호', '요청 URL', 59, 'Sentry는 보안상 사용자 비밀번호와 같은 민감 정보를 수집하지 않도록 설계되어 있다.'),
    (2951, 'INNER JOIN을 사용할 때 반환되는 결과는?', 2, 'low','왼쪽 테이블의 모든 행과 오른쪽 테이블의 일부 행','두 테이블에서 조인 조건에 일치하는 행만 반환','오른쪽 테이블의 모든 행만 반환','조인 조건과 상관없이 두 테이블의 모든 행 반환',43,'INNER JOIN은 두 테이블의 조인 조건에 모두 일치하는 행만 결과로 반환한다. 일치하지 않는 행은 결과에 포함되지 않는다.'),
    (2952, 'LEFT JOIN과 RIGHT JOIN의 가장 큰 차이점은?', 3, 'low','두 테이블 모두의 데이터를 가져온다','조인 조건이 없는 경우에도 사용 가능하다','LEFT JOIN은 왼쪽 테이블의 모든 데이터를 기준으로 조인하고, RIGHT JOIN은 오른쪽 테이블을 기준으로 한다','서브쿼리 안에서만 사용 가능하다',43,'LEFT JOIN은 왼쪽 테이블을 기준으로 오른쪽 테이블과 매칭된 결과를 가져오고, RIGHT JOIN은 반대로 오른쪽 테이블을 기준으로 한다.'),
    (2953, '다음 중 서브쿼리에 대한 설명으로 옳은 것은?', 1, 'low','서브쿼리는 메인 쿼리 내에서 SELECT, FROM, WHERE 절 등에 포함될 수 있다','서브쿼리는 항상 하나의 행만 반환해야 한다','서브쿼리는 JOIN보다 항상 성능이 좋다','서브쿼리는 SELECT 문에서만 사용 가능하다',43,'서브쿼리는 메인 쿼리 내의 WHERE, FROM, SELECT 등 다양한 절에서 사용 가능하며, 반환 값 개수는 문맥에 따라 달라진다.'),
    (2954, '다음 중 두 테이블의 모든 조합을 반환하는 SQL 구문은?', 4, 'low','SELECT * FROM A INNER JOIN B ON A.id = B.id;','SELECT * FROM A LEFT JOIN B ON A.id = B.id;','SELECT * FROM A RIGHT JOIN B ON A.id = B.id;','SELECT * FROM A CROSS JOIN B;',43,'CROSS JOIN은 두 테이블의 가능한 모든 조합을 반환하며, 이는 카티션 곱(Cartesian Product)이다.'),
    (2955, '다음 SQL 중 평균 급여보다 높은 급여를 받는 직원 목록을 조회하는 쿼리는?', 2, 'medium','SELECT * FROM employees WHERE salary > salary;','SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);','SELECT * FROM employees WHERE AVG(salary) < salary;','SELECT * FROM employees WHERE salary IN (AVG(salary));',43,'서브쿼리를 사용해 전체 평균 급여를 먼저 계산한 뒤, 메인 쿼리에서 그 값보다 높은 salary 값을 가진 행을 필터링해야 한다. 이는 비교 연산자가 필요한 서브쿼리의 전형적인 예시다.'),
    (2956, '다음 중 서브쿼리의 사용 예로 가장 적절한 것은?', 4, 'medium','테이블 내 모든 데이터를 삭제할 때','단순한 집계함수를 사용하는 경우','테이블의 스키마를 변경할 때','다른 테이블의 결과를 조건으로 활용해 데이터를 조회할 때',43,'서브쿼리는 일반적으로 다른 테이블의 결과를 조건으로 사용하거나, 특정 값을 동적으로 계산하는 데 사용된다. 주로 WHERE 절, FROM 절 등에서 조건 설정에 활용된다.'),
    (2957, '다음 중 두 테이블 간의 외부 조인을 올바르게 표현한 SQL문은?', 3, 'medium','SELECT * FROM A JOIN B;','SELECT * FROM A INNER JOIN B;','SELECT * FROM A LEFT OUTER JOIN B ON A.id = B.a_id;','SELECT * FROM A NATURAL JOIN B;',43,'LEFT OUTER JOIN은 왼쪽 테이블의 모든 행을 기준으로 오른쪽 테이블과 조인하며, 오른쪽 테이블에 매칭되는 값이 없으면 NULL로 표시된다. 이는 외부 조인의 대표적인 형태다.'),
    (2958, '다음 SQL 중, 직원 테이블에서 부서별 최고 급여를 받는 직원만 조회하는 쿼리는?', 1, 'medium','SELECT * FROM employees e WHERE salary = (SELECT MAX(salary) FROM employees WHERE department_id = e.department_id);','SELECT * FROM employees WHERE salary > ALL(salary);','SELECT * FROM employees WHERE department_id = (SELECT department_id FROM employees);','SELECT name FROM employees WHERE EXISTS (salary);',43,'이 쿼리는 상관 서브쿼리를 사용해 부서별로 최고 급여를 가진 직원만 조회하는 구조이다. 각 직원의 부서에 대해 MAX(salary)를 계산하는 것이 핵심이다.'),
    (2959, 'COUNT 함수의 주된 목적은 무엇인가?', 1, 'low','행의 개수를 세기 위해 사용된다','문자열을 결합하기 위해 사용된다','조건에 맞는 값을 삭제하기 위해 사용된다','숫자형 값을 정렬하기 위해 사용된다',43,'COUNT 함수는 테이블에서 특정 조건을 만족하는 행(row)의 개수를 세는 집계 함수이다. NULL 값은 제외하고 계산한다.'),
    (2960, '다음 중 GROUP BY 절의 주된 기능은?', 2, 'low','테이블을 새로운 테이블로 복사한다','지정한 컬럼 값을 기준으로 데이터를 그룹화한다','컬럼을 삭제한다','모든 행을 개별적으로 출력한다',43,'GROUP BY는 지정한 컬럼 값을 기준으로 동일한 값을 갖는 행들을 하나의 그룹으로 묶어, 집계 함수와 함께 사용할 수 있도록 해준다.'),
    (2961, 'AVG 함수의 결과는 어떤 값인가?', 4, 'low','최소값','최대값','행의 수','지정된 컬럼의 평균값',43,'AVG 함수는 숫자형 컬럼의 평균값(산술 평균)을 반환한다. NULL 값은 평균 계산에서 제외된다.'),
    (2962, '다음 SQL 문에서 "HAVING" 절은 어떤 용도로 사용되는가?', 3, 'medium','정렬된 결과를 필터링한다','전체 테이블을 서브쿼리로 변환한다','GROUP BY로 그룹화된 결과에 조건을 적용한다','NULL 값을 제거한다',43,'HAVING 절은 GROUP BY로 그룹화된 결과 집합에 조건을 지정할 때 사용된다. WHERE 절은 개별 행에 대해 조건을 설정하는 반면, HAVING은 집계된 그룹에 대해 조건을 설정한다.'),
    (2963, '부서별로 평균 급여가 3000 이상인 부서를 조회하고 싶다. 올바른 SQL은?', 2, 'medium','SELECT dept_id FROM employees WHERE AVG(salary) > 3000;','SELECT dept_id FROM employees GROUP BY dept_id HAVING AVG(salary) >= 3000;','SELECT dept_id FROM employees WHERE salary > 3000 GROUP BY dept_id;','SELECT dept_id, AVG(salary) FROM employees;',43,'AVG는 집계 함수이므로 WHERE 절이 아닌 HAVING 절에서 사용해야 한다. GROUP BY를 통해 부서별로 그룹화한 뒤 HAVING을 통해 평균 급여 조건을 지정해야 한다.'),
    (2964, '다음 중 SUM 함수의 사용 예로 적절한 것은?', 1, 'medium','SELECT SUM(price) FROM orders WHERE status = "complete";','SELECT SUM(*) FROM products;','SELECT * FROM SUM(sales);','SELECT price FROM orders GROUP BY SUM(price);',43,'SUM 함수는 특정 컬럼의 값을 모두 더하는 데 사용된다. 1번 예시는 조건(status="complete")을 만족하는 주문의 총액을 계산하는 데 적절하다.'),-- [high 난이도]
    (2965, '다음 SQL 문을 실행하면 어떤 결과가 나오는가?\nSELECT department_id, COUNT(*), AVG(salary) FROM employees GROUP BY department_id HAVING COUNT(*) > 5 AND AVG(salary) > 4000;', 3, 'high','모든 부서의 평균 급여와 인원 수를 보여준다','5명 이하인 부서만 필터링된다','각 부서 중 인원이 5명 초과이고 평균 급여가 4000 이상인 부서만 출력된다','HAVING 절은 두 조건을 동시에 평가할 수 없으므로 에러가 발생한다',43,'HAVING COUNT(*) > 5 AND AVG(salary) > 4000 조건은 GROUP BY로 그룹화된 각 부서 집합에 대해 두 조건을 모두 만족하는 경우만 결과로 포함한다. 즉, 인원 수가 5명 초과이면서 평균 급여가 4000 초과인 부서만 출력된다.'),
    (2966, '다음 중 ROLLUP과 함께 집계 결과를 확장하여 총합까지 구하는 구문은?', 2, 'high','SELECT department_id, SUM(salary) FROM employees;','SELECT department_id, SUM(salary) FROM employees GROUP BY ROLLUP(department_id);','SELECT SUM(salary) ROLLUP FROM employees;','SELECT * FROM employees GROUP ROLLUP BY department_id;',43,'ROLLUP은 GROUP BY 확장 기능으로, 지정된 컬럼의 집계뿐 아니라 전체 집계(총합)를 함께 보여준다. 2번처럼 GROUP BY ROLLUP(column)을 사용하면 부서별 합계와 전체 합계까지 포함한 결과를 얻을 수 있다.'),
    (2967, '트랜잭션(Transaction)의 특징 중 "원자성"에 대한 설명으로 가장 적절한 것은?', 2, 'low','트랜잭션은 외부 간섭 없이 수행되어야 한다','트랜잭션 내 작업은 전부 수행되거나 전혀 수행되지 않아야 한다','트랜잭션의 실행 순서는 고정되어야 한다','트랜잭션은 즉시 커밋되어야 한다',43,'원자성(Atomicity)은 트랜잭션의 모든 작업이 하나의 단위로 수행되어야 함을 의미하며, 일부만 수행되면 전체가 롤백되어야 한다.'),
    (2968, '다음 중 트랜잭션을 영구적으로 저장하는 명령은?', 3, 'low','ROLLBACK','SAVEPOINT','COMMIT','AUTOCOMMIT OFF',43,'COMMIT 명령은 트랜잭션에서 수행된 변경 사항을 데이터베이스에 영구적으로 반영하는 명령이다.'),
    (2969, '다음 중 SQL에서 트랜잭션을 명시적으로 시작하는 명령어는?', 1, 'low','BEGIN TRANSACTION','CREATE TRANSACTION','START SESSION','INIT TRANS',43,'트랜잭션은 일반적으로 BEGIN TRANSACTION 또는 BEGIN으로 명시적으로 시작하며, 이후 COMMIT 또는 ROLLBACK으로 종료한다.'),-- [medium 난이도]
    (2970, '트랜잭션의 격리 수준 중 "REPEATABLE READ"의 특징으로 올바른 것은?', 4, 'medium','동일 트랜잭션 내에서도 읽은 값이 변경될 수 있다','다른 트랜잭션에서 삽입한 새로운 행을 볼 수 있다','Dirty Read를 허용한다','같은 SELECT 문은 항상 동일한 결과를 반환하지만 Phantom Read는 발생할 수 있다',43,'REPEATABLE READ는 동일 트랜잭션 내에서 SELECT 결과가 항상 동일하게 유지되지만, 다른 트랜잭션에서 새로 삽입된 행으로 인해 Phantom Read는 발생할 수 있다.'),
    (2971, '다음 SQL 중 ROLLBACK 동작에 대한 설명으로 옳은 것은?', 3, 'medium','모든 트랜잭션을 종료한다','데이터베이스 연결을 해제한다','현재 트랜잭션의 변경 사항을 취소한다','트랜잭션을 병합한다',43,'ROLLBACK은 트랜잭션 내에서 이루어진 모든 변경 사항을 원래대로 되돌리는 명령이다. 예외 발생 시 데이터 일관성을 유지하는 데 사용된다.'),
    (2972, '다음 중 뷰(View)의 특징으로 옳지 않은 것은?', 2, 'medium','뷰는 실제 데이터를 저장하지 않는다','뷰를 통해 삽입한 데이터는 기본 테이블에 영향을 주지 않는다','뷰는 SELECT 문을 기반으로 정의된다','뷰를 사용하면 보안 및 접근 제한에 도움이 될 수 있다',43,'뷰는 SELECT 문 결과를 가상 테이블로 표현한 것이며, 삽입/수정이 가능한 경우도 있어 기본 테이블에 영향을 줄 수 있다.'),
    (2973, '다음 중 트리거(Trigger)에 대한 설명으로 옳은 것은?', 1, 'high','트리거는 INSERT, UPDATE, DELETE와 같은 이벤트가 발생할 때 자동으로 실행된다','트리거는 반드시 수동으로 호출해야 한다','트리거는 SELECT 문에만 적용된다','트리거는 데이터를 백업하는 데 사용된다',43,'트리거는 테이블에 대한 특정 이벤트(INSERT, UPDATE, DELETE)가 발생했을 때 자동으로 실행되며, 무결성 유지, 자동 로그 등의 목적에 사용된다.'),
    (2974, '인덱스(Index)의 주요 목적은 무엇인가?', 4, 'high','데이터를 암호화하여 보호한다','중복 데이터를 제거한다','데이터를 자동으로 정렬한다','검색 속도를 향상시키기 위해 특정 컬럼에 대한 참조 구조를 제공한다',43,'인덱스는 특정 컬럼의 값을 기반으로 검색 속도를 높이는 자료구조이며, B-Tree나 Hash 기반으로 구현된다. 특히 WHERE, JOIN, ORDER BY 절에서 효과적이다.'),
    (2975, 'Flask는 어떤 언어로 작성된 웹 프레임워크인가?', 1, 'low','Python','JavaScript','Java','Ruby',49,'Flask는 Python으로 작성된 마이크로 웹 프레임워크로, 경량성과 확장성이 뛰어난 것이 특징이다.'),
    (2976, '다음 중 Flask 애플리케이션을 실행하는 기본 명령어는?', 2, 'low','python runserver.py','flask run','python manage.py runserver','flask start',49,'`flask run` 명령은 환경 변수에 FLASK_APP이 지정되어 있는 경우 해당 애플리케이션을 실행하는 기본 명령어이다.'),
    (2977, '다음 중 Flask에서 라우팅을 정의하는 데 사용하는 데코레이터는?', 3, 'low','@flask.route','@endpoint','@app.route','@url.route',49,'`@app.route` 데코레이터는 특정 URL 경로에 대한 뷰 함수를 정의하는 Flask의 핵심 라우팅 메커니즘이다.'),
    (2978, 'Flask에서 디버그 모드를 활성화하는 방법은?', 2, 'low','app.debug = False','app.debug = True','flask set-debug','app.enable_debug()',49,'`app.debug = True`를 설정하면 Flask 애플리케이션에서 코드 변경 시 자동으로 서버를 재시작하고, 상세 오류 메시지를 출력하는 디버그 모드가 활성화된다.'),
    (2979, 'Flask에서 사용자가 폼을 제출했을 때 POST 요청을 처리하려면 어떤 메서드 설정이 필요한가?', 4, 'medium','@app.route("/submit")','@app.route("/submit", method="POST")','@app.route("/submit", get=False)','@app.route("/submit", methods=["POST"])',49,'Flask에서는 HTTP 메서드를 명시할 때 `methods` 매개변수를 사용하며, POST 요청을 처리하려면 `methods=["POST"]`로 지정해야 한다.'),
    (2980, 'Flask의 템플릿 엔진으로 기본 제공되는 것은?', 1, 'medium','Jinja2','Mako','Handlebars','Mustache',49,'Flask는 기본적으로 Jinja2 템플릿 엔진을 사용하여 HTML에 Python 변수를 주입하거나 제어 구조를 표현할 수 있게 한다.'),
    (2981, 'Flask에서 request 객체를 사용하기 위해 필요한 임포트는?', 2, 'medium','import flask.request','from flask import request','import request from flask','from flask.request import *',49,'Flask의 request 객체는 `from flask import request`를 통해 가져오며, HTTP 요청의 메서드, 폼 데이터, 헤더 등을 처리할 수 있다.'),
    (2982, '다음 중 Flask 애플리케이션에서 전역 상태를 저장할 수 있는 객체는?', 3, 'medium','app.route','request','session','url_for',49,'`session` 객체는 사용자의 브라우저와 서버 간의 전역 상태를 유지하기 위해 사용되며, Flask는 이를 암호화된 쿠키 기반으로 제공한다.'),
    (2983, '다음 중 Flask의 Blueprint 기능에 대한 설명으로 가장 적절한 것은?', 1, 'high','Blueprint는 Flask 애플리케이션을 여러 모듈로 분리하여 유지보수를 쉽게 해준다','Blueprint는 Flask의 백그라운드 스레드를 관리하는 기능이다','Blueprint는 DB 트랜잭션을 자동으로 관리한다','Blueprint는 템플릿에서만 사용할 수 있는 객체이다',49,'Blueprint는 Flask 애플리케이션을 여러 라우트와 기능 단위로 분리하여 모듈화할 수 있도록 해주는 구조적 확장 도구이다.'),
    (2984, 'Flask에서 CSRF 공격을 방지하려면 일반적으로 어떤 방식이 사용되는가?', 2, 'high','JWT 토큰','폼에 CSRF 토큰을 삽입하고 검증하는 방식','IP 필터링','Flask는 기본적으로 CSRF를 차단함',49,'Flask에서는 CSRF 보호를 위해 `Flask-WTF` 확장을 사용하여 폼에 CSRF 토큰을 삽입하고 서버에서 이를 검증하는 방식으로 보안을 강화한다.'),
    (2985, 'Flask의 url_for 함수의 주요 목적은?', 3, 'high','템플릿 내 반복문을 처리한다','HTML 문서에서 외부 스크립트를 로드한다','뷰 함수명을 기반으로 URL 경로를 동적으로 생성한다','서버의 루트 디렉토리를 반환한다',49,'`url_for()`는 Flask에서 URL 하드코딩을 방지하고, 라우트 함수 이름을 기반으로 동적으로 URL을 생성할 수 있도록 도와주는 함수이다.'),
    (2986, 'Django REST Framework에서 ViewSet과 Router를 함께 사용하는 주된 이유는?', 2, 'high', 'URL 패턴을 더 복잡하게 정의하기 위해서', '자동으로 URLconf를 생성하여 CRUD API 구현을 단순화하기 위해서', 'APIView 기능을 대체하기 위해서', 'Template 기반 렌더링을 지원하기 위해서', 48, 'ViewSet은 비즈니스 로직만 작성하면 되고, Router가 자동으로 URLconf를 생성해줘서 빠르게 REST API를 만들 수 있다.'),
    (2987, 'DRF에서 인증(Authentication)과 권한(Permission)의 차이점으로 옳은 것은?', 3, 'high', '인증은 사용자의 데이터를 필터링하고, 권한은 요청을 암호화한다.', '인증은 사용자의 요청 속도를 제한하고, 권한은 로그인 유무를 판단한다.', '인증은 사용자를 식별하고, 권한은 요청이 허용되는지를 판단한다.', '인증과 권한은 동일하며 보안을 위해 함께 설정한다.', 48, '인증은 사용자가 누구인지 확인하는 절차이고, 권한은 해당 사용자가 특정 작업을 수행할 수 있는지를 판단하는 절차이다.'),
    (2988, 'Serializer에서 `create()` 메서드를 오버라이드하는 주된 이유는?', 1, 'high', '객체 생성 시 추가 로직을 적용하기 위해서', '유효성 검사를 우회하기 위해서', '데이터 저장을 방지하기 위해서', '데이터를 JSON으로 직렬화하기 위해서', 48, 'create()를 오버라이드하면 모델 인스턴스를 생성할 때 커스텀 로직(예: 필드 추가, 후처리 등)을 적용할 수 있다.'),
    (2989, 'Django REST Framework에서 `@action` 데코레이터를 사용할 때 올바른 사용 목적은?', 4, 'high', '모델 필드를 자동으로 생성하기 위해', '뷰의 HTTP 응답을 캐싱하기 위해', 'Serializer 클래스를 동적으로 변경하기 위해', 'ViewSet에 커스텀 엔드포인트를 추가하기 위해', 48, '`@action`은 ViewSet 클래스에서 기본 CRUD 외의 커스텀 메서드(예: like, vote 등)를 별도 URL로 노출할 때 사용한다.'),
    (2990, 'Django의 MTV 아키텍처에서 Template의 주요 역할은 무엇인가?', 4, 'high', '요청을 처리하고 적절한 응답을 반환한다.', '데이터베이스와의 상호작용을 담당한다.', '비즈니스 로직을 처리한다.', '사용자에게 보여질 화면을 렌더링한다.', 48, 'Django의 MTV 아키텍처에서 Template은 사용자에게 보여지는 UI를 담당하며 HTML 응답을 생성하는 데 사용된다.'),
    (2991, 'Django에서 settings.py 파일에서 INSTALLED_APPS에 앱을 등록하는 주된 이유는?', 2, 'high', '앱의 모델을 강제로 마이그레이션하기 위해', 'Django가 해당 앱의 설정, 모델, 템플릿 등을 인식하게 하기 위해', '템플릿 파일을 자동 생성하기 위해', '데이터베이스와의 연결을 생략하기 위해',48, 'INSTALLED_APPS에 앱을 등록해야 Django가 해당 앱의 모델과 설정, URL 등을 인식하고 동작에 포함시킬 수 있다.'),
    (2992, 'Django에서 URLconf의 역할로 가장 적절한 것은?', 3, 'high', '모델과 뷰 간의 데이터를 직렬화한다.', '템플릿 엔진으로 렌더링을 담당한다.', '요청된 URL을 해당 뷰(View)로 매핑하는 역할을 한다.', 'ORM에서 SQL 쿼리를 최적화하는 역할을 한다.',48, 'URLconf는 클라이언트의 URL 요청을 어떤 뷰 함수 또는 클래스에 전달할지 매핑하는 설정으로, URL 라우팅을 담당한다.'),
    (2993, 'Django에서 클래스 기반 뷰(Class-Based View)를 URLconf에 연결할 때 사용하는 메서드는?', 2, 'high', 'get_context_data', 'as_view()', 'dispatch()', 'render_to_response',48, '클래스 기반 뷰는 함수가 아니기 때문에 URLconf에 등록할 때 as_view() 메서드를 사용해 인스턴스로 변환해야 한다.'),
    (2994, '다음 중 Django에서 URL 이름(name)을 지정하는 주된 목적은?', 3, 'high', '뷰 함수의 이름을 변경하기 위해', '정적 파일 경로를 등록하기 위해', '템플릿 또는 뷰에서 URL 역참조(reverse)를 가능하게 하기 위해', 'url 패턴을 자동으로 생성하기 위해',48, 'URL에 name을 지정하면 reverse() 함수나 {% url %} 템플릿 태그를 사용하여 경로를 문자열이 아닌 이름으로 참조할 수 있다.'),
    (2995, 'Django에서 path()와 re_path() 함수의 주요 차이점은?', 1, 'high', 'path()는 간단한 경로 지정에 사용되고, re_path()는 정규표현식을 이용한 복잡한 경로 지정에 사용된다.', 're_path()는 클래스 기반 뷰 전용이며, path()는 함수형 뷰에서만 사용된다.', 'path()는 정적 파일 라우팅에 특화되어 있다.', '둘의 기능은 동일하지만 re_path()는 더 최신 방식이다.',48, 'path()는 읽기 쉬운 경로 문자열을 사용하며, re_path()는 복잡한 정규표현식 기반 URL 처리를 위해 사용된다.'),
    (2996, 'Django 모델에서 related_name 옵션의 주된 목적은?', 3, 'high', 'ForeignKey의 삭제 동작을 제어하기 위해', '모델의 기본 정렬 방식을 지정하기 위해', '역참조 시 사용할 매니저 이름을 정의하기 위해', '모델 필드의 nullable 여부를 결정하기 위해',48, 'related_name은 역참조할 때 사용할 이름을 설정하는 데 사용된다. 예를 들어 author.book_set 대신 author.books처럼 커스텀 가능하다.'),
    (2997, 'Django ORM에서 select_related()와 prefetch_related()의 차이로 가장 적절한 설명은?', 1, 'high', 'select_related()는 SQL JOIN을 사용하고, prefetch_related()는 별도 쿼리로 데이터를 가져온다.', '둘 다 동일한 방식의 조인을 사용하지만 성능 차이가 있다.', 'select_related()는 다대다 관계 전용이며, prefetch_related()는 일대일 관계 전용이다.', 'select_related()는 QuerySet 캐싱을 위해 사용된다.',48, 'select_related는 JOIN을 사용하여 하나의 쿼리로 가져오고, prefetch_related는 별도 쿼리 후 파이썬에서 매칭하여 성능 최적화를 한다.'),
    (2998, 'Django에서 모델을 마이그레이션하지 않고 데이터베이스 구조를 직접 수정했을 때 발생할 수 있는 문제는?', 4, 'high', 'Admin 페이지에서 모델이 표시되지 않는다.', '쿼리셋이 자동으로 초기화된다.', 'ORM이 해당 모델을 무시하고 실행된다.', '모델 정의와 DB 스키마가 불일치하여 런타임 오류가 발생할 수 있다.',48, 'Django는 models.py를 기반으로 ORM을 구성하므로, 직접 DB 구조를 바꾸면 ORM과 불일치가 생겨 런타임에서 오류가 발생할 수 있다.'),
    (2999, 'Django 템플릿에서 `{{ some_list|length }}`와 같이 필터를 사용하는 주요 목적은?', 2, 'high', '템플릿 내에서 함수를 정의하기 위해', '데이터를 출력 전에 처리하거나 변형하기 위해', '변수를 선언하고 루프를 제어하기 위해', '모델 필드를 직접 수정하기 위해',48, '템플릿 필터는 데이터를 화면에 출력하기 전에 변형하거나 포맷팅하는 데 사용된다. 예를 들어 |length는 리스트의 길이를 출력한다.'),
    (3000, 'Django에서 `{% static "css/styles.css" %}` 태그가 정상 작동하기 위해 반드시 설정해야 하는 것은?', 4, 'high', 'MEDIA_ROOT 설정', 'BASE_DIR 환경변수', 'INSTALLED_APPS에 django.template 추가', 'STATICFILES_DIRS 또는 STATIC_ROOT 설정 및 static 템플릿 태그 로딩',48, '`{% static %}`을 사용하려면 static 경로 설정과 {% load static %} 태그를 포함해야 한다. 또한 STATICFILES_DIRS나 STATIC_ROOT도 설정되어 있어야 한다.'),
    (3001, 'Django 템플릿 언어에서 `{% include %}` 태그와 `{% extends %}` 태그의 차이점으로 올바른 설명은?', 1, 'high', '`include`는 템플릿을 삽입하고, `extends`는 상속을 통해 구조를 재사용한다.', '`extends`는 하위 템플릿을 삽입하고, `include`는 base 템플릿을 참조한다.', '`include`는 오직 정적 파일에만 사용된다.', '두 태그는 기능적으로 동일하며, 상호 치환 가능하다.',48, '`include`는 템플릿 조각을 삽입할 때 사용되고, `extends`는 상위 템플릿을 기반으로 블록을 오버라이딩하는 방식으로 전체 구조를 재사용한다.'),
    (3002, 'DRF에서 `validate_<fieldname>` 메서드의 주된 목적은?', 2, 'high', '전체 필드 검증 로직을 수행하기 위해', '특정 필드에 대한 개별 검증 로직을 정의하기 위해', 'serializer 저장 시 후처리를 위해', '뷰에서 사용할 에러 메시지를 포맷팅하기 위해',57, 'validate_<fieldname>()은 해당 필드 값에 대한 유효성 검사 및 조건 검사를 위해 사용된다.'),
    (3003, 'DRF에서 `raise serializers.ValidationError(...)`가 호출되는 위치로 적절하지 않은 것은?', 4, 'high', 'validate_<fieldname> 메서드 내부', 'validate 메서드 내부', 'create() 또는 update() 메서드 내부', 'Serializer 클래스 외부',57, 'ValidationError는 주로 Serializer 내에서 사용되며, 외부에서 호출하면 DRF의 예외 처리 흐름과 어긋난다.'),
    (3004, 'DRF의 `validators` 인자에 커스텀 함수를 전달할 때, 주의할 점은?', 3, 'high', '해당 함수는 반드시 serializer 클래스 외부에 정의되어야 한다.', '함수명은 validate_로 시작해야 한다.', '입력값을 인자로 받고 ValidationError를 명시적으로 발생시켜야 한다.', '함수 내에서는 request 객체에 접근할 수 있어야 한다.',57, 'validators에 전달하는 함수는 인자 값만 받아 검증하며, 조건 불일치 시 ValidationError를 명시적으로 발생시켜야 한다.'),
    (3005, 'Simple JWT에서 Refresh Token의 주요 목적은?', 1, 'high', 'Access Token 만료 후 재발급을 가능하게 하기 위해', '사용자의 비밀번호 재설정을 위해', '클라이언트의 인증 상태를 영구히 유지하기 위해', 'OAuth 인증 연동을 처리하기 위해',57, 'Refresh Token은 Access Token이 만료된 후 새 Access Token을 발급받기 위한 토큰이다.'),
    (3006, 'Simple JWT에서 토큰 블랙리스트 기능을 사용하기 위해 필요한 설정은?', 2, 'high', 'DEFAULT_PERMISSION_CLASSES에 BlacklistPermission 추가', 'INSTALLED_APPS에 rest_framework_simplejwt.token_blacklist 추가', 'MIDDLEWARE에 TokenBlacklistMiddleware 추가', 'settings.py에 JWT_ALLOW_BLACKLIST = True 설정',57, '토큰 블랙리스트 기능은 `rest_framework_simplejwt.token_blacklist` 앱을 추가해야 활성화된다.'),
    (3007, 'Simple JWT에서 토큰 유효 시간을 변경하기 위한 설정 키는?', 3, 'high', 'JWT_EXPIRE_MINUTES', 'ACCESS_TOKEN_TTL', 'ACCESS_TOKEN_LIFETIME', 'JWT_REFRESH_VALIDITY',57, '`ACCESS_TOKEN_LIFETIME`은 Access Token의 만료 시간을 설정하는 공식 키이다.'),
    (3008, 'Django ORM의 `F()` 객체를 사용하는 주요 이유는?', 2, 'high', '필드 값을 상수로 비교하기 위해', '쿼리셋 내에서 필드 간 연산을 수행하기 위해', 'SQL 조인을 수동으로 지정하기 위해', 'Raw SQL 구문을 삽입하기 위해',57, 'F() 객체는 필드 간 연산이나 기존 값 기준 변경 등에 사용된다 (ex: count = F("count") + 1).'),
    (3009, 'Django ORM에서 Q 객체를 사용하는 가장 주된 목적은?', 1, 'high', 'OR 조건 및 복잡한 논리 쿼리 작성', '데이터베이스 트랜잭션 제어', '쿼리셋 캐싱', '모델 필드에 대한 제한 설정',57, 'Q 객체는 OR 조건 또는 괄호가 필요한 조건 쿼리를 정의하는 데 사용된다.'),
    (3010, 'Django에서 `annotate()`와 `aggregate()`의 주된 차이는?', 4, 'high', '둘 다 필터 조건을 구성한다.', 'aggregate는 쿼리셋을 수정하지 않는다.', 'annotate는 전체 쿼리셋을 하나로 요약한다.', 'annotate는 각 객체에 계산 결과를 추가하고, aggregate는 전체 쿼리에 대한 계산값을 반환한다.',57, 'annotate는 개별 객체에 값을 추가하고, aggregate는 전체 쿼리셋에 대한 계산을 반환한다.'),
    (3011, 'DRF에서 `GenericAPIView`가 제공하는 기능 중 옳은 것은?', 3, 'high', '템플릿 렌더링을 지원하는 Mixin', 'URLConf 자동 등록', '쿼리셋 및 serializer_class 속성 기반 처리', 'JWT 기반 인증 처리 전용 뷰',57, 'GenericAPIView는 queryset, serializer_class 속성을 바탕으로 기본적인 처리 로직을 내장한다.'),
    (3012, 'DRF에서 ViewSet을 사용할 때 Router를 함께 사용하는 목적은?', 4, 'high', '데이터 정렬을 위한 필터 기능 제공', 'permission 클래스 설정을 위해', '쿼리셋을 자동으로 저장하기 위해', '자동으로 URL 패턴을 생성하여 코드량을 줄이기 위해',57, 'Router는 ViewSet과 함께 사용되어 자동으로 CRUD URLconf를 생성해준다.'),
    (3013, 'DRF에서 `ListModelMixin`의 기본 동작은?', 2, 'high', '하나의 객체를 상세 조회한다.', '전체 객체 목록을 조회한다.', '새 객체를 생성한다.', '선택한 객체를 삭제한다.',57, 'ListModelMixin은 `list()` 메서드를 제공하여 전체 객체를 반환한다.'),
    (3014, 'drf-yasg에서 `@swagger_auto_schema` 데코레이터를 사용하는 이유는?', 1, 'high', 'APIView에 명시적으로 입력/출력 스펙을 정의하기 위해', 'Serializer의 필드 값을 디버깅하기 위해', 'HTML 렌더링을 커스터마이징하기 위해', 'REST API 경로를 보호하기 위해',57, 'swagger_auto_schema는 API 스펙을 명시적으로 정의할 수 있게 해준다.'),
    (3015, 'drf-spectacular에서 `extend_schema`의 주요 사용 목적은?', 2, 'high', '템플릿 경로를 지정하기 위해', '각 API 엔드포인트의 문서와 스키마를 커스터마이징하기 위해', '뷰 함수의 권한을 제어하기 위해', 'Swagger UI의 디자인을 변경하기 위해',57, '`extend_schema`는 각 API에 대한 문서 및 파라미터 스펙을 커스터마이징할 수 있게 한다.'),
    (3016, 'drf-spectacular의 OpenAPI 스키마 생성 명령어는?', 3, 'high',  'python manage.py collectstatic', 'python manage.py makemigrations', 'python manage.py spectacular --file schema.yml', 'python manage.py generate_docs',57, '`spectacular --file schema.yml` 명령어는 OpenAPI 스펙 파일을 생성해주는 기본 명령이다.'),
    (3017, 'Flask 애플리케이션에서 CSRF 공격을 방지하기 위한 일반적인 방법은?', 2, 'high', '비밀번호 암호화 적용', '폼에 CSRF 토큰을 삽입하고 서버에서 검증', '클라이언트 측 입력값 길이 제한', '정적 파일 접근을 제한',49, 'CSRF 보호는 각 요청에 고유한 토큰을 삽입하고 서버에서 이를 확인하는 방식으로 이뤄진다.'),
    (3018, 'Flask를 Gunicorn으로 배포할 때, 보안 및 성능 향상을 위해 추천되는 설정은?', 3, 'high',  'Flask debug 모드를 켠 채로 운영', '기본 HTTP 서버만으로 처리', 'Nginx를 리버스 프록시로 앞단에 두는 구성', 'threaded=True 설정 제거',49, 'Flask는 개발용 서버로 적합하지 않으며, 운영환경에서는 Nginx + Gunicorn 조합이 일반적이다.'),
    (3019, 'Flask에서 HTTPS를 적용할 때 가장 적절한 방식은?', 4, 'high', 'Flask 내부에서 직접 SSLContext 설정', 'Werkzeug 내장 서버에서 인증서 설정', 'Flask 앱에서 직접 인증서 파일을 로드', 'Nginx에서 HTTPS 처리 후 Flask로 프록시',49, '실제 운영 환경에서는 Nginx 등 프록시 서버에서 HTTPS를 처리하고 Flask는 HTTP로 통신한다.'),
    (3020, 'Flask-SQLAlchemy에서 모델 클래스에 정의된 __tablename__ 속성의 의미는?', 1, 'high',  '해당 모델이 매핑될 데이터베이스 테이블명을 지정한다.', '쿼리의 기본 정렬 기준을 지정한다.', 'ORM이 모델을 무시하게 한다.', '테이블 간 조인을 자동 수행한다.',49, '__tablename__은 모델이 실제 데이터베이스에서 매핑될 테이블 이름을 명시적으로 지정한다.'),
    (3021, 'Flask-SQLAlchemy에서 `session.commit()` 호출 전까지 데이터가 반영되지 않는 이유는?', 3, 'high', 'ORM이 비동기로 작동하기 때문', '쿼리셋이 캐싱되기 때문', '트랜잭션 방식으로 작동하기 때문', '데이터베이스에 연결되지 않았기 때문',49, 'Flask-SQLAlchemy는 트랜잭션 기반으로 동작하며, commit() 호출 전까지는 실제 반영되지 않는다.'),
    (3022, '다음 중 Flask-SQLAlchemy에서 객체를 삭제하는 올바른 방법은?', 2, 'high', 'db.session.drop(object)', 'db.session.delete(object) 후 db.session.commit()', 'object.remove() 후 flush()', 'DELETE 쿼리를 직접 실행',49, 'SQLAlchemy에서는 delete()로 객체를 삭제한 후 commit()으로 반영해야 한다.'),
    (3023, 'Flask에서 URL 경로 매개변수에 타입을 지정하는 이유는?', 4, 'high', '디버깅 편의를 위해', '라우팅 속도를 높이기 위해', '템플릿 자동 생성에 필요', '뷰 함수로 전달되기 전에 형 변환 처리를 하기 위해',49, 'Flask는 <int:id>와 같이 URL 매개변수에 타입을 지정하면 자동으로 해당 타입으로 변환해준다.'),
    (3024, '다음 중 Flask에서 route 데코레이터를 통해 정의할 수 없는 것은?', 2, 'high', 'HTTP 메서드(GET, POST 등) 제한', '세션 유지 시간 설정', 'URL 경로 정의', '동적 URL 매개변수 지정',49, 'route()는 URL과 메서드를 정의하는 데 사용되며, 세션 설정은 전혀 다른 방식으로 처리된다.'),
    (3025, 'Flask에서 여러 route가 동일한 뷰 함수를 공유할 수 있는 방법은?', 1, 'high',  'route() 데코레이터를 중첩하거나 다중 선언한다.', '뷰 함수 안에서 URL을 분기한다.', '클래스 기반 뷰로만 가능하다.', 'Blueprint를 반드시 사용해야 한다.',49, 'Flask에서는 하나의 뷰 함수에 여러 @app.route() 데코레이터를 붙여 여러 URL에 대응하게 할 수 있다.'),
    (3026, 'Jinja2에서 `{{ user.name | default(''익명'') }}`의 동작은?', 3, 'high', 'user.name이 항상 "익명"으로 출력된다.', '템플릿에서 변수를 삭제한다.', 'user.name이 None 또는 undefined일 경우 "익명"을 출력한다.', 'user.name이 문자열이면 익명으로 치환한다.',49, 'default 필터는 값이 None이거나 정의되지 않았을 경우 대체 값을 출력하도록 한다.'),
    (3027, '다음 중 Jinja2 템플릿 상속과 관련된 설명으로 옳은 것은?', 1, 'high', '`{% block %}` 태그를 사용하여 자식 템플릿에서 내용을 재정의할 수 있다.', '상속은 파이썬 클래스처럼 다중 상속이 가능하다.', '부모 템플릿은 반드시 HTML 전체 구조를 포함해야 한다.', 'Jinja2는 상속을 지원하지 않으며 include만 제공한다.',49, 'block 태그는 상속 구조에서 자식 템플릿이 내용을 덮어쓸 수 있도록 해준다.'),
    (3028, 'Jinja2 템플릿에서 `{% with %}` 블록의 용도는?', 4, 'high', '변수를 삭제하기 위해', '템플릿을 조건부로 렌더링하기 위해', '반복문 중간에 변수 초기화하기 위해', '일시적으로 변수에 값을 할당하고 블록 내에서만 사용할 수 있게 하기 위해',49, '`with` 블록은 블록 내부에서만 사용할 수 있는 임시 변수를 선언하는 데 사용된다.'),
    (3029, 'Flask-SQLAlchemy에서 데이터베이스 모델 클래스는 어떤 클래스를 상속받아야 하는가?', 2, 'low', 'ModelBase', 'db.Model', 'BaseModel', 'FlaskModel',49, 'SQLAlchemy의 모델 클래스는 db.Model을 상속받아야 SQLAlchemy가 인식할 수 있다.'),
    (3030, 'Flask-SQLAlchemy에서 새 객체를 데이터베이스에 추가할 때 사용하는 메서드는?', 3, 'low', 'db.session.append()', 'db.session.insert()', 'db.session.add()', 'db.session.create()',49, 'db.session.add()를 사용해 객체를 세션에 등록한 후 commit()으로 DB에 반영한다.'),
    (3031, 'GitHub Actions에서 DockerHub에 이미지를 푸시하기 위해 필요한 인증 방식은?', 1, 'high',   'secrets에 DockerHub 사용자명과 액세스 토큰을 저장하고 사용한다.', 'GitHub Actions runner에서 직접 로그인하도록 한다.', 'DockerHub의 API Key를 README에 명시한다.', 'GitHub CLI를 통해 수동으로 푸시한다.',59, 'GitHub Actions에서 secrets.DOCKER_USERNAME, secrets.DOCKER_PASSWORD 등을 설정해 로그인 후 push한다.'),
    (3032, '다음 중 GitHub Actions 워크플로우에서 Docker 이미지를 빌드하고 푸시하기 위한 올바른 순서는?', 2, 'high', 'push → build → tag → login', 'login → build → tag → push', 'tag → build → push → login', 'build → login → push → tag',59, '먼저 DockerHub에 로그인한 후, 이미지를 빌드하고 태그한 뒤 푸시하는 것이 일반적인 순서이다.'),
    (3033, 'GitHub Actions에서 특정 브랜치에 push될 때만 CI/CD 파이프라인이 동작하도록 하기 위한 설정은?', 3, 'high', 'jobs.only.branch', 'filters.branch.include', 'on.push.branches', 'env.branch-restrict',59, '`on.push.branches` 키를 사용하면 특정 브랜치에 push가 일어날 때만 워크플로우가 실행된다.'),
    (3034, 'Flask 앱을 Docker로 배포할 때 권장되는 베이스 이미지는?', 1, 'high', 'python:3.x-slim', 'flask:latest', 'alpine-nginx-flask', 'ubuntu-flask-dev',59, '`python:3.x-slim` 이미지는 가볍고 Python 기반 Flask 앱 배포에 적합하다.'),
    (3035, 'Nginx 설정에서 Flask 앱을 리버스 프록시할 때 올바른 설정은?', 4, 'high', 'proxy_pass http://localhost:443;', 'proxy_pass flask.sock;', 'proxy_pass unix:/var/www/flask;', 'proxy_pass http://127.0.0.1:8000;',59, 'Gunicorn 등이 127.0.0.1:8000에서 동작할 경우, Nginx는 proxy_pass로 이를 참조한다.'),
    (3036, 'Flask 앱을 Docker와 Nginx를 조합해 배포할 때 자주 발생하는 문제는?', 2, 'high', 'Flask가 static 디렉토리를 못 읽는 문제', 'Docker container 간 네트워크 연결이 되지 않는 문제', 'requirements.txt가 무시되는 문제', 'pipenv가 자동 실행되지 않는 문제',59, 'docker-compose에서 nginx와 flask 컨테이너를 동일 네트워크로 연결하지 않으면 연결 불가 문제가 자주 발생한다.'),
    (3037, 'Gunicorn에서 워커 수 설정을 위한 일반적인 공식은?', 1, 'high', 'CPU 코어 수 × 2 + 1', 'CPU 코어 수 ÷ 2', 'CPU 코어 수 × 1.5', '메모리 용량 ÷ 워커당 메모리 사용량',59, 'Gunicorn 공식 문서에서도 권장하는 워커 수는 CPU 수 × 2 + 1이다.'),
    (3038, 'Gunicorn이 WSGI 서버로 적합한 이유는?', 3, 'high', '스레드 기반 구조이기 때문', 'Flask 내장 서버보다 메모리를 더 많이 쓰기 때문', '비동기 요청을 다수 처리할 수 있는 워커 기반 구조이기 때문', '템플릿 렌더링을 지원하기 때문',59, 'Gunicorn은 여러 워커를 통해 동시에 요청을 처리할 수 있어 실 서비스에 적합하다.'),
    (3039, 'Waitress를 선택하는 경우로 적절한 것은?', 2, 'high', 'Gunicorn이 없는 Windows 환경에서 운영할 때', 'Windows 서버에서 Python 앱을 운영할 때', '동시에 대용량 비동기 요청을 처리할 때', 'Flask 개발 서버를 배포용으로 쓸 때',59, 'Waitress는 Windows에서도 안정적으로 작동하는 WSGI 서버로 추천된다.'),
    (3040, 'Flask에서 S3를 이용한 정적 파일 저장 시 보안상 중요한 설정은?', 2, 'high', '정적 폴더를 templates와 함께 두기', 'S3 버킷 정책에서 public read 접근을 제한하기', '모든 파일에 signed URL 적용 금지', '버킷 이름을 앱에 하드코딩',59, '정적 파일을 보호하기 위해 public read를 제한하거나 signed URL을 사용하는 것이 좋다.'),
    (3041, 'Flask 앱에서 로깅 설정 시 RotatingFileHandler를 사용하는 이유는?', 3, 'high', '로그에 색상 강조를 적용하기 위해', '서버 간 로그 공유를 위해', '로그 파일 크기를 제한하고 순환시키기 위해', 'SQLAlchemy 쿼리 출력을 보기 위해',59, 'RotatingFileHandler는 파일이 일정 크기를 넘으면 자동으로 새 로그 파일을 생성하며 이전 로그를 보존한다.'),
    (3042, 'Sentry를 Flask에 연동할 때 가장 중요한 초기화 요소는?', 4, 'high', 'Flask 로그 핸들러 등록', 'Flask의 run() 함수 내에서 설치', '환경 변수로 SENTRY_SILENT 설정', 'DSN 키로 클라이언트를 초기화',59, 'Sentry는 DSN 키를 통해 프로젝트와 연동되며, 초기화 시 반드시 필요하다.'),
    (3043, 'Flask 앱에서 환경변수를 `.env` 파일로 관리할 때 필요한 패키지는?', 1, 'high', 'python-dotenv', 'flask-environ', 'env-handler','dotenv-cli',59, 'Flask에서 .env 파일을 로드하려면 `python-dotenv` 패키지가 일반적으로 사용된다.'),
    (3044, 'Flask의 `app.config.from_object()` 메서드의 주요 용도는?', 4, 'high', '환경에 따라 다른 파이썬 인터프리터를 설정', '템플릿 경로를 추가', '로깅 파일 위치를 설정', '클래스 기반 설정 객체로부터 구성값을 불러오기 위해',59, 'from_object()는 설정 클래스를 전달받아 설정값을 로드하는 데 사용된다.'),
    (3045, '환경 설정 시 보안을 위해 피해야 할 방식은?', 3, 'high', 'Flask.config에 from_envvar 사용', '환경변수를 활용한 비밀키 저장', '하드코딩된 설정값을 GitHub에 커밋', 'Flask CLI에서 환경 선택 사용',59, '비밀번호나 시크릿 키 등을 코드에 하드코딩한 채로 GitHub에 업로드하면 보안상 큰 문제가 된다.'),
    (3046, 'Spring Boot 애플리케이션에서 내장 톰캣을 비활성화하고 외부 톰캣으로 배포하기 위한 설정은?', 4, 'high', 'server.port를 0으로 설정', 'application.yml에서 embeddedTomcat: false', 'WebApplicationType을 NONE으로 설정', 'spring-boot-starter-tomcat 의 scope를 provided로 설정',53, '내장 톰캣을 제외하려면 starter-tomcat의 scope를 provided로 설정하여 외부 톰캣에 배포할 수 있다.'),
    (3047, 'Spring Boot에서 실행 시 특정 profile을 적용하는 방법으로 올바른 것은?', 1, 'high', '--spring.profiles.active=prod 옵션을 추가한다.', 'application-run.yml을 생성한다.', 'WebApplicationType을 PROFILE로 설정한다.', 'application.properties에 spring.profile.only 설정',53, '명령행 인자로 --spring.profiles.active=prod와 같이 지정하여 실행할 수 있다.'),
    (3048, 'Spring Boot fat jar 실행 시 `java -jar` 명령으로 설정을 추가하려면 어떻게 해야 하는가?', 2, 'high', 'jar 내부의 application.yml만 수정하면 된다.', '명령행 인자 또는 환경변수로 설정을 오버라이드할 수 있다.', 'JVM 환경변수로만 설정 가능하다.', 'properties 파일만 사용 가능하다.',53, '명령행 인자나 환경변수를 통해 jar 실행 시 설정을 동적으로 지정할 수 있다.'),
    (3049, 'Spring Boot 앱을 Nginx와 연동할 때 주의할 점은?', 1, 'high', 'Nginx가 proxy_pass로 전달할 대상 포트를 정확히 설정해야 한다.', 'Spring 앱에서 반드시 HTTPS만 허용해야 한다.', 'Nginx는 Spring 앱의 jar 파일을 직접 실행할 수 있다.', 'Spring 앱은 반드시 루트 도메인("/")에 배포되어야 한다.',53, 'Nginx 설정에서 proxy_pass가 Spring 앱의 포트를 정확히 가리켜야 통신이 가능하다.'),
    (3050, 'Spring Boot를 Docker로 배포할 때 가장 좋은 베이스 이미지는?', 3, 'high', 'ubuntu:latest', 'tomcat:9-jdk11', 'openjdk:17-slim', 'alpine-java',53, 'Spring Boot를 Docker로 배포할 땐 openjdk slim 이미지가 용량과 보안 측면에서 우수하다.'),
    (3051, 'Spring Boot에서 HTTPS를 적용하려면 반드시 필요한 설정은?', 4, 'high', 'application.yml에 https=true 설정', '톰캣 포트를 443으로 변경', 'HTTPS 인코딩 설정', 'keystore 및 인증서 정보를 application.yml에 등록',53, 'HTTPS 적용을 위해서는 keystore 파일 경로, 비밀번호, 프로토콜 등을 명시해야 한다.'),
    (3052, 'Spring Boot에서 `@Value`로 주입할 수 없는 설정 방식은?', 2, 'high', 'application.yml에 정의된 값', '자바 클래스에서 선언된 static final 필드', '환경변수에 설정된 값', 'application.properties의 커스텀 설정값',53, '`@Value`는 static final 필드에는 주입되지 않으며, 스프링 컨텍스트에서 관리되는 빈에서만 가능하다.'),
    (3053, 'Spring Boot에서 다중 환경별 설정을 분리하기 위해 사용하는 기능은?', 1, 'high', 'Spring Profile', 'Config Hash', '설정 정규화', 'Bean Diff Config',53, 'Spring Profile 기능을 이용하면 dev, test, prod 등의 환경에 따라 설정을 분리할 수 있다.'),
    (3054, 'application.yml 설정에서 profile별 파일을 자동으로 적용하기 위한 구성은?', 3, 'high', 'spring.load.activeProfiles=dev', 'profile-mapping.yml 사용', 'application-{profile}.yml 파일을 만들어야 한다.', 'application-profile-override=true',53, '`application-prod.yml`과 같이 profile명을 포함한 파일을 만들면 해당 profile 활성화 시 자동 적용된다.'),
    (3055, 'Gradle 기반 Spring 프로젝트에서 Docker 이미지 빌드를 자동화하는 방법은?', 2, 'high', 'Maven plugin을 설정', 'Gradle의 Docker plugin 또는 Jib을 사용', 'Makefile로 빌드만 수행', 'DockerHub에서 jar 직접 업로드',53, 'Gradle 프로젝트는 Jib 플러그인을 사용해 도커 없이도 이미지 빌드가 가능하다.'),
    (3056, 'GitHub Actions에서 Spring Boot 프로젝트를 빌드하고 테스트하는 job 구성의 필수 단계는?', 3, 'high', 'init → install', 'build → docker-compose up', 'checkout → setup-java → gradle build/test', 'cache → deploy',53, 'Spring 프로젝트 빌드에는 GitHub Actions에서 체크아웃, JDK 설정, gradle build/test 단계가 필요하다.'),
    (3057, 'DockerHub로 Spring Boot 이미지를 push하기 위한 인증 방식은?', 1, 'high', 'GitHub Secrets에 로그인 정보 저장 후 로그인', 'Spring Boot 설정에 직접 Docker ID 입력', 'JDK 환경변수로 Docker 토큰 설정', 'Dockerfile 내에 인증 정보 삽입',53, 'GitHub Actions의 secrets에 Docker ID/PW를 저장하고 로그인 처리해야 push가 가능하다.'),
    (3058, 'Spring Boot에서 Actuator의 특정 엔드포인트를 활성화하려면?', 3, 'high', 'spring.monitor.enable=true', 'actuator.properties에 등록', 'management.endpoints.web.exposure.include에 해당 엔드포인트를 추가', 'ActuatorController를 직접 구현',3, 'Actuator의 엔드포인트는 expose 설정을 통해 개별적으로 활성화할 수 있다.'),
    (3059, 'Micrometer를 Prometheus와 연동할 때 필요한 exporter는?', 1, 'high', 'micrometer-registry-prometheus', 'spring-export-prometheus', 'prometheus-viewer-core', 'spring-metrics-viewer',53, 'Micrometer를 Prometheus에 연동하려면 micrometer-registry-prometheus 라이브러리가 필요하다.'),
    (3060, 'ELK 스택을 이용한 Spring 로그 분석에서 Logstash의 역할은?', 2, 'high', '로그 시각화', '로그 수집 및 변환', '모니터링 지표 수집', '애플리케이션 성능 추적',53, 'Logstash는 로그를 수집하고 변환/필터링한 후 Elasticsearch로 전달하는 역할을 한다.'),
    (3061, 'GitHub Actions에서 Node.js 애플리케이션의 CI 파이프라인 설정 시 가장 먼저 필요한 job 단계는?', 2, 'high', 'node_modules 캐싱', '코드 checkout 및 Node.js 환경 설정', 'Jest 실행', 'Docker 이미지 태깅',55, 'GitHub Actions에서 CI를 구성하려면 먼저 코드를 체크아웃하고 Node.js 환경을 세팅해야 한다.'),
    (3062, 'Node.js 애플리케이션을 GitHub Actions로 DockerHub에 자동 배포하려면 필요한 구성은?', 4, 'high', 'GitHub CLI 사용 및 run.sh 스크립트 작성', 'Node.js 프로젝트에 DockerHub 토큰 삽입', 'Dockerfile을 actions.yml에 하드코딩', 'GitHub Secrets에 Docker ID와 토큰 등록 및 login → build → push 과정',55, 'GitHub Secrets에 Docker 인증 정보를 등록하고 login → build → push 과정을 workflow에 작성해야 한다.'),
    (3063, '다음 중 GitHub Actions 워크플로우 파일에서 CI/CD 실행 조건을 정의하는 올바른 위치는?', 1, 'high', '`on:` 필드 아래에 push 또는 pull_request 지정', '`jobs:` 필드에 조건 작성', '`env:` 필드에 조건 지정', '조건은 actions 디렉토리에만 작성',5, '`on:` 키워드는 워크플로우 트리거를 지정하는 기본 위치이다 (ex: on: push, on: pull_request).'),
    (3064, 'Node.js 앱을 Docker로 배포할 때 최적의 Dockerfile 구성은?', 2, 'high', 'node:latest 사용 및 npm run start', 'node:alpine 사용, 작업 디렉토리 설정 후 COPY → RUN → CMD 순서로 작성', 'npm start만 설정', 'Dockerfile 없이 직접 컨테이너 실행',5, '경량 이미지(node:alpine)를 기반으로 명확한 빌드 순서와 작업 디렉토리 설정을 포함해야 효율적이다.'),
    (3065, 'Nginx를 Node.js 애플리케이션과 Reverse Proxy로 구성할 때 주의할 점은?', 3, 'high', 'Nginx가 Node.js 소스를 직접 렌더링해야 한다.', 'Nginx는 반드시 HTTPS를 직접 처리해야 한다.', 'proxy_pass 지시어로 Node.js 백엔드 서버 주소와 포트를 정확히 지정해야 한다.', 'Node.js는 반드시 443 포트를 사용해야 한다.',55, 'proxy_pass 설정에서 Node.js 서버의 정확한 host:port를 지정하지 않으면 프록시가 실패한다.'),
    (3066, 'Docker Compose를 사용해 Node.js와 Nginx를 함께 배포할 때 필요한 조건은?', 1, 'high', '두 컨테이너가 동일 네트워크에서 실행되어야 한다.', 'Node.js는 도커 외부에서 실행되어야 한다.', 'Nginx는 app.js 파일을 직접 참조해야 한다.', '각 서비스는 별도 Dockerfile 없이 실행되어야 한다.',55, 'Nginx와 Node.js 컨테이너가 같은 Docker 네트워크에 있어야 proxy가 정상 작동한다.'),
    (3067, 'PM2를 사용하여 Node.js 앱을 운영할 때 메모리 누수나 크래시 대응을 위한 전략은?', 4, 'high', 'Node.js 자체로 로그 출력', 'Forever 모드로 실행', '정적 설정 파일을 구성', 'watch, restart_delay, max_memory_restart 등을 설정',55, 'PM2에서는 메모리 초과 시 재시작 설정(max_memory_restart) 등으로 프로세스를 안정적으로 관리할 수 있다.'),
    (3068, 'PM2에서 애플리케이션 환경별 설정을 자동화하려면 어떻게 해야 하는가?', 2, 'high', 'env.sh 파일만 만들면 된다.', 'ecosystem.config.js 파일에 env, env_production 등을 정의한다.', 'PM2 커맨드라인에 직접 환경변수를 입력한다.', 'settings.json 파일에 환경을 저장한다.',55, 'PM2는 ecosystem.config.js에 각 환경별 설정(env, env_production 등)을 정의해 자동화할 수 있다.'),
    (3069, '다음 중 PM2의 클러스터 모드의 주된 이점은?', 3, 'high', '스레드 기반 동시성 향상', '모놀리식 구조 유지', '멀티코어 환경에서 병렬 처리 성능 향상', '단일 포트 바인딩 제거',55, 'PM2 클러스터 모드는 멀티코어 시스템에서 여러 인스턴스를 생성해 병렬 처리 성능을 높인다.'),
    (3070, 'Winston 로거에서 로그 레벨을 동적으로 제어하기 위한 설정은?', 2, 'high', '로그 포맷을 JSON으로 설정', 'logger 인스턴스 생성 시 level 속성 동적 지정', '환경변수 NODE_LOG만 사용', 'app.js에서 직접 console.log로 조작',55, 'Winston은 level 속성을 통해 로깅 레벨을 설정하며, 동적으로도 변경 가능하다.'),
    (3071, 'Node.js 로깅과 관련하여 Logrotate의 사용 목적은?', 3, 'high', '로그의 색상을 지정하기 위해', '로그 레벨 필터링을 위해', '로그 파일 용량 제한 및 자동 순환 보관', '서버 간 로그 전달',55, 'Logrotate는 로그 파일이 일정 크기를 넘거나 오래되면 순환하고 보관할 수 있도록 해준다.'),
    (3072, 'Sentry를 Node.js 앱에 연동할 때 필수 요소는?', 1, 'high', 'Sentry DSN 키를 초기화 코드에 포함', 'Sentry의 로그 파일 직접 업로드', 'logger.error를 직접 실행', 'Sentry 전용 포트를 열어야 한다.',55, 'Sentry는 DSN 키를 통해 프로젝트에 연결되며 초기화 시 필수로 포함해야 한다.'),
    (3073, 'Node.js 애플리케이션에서 dotenv 패키지를 사용하는 주된 이유는?', 1, 'high', '환경변수를 코드 외부에서 관리할 수 있기 때문', '코드 실행 시간을 줄이기 위해', '파일 시스템을 자동으로 로드하기 위해', 'YAML 설정을 지원하기 위해',55, 'dotenv는 .env 파일을 로드해 process.env를 통해 환경변수를 사용할 수 있게 한다.'),
    (3074, '다중 환경(dev, prod 등)을 설정할 때 보안적으로 가장 안전한 방식은?', 3, 'high', '.env 파일을 하드코딩하고 커밋', '환경별 config.js 파일을 직접 실행', '민감 정보는 .env에 분리하고 Git에 커밋하지 않는다.', '설정 파일을 URL로 불러온다.',55, '.env에 민감 정보를 분리하고 .gitignore에 추가해 Git에 커밋되지 않도록 해야 보안이 유지된다.'),
    (3075, 'Node.js 설정에서 `process.env.NODE_ENV`를 사용하는 주된 목적은?', 2, 'high', '서버 포트를 지정하기 위해', '실행 환경(dev, test, prod 등)에 따라 분기 처리하기 위해', '서버를 클러스터링하기 위해', '환경변수를 하드코딩하지 않기 위해',55, 'NODE_ENV는 현재 실행 환경에 따라 설정 로직, 로그 레벨, DB 접속 등을 다르게 처리할 수 있도록 해준다.'),
    (3076, 'Spring Boot에서 Kotlin DSL 스타일의 라우팅을 사용할 때 필요한 설정은?', 3, 'high', 'WebMvcConfigurer에서 route 등록', 'RestController에서 RequestMapping 직접 사용', 'RouterFunction을 정의하고 RouterDsl을 적용', 'PathVariable 대신 RequestParam으로 통일',50, 'Kotlin에서는 functional routing 방식으로 RouterFunction을 DSL 형태로 정의해 사용할 수 있다.'),
    (3077, 'Kotlin에서 `@RestController`에 DSL을 적용하지 않고 함수형 방식으로 라우팅할 경우 사용되는 핵심 구성 요소는?', 2, 'high', 'RequestHandler 및 ResponseResolver', 'RouterFunction과 HandlerFunction', 'ControllerAdvice와 DataClass', 'SpringKotlinControllerAdapter',50, '함수형 라우팅에서는 RouterFunction과 HandlerFunction을 통해 요청과 응답을 분리된 방식으로 구성한다.'),
    (3078, 'Kotlin + Spring WebFlux에서 `coRouter`를 사용한 라우팅의 장점은?', 1, 'high', '비동기 흐름을 DSL 스타일로 명확하게 구성할 수 있다.', 'MVC 기반 구조를 자동으로 생성한다.', '라우팅 자동 문서화가 가능하다.', '@RequestMapping을 대체해 HTTP 메시지 변환을 최소화한다.',50, '`coRouter`는 코루틴 기반 비동기 처리를 DSL 형태로 명확하고 선언적으로 표현할 수 있게 해준다.'),
    (3079, '다음 중 외래 키 제약 조건을 추가하는 SQL 문으로 올바른 것은?', 2, 'high', 'ALTER TABLE orders ADD FOREIGN KEY customer_id REFERENCES customers;', 'ALTER TABLE orders ADD CONSTRAINT fk_customer FOREIGN KEY (customer_id) REFERENCES customers(id);', 'MODIFY TABLE orders ADD CONSTRAINT fk_customer (customer_id) REFERENCES customers;', 'CREATE TABLE orders ADD FOREIGN KEY (customer_id);',43, '외래 키 제약 조건은 CONSTRAINT 이름과 FOREIGN KEY (컬럼) REFERENCES (참조테이블)을 포함해야 한다.'),
    (3080, '다음 중 `CHECK` 제약 조건이 유효한 컬럼 생성 구문은?', 4, 'high', 'age INT CHECK age > 18', 'age INT CONSTRAINT CHECK(age > 18)', 'CHECK age > 18 INT', 'age INT CHECK (age > 18)',43, 'CHECK 제약 조건은 괄호 안에 논리 조건을 포함하며, 데이터 타입 뒤에 선언해야 한다.'),
    (3081, '다음 중 트랜잭션 제어 관련 SQL 문이 아닌 것은?', 1, 'high', 'SAVE', 'COMMIT', 'ROLLBACK', 'SAVEPOINT',43, 'SAVE는 유효한 트랜잭션 제어 명령이 아니며, SAVEPOINT를 사용하는 것이 올바르다.'),
    (3082, '다음 중 LEFT OUTER JOIN을 사용하는 이유로 가장 적절한 것은?', 3, 'high', '두 테이블의 교집합을 얻기 위해', 'NULL 값을 제거하기 위해', '왼쪽 테이블의 모든 값을 포함하면서 조건에 맞는 오른쪽 테이블의 값만 포함하기 위해', '서브쿼리를 대체하기 위해',43, 'LEFT OUTER JOIN은 왼쪽 테이블의 모든 행을 유지하면서 오른쪽 테이블의 조건에 맞는 값을 가져온다.'),
    (3083, '다음 SQL 중 상관 서브쿼리를 사용하는 것은?', 1, 'high', 'SELECT name FROM employees e WHERE salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id);', 'SELECT name FROM employees WHERE id IN (SELECT manager_id FROM departments);', 'SELECT * FROM employees WHERE department_id = (SELECT MAX(department_id) FROM departments);', 'SELECT * FROM employees WHERE EXISTS (SELECT 1 FROM departments);',43, '상관 서브쿼리는 외부 쿼리의 값을 내부 쿼리에서 참조하는 구조로, 예제 1이 해당된다.'),
    (3084, '다음 중 두 테이블의 교집합을 구하는 SQL 문은?', 2, 'high', 'SELECT * FROM A FULL JOIN B;', 'SELECT * FROM A INTERSECT SELECT * FROM B;', 'SELECT * FROM A UNION SELECT * FROM B;', 'SELECT * FROM A LEFT JOIN B;',43, '`INTERSECT`는 두 SELECT 결과의 공통된 행만 반환한다.'),
    (3085, '다음 중 CSS 선택자 우선순위가 가장 높은 것은?', 2, 'high', '태그 선택자', '인라인 스타일', '클래스 선택자', 'id 선택자',20, '인라인 스타일은 우선순위에서 가장 높으며, 그 다음은 id > class > tag 순이다.'),
    (3086, '다음 중 box-sizing: border-box가 적용되었을 때 width 계산 방식으로 올바른 것은?', 3, 'high', 'width는 content 영역만 포함한다.', 'width는 content + padding만 포함한다.', 'width는 content + padding + border를 모두 포함한다.', 'width는 margin까지 포함한다.',20, 'border-box는 padding과 border를 포함한 전체 너비를 width로 계산한다.'),
    (3087, '다음 중 CSS Grid에서 특정 영역을 2행 2열로 병합할 때 사용하는 문법은?', 4, 'high', 'grid-area: span 2;', 'grid-template: repeat(2, auto);', 'grid-column: auto / span 2;', 'grid-column: span 2; grid-row: span 2;',20, 'grid-column과 grid-row를 각각 span 2로 지정하면 셀을 2x2 크기로 병합할 수 있다.'),
    (3088, '다음 중 화면 너비가 768px 이하일 때 스타일을 적용하는 미디어 쿼리 문법은?', 1, 'high',  '@media screen and (max-width: 768px)', '@media screen or (width <= 768px)', '@media only if width < 768px', '@media mobile-width: 768px',20, '올바른 문법은 @media screen and (max-width: 768px)이며, 반응형 설계에서 자주 사용된다.'),
    (3089, '다음 중 CSS 트랜지션이 적용되지 않는 이유로 가장 적절한 것은?', 3, 'high', 'transition-duration이 설정되지 않음', 'transition-property가 all로 설정됨', '속성값이 즉시 변화하는 display 속성에 transition을 적용함', 'transition-delay가 너무 길게 설정됨',20, 'display 속성은 트랜지션이 불가능한 속성 중 하나이므로 변화가 애니메이션되지 않는다.'),
    (3090, '테스트 피라미드(Test Pyramid) 원칙에 따라 테스트를 구성할 때 가장 바람직한 방식은?', 2, 'high', 'E2E 테스트를 가장 많이 작성하고, 단위 테스트는 최소화한다.', '단위 테스트를 기반으로 가장 많이 작성하고, E2E 테스트는 최소화한다.', '통합 테스트만으로 전체 테스트 커버리지를 확보한다.', '스냅샷 테스트 중심으로 구성한다.',33, '테스트 피라미드는 단위 테스트를 가장 많이, 통합 테스트를 중간 수준으로, E2E 테스트를 적게 작성하는 것을 권장한다.'),
    (3091, 'JavaScript 로직 함수의 단위 테스트를 작성할 때 테스트하기 어려운 대상은?', 3, 'high', '리턴값이 명확한 순수 함수', '입력값에 따라 결과가 결정되는 조건문', '의존성이 외부 시스템(API, DB 등)에 연결된 사이드 이펙트 함수', '논리 연산자 중심의 단일 함수',33, '단위 테스트는 외부 시스템에 의존하지 않아야 하며, 사이드 이펙트가 있는 함수는 Mocking 또는 Stub이 필요해 테스트가 어렵다.'),
    (3092, 'React 컴포넌트 테스트에서 사용자가 버튼을 클릭했을 때 상태가 변경되는지를 확인하려면 가장 적절한 접근은?', 1, 'high', 'fireEvent를 통해 클릭 이벤트를 발생시키고, 상태 변경 후 UI를 검사한다.', '컴포넌트 내부 state 값을 직접 변경하고 렌더링을 체크한다.', '렌더링된 DOM을 직접 조작하여 결과를 예상한다.', 'snapshot 테스트만으로 충분하다.',33, 'React Testing Library에서 fireEvent를 통해 사용자 인터랙션을 모사하고 상태 반영을 렌더링된 UI로 확인하는 것이 적절한 방식이다.');

CREATE TABLE feedback (
                          feedback_id BIGINT AUTO_INCREMENT PRIMARY KEY,
                          feedback_content TEXT NOT NULL,
                          nth INT NOT NULL,
                          is_pre BOOLEAN NOT NULL,
                          user_id BIGINT NOT NULL,
                          sub_id BIGINT NOT NULL,
                          strenth LONGTEXT NOT NULL,
                          weakness LONGTEXT NOT NULL,
                          created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
                          CONSTRAINT fk_feedback_user FOREIGN KEY (user_id) REFERENCES users(user_id),
                          CONSTRAINT fk_feedback_subject FOREIGN KEY (sub_id) REFERENCES subject(sub_id)
);


CREATE TABLE chat(
                     chat_id BIGINT AUTO_INCREMENT PRIMARY KEY,
                     user_message TEXT NOT NULL,
                     ai_message TEXT NOT NULL,
                     chat_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                     user_id BIGINT NOT NULL,
                     CONSTRAINT fk_chat_user FOREIGN KEY (user_id) REFERENCES users(user_id)
);
# 면접 질문 테이블 생성
CREATE TABLE interview (
                           interview_id BIGINT AUTO_INCREMENT PRIMARY KEY,
                           interview_content TEXT NOT NULL,
                           interview_answer TEXT NOT NULL,
                           sub_id BIGINT NOT NULL,
                           CONSTRAINT fk_interview_subject FOREIGN KEY (sub_id) REFERENCES subject(sub_id)
);

# 사용자 면접 답변 테이블 생성
CREATE TABLE user_interview_reply(
                                     reply_id BIGINT AUTO_INCREMENT PRIMARY KEY ,
                                     user_reply TEXT NOT NULL,
                                     interview_id BIGINT NOT NULL,
                                     user_id BIGINT NOT NULL,
                                     nth INT NOT NULL,
                                     ai_feedback TEXT NOT NULL,
                                     CONSTRAINT fk_user_reply_interview FOREIGN KEY (interview_id) REFERENCES interview(interview_id),
                                     CONSTRAINT fk_interview_user FOREIGN KEY (user_id) REFERENCES users(user_id)
);

INSERT INTO interview (interview_content, interview_answer, sub_id) values
                                                                        ('HTML이란 무엇인가요?', 'HTML은 HyperText Markup Language의 약자로, 웹 페이지의 구조를 정의하는 마크업 언어입니다. 텍스트, 이미지, 링크, 폼 등 다양한 요소를 웹 문서에 포함시키며, 브라우저가 HTML 코드를 해석하여 사용자에게 시각적으로 출력합니다. HTML은 구조적 의미를 부여하는 태그들로 구성되어 있으며, 웹 개발의 기초를 이루는 핵심 기술입니다.', 1),
                                                                        ('HTML의 기본 구조는 어떻게 구성되나요?', 'HTML 문서는 반드시 <!DOCTYPE html> 선언으로 시작하며, <html> 요소로 전체 문서를 감쌉니다. 그 내부에는 <head>와 <body> 요소가 있으며, <head>는 문서의 메타데이터(문서 제목, 문자 인코딩, 외부 CSS/JS 링크 등)를 포함하고, <body>는 실제 화면에 표시될 콘텐츠 요소들(텍스트, 이미지, 버튼 등)을 포함합니다.', 1),
                                                                        ('HTML에서 시맨틱 태그란 무엇이며 왜 중요한가요?', '시맨틱 태그는 태그 이름만으로도 그 내용의 의미를 파악할 수 있는 태그로, 예를 들어 <header>, <footer>, <nav>, <section>, <article> 등이 있습니다. 이러한 태그들은 문서 구조를 논리적으로 표현하고, 접근성 향상 및 검색 엔진 최적화(SEO)에 도움을 주며, 코드의 가독성과 유지보수성을 높입니다.', 1),
                                                                        ('블록 요소와 인라인 요소의 차이는 무엇인가요?', '블록 요소는 항상 새로운 줄에서 시작하며 가로 전체 너비를 차지합니다. 예를 들어 <div>, <p>, <h1>~<h6> 등이 있습니다. 인라인 요소는 줄 안에 배치되며, 요소의 콘텐츠 크기만큼만 공간을 차지합니다. 예: <span>, <a>, <strong>. 이러한 차이는 CSS 레이아웃을 설계할 때 중요한 기준이 됩니다.', 1),
                                                                        ('HTML 폼(form)은 무엇이고 어떤 역할을 하나요?', 'HTML에서 <form> 요소는 사용자로부터 입력을 받아 서버로 전송하기 위한 양식입니다. <form> 내부에는 <input>, <textarea>, <select>, <button> 등의 요소들이 들어갑니다. action 속성은 전송할 URL, method 속성은 전송 방식(GET 또는 POST)을 지정합니다. 폼은 로그인, 회원가입, 검색 등 다양한 사용자 상호작용을 처리할 때 사용됩니다.', 1),
                                                                        ('input 태그의 주요 type 속성에는 어떤 것들이 있나요?', 'input 태그는 사용자 입력을 받기 위해 사용되며, 다양한 type 속성을 통해 입력 유형을 지정할 수 있습니다. 예: text(일반 텍스트), password(비밀번호), email(이메일 주소 형식 검증), number(숫자만 허용), checkbox(다중 선택), radio(단일 선택), date(날짜 선택) 등. 각 타입은 입력 제한과 유효성 검사에도 활용됩니다.', 1),
                                                                        ('HTML에서 링크를 생성하는 방법은 무엇인가요?', '<a> 태그를 사용하여 링크를 생성합니다. href 속성에 이동할 URL을 지정하며, 예를 들어 <a href="https://example.com">Example</a>와 같이 작성합니다. target="_blank"를 지정하면 새 창에서 링크가 열리고, rel="noopener noreferrer"를 함께 사용하면 보안과 성능에 도움이 됩니다.', 1),
                                                                        ('이미지를 웹 페이지에 삽입하려면 어떻게 하나요?', '이미지는 <img> 태그를 사용하여 삽입하며, src 속성에는 이미지 파일의 경로를, alt 속성에는 이미지 설명을 작성합니다. 예: <img src="image.jpg" alt="설명 텍스트">. alt 텍스트는 이미지가 로드되지 않을 경우 대체로 표시되며, 시각장애인을 위한 스크린 리더에 중요한 정보를 제공합니다.', 1),
                                                                        ('HTML 테이블을 구성하기 위한 주요 태그는 무엇인가요?', 'HTML에서 <table> 태그를 사용하여 표를 만들 수 있습니다. <tr>은 행(row)을, <th>는 헤더 셀을, <td>는 일반 셀을 의미합니다. 또한 <thead>, <tbody>, <tfoot>을 사용해 테이블 구조를 논리적으로 나눌 수 있습니다. 각 셀에는 colspan, rowspan 속성을 통해 병합도 가능합니다.', 1),
                                                                        ('HTML5에서 추가된 주요 기능은 무엇인가요?', 'HTML5는 기존 HTML의 기능을 보완하고 현대적인 웹 요구에 대응하기 위해 도입된 버전입니다. 주요 기능으로는 시맨틱 태그(<section>, <article> 등), 멀티미디어 태그(<video>, <audio>), 그래픽 요소(canvas, svg), 웹 저장소(localStorage, sessionStorage), 드래그 앤 드롭 API, 향상된 폼 기능 등이 있습니다.', 1),
                                                                        ('CSS란 무엇인가요?', 'CSS는 Cascading Style Sheets의 약자로, HTML로 구성된 웹 문서에 디자인과 스타일을 입히기 위한 언어입니다. 글자 색상, 크기, 여백, 정렬, 배경, 애니메이션 등 다양한 시각적 요소를 제어할 수 있으며, HTML과 완전히 분리된 스타일 정의가 가능하여 유지보수성과 재사용성을 높입니다.', 2),
                                                                        ('CSS를 HTML에 적용하는 방법에는 어떤 것들이 있나요?', 'CSS를 HTML에 적용하는 방식에는 세 가지가 있습니다. 인라인 스타일은 HTML 태그 내 style 속성에 직접 작성하는 방식, 내부 스타일은 <style> 태그를 <head>에 작성하는 방식, 외부 스타일은 별도의 .css 파일로 작성한 후 <link> 태그를 이용해 연결하는 방식입니다. 유지보수성과 재사용 측면에서 외부 스타일시트가 가장 권장됩니다.', 2),
                                                                        ('CSS의 선택자(selector)란 무엇이고 종류에는 어떤 것이 있나요?', '선택자는 특정 HTML 요소를 선택하여 스타일을 적용하는 역할을 합니다. 기본적으로 태그 선택자, 클래스 선택자(.class), 아이디 선택자(#id), 그룹 선택자 등이 있으며, 결합자(자식 >, 후손 공백, 형제 +, ~)와 속성 선택자, 의사 클래스(:hover, :nth-child) 및 의사 요소(::before, ::after) 등도 포함됩니다.', 2),
                                                                        ('클래스 선택자와 아이디 선택자의 차이는 무엇인가요?', '클래스 선택자는 동일한 클래스를 여러 요소에 적용할 수 있어 재사용이 용이하며, 마침표(.)를 사용해 정의합니다. 반면 아이디 선택자는 문서 내 고유한 요소에만 적용되며, 샵(#)을 사용해 지정합니다. 스타일 적용 우선순위에서도 아이디 선택자가 클래스 선택자보다 높습니다.', 2),
                                                                        ('CSS에서 박스 모델(Box Model)이란 무엇인가요?', '박스 모델은 HTML 요소를 사각형 박스로 간주하고, 콘텐츠(content), 패딩(padding), 테두리(border), 마진(margin) 네 가지 영역으로 구성된 구조를 의미합니다. 요소 간 간격 조절, 크기 계산 등 레이아웃 설계에 핵심적인 개념이며, box-sizing 속성을 통해 너비/높이 계산 방식도 제어할 수 있습니다.', 2),
                                                                        ('position 속성의 종류와 차이점을 설명해주세요.', 'position 속성은 요소의 위치 지정 방식을 설정하는 속성입니다. static은 기본 위치, relative는 자신의 원래 위치 기준으로 이동, absolute는 가장 가까운 position이 지정된 조상 기준, fixed는 화면 기준 고정, sticky는 스크롤에 따라 위치가 변하는 하이브리드 방식입니다. 각각은 다른 레이아웃 시나리오에 활용됩니다.', 2),
                                                                        ('display 속성에는 어떤 값들이 있고 어떤 차이가 있나요?', 'display 속성은 요소의 박스 유형을 정의하는 데 사용됩니다. 대표적으로 block(한 줄 전체 사용), inline(콘텐츠 크기만큼 사용), inline-block(줄 안 배치 + 블록 속성 가능), flex(유연한 레이아웃), grid(격자 레이아웃), none(비표시) 등이 있으며, 각 값은 요소의 배치 및 흐름에 큰 영향을 미칩니다.', 2),
                                                                        ('CSS에서 Flexbox란 무엇이고 언제 사용하나요?', 'Flexbox는 1차원(가로 또는 세로) 레이아웃을 위한 CSS 모듈로, 컨테이너와 그 자식 요소 간의 간격, 정렬, 크기 조절을 쉽게 해줍니다. display: flex로 선언 후 justify-content, align-items, flex-grow 등 다양한 속성으로 배치 제어가 가능합니다. 반응형 디자인에 자주 활용됩니다.', 2),
                                                                        ('z-index 속성은 무엇이고 언제 사용하나요?', 'z-index는 요소의 쌓임 순서를 제어하는 속성으로, 값이 클수록 위에 표시됩니다. position 속성이 static이 아닌 요소에 적용되며, 겹치는 요소 중 어떤 것이 앞에 나올지 결정할 때 사용합니다. 음수도 지정 가능하며, 레이어 구조가 복잡한 UI에서 유용합니다.', 2),
                                                                        ('미디어 쿼리(Media Query)는 무엇이고 어떻게 사용하나요?', '미디어 쿼리는 디바이스의 화면 크기, 해상도, 방향 등에 따라 다른 스타일을 적용할 수 있도록 하는 CSS 기능입니다. @media 키워드를 사용하며, 조건에 따라 스타일을 분기할 수 있어 반응형 웹 디자인 구현에 필수적입니다. 예: @media (max-width: 768px) { ... }', 2),
                                                                        ('JavaScript란 무엇인가요?', 'JavaScript는 웹 브라우저에서 동적으로 동작하는 기능을 구현하기 위한 객체 기반의 스크립트 언어입니다. HTML과 CSS가 각각 콘텐츠와 스타일을 담당한다면, JavaScript는 사용자 인터랙션, DOM 조작, 이벤트 처리, 비동기 통신 등을 담당하여 웹 페이지를 동적으로 만듭니다.', 3),
                                                                        ('var, let, const의 차이는 무엇인가요?', 'var는 함수 스코프를 가지며, 호이스팅될 때 undefined로 초기화됩니다. let과 const는 블록 스코프를 가지며, 호이스팅은 되지만 TDZ(Temporal Dead Zone) 때문에 선언 전에 접근할 수 없습니다. const는 재할당이 불가능하여 상수로 사용됩니다.', 3),
                                                                        ('JavaScript의 호이스팅이란 무엇인가요?', '호이스팅은 변수나 함수 선언이 코드 실행 전에 해당 스코프의 최상단으로 끌어올려지는 JavaScript의 동작 방식입니다. var 변수는 undefined로 초기화되며 호이스팅되고, 함수 선언문은 전체 함수가 끌어올려집니다. 반면 let, const는 TDZ로 인해 선언 전에 접근 시 ReferenceError가 발생합니다.', 3),
                                                                        ('== 와 === 의 차이는 무엇인가요?', '==는 느슨한 동등 비교로 타입이 다르면 타입을 강제로 변환한 후 비교합니다. 반면 ===는 엄격한 동등 비교로 타입과 값이 모두 일치해야 true를 반환합니다. 일반적으로 예기치 않은 타입 변환을 방지하기 위해 === 사용이 권장됩니다.', 3),
                                                                        ('클로저(Closure)란 무엇인가요?', '클로저는 함수가 선언될 당시의 렉시컬 환경을 기억하여, 함수 외부에서 정의된 변수에 접근할 수 있는 기능입니다. 클로저는 데이터 은닉, private 변수 구현, 상태 유지 등에 활용되며, 자바스크립트의 고급 기능 중 하나입니다.', 3),
                                                                        ('this 키워드는 무엇을 가리키나요?', 'this는 함수가 호출되는 방식에 따라 동적으로 결정됩니다. 일반 함수에서는 전역 객체(window)를, 객체의 메서드에서는 해당 객체를 가리킵니다. 화살표 함수는 this를 렉시컬하게 결정하여 상위 스코프의 this를 그대로 사용합니다.', 3),
                                                                        ('이벤트 버블링과 캡처링이란 무엇인가요?', '이벤트 버블링은 이벤트가 가장 깊은 요소에서 발생해 상위 요소로 전파되는 방식이고, 캡처링은 반대로 최상위 요소에서 시작하여 타겟 요소까지 내려가는 방식입니다. addEventListener에서 세 번째 인자를 true로 설정하면 캡처링 단계에서 이벤트를 처리할 수 있습니다.', 3),
                                                                        ('Promise란 무엇이며 왜 사용하나요?', 'Promise는 비동기 작업의 완료 또는 실패를 나타내는 객체로, 콜백 지옥을 해결하고 코드의 가독성을 높입니다. then(), catch(), finally()를 사용하여 비동기 로직을 체계적으로 구성할 수 있으며, async/await 구문과 함께 사용되면 더욱 직관적인 코드 구성이 가능합니다.', 3),
                                                                        ('async/await는 어떻게 동작하나요?', 'async 함수는 항상 Promise를 반환하며, 내부에서 await 키워드를 사용하여 Promise가 해결될 때까지 대기합니다. 이는 비동기 코드를 마치 동기 코드처럼 작성할 수 있게 해주어 가독성을 높이고 예외 처리를 try/catch로 통일할 수 있습니다.', 3),
                                                                        ('DOM이란 무엇이며 어떻게 조작하나요?', 'DOM(Document Object Model)은 HTML 문서를 객체로 표현한 구조로, JavaScript를 통해 문서 구조를 동적으로 조작할 수 있게 해줍니다. document.querySelector, getElementById 등의 메서드로 요소를 선택하고, innerText, classList, setAttribute 등의 속성을 통해 수정할 수 있습니다.', 3),
                                                                        ('TypeScript란 무엇인가요?', 'TypeScript는 Microsoft에서 개발한 오픈소스 프로그래밍 언어로, JavaScript에 정적 타입을 추가한 슈퍼셋입니다. 컴파일 단계에서 타입 오류를 사전에 감지할 수 있어 개발 초기부터 버그를 줄일 수 있으며, 대규모 애플리케이션 개발 시 코드의 안정성과 유지보수성을 크게 향상시킵니다.', 4),
                                                                        ('TypeScript와 JavaScript의 차이점은 무엇인가요?', 'TypeScript는 JavaScript의 상위 집합으로, 정적 타입 지정, 클래스 기반 객체지향 프로그래밍, 인터페이스, 제네릭 등의 기능을 제공합니다. JavaScript는 동적 타입 언어로 런타임에 오류를 발견하지만, TypeScript는 컴파일 타임에 오류를 감지할 수 있어 안정성이 높습니다.', 4),
                                                                        ('TypeScript에서 타입 주석(type annotation)은 무엇인가요?', '타입 주석은 변수, 함수 매개변수, 반환값 등에 타입을 명시적으로 지정하는 방식입니다. 예를 들어 let count: number = 5;와 같이 작성하여 변수의 타입을 명확히 하고, 실수나 불일치한 타입 사용을 사전에 방지할 수 있습니다.', 4),
                                                                        ('인터페이스(interface)란 무엇이고 어떻게 사용하나요?', '인터페이스는 객체의 구조를 정의하는 타입입니다. 속성의 이름과 타입을 지정하여 해당 구조를 따르는 객체만 허용하게 만들 수 있습니다. 예: interface User { name: string; age: number; }. 인터페이스는 코드의 명확성과 타입 안정성을 높이고 협업 시 의사소통을 명확하게 합니다.', 4),
                                                                        ('TypeScript의 타입 추론(type inference)이란 무엇인가요?', '타입 추론은 TypeScript가 변수나 함수의 타입을 명시적으로 지정하지 않아도, 초기값이나 문맥을 통해 자동으로 타입을 유추하는 기능입니다. 예를 들어 let name = "John";은 TypeScript가 name의 타입을 string으로 추론합니다.', 4),
                                                                        ('유니온 타입과 인터섹션 타입의 차이는 무엇인가요?', '유니온 타입(A | B)은 변수나 매개변수가 둘 중 하나의 타입일 수 있도록 허용하며, 인터섹션 타입(A & B)은 두 타입을 모두 만족하는 구조를 의미합니다. 유니온은 선택의 개념, 인터섹션은 결합의 개념입니다.', 4),
                                                                        ('제네릭(Generic)이란 무엇이며 왜 사용하나요?', '제네릭은 타입을 함수나 클래스 외부에서 주입받아 유연하고 재사용 가능한 컴포넌트를 만들기 위한 기능입니다. 예를 들어 function identity<T>(arg: T): T는 어떤 타입이든 동일하게 처리할 수 있는 함수를 정의합니다. 타입 안정성을 유지하면서 다양한 타입에 대응할 수 있습니다.', 4),
                                                                        ('타입 단언(Type Assertion)이란 무엇인가요?', '타입 단언은 개발자가 해당 값이 특정 타입이라고 확신할 때 사용하는 문법입니다. 예: const input = document.getElementById("username") as HTMLInputElement;. 이는 TypeScript에게 명시적으로 타입 정보를 전달하여 컴파일러의 타입 검사를 보완합니다.', 4),
                                                                        ('타입 가드(Type Guard)란 무엇인가요?', '타입 가드는 런타임에서 변수의 타입을 좁혀주는 역할을 하는 조건문입니다. typeof, instanceof, 사용자 정의 함수 등을 활용해 특정 타입 여부를 검사하고, 그 블록 안에서 컴파일러가 타입을 좁혀 안정적인 코드 작성을 돕습니다.', 4),
                                                                        ('타입스크립트에서 any와 unknown의 차이점은 무엇인가요?', 'any는 어떤 타입도 허용하며, 타입 검사를 우회하므로 오류를 유발할 수 있습니다. 반면 unknown은 모든 타입을 받을 수 있지만, 사용 전에는 반드시 타입 검사를 거쳐야 하므로 더 안전합니다. 가능한 any보다는 unknown을 사용하는 것이 권장됩니다.', 4),
                                                                        ('Virtual DOM이란 무엇인가요?', 'Virtual DOM은 실제 DOM과 동일한 구조를 갖는 가상의 메모리 내 객체입니다. 브라우저의 실제 DOM 조작은 비용이 크기 때문에, Virtual DOM에서 변경 사항을 계산한 후 실제 DOM에는 최소한의 변경만 적용함으로써 성능을 최적화합니다. 주로 React 같은 라이브러리에서 사용됩니다.', 5),
                                                                        ('Virtual DOM의 작동 방식은 어떻게 되나요?', '컴포넌트 상태(state)가 변경되면 Virtual DOM이 새롭게 생성되고, 이전 Virtual DOM과 비교(diff)하여 변경된 부분만 계산합니다. 그 후 실제 DOM에는 변경이 필요한 최소한의 조작만 수행됩니다. 이 과정을 통해 전체 DOM을 다시 렌더링하는 비효율을 줄입니다.', 5),
                                                                        ('Virtual DOM이 성능 최적화에 어떤 도움을 주나요?', 'DOM 조작은 브라우저 렌더링에서 가장 비용이 큰 작업 중 하나입니다. Virtual DOM은 변경 전후의 상태를 비교(diff)하고 필요한 부분만 patch하여 실제 DOM에 반영하기 때문에 렌더링 횟수와 범위를 줄여 성능을 최적화합니다.', 5),
                                                                        ('Virtual DOM과 Real DOM의 차이는 무엇인가요?', 'Real DOM은 브라우저가 실제로 렌더링하는 객체이며, 변경 시 직접 DOM을 조작하게 됩니다. 반면 Virtual DOM은 메모리 상의 가상 객체로, 변경 사항을 먼저 반영하고 실제 DOM에는 필요한 부분만 업데이트함으로써 효율적으로 작동합니다.', 5),
                                                                        ('diff 알고리즘이란 무엇인가요?', 'diff 알고리즘은 이전 Virtual DOM과 새로운 Virtual DOM을 비교하여 변경된 부분을 찾아내는 알고리즘입니다. React의 경우 O(n) 시간 복잡도로 트리 구조를 비교하며, key 속성을 통해 효율성을 높입니다. 변경 사항이 많을수록 성능 최적화 효과가 커집니다.', 5),
                                                                        ('Virtual DOM이 항상 실제 DOM보다 빠른가요?', 'Virtual DOM은 일반적으로 실제 DOM보다 빠르지만, 모든 경우에 그렇지는 않습니다. 변경 범위가 매우 작거나 DOM 조작이 단순한 경우에는 오히려 Virtual DOM의 diff 비용이 더 클 수 있습니다. 하지만 대부분의 동적인 UI에서는 Virtual DOM이 더 효율적입니다.', 5),
                                                                        ('React는 Virtual DOM을 어떻게 활용하나요?', 'React는 상태 변경 시 컴포넌트를 다시 렌더링하며 새로운 Virtual DOM을 생성합니다. React는 이전 Virtual DOM과 비교하여 변경된 부분만 실제 DOM에 반영합니다. 이 과정은 React 내부의 reconciler와 renderer가 협력하여 처리합니다.', 5),
                                                                        ('Virtual DOM의 단점은 무엇인가요?', 'Virtual DOM을 사용하면 메모리 사용량이 증가하고, diff 및 patch 계산에도 CPU 자원이 소모됩니다. 또한 초기 렌더링에는 별다른 이점이 없으며, 복잡한 diff 계산이 오히려 성능을 저하시킬 수 있는 엣지 케이스도 존재합니다.', 5),
                                                                        ('key 속성은 Virtual DOM에서 어떤 역할을 하나요?', 'key는 Virtual DOM에서 요소를 식별하는 고유값으로, 리스트 렌더링 시 diff 알고리즘의 효율성을 높입니다. key가 없으면 React는 위치 기반 비교를 수행하게 되어 불필요한 재렌더링이 발생할 수 있으므로, 고유한 key 설정이 성능 최적화에 중요합니다.', 5),
                                                                        ('Virtual DOM이 없는 환경에서는 어떻게 작동하나요?', 'Virtual DOM이 없는 환경에서는 상태 변경이 발생할 때마다 실제 DOM에 직접 접근하여 조작해야 합니다. 이는 렌더링 비용이 크고 UI 성능이 저하될 수 있으며, 복잡한 상태 관리 및 UI 업데이트가 어렵기 때문에 Virtual DOM이 도입된 것입니다.', 5),
                                                                        ('Git이란 무엇인가요?', 'Git은 분산형 버전 관리 시스템(VCS)으로, 소스 코드의 변경 이력을 로컬 저장소에 저장하며 협업 및 변경 이력 관리를 용이하게 합니다. Git은 각 개발자의 로컬 저장소에서도 전체 히스토리를 관리할 수 있어 네트워크 연결 없이도 작업이 가능하며, 빠른 속도와 강력한 브랜치 기능을 제공합니다.', 6),
                                                                        ('GitHub란 무엇인가요?', 'GitHub는 Git 저장소를 온라인에서 호스팅해주는 플랫폼으로, 코드 공유, 협업, 이슈 추적, Pull Request 등을 통해 개발자 간 협업을 원활하게 도와줍니다. 또한 GitHub Actions와 같은 CI/CD 기능도 제공하여 자동화된 배포와 테스트를 수행할 수 있습니다.', 6),
                                                                        ('commit과 push의 차이는 무엇인가요?', 'commit은 로컬 저장소에 변경 사항을 저장하는 작업이며, 메시지를 통해 해당 변경의 목적을 기록합니다. 반면 push는 로컬 저장소의 커밋 내역을 원격 저장소(GitHub 등)로 전송하는 명령으로, 협업을 위해 변경사항을 공유할 때 사용됩니다.', 6),
                                                                        ('브랜치(branch)의 개념과 사용하는 이유는 무엇인가요?', '브랜치는 독립적인 개발 흐름을 만들기 위한 기능으로, 메인 코드에 영향을 주지 않고 기능 개발, 버그 수정 등을 진행할 수 있게 해줍니다. 브랜치를 사용하면 여러 개발자가 동시에 작업할 수 있으며, 완료된 후 병합(merge)을 통해 메인 브랜치에 통합합니다.', 6),
                                                                        ('merge와 rebase의 차이점은 무엇인가요?', 'merge는 두 브랜치의 커밋을 병합하여 새로운 커밋을 생성하는 방식이며, 커밋 히스토리가 분기 형태로 유지됩니다. rebase는 브랜치의 베이스를 옮겨 일직선 형태의 히스토리를 만들며, 커밋 로그가 깔끔해지는 장점이 있지만 충돌 관리가 필요합니다.', 6),
                                                                        ('Git에서 충돌(conflict)은 언제 발생하고 어떻게 해결하나요?', '충돌은 두 브랜치에서 동일한 파일의 동일한 위치를 수정했을 때 발생합니다. Git은 자동 병합을 하지 못하고 수동 해결을 요구합니다. 이 경우 충돌 표시(<<<<<, =====, >>>>> 등)를 기준으로 어느 쪽을 선택할지 편집한 후, add → commit 순으로 해결합니다.', 6),
                                                                        ('Git에서 .gitignore 파일의 역할은 무엇인가요?', '.gitignore 파일은 Git이 추적하지 않아야 할 파일이나 디렉토리를 명시하는 설정 파일입니다. 예를 들어 로그 파일, 빌드 결과물, IDE 설정 파일 등 프로젝트 외부 요소를 무시하도록 하여 저장소를 깔끔하게 유지할 수 있습니다.', 6),
                                                                        ('fork와 clone의 차이는 무엇인가요?', 'fork는 GitHub 상에서 타인의 저장소를 자신의 GitHub 계정으로 복사하여 독립적으로 작업할 수 있도록 하는 기능이며, clone은 로컬 컴퓨터에 원격 저장소를 복제하는 명령입니다. fork는 협업 시, clone은 개발 환경 설정 시 주로 사용됩니다.', 6),
                                                                        ('pull request란 무엇이고 왜 사용하나요?', 'pull request(PR)는 다른 개발자가 작성한 브랜치를 메인 브랜치에 병합해달라고 요청하는 작업입니다. 리뷰와 토론 과정을 거쳐 품질을 보장하고 코드 일관성을 유지할 수 있으며, 팀 협업 시 필수적인 기능입니다.', 6),
                                                                        ('Git의 stash 기능은 무엇인가요?', 'stash는 현재 작업 중인 변경 사항을 임시로 저장해두고 작업 공간을 깨끗이 초기화할 수 있게 해주는 기능입니다. 예를 들어 긴급한 브랜치 변경이 필요한 경우 stash로 현재 작업을 저장하고, 브랜치 전환 후 다시 pop하여 복원할 수 있습니다.', 6),
                                                                        ('Git Hook이란 무엇인가요?', 'Git Hook은 Git의 특정 이벤트가 발생할 때 자동으로 실행되는 스크립트입니다. 예를 들어 커밋 전(pre-commit), 커밋 후(post-commit), 푸시 전(pre-push) 등 다양한 시점에 스크립트를 연결할 수 있어, 자동화된 검사, 포맷팅, 테스트 실행 등 개발 워크플로우를 자동화하는 데 활용됩니다.', 7),
                                                                        ('Husky는 무엇이며 왜 사용하나요?', 'Husky는 Git Hook을 쉽게 설정하고 관리할 수 있도록 도와주는 도구입니다. 복잡한 shell 스크립트를 작성하지 않아도, JavaScript 기반으로 pre-commit, pre-push 등 여러 훅에 간단하게 명령을 등록할 수 있어 프로젝트의 일관된 코드 품질을 유지하는 데 유용합니다.', 7),
                                                                        ('lint-staged는 무엇인가요?', 'lint-staged는 Git stage에 올라간 파일들만 대상으로 린트(lint) 또는 포맷팅 작업을 수행하는 도구입니다. pre-commit 훅과 함께 사용하면, 변경된 파일만 검사하여 성능을 높이고, 불필요한 전체 검사로 인한 시간 낭비를 줄일 수 있습니다.', 7),
                                                                        ('Husky를 설치하고 설정하는 방법은?', 'Husky는 npm 또는 yarn으로 설치한 후, `husky install` 명령어로 Git Hook을 활성화할 수 있습니다. 이후 `husky add .husky/pre-commit "npm test"`와 같이 훅을 생성하고 명령어를 등록하여 사용합니다. package.json에서 prepare 스크립트를 설정하면 설치 후 자동 초기화도 가능합니다.', 7),
                                                                        ('pre-commit 훅에서는 어떤 작업을 수행할 수 있나요?', 'pre-commit 훅에서는 커밋 직전에 실행할 작업을 설정할 수 있습니다. 대표적으로 ESLint를 통한 코드 스타일 검사, Prettier로 코드 포맷 정리, Jest 같은 테스트 도구 실행, 타입 체크 등을 통해 코드 품질을 사전에 보장할 수 있습니다.', 7),
                                                                        ('pre-push 훅은 어떤 상황에 유용한가요?', 'pre-push 훅은 커밋 내용을 원격 저장소에 푸시하기 전에 실행됩니다. 주요 사용 예로는 전체 테스트 실행, 빌드 성공 여부 확인, 배포 환경 조건 체크 등이 있으며, 품질 기준을 충족하지 못한 코드를 푸시하지 않도록 막는 데 유용합니다.', 7),
                                                                        ('lint-staged는 어떤 방식으로 작동하나요?', 'lint-staged는 Git의 staged 상태에 있는 파일 목록을 받아와, 설정된 확장자나 경로에 따라 명령어를 실행합니다. 예: `"*.ts": "eslint --fix"`와 같이 설정하면 커밋 직전 변경된 .ts 파일만 ESLint로 자동 포맷팅할 수 있습니다.', 7),
                                                                        ('Git Hook 자동화를 통해 얻는 이점은 무엇인가요?', 'Git Hook 자동화를 통해 실수나 스타일 일관성 문제를 사전에 차단할 수 있어 코드 품질을 유지할 수 있습니다. 팀 내 규칙을 코드 레벨에서 자동으로 강제할 수 있으며, 리뷰어의 반복적인 피드백을 줄여 생산성과 협업 효율을 높일 수 있습니다.', 7),
                                                                        ('Husky와 lint-staged를 함께 사용할 때의 시너지는?', 'Husky는 Git Hook 트리거를 관리하고, lint-staged는 변경된 파일만을 대상으로 린팅 및 포맷팅을 수행합니다. 이 둘을 함께 사용하면 최소한의 연산으로 최대한의 품질 검사를 할 수 있어, 커밋 속도는 빠르게 유지하면서도 코드 기준을 자동으로 적용할 수 있습니다.', 7),
                                                                        ('Git Hook 설정 시 주의할 점은 무엇인가요?', 'Git Hook은 개발자의 로컬 환경에만 적용되므로, 팀원 간 설정이 일치하지 않으면 동작이 다를 수 있습니다. 이를 방지하기 위해 Husky 설치 및 설정은 package.json과 함께 관리하고, `prepare` 스크립트를 통해 자동화해야 합니다. 또한 너무 많은 작업을 pre-commit에 몰아넣으면 개발 흐름을 방해할 수 있으므로 적절한 분배가 필요합니다.', 7),
                                                                        ('Axios란 무엇인가요?', 'Axios는 브라우저와 Node.js 환경 모두에서 사용할 수 있는 Promise 기반의 HTTP 클라이언트 라이브러리입니다. GET, POST, PUT, DELETE 등 다양한 HTTP 요청을 간편하게 보낼 수 있으며, JSON 자동 변환, 요청 및 응답 인터셉터, 요청 취소 등 다양한 기능을 제공합니다.', 8),
                                                                        ('Axios 인스턴스를 사용하는 이유는 무엇인가요?', 'Axios 인스턴스를 사용하면 baseURL, timeout, headers와 같은 공통 설정을 미리 정의하여 모든 요청에 일관되게 적용할 수 있습니다. 이를 통해 코드 중복을 줄이고 유지보수를 효율적으로 할 수 있으며, 프로젝트 규모가 커질수록 그 효과가 커집니다.', 8),
                                                                        ('Axios 인스턴스는 어떻게 생성하나요?', 'Axios 인스턴스는 axios.create() 함수를 사용하여 생성합니다. 예: const instance = axios.create({ baseURL: "/api", timeout: 5000, headers: { "Content-Type": "application/json" } }); 이 인스턴스를 통해 설정이 일관된 요청을 관리할 수 있습니다.', 8),
                                                                        ('요청 인터셉터(Request Interceptor)는 무엇이며 언제 사용하나요?', '요청 인터셉터는 요청이 서버로 전송되기 전에 실행되는 함수로, 인증 토큰 추가, 공통 헤더 삽입, 로딩 상태 관리 등의 작업에 사용됩니다. instance.interceptors.request.use(config => { ... return config; }); 형식으로 작성하며, 요청을 가로채어 수정하거나 조건을 추가할 수 있습니다.', 8),
                                                                        ('응답 인터셉터(Response Interceptor)는 무엇이며 어떤 역할을 하나요?', '응답 인터셉터는 서버로부터 응답을 받은 후 실행되는 함수로, 에러 처리, 응답 데이터 전처리, 공통 메시지 표시 등에 사용됩니다. instance.interceptors.response.use(response => { ... return response; }, error => { ... }); 형식으로 설정합니다.', 8),
                                                                        ('인터셉터에서 토큰을 자동으로 추가하는 방법은?', '요청 인터셉터에서 config.headers에 토큰을 삽입할 수 있습니다. 예: config.headers.Authorization = `Bearer ${accessToken}`; 이렇게 하면 모든 요청에 자동으로 인증 토큰이 포함되어 반복적인 코드 작성을 줄일 수 있습니다.', 8),
                                                                        ('에러 응답을 인터셉터에서 처리하는 방식은?', '응답 인터셉터에서 error 객체를 활용해 status 코드에 따라 분기 처리할 수 있습니다. 예: if (error.response.status === 401) { 리프레시 토큰 로직 } 등을 통해 전역 에러 핸들링이 가능하며, 사용자 경험 향상과 코드 일관성 유지에 도움이 됩니다.', 8),
                                                                        ('인터셉터에서 요청 취소는 어떻게 구현하나요?', 'axios.CancelToken을 사용하면 요청을 수동으로 취소할 수 있습니다. 취소 토큰을 생성하여 요청에 전달하고, 필요 시 cancel 함수를 호출하면 요청이 중단됩니다. 이는 검색 자동완성이나 중복 요청 방지 등에 활용됩니다.', 8),
                                                                        ('인터셉터 설정 시 주의해야 할 점은 무엇인가요?', '인터셉터는 전역적으로 작동하므로, 잘못된 설정이나 무한 루프를 유발할 수 있는 조건을 피해야 합니다. 응답 인터셉터에서는 반드시 error를 throw하거나 reject해야 하고, 필요 시 인터셉터 제거(clean-up) 로직도 고려해야 합니다.', 8),
                                                                        ('Axios 인스턴스를 활용한 코드 구조 분리는 어떻게 하나요?', 'API 요청 모듈을 별도의 파일로 분리하고, 인스턴스를 통해 공통 설정을 관리하면 모듈화가 쉬워집니다. 예: api.js 파일에 인스턴스를 생성하고, 개별 API 함수들을 정의한 후 export하여 전역에서 재사용할 수 있습니다. 이는 테스트, 유지보수, 확장성 측면에서 유리합니다.', 8),
                                                                        ('REST API에서 에러 처리를 왜 해야 하나요?', '에러 처리는 API 통신 중 발생할 수 있는 네트워크 오류, 서버 오류, 클라이언트 요청 오류 등을 사용자에게 명확히 전달하고, 안정적인 사용자 경험을 보장하기 위해 필요합니다. 에러를 무시하면 사용자 혼란, 데이터 손실, 보안 문제로 이어질 수 있으므로, 체계적인 예외 대응 로직이 중요합니다.', 9),
                                                                        ('HTTP 상태 코드로 에러를 구분하는 방법은?', 'HTTP 상태 코드는 4xx(클라이언트 오류), 5xx(서버 오류) 등으로 구분됩니다. 예를 들어 400은 잘못된 요청, 401은 인증 실패, 403은 권한 없음, 404는 리소스 없음, 500은 서버 내부 오류입니다. 이 코드를 기준으로 사용자 메시지 출력, 재시도 여부 등을 결정할 수 있습니다.', 9),
                                                                        ('Axios에서 에러 응답은 어떻게 처리하나요?', 'Axios는 실패한 요청에 대해 catch 블록에서 error 객체를 제공합니다. error.response.status를 통해 HTTP 상태 코드를 확인하고, 조건에 따라 사용자 알림, 재시도, 리디렉션 등의 로직을 구현할 수 있습니다. 응답 인터셉터를 활용하면 전역적으로 처리 가능합니다.', 9),
                                                                        ('401 에러가 발생했을 때 어떻게 대응해야 하나요?', '401 Unauthorized는 인증이 만료되었거나 유효하지 않음을 의미합니다. 이 경우 토큰이 만료된 상황이라면 리프레시 토큰을 사용하여 재발급 요청을 시도하고, 실패 시 자동 로그아웃 처리 및 로그인 페이지로 리디렉션하는 방식으로 대응할 수 있습니다.', 9),
                                                                        ('에러 메시지를 사용자에게 어떻게 전달하는 것이 좋나요?', '사용자에게는 기술적인 오류 메시지보다는 상황에 맞는 친절하고 명확한 메시지를 전달하는 것이 좋습니다. 예를 들어 "서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요."처럼 안내하고, 필요시 재시도 버튼이나 고객센터 링크를 함께 제공하면 좋습니다.', 9),
                                                                        ('Axios에서 재시도 로직은 어떻게 구현하나요?', 'Axios 재시도는 재귀 호출이나 재시도용 라이브러리(예: axios-retry)를 활용하여 구현할 수 있습니다. 일정 횟수까지 실패 시 다시 요청하고, 실패 횟수가 초과되면 사용자에게 알림을 주는 방식으로 구성합니다. 네트워크 오류나 5xx 오류에서 주로 사용됩니다.', 9),
                                                                        ('지수 백오프(Exponential Backoff)란 무엇인가요?', '지수 백오프는 재시도 간 시간 간격을 점점 증가시키는 방식입니다. 예를 들어 1초 → 2초 → 4초 식으로 딜레이를 주며 재요청하여 서버 부하를 줄이고, 일시적인 문제 해결 가능성을 높입니다. 주로 API 호출 실패 재시도에 사용됩니다.', 9),
                                                                        ('재시도 로직에서 주의할 점은 무엇인가요?', '무한 루프 방지와 과도한 요청으로 인한 서버 부하를 피하기 위해 재시도 횟수 제한과 딜레이 설정이 필수입니다. 또한 재시도 대상 오류를 선별적으로 지정해야 하며, 클라이언트 오류(예: 400 Bad Request)는 재시도 대상에서 제외하는 것이 좋습니다.', 9),
                                                                        ('전역 에러 핸들링을 구현하는 방법은?', 'Axios의 응답 인터셉터를 통해 모든 API 응답에 대해 공통 에러 처리를 구현할 수 있습니다. 예를 들어 401 처리 시 자동 로그아웃, 500 처리 시 공통 에러 페이지로 리디렉션 등 일관된 처리 로직을 설정하여 코드 중복을 줄이고 유지보수를 효율화할 수 있습니다.', 9),
                                                                        ('REST API 에러 처리와 재시도가 사용자 경험에 미치는 영향은?', '적절한 에러 처리와 재시도는 사용자에게 안정적이고 신뢰할 수 있는 서비스를 제공하며, 오류 상황에서도 사용자의 이탈을 줄일 수 있습니다. 반면 에러에 대한 피드백이 없거나 예기치 않은 동작이 발생하면 사용자는 혼란을 느끼고 서비스 신뢰도가 낮아질 수 있습니다.', 9),
                                                                        ('React란 무엇인가요?', 'React는 Facebook에서 개발한 JavaScript 기반의 UI 라이브러리로, 사용자 인터페이스를 빠르고 효율적으로 구성할 수 있도록 도와줍니다. React는 컴포넌트 기반 아키텍처를 사용하여 화면을 재사용 가능한 단위로 분리하고, 상태(state) 변화에 따라 필요한 부분만 다시 렌더링하여 성능을 최적화합니다.', 10),
                                                                        ('React의 컴포넌트란 무엇인가요?', '컴포넌트는 UI를 구성하는 독립적이고 재사용 가능한 코드 블록입니다. React에서는 함수형 또는 클래스형 컴포넌트로 작성할 수 있으며, 각 컴포넌트는 props(속성)를 통해 데이터를 받아 출력하고, 상태를 가질 수 있습니다. 이를 통해 복잡한 UI를 작은 단위로 관리할 수 있습니다.', 10),
                                                                        ('JSX란 무엇이며 어떻게 작동하나요?', 'JSX는 JavaScript XML의 약자로, JavaScript 코드 안에서 HTML 태그를 작성할 수 있는 문법입니다. 브라우저가 직접 이해할 수는 없지만 Babel 같은 트랜스파일러가 JSX를 React.createElement() 형태로 변환하여 실행됩니다. 이를 통해 UI를 선언적으로 작성할 수 있습니다.', 10),
                                                                        ('React에서 상태(state)란 무엇인가요?', '상태는 컴포넌트 내부에서 관리되는 동적인 데이터입니다. useState 훅을 사용하여 함수형 컴포넌트에서 상태를 선언하고 변경할 수 있습니다. 상태가 변경되면 해당 컴포넌트는 자동으로 다시 렌더링되어 최신 상태를 반영합니다.', 10),
                                                                        ('props와 state의 차이는 무엇인가요?', 'props는 부모 컴포넌트로부터 자식 컴포넌트에게 전달되는 읽기 전용 데이터이며, 컴포넌트 외부에서 관리됩니다. 반면 state는 컴포넌트 내부에서 선언되고 변경할 수 있는 데이터입니다. props는 전달, state는 컴포넌트의 내부 상태 관리에 사용됩니다.', 10),
                                                                        ('useEffect 훅은 어떤 역할을 하나요?', 'useEffect는 컴포넌트가 렌더링된 후 특정 작업을 수행하기 위한 React 훅입니다. 예를 들어 API 호출, 구독 설정, 타이머 등록 등의 부수 효과(side effect)를 처리하는 데 사용됩니다. 의존성 배열을 통해 언제 실행할지를 제어할 수 있습니다.', 10),
                                                                        ('key props의 역할은 무엇인가요?', 'React에서 key는 리스트 렌더링 시 각 요소를 고유하게 식별하기 위한 속성입니다. key를 설정하면 React가 요소 간의 변경을 정확히 추적할 수 있어 성능 최적화에 도움이 됩니다. key는 유일해야 하며, 일반적으로 고유 ID를 사용하는 것이 좋습니다.', 10),
                                                                        ('Virtual DOM이란 무엇이고 어떻게 작동하나요?', 'Virtual DOM은 메모리 상의 가상 DOM 객체로, 실제 DOM 조작보다 훨씬 가볍고 빠르게 동작합니다. 상태나 props가 변경되면 새로운 Virtual DOM이 생성되고, 이전과 비교(diff)하여 변경된 부분만 실제 DOM에 반영(patch)됩니다.', 10),
                                                                        ('React에서 조건부 렌더링은 어떻게 구현하나요?', '조건부 렌더링은 JavaScript의 조건문(삼항 연산자, && 연산자 등)을 이용하여 특정 조건에 따라 다른 UI를 렌더링하는 방식입니다. 예를 들어 isLoggedIn ? <LogoutButton /> : <LoginButton />와 같은 방식으로 구현할 수 있습니다.', 10),
                                                                        ('React의 성능 최적화 방법에는 어떤 것이 있나요?', 'React에서 성능을 최적화하기 위해 React.memo, useMemo, useCallback 등의 훅을 사용하여 불필요한 렌더링을 방지할 수 있습니다. 또한 key 설정, 코드 스플리팅, lazy loading, Virtualization 등을 통해 렌더링 효율을 높일 수 있습니다.', 10),
                                                                        ('Redux란 무엇인가요?', 'Redux는 JavaScript 애플리케이션에서 상태(state)를 예측 가능하게 관리하기 위한 상태 관리 라이브러리입니다. 모든 상태를 하나의 전역 저장소(store)에서 관리하며, 상태 변경은 반드시 순수 함수인 reducer를 통해 일어나도록 강제하여 애플리케이션의 흐름을 명확히 합니다.', 11),
                                                                        ('Redux를 사용하는 이유는 무엇인가요?', '컴포넌트 간 공유되는 상태가 많아지면 prop drilling이나 상태 중복 문제가 발생할 수 있습니다. Redux는 중앙 집중형 상태 관리 방식으로 이러한 문제를 해결하며, 상태 변경 흐름이 명확하고 일관되게 관리되어 대규모 애플리케이션에서 유지보수가 용이합니다.', 11),
                                                                        ('Redux의 주요 구성 요소는 무엇인가요?', 'Redux는 세 가지 핵심 요소인 store(상태 저장소), action(상태 변경 요청), reducer(상태 변경 함수)로 구성됩니다. 사용자는 action을 dispatch하고, reducer는 이를 기반으로 새로운 상태를 계산해 store를 갱신합니다.', 11),
                                                                        ('store는 무엇이고 어떻게 생성하나요?', 'store는 애플리케이션의 상태를 저장하는 객체이며, createStore(reducer) 또는 @reduxjs/toolkit의 configureStore() 함수를 통해 생성됩니다. store는 상태를 조회(getState), 액션을 전송(dispatch), 상태 변경 구독(subscribe) 기능을 제공합니다.', 11),
                                                                        ('reducer란 무엇인가요?', 'reducer는 순수 함수로, 이전 상태(state)와 action 객체를 입력받아 새로운 상태를 반환합니다. 상태 변경 로직은 반드시 reducer 내부에서만 수행되며, 불변성을 유지해야 하므로 상태 복사 및 새로운 객체 생성을 통해 처리해야 합니다.', 11),
                                                                        ('dispatch는 어떤 역할을 하나요?', 'dispatch는 action 객체를 store에 전달하는 함수로, 해당 action에 따라 reducer가 실행되어 상태를 변경합니다. 모든 상태 변화는 dispatch를 통해 일어나며, 이는 Redux의 단방향 데이터 흐름을 유지하게 합니다.', 11),
                                                                        ('Redux에서 middleware는 어떤 역할을 하나요?', 'middleware는 action이 reducer에 도달하기 전에 가로채어 비동기 로직, 로깅, 에러 처리 등을 수행할 수 있는 중간 처리 계층입니다. 예: redux-thunk는 함수 형태의 action을 dispatch할 수 있게 하여 비동기 처리를 가능하게 합니다.', 11),
                                                                        ('redux-thunk와 redux-saga의 차이는 무엇인가요?', 'redux-thunk는 action creator에서 함수를 반환할 수 있게 하여 간단한 비동기 처리를 지원합니다. 반면 redux-saga는 generator 기반의 이펙트 모델을 사용하여 더 복잡한 비동기 흐름(예: 병렬, 레이스 조건 등)을 제어할 수 있습니다.', 11),
                                                                        ('Redux Toolkit이란 무엇인가요?', 'Redux Toolkit은 Redux의 공식 유지관리 도구로, store 설정, reducer 생성, action 관리 등의 반복 코드를 간소화합니다. createSlice, configureStore 등 직관적인 API를 제공하며, Redux 사용 시 권장되는 표준 방식입니다.', 11),
                                                                        ('Redux 상태 구조를 설계할 때 주의할 점은?', 'Redux 상태는 normalize된 구조를 갖는 것이 바람직합니다. 중첩된 구조보다는 평탄화(flatten)된 형태로 관리하며, 불변성을 유지하고 slice 단위로 명확하게 나누는 것이 유지보수와 성능 측면에서 유리합니다.', 11),
                                                                        ('Zustand란 무엇인가요?', 'Zustand는 React 애플리케이션에서 전역 상태 관리를 단순하고 가볍게 구현할 수 있도록 설계된 상태 관리 라이브러리입니다. Redux보다 설정이 간단하고 보일러플레이트가 적으며, useStore라는 단일 훅으로 상태를 쉽게 생성하고 사용할 수 있습니다.', 12),
                                                                        ('Zustand의 주요 특징은 무엇인가요?', 'Zustand는 상태의 선언과 사용이 모두 훅 기반으로 이루어지며, Redux처럼 reducer나 action type이 필요하지 않습니다. 불필요한 리렌더링을 방지하기 위해 상태 구독이 선택적으로 동작하고, 미들웨어 없이도 간단한 로직으로 전역 상태를 관리할 수 있습니다.', 12),
                                                                        ('Zustand 스토어는 어떻게 생성하나요?', 'Zustand 스토어는 create 함수를 통해 생성합니다. 예: const useStore = create((set) => ({ count: 0, increment: () => set((state) => ({ count: state.count + 1 })) })); 이렇게 생성한 훅을 컴포넌트에서 useStore((state) => state.count) 형태로 호출하여 사용할 수 있습니다.', 12),
                                                                        ('Zustand에서 상태를 업데이트하는 방법은?', 'Zustand에서는 set 함수를 통해 상태를 직접 업데이트합니다. 상태는 함수형 업데이트 방식으로 이전 상태를 받아 새로운 상태를 반환하는 구조를 갖습니다. 이는 React의 setState와 유사하며, 명확하고 직관적인 상태 변경 로직을 구성할 수 있습니다.', 12),
                                                                        ('Zustand에서 상태를 구독하는 방법은?', 'useStore((state) => state.property) 형식으로 특정 상태만 선택적으로 구독할 수 있습니다. 이를 통해 관련 없는 상태 변경에 따른 불필요한 리렌더링을 방지할 수 있어 성능 최적화가 가능합니다.', 12),
                                                                        ('Zustand와 Redux의 차이점은?', 'Redux는 액션, 리듀서, 미들웨어 등 복잡한 구조를 갖지만, Zustand는 훅 기반으로 간결한 상태 관리를 제공합니다. 보일러플레이트 코드가 거의 없고, 직관적인 API로 상태 선언과 갱신이 가능하여 소규모 또는 중간 규모 프로젝트에 특히 적합합니다.', 12),
                                                                        ('Zustand에서 상태를 유지하려면 어떻게 하나요?', 'zustand/middleware 모듈의 persist 미들웨어를 사용하면 로컬 스토리지에 상태를 저장하고, 애플리케이션 재시작 시에도 상태를 유지할 수 있습니다. 예: persist((set) => ({}), { name: "store-name" }) 형식으로 설정합니다.', 12),
                                                                        ('Zustand에서 미들웨어는 어떻게 활용하나요?', 'Zustand는 로깅(log), 상태 저장(persist), 개발자 도구(devtools) 등을 미들웨어 형태로 지원합니다. 이들은 create 함수에 체이닝하여 적용하며, 기능 확장이나 상태 추적 등을 쉽게 구현할 수 있습니다.', 12),
                                                                        ('Zustand는 어떤 경우에 사용하는 것이 좋나요?', 'Zustand는 상태 공유가 필요하지만 상태 구조가 복잡하지 않은 프로젝트에 적합합니다. 예를 들어 로그인 상태, 다크모드 설정, 필터 상태처럼 간단하고 자주 사용되는 전역 상태를 빠르게 구성하고 싶을 때 유용합니다.', 12),
                                                                        ('Zustand의 성능 최적화 방식은 무엇인가요?', 'Zustand는 상태 구독 시 선택적 선택(selector) 기능을 제공하여 필요한 상태만 구독하게 합니다. 또한 shallow 비교와 memoization을 통해 불필요한 리렌더링을 줄일 수 있으며, React 18의 자동 배치와도 잘 통합됩니다.', 12),
                                                                        ('Vue란 무엇인가요?', 'Vue는 사용자 인터페이스(UI)를 만들기 위한 프로그레시브 프레임워크로, 컴포넌트 기반 구조를 사용하여 재사용 가능한 UI 구성 요소를 만들 수 있습니다. HTML, CSS, JavaScript를 조합하여 직관적으로 선언적 렌더링과 양방향 데이터 바인딩을 구현할 수 있습니다.', 13),
                                                                        ('Vue의 주요 특징은 무엇인가요?', 'Vue는 가볍고 학습 곡선이 낮으며, 반응형 데이터 바인딩, 컴포넌트 기반 아키텍처, 가상 DOM, 디렉티브, Vue CLI, Vuex 등의 기능을 통해 개발자가 빠르게 애플리케이션을 구축하고 유지보수할 수 있도록 돕습니다.', 13),
                                                                        ('Vue의 양방향 바인딩은 어떻게 작동하나요?', 'Vue는 v-model 디렉티브를 통해 양방향 데이터 바인딩을 지원합니다. 이는 사용자 입력과 데이터 상태를 실시간으로 동기화하며, input 요소의 값이 변경되면 data 속성도 함께 변경되고, 그 반대도 자동으로 반영됩니다.', 13),
                                                                        ('Vue의 컴포넌트 시스템이란?', 'Vue의 컴포넌트는 독립적이고 재사용 가능한 UI 단위입니다. 각 컴포넌트는 template, script, style 영역을 갖는 단일 파일 컴포넌트(SFC)로 구성되며, 부모-자식 간 props 전달과 이벤트 emit을 통해 데이터와 동작을 분리하여 구조화된 개발이 가능합니다.', 13),
                                                                        ('Vue의 라이프사이클 훅에는 어떤 것들이 있나요?', 'Vue 컴포넌트는 생성, 마운트, 업데이트, 소멸의 생명주기 동안 다양한 훅을 제공합니다. 대표적으로 created, mounted, updated, destroyed 등이 있으며, 이 훅들을 통해 비동기 요청, DOM 접근, 이벤트 등록 등 타이밍에 맞는 작업을 수행할 수 있습니다.', 13),
                                                                        ('Vue에서 디렉티브(Directives)란 무엇인가요?', '디렉티브는 HTML 요소에 Vue의 반응형 동작을 부여하는 특별한 속성입니다. 예를 들어 v-if, v-for, v-bind, v-on, v-model 등은 DOM 요소의 렌더링 제어, 반복, 속성 바인딩, 이벤트 처리, 양방향 바인딩에 사용됩니다.', 13),
                                                                        ('Vue의 computed와 methods의 차이는?', 'computed는 종속된 반응형 데이터가 변경될 때만 다시 계산되며, 결과를 캐싱하여 성능을 최적화합니다. 반면 methods는 호출될 때마다 실행되며, 계산 결과를 저장하지 않습니다. 주로 렌더링에 관련된 계산은 computed, 이벤트 핸들링은 methods를 사용합니다.', 13),
                                                                        ('Vue에서 props란 무엇인가요?', 'props는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 방법입니다. 자식 컴포넌트는 props 옵션을 통해 전달받을 값을 정의하며, 이는 읽기 전용으로 취급되어야 하며 내부에서 직접 변경해서는 안 됩니다.', 13),
                                                                        ('Vue에서 이벤트 전달은 어떻게 하나요?', '자식 컴포넌트는 $emit을 통해 커스텀 이벤트를 발생시키고, 부모 컴포넌트는 해당 이벤트를 v-on 또는 @을 사용해 청취할 수 있습니다. 이를 통해 자식 → 부모 방향으로 사용자 상호작용 결과를 전달할 수 있습니다.', 13),
                                                                        ('Vue에서 상태 관리를 위한 Vuex는 무엇인가요?', 'Vuex는 Vue 애플리케이션의 상태를 중앙 집중식으로 관리하기 위한 상태 관리 패턴 및 라이브러리입니다. 상태(state), 변이(mutations), 행동(actions), 게터(getters)로 구성되며, 대규모 앱에서 컴포넌트 간 상태 공유 및 추적이 용이합니다.', 13),
                                                                        ('Vuex란 무엇인가요?', 'Vuex는 Vue.js 애플리케이션을 위한 상태 관리 라이브러리로, 중앙 집중형 저장소(store)를 통해 컴포넌트 간 상태를 일관되게 관리할 수 있게 해줍니다. 상태(state), 변이(mutations), 동작(actions), 게터(getters) 등의 개념을 통해 상태 흐름을 명확히 하고 예측 가능한 상태 변경을 구현합니다.', 14),
                                                                        ('Pinia란 무엇인가요?', 'Pinia는 Vuex의 공식적인 차세대 대체 도구로, Vue 3에서 기본 상태 관리 도구로 권장됩니다. Composition API를 기반으로 하며, 더 간결하고 타입 안전한 API를 제공하고, setup() 함수 내에서 자연스럽게 사용할 수 있습니다.', 14),
                                                                        ('Vuex와 Pinia의 주요 차이점은?', 'Vuex는 옵션 API 기반으로 복잡한 구조(store, mutations, actions 등)를 따르지만, Pinia는 Composition API에 최적화되어 훨씬 간단하고 직관적인 방식으로 상태를 정의하고 사용할 수 있습니다. 또한 Pinia는 TypeScript 지원이 뛰어나며 개발자 경험을 개선한 문법을 제공합니다.', 14),
                                                                        ('Vuex의 상태(state)는 어떻게 정의되고 접근하나요?', 'Vuex에서는 store 객체 내에 state를 정의하며, 컴포넌트에서는 mapState 헬퍼나 this.$store.state를 통해 접근합니다. state는 중앙에서 관리되므로 컴포넌트 간의 데이터 공유가 용이합니다.', 14),
                                                                        ('Vuex에서 mutations와 actions의 차이는?', 'mutations는 동기적인 방식으로 state를 직접 변경하는 함수이고, actions는 비동기 작업을 처리한 후 mutation을 호출하는 함수입니다. 예를 들어 API 호출은 action에서 수행하고, 응답을 받은 후 mutation을 통해 상태를 갱신합니다.', 14),
                                                                        ('Pinia에서 상태 관리는 어떻게 하나요?', 'Pinia는 defineStore를 사용하여 상태 저장소를 정의합니다. 예: defineStore("useUserStore", { state: () => ({ name: "", isLoggedIn: false }) }) 와 같이 선언하고, setup() 내에서 useUserStore()로 호출하여 상태를 직접 읽고 수정할 수 있습니다.', 14),
                                                                        ('Pinia의 getters는 어떤 역할을 하나요?', 'Pinia의 getters는 상태를 기반으로 파생된 값을 계산할 때 사용됩니다. 이는 computed 속성처럼 동작하며, store 내부에서 선언된 함수로 구성되어 효율적이고 재사용 가능한 상태 계산을 가능하게 합니다.', 14),
                                                                        ('Vue 애플리케이션에서 전역 상태 관리가 필요한 이유는?', '복잡한 Vue 애플리케이션에서는 여러 컴포넌트에서 동일한 데이터를 사용하거나 상태를 공유할 필요가 많습니다. 전역 상태 관리를 통해 이러한 데이터를 중앙 집중식으로 관리하면 데이터 흐름이 명확해지고 유지보수성이 높아집니다.', 14),
                                                                        ('Vuex나 Pinia에서 상태를 영구 저장하려면 어떻게 하나요?', 'Vuex는 vuex-persistedstate, Pinia는 @pinia/plugin-persistedstate 플러그인을 사용하여 로컬 스토리지 또는 세션 스토리지에 상태를 저장할 수 있습니다. 이를 통해 새로고침 시에도 상태가 유지되도록 설정할 수 있습니다.', 14),
                                                                        ('Pinia의 장점은 무엇이고 언제 사용하는 것이 좋은가요?', 'Pinia는 간결한 문법, 강력한 타입 지원, Composition API와의 높은 호환성, 직관적인 디버깅 경험 등을 제공하여 Vue 3 기반 프로젝트에 특히 적합합니다. 복잡한 로직 없이 빠르게 상태 관리를 구현하고자 할 때 Pinia는 매우 효율적인 선택입니다.', 14),
                                                                        ('Angular란 무엇인가요?', 'Angular는 Google에서 개발한 TypeScript 기반의 프론트엔드 프레임워크로, 컴포넌트 기반 구조와 모듈화, 강력한 DI(의존성 주입), 라우팅, 폼 처리, HTTP 통신 등 웹 애플리케이션 구축에 필요한 기능을 모두 포함하고 있는 풀스택 프레임워크입니다.', 15),
                                                                        ('Angular의 컴포넌트란 무엇인가요?', 'Angular에서 컴포넌트는 UI를 구성하는 기본 단위로, HTML 템플릿, CSS 스타일, TypeScript 클래스(로직)로 구성됩니다. @Component 데코레이터를 통해 메타데이터를 정의하며, 각각 독립적으로 동작하여 재사용성과 테스트 용이성을 높입니다.', 15),
                                                                        ('Angular에서 모듈(Module)의 역할은 무엇인가요?', '모듈은 관련된 컴포넌트, 디렉티브, 파이프, 서비스 등을 그룹화하여 응집력 있는 기능 단위로 관리합니다. @NgModule 데코레이터를 통해 정의되며, 루트 모듈(AppModule)부터 시작하여 기능별로 Feature Module을 나눠 구조화할 수 있습니다.', 15),
                                                                        ('Angular의 의존성 주입(Dependency Injection)이란?', 'Angular의 DI는 컴포넌트나 서비스가 필요로 하는 의존 객체를 생성자 주입을 통해 자동으로 주입해주는 메커니즘입니다. 이를 통해 코드의 결합도를 낮추고, 테스트와 재사용성을 높일 수 있으며, 제공자(provider) 설정을 통해 범위를 제어할 수 있습니다.', 15),
                                                                        ('라우팅(Routing)은 어떻게 구성되나요?', 'Angular 라우팅은 @angular/router 모듈을 사용하여 URL 경로와 컴포넌트를 매핑합니다. RouterModule.forRoot(routes) 형식으로 루트 라우팅 설정을 하고, <router-outlet>을 통해 컴포넌트를 동적으로 렌더링합니다. 라우트 가드, 중첩 라우트, lazy loading도 지원됩니다.', 15),
                                                                        ('양방향 바인딩은 어떻게 구현되나요?', 'Angular는 [(ngModel)] 디렉티브를 통해 양방향 바인딩을 제공합니다. 이는 폼 요소의 값과 컴포넌트의 변수 간 값을 자동으로 동기화시켜 사용자 입력에 즉각 반응하는 인터페이스를 쉽게 구현할 수 있습니다.', 15),
                                                                        ('Reactive Forms와 Template-driven Forms의 차이는?', 'Template-driven Forms는 템플릿에 중심을 둔 폼 작성 방식으로 간단한 폼 구현에 적합하며, ngModel을 활용합니다. 반면 Reactive Forms는 TypeScript 코드 중심으로 FormControl, FormGroup 등을 사용하여 폼 상태를 명시적으로 제어하며 복잡한 폼에 적합합니다.', 15),
                                                                        ('서비스(Service)는 언제 사용하나요?', '서비스는 비즈니스 로직, 공통 기능, HTTP 요청 등을 컴포넌트와 분리하여 관리할 때 사용합니다. Angular에서는 @Injectable 데코레이터로 정의되며, DI를 통해 컴포넌트나 다른 서비스에 주입됩니다. 상태 공유, API 호출 등의 목적으로 자주 사용됩니다.', 15),
                                                                        ('Angular에서 HTTP 요청은 어떻게 처리하나요?', 'Angular는 @angular/common/http 모듈의 HttpClient를 통해 REST API와 통신할 수 있습니다. GET, POST, PUT, DELETE 등의 메서드를 제공하며, Observable 기반으로 동작하여 RxJS 연산자와 함께 비동기 흐름을 효과적으로 처리할 수 있습니다.', 15),
                                                                        ('Angular의 장점은 무엇인가요?', 'Angular는 대규모 애플리케이션 개발에 최적화된 구조적 프레임워크로, 강력한 타입 지원(TypeScript), DI, 모듈화, 성능 최적화, 테스트 용이성, 툴링(Angular CLI), 일관된 개발 패턴 등으로 생산성과 유지보수성을 크게 향상시킵니다.', 15),
                                                                        ('NgRx란 무엇인가요?', 'NgRx는 Angular 애플리케이션에서 상태 관리를 위한 라이브러리로, Redux 아키텍처 패턴을 기반으로 구성됩니다. 액션, 리듀서, 스토어, 이펙트 등의 개념을 통해 상태 변경 흐름을 예측 가능하게 만들며, 대규모 애플리케이션에서도 일관된 상태 관리를 가능하게 합니다.', 16),
                                                                        ('NgRx의 주요 구성 요소에는 무엇이 있나요?', 'NgRx는 store(전역 상태 저장소), actions(이벤트 정의), reducers(상태 변경 함수), selectors(상태 조회 함수), effects(비동기 처리 로직) 등의 핵심 구성 요소로 이루어져 있습니다. 이들을 통해 상태 생성부터 변경, 조회, 비동기 로직까지 전 과정을 체계화할 수 있습니다.', 16),
                                                                        ('NgRx의 Store란 무엇인가요?', 'Store는 애플리케이션의 전역 상태를 보관하는 저장소 역할을 하며, 상태는 불변성을 유지하고 단방향 데이터 흐름을 따릅니다. 상태를 직접 수정하는 대신 action을 dispatch하고, reducer가 이를 받아 새로운 상태를 생성하여 Store에 반영합니다.', 16),
                                                                        ('NgRx의 Action은 어떤 역할을 하나요?', 'Action은 상태에 변화를 일으키는 트리거로, type 속성과 필요한 payload를 포함합니다. 예를 들어 `[User] Load Profile`과 같은 액션은 특정 목적의 상태 변경을 명시적으로 표현하며, reducer와 effect에서 이 액션을 기준으로 로직이 수행됩니다.', 16),
                                                                        ('NgRx에서 Reducer란 무엇인가요?', 'Reducer는 액션에 따라 상태를 어떻게 변경할지를 정의하는 순수 함수입니다. 이전 상태와 action을 인자로 받아 새로운 상태를 반환하며, 상태 변경은 불변성을 유지해야 합니다. 이는 상태 변경의 예측 가능성과 디버깅 편의성을 보장합니다.', 16),
                                                                        ('NgRx의 Selector는 무엇이며 왜 사용하나요?', 'Selector는 Store의 상태에서 필요한 데이터를 효율적으로 추출하는 함수입니다. memoization 기능을 통해 동일한 입력에 대해 캐시된 결과를 반환함으로써 성능을 최적화하며, 컴포넌트에서 직접 store를 탐색하지 않고 필요한 데이터를 안전하게 접근할 수 있게 해줍니다.', 16),
                                                                        ('NgRx Effects는 무엇이고 어떤 문제를 해결하나요?', 'Effects는 액션 기반의 비동기 작업(API 호출, 사이드 이펙트 등)을 처리하기 위한 NgRx 구성 요소입니다. @Effect 데코레이터를 사용하거나 createEffect 함수를 통해 정의하며, 액션 스트림을 관찰하고 새로운 액션을 dispatch함으로써 상태 변경 흐름을 외부 처리와 분리할 수 있습니다.', 16),
                                                                        ('NgRx에서 상태는 어떻게 불변성을 유지하나요?', 'NgRx에서는 상태를 직접 수정하지 않고, reducer에서 객체 전개 연산자(...) 또는 immer 같은 라이브러리를 사용하여 기존 상태를 복사한 후 변경된 값을 반영한 새로운 상태 객체를 반환합니다. 이를 통해 상태 변경의 추적성과 예측 가능성을 유지합니다.', 16),
                                                                        ('NgRx의 장점은 무엇인가요?', 'NgRx는 상태 변경 흐름을 액션 중심으로 구조화하여 예측 가능하고 디버깅이 쉬운 상태 관리를 제공합니다. 특히 대규모 앱에서 상태 분산 문제를 해결하고, devtools를 통한 시간 여행 디버깅, 이펙트를 통한 비동기 분리 등 고급 기능으로 생산성과 유지보수성을 높입니다.', 16),
                                                                        ('NgRx를 도입할 때 주의할 점은?', 'NgRx는 구조가 명확하고 강력하지만 초기 설정과 학습 비용이 존재하며, 작은 프로젝트에서는 오히려 복잡도를 증가시킬 수 있습니다. 따라서 상태가 복잡하거나 다수의 컴포넌트 간 상태 공유가 필요한 중대형 프로젝트에 적합하며, 필요에 따라 모듈화와 코드 분리를 잘 설계해야 합니다.', 16),
                                                                        ('Storybook이란 무엇인가요?', 'Storybook은 UI 컴포넌트를 독립적으로 개발, 테스트, 문서화할 수 있는 오픈소스 툴로, 컴포넌트 기반 개발을 보다 체계적이고 효율적으로 만들어줍니다. 실제 애플리케이션과 분리된 환경에서 컴포넌트를 시각적으로 확인하고 다양한 상태를 시뮬레이션할 수 있습니다.', 17),
                                                                        ('Storybook을 사용하는 이유는 무엇인가요?', 'Storybook은 컴포넌트를 개별적으로 확인하고 문서화함으로써 UI 품질을 높이고, 개발자·디자이너·QA 간 협업을 효율적으로 만듭니다. 또한 디자인 시스템을 기반으로 한 재사용성과 일관된 UI 개발이 가능하며, 빠른 피드백과 테스트 자동화에도 유리합니다.', 17),
                                                                        ('Storybook의 구성 요소에는 무엇이 있나요?', 'Storybook은 stories, addons, controls, docs 등으로 구성됩니다. stories는 각 컴포넌트의 상태를 정의한 시나리오이며, addons은 접근성 검사, 디자인 비교, 상호작용 기록 등 다양한 확장 기능을 제공합니다.', 17),
                                                                        ('스토리(Story)는 어떻게 작성하나요?', '스토리는 특정 컴포넌트의 사용 예시를 정의한 객체 또는 함수입니다. 기본적으로 `export default`로 메타 정보를 제공하고, 각 상태는 `export const Primary = () => <Component ... />` 형식으로 작성됩니다. 최근에는 Component Story Format(CSF)을 표준으로 사용합니다.', 17),
                                                                        ('Storybook에서 Controls 기능은 어떤 역할을 하나요?', 'Controls는 Storybook UI에서 컴포넌트 props를 실시간으로 조작할 수 있게 해주는 기능입니다. 이를 통해 다양한 입력 값을 즉석에서 테스트하며 컴포넌트의 동작을 시각적으로 확인할 수 있고, 사용 예시를 더 직관적으로 전달할 수 있습니다.', 17),
                                                                        ('Storybook에서 Docs는 어떻게 활용되나요?', 'Docs는 Storybook에 자동으로 생성되는 문서 페이지로, 컴포넌트의 props, 기본 예시, 설명 등을 정리해줍니다. Markdown 또는 JSDoc을 활용해 사용자 정의 설명도 추가할 수 있으며, 팀 내 디자인 시스템 구축 시 문서화 도구로 활용됩니다.', 17),
                                                                        ('Storybook의 Addons는 어떤 것이 있나요?', '대표적인 Addons로는 `@storybook/addon-essentials`, `addon-a11y`(접근성 검사), `addon-actions`(이벤트 기록), `addon-backgrounds`(배경 설정), `addon-viewport`(디바이스 뷰 테스트) 등이 있으며, 개발 및 디자인 품질 향상에 도움을 줍니다.', 17),
                                                                        ('Storybook을 CI/CD 파이프라인에 통합할 수 있나요?', 'Storybook은 정적 웹사이트로 빌드될 수 있어, CI/CD 환경에서 `build-storybook` 명령어로 문서화를 자동화하고, GitHub Pages, Netlify, Vercel 등의 플랫폼에 배포할 수 있습니다. 이를 통해 디자인 시스템을 외부와 공유하고 버전 관리할 수 있습니다.', 17),
                                                                        ('Storybook에서 상호작용 테스트는 어떻게 구현하나요?', 'Storybook에서는 play 함수와 Testing Library를 이용해 컴포넌트 내 상호작용(예: 클릭, 입력)을 테스트할 수 있습니다. 이를 통해 단순 렌더링을 넘어서 실제 사용자 시나리오 기반의 동작 검증을 시각적으로 실행할 수 있습니다.', 17),
                                                                        ('Storybook이 팀 개발에 어떤 기여를 하나요?', 'Storybook은 컴포넌트를 문서화하고 시각화함으로써 프론트엔드, 디자이너, 기획자 간의 커뮤니케이션을 명확하게 해줍니다. 개발자는 독립된 컴포넌트 개발이 가능하고, 디자이너는 상태별 UI를 확인하며, QA는 사양 기반 테스트를 할 수 있어 협업 효율이 증가합니다.', 17),
                                                                        ('Tailwind CSS란 무엇인가요?', 'Tailwind CSS는 유틸리티 클래스 기반의 CSS 프레임워크로, HTML 클래스 속성에 미리 정의된 스타일 클래스를 조합하여 빠르게 UI를 구성할 수 있게 해줍니다. 별도의 CSS 파일을 작성하지 않아도 스타일링이 가능하며, 구성 요소마다 독립적으로 스타일을 적용할 수 있어 유지보수성과 확장성이 뛰어납니다.', 18),
                                                                        ('Tailwind CSS의 장점은 무엇인가요?', 'Tailwind CSS는 개발 속도가 빠르고, 일관된 디자인 시스템을 구축할 수 있으며, 불필요한 CSS 코드가 줄어드는 점이 큰 장점입니다. 또한 JIT(Just-in-Time) 모드를 사용하면 실제 사용하는 클래스만 빌드되어 번들 사이즈도 최소화됩니다.', 18),
                                                                        ('Tailwind CSS의 단점은 무엇인가요?', '클래스명이 길어져 HTML이 복잡해질 수 있으며, 스타일이 마크업에 직접 들어가기 때문에 컴포넌트와 스타일이 완전히 분리되지 않습니다. 또한 디자이너와 협업 시 커스텀 디자인 시스템에 적응하는 시간이 필요할 수 있습니다.', 18),
                                                                        ('Tailwind에서 JIT 모드란?', 'JIT(Just-in-Time) 모드는 Tailwind v2.1 이후 기본 지원되는 빌드 모드로, 실제 사용된 클래스만 실시간으로 생성하여 매우 빠른 빌드 속도와 작은 번들 크기를 제공합니다. 개발 중 즉시 새로운 클래스 사용이 가능하며, 생산성과 성능 모두에 장점을 줍니다.', 18),
                                                                        ('Tailwind에서 커스터마이징은 어떻게 하나요?', 'tailwind.config.js 파일을 통해 테마(색상, 폰트, 간격 등)를 사용자 정의할 수 있습니다. 예: theme.extend 속성을 사용해 기존 설정을 확장하거나 새로 정의할 수 있으며, 플러그인을 등록해 기능을 확장할 수도 있습니다.', 18),
                                                                        ('Tailwind에서 반응형 디자인은 어떻게 구현하나요?', 'Tailwind는 sm, md, lg, xl, 2xl 등의 반응형 접두사를 클래스 앞에 붙여 각 뷰포트별 스타일을 지정할 수 있습니다. 예: sm:text-sm md:text-base lg:text-lg 와 같이 작성하면 화면 크기에 따라 다른 텍스트 크기를 적용할 수 있습니다.', 18),
                                                                        ('Tailwind에서 조건부 스타일링은 어떻게 적용하나요?', 'hover:, focus:, active:, disabled: 등의 상태 접두사를 클래스에 붙여 다양한 UI 상태를 처리할 수 있습니다. 예: hover:bg-blue-500, focus:outline-none 등. 이는 Tailwind의 핵심 특징 중 하나로, 복잡한 CSS 없이도 상태별 스타일을 쉽게 관리할 수 있습니다.', 18),
                                                                        ('Tailwind CSS를 컴포넌트 단위로 관리하려면?', 'Tailwind는 class 기반이므로 컴포넌트를 atomic하게 나누어 스타일을 직접 포함하거나, @apply 지시어를 사용해 재사용 가능한 클래스 그룹을 정의할 수 있습니다. 또한 React, Vue, Svelte 등과 결합해 styled-components나 props 기반으로 유연한 구성도 가능합니다.', 18),
                                                                        ('@apply 지시어는 무엇인가요?', '@apply는 Tailwind의 유틸리티 클래스를 CSS 내에서 조합하여 재사용 가능한 클래스로 만드는 기능입니다. 예: .btn { @apply px-4 py-2 bg-blue-500 text-white; }. 이를 통해 중복 제거 및 클래스 관리가 쉬워지며 유지보수성이 향상됩니다.', 18),
                                                                        ('Tailwind를 대규모 프로젝트에 적용할 때 주의할 점은?', '클래스 중복과 관리가 어려워질 수 있으므로, 컴포넌트 기반 구조와 @apply 사용으로 스타일을 구조화하는 것이 중요합니다. 또한 디자인 시스템과의 통합, 커스터마이징 범위 정의, 팀 내 스타일 가이드 마련 등을 통해 일관성과 생산성을 유지해야 합니다.', 18),
                                                                        ('SCSS란 무엇인가요?', 'SCSS는 SASS(Syntactically Awesome Stylesheets)의 문법 중 하나로, 기존 CSS 문법을 그대로 유지하면서 변수, 중첩, 믹스인, 함수 등 프로그래밍적인 기능을 추가하여 더 효율적이고 유지보수하기 쉬운 스타일 코드를 작성할 수 있게 해주는 CSS 전처리기입니다.', 19),
                                                                        ('SCSS의 변수($)는 어떻게 사용하나요?', 'SCSS에서는 `$` 기호를 사용해 변수에 값을 저장할 수 있으며, 색상, 폰트 사이즈, 여백 등 반복되는 값을 변수로 관리하면 유지보수가 쉬워집니다. 예: `$primary-color: #3498db;` 이후 `color: $primary-color;`처럼 활용 가능합니다.', 19),
                                                                        ('SCSS의 중첩(Nesting)은 무엇인가요?', 'SCSS는 선택자 안에 또 다른 선택자를 중첩하여 작성할 수 있으며, 이는 HTML 구조를 반영한 계층적 스타일링에 유리합니다. 예: `.nav { ul { li { a { color: red; } } } }`처럼 작성하면 `.nav ul li a`가 생성됩니다.', 19),
                                                                        ('Mixin은 무엇이며 어떻게 사용하나요?', 'Mixin은 재사용 가능한 스타일 블록을 정의하는 기능으로, `@mixin`으로 정의하고 `@include`로 호출합니다. 예를 들어 `@mixin center { display: flex; justify-content: center; align-items: center; }`를 만들어 여러 곳에서 재사용할 수 있습니다.', 19),
                                                                        ('SCSS에서 함수(Function)는 어떤 용도로 사용되나요?', 'SCSS 함수는 스타일 내 계산이나 조건 처리를 위해 사용됩니다. `@function`으로 정의하며, 사용자 정의 함수 또는 내장 함수(lighten, darken 등)을 활용해 동적인 스타일 계산이 가능합니다. 예: `@function pxToRem($px) { @return $px / 16 * 1rem; }`', 19),
                                                                        ('SCSS에서 반복문은 어떻게 활용되나요?', 'SCSS에서는 `@for`, `@each`, `@while` 등을 사용하여 반복적인 스타일 코드를 줄일 수 있습니다. 예: `@for $i from 1 through 5 { .m-#{$i} { margin: #{$i}rem; } }`는 `.m-1`부터 `.m-5`까지 자동 생성합니다.', 19),
                                                                        ('SCSS에서 조건문은 어떻게 작성하나요?', '`@if`, `@else if`, `@else` 구문을 통해 조건에 따라 스타일을 분기할 수 있습니다. 예: `@if $theme == dark { background: black; } @else { background: white; }` 처럼 동적인 스타일 제어가 가능합니다.', 19),
                                                                        ('SCSS의 Partials와 Import는 무엇인가요?', 'Partials는 파일 이름이 `_`로 시작되는 SCSS 파일로, 직접 컴파일되지 않고 다른 SCSS 파일에 `@import` 또는 `@use`를 통해 포함되어 사용됩니다. 이를 통해 스타일을 논리적으로 분리하고 모듈화할 수 있습니다.', 19),
                                                                        ('@extend와 @mixin의 차이는?', '`@extend`는 기존 클래스의 스타일을 상속받아 중복 없이 코드를 줄일 수 있지만, 예기치 않은 스타일 누수를 일으킬 수 있습니다. 반면 `@mixin`은 호출될 때마다 스타일을 복사하므로 유연성이 높고 재사용성이 뛰어납니다.', 19),
                                                                        ('SCSS 사용 시 주의할 점은?', '과도한 중첩은 CSS specificity 문제를 야기할 수 있으며, @extend 사용 시 전역 영향을 고려해야 합니다. 또한 잘못된 변수, mixin 관리 구조는 유지보수에 오히려 불리할 수 있으므로 일관된 네이밍과 구조화가 중요합니다.', 19),
                                                                        ('styled-components란 무엇인가요?', 'styled-components는 CSS-in-JS 방식의 스타일링 도구로, JavaScript 파일 안에서 CSS를 작성하여 컴포넌트 단위로 스타일을 관리할 수 있게 해주는 라이브러리입니다. React 환경에서 자주 사용되며, 코드와 스타일을 하나의 단위로 유지할 수 있어 유지보수성과 재사용성이 뛰어납니다.', 20),
                                                                        ('styled-components의 주요 장점은?', '컴포넌트 기반 스타일링으로 코드의 응집도를 높이고, props 기반 동적 스타일링, 자동 클래스 네이밍, 글로벌 네임 충돌 방지, 조건부 스타일 적용 등의 장점을 제공합니다. 또한 theme을 통한 디자인 시스템 통합도 용이합니다.', 20),
                                                                        ('styled-components에서 스타일은 어떻게 정의하나요?', 'styled-components는 tagged template literal 문법을 사용하여 정의합니다. 예: `const Button = styled.button\` background: blue; color: white; \`;`와 같이 작성하면 Button 컴포넌트를 해당 스타일로 정의할 수 있습니다.', 20),
                                                                        ('props를 이용한 동적 스타일링은 어떻게 구현하나요?', 'styled-components는 props를 통해 조건부 스타일을 쉽게 적용할 수 있습니다. 예: `color: \${props => props.primary ? `blue` : `gray`};`와 같이 작성하면 컴포넌트 사용 시 전달된 props에 따라 스타일이 동적으로 결정됩니다.', 20),
                                                                        ('ThemeProvider는 무엇이며 어떻게 사용하나요?', 'ThemeProvider는 styled-components에서 제공하는 컨텍스트 API로, 전체 앱에 공통된 테마 객체를 전달합니다. `theme` 객체에는 색상, 폰트, 여백 등의 디자인 시스템 설정을 담아 어떤 컴포넌트에서도 접근하여 일관된 스타일을 유지할 수 있습니다.', 20),
                                                                        ('전역 스타일(GlobalStyle)은 어떻게 적용하나요?', 'styled-components의 `createGlobalStyle`을 사용하면 전체 애플리케이션에 적용되는 전역 스타일을 정의할 수 있습니다. 예: `const GlobalStyle = createGlobalStyle\` body { margin: 0; } \`;`를 App 루트 컴포넌트에서 렌더링하면 적용됩니다.', 20),
                                                                        ('styled-components의 CSS 네임 충돌을 어떻게 방지하나요?', 'styled-components는 각 컴포넌트마다 고유한 클래스 이름을 자동으로 생성하여 글로벌 네임스페이스 오염을 방지합니다. 이로 인해 CSS 클래스 충돌이 발생하지 않고, 스타일이 해당 컴포넌트에만 적용됩니다.', 20),
                                                                        ('styled-components와 SCSS의 차이는?', 'SCSS는 별도의 스타일 파일을 작성하고 클래스명을 HTML에 연결하는 방식인 반면, styled-components는 JavaScript 내에서 스타일과 컴포넌트를 함께 정의합니다. SCSS는 글로벌 스타일이 기본이며, styled는 컴포넌트 단위 캡슐화를 통해 유지보수에 유리합니다.', 20),
                                                                        ('styled-components에서 애니메이션은 어떻게 구현하나요?', 'styled-components는 `keyframes` 함수를 사용해 CSS 애니메이션을 정의할 수 있습니다. 예: `const fadeIn = keyframes\` from { opacity: 0; } to { opacity: 1; } \`;` 이후 styled 요소에 `animation: \${fadeIn} 1s ease-in;`처럼 적용할 수 있습니다.', 20),
                                                                        ('styled-components 사용 시 성능 최적화 방법은?', '불필요한 컴포넌트 렌더링 방지를 위해 React.memo와 함께 사용하거나, 동적 스타일 계산을 최소화하고, 공통 스타일은 추상화하여 중복 정의를 피하는 것이 좋습니다. 또한 프로덕션 환경에서는 Babel plugin을 통한 클래스 축약 및 스타일 인라이닝 최적화가 가능합니다.', 20),
                                                                        ('ESLint란 무엇인가요?', 'ESLint는 JavaScript 및 TypeScript 코드에서 문법 오류, 코드 스타일 위반, 잠재적인 버그를 정적 분석을 통해 탐지해주는 린팅 도구입니다. 플러그인과 커스터마이징 가능한 규칙을 통해 프로젝트의 코딩 컨벤션을 일관되게 유지할 수 있습니다.', 21),
                                                                        ('Prettier는 어떤 역할을 하나요?', 'Prettier는 코드 포매터로, 들여쓰기, 공백, 세미콜론, 따옴표 등 코드 스타일 요소를 자동으로 포맷팅하여 팀 내 코드 스타일을 통일시키는 데 사용됩니다. 의견 충돌 없이 코드를 정리할 수 있게 해주는 도구입니다.', 21),
                                                                        ('ESLint와 Prettier의 차이점은?', 'ESLint는 코드의 품질, 버그 가능성, 규칙 위반 등을 감지하고 고칠 수 있게 도와주는 분석 도구이며, Prettier는 코드의 가독성과 일관성을 위해 포맷을 자동 정렬해주는 도구입니다. ESLint는 논리, Prettier는 형태에 초점을 둡니다.', 21),
                                                                        ('ESLint 규칙은 어떻게 설정하나요?', '`.eslintrc` 파일에서 `rules` 항목에 원하는 규칙을 key-value 형태로 지정할 수 있습니다. 예: `"no-console": "warn", "eqeqeq": "error"`처럼 설정하면, console 사용은 경고, 느슨한 비교는 에러로 처리됩니다.', 21),
                                                                        ('Prettier 설정은 어떻게 구성하나요?', '`prettier.config.js` 또는 `.prettierrc` 파일을 통해 설정합니다. 예: `{ "semi": true, "singleQuote": true, "tabWidth": 2 }` 등으로 세미콜론, 따옴표, 탭 너비 등을 지정할 수 있습니다.', 21),
                                                                        ('ESLint와 Prettier를 함께 사용할 때 주의할 점은?', '두 도구가 겹치는 포맷팅 규칙을 다르게 처리할 수 있으므로 `eslint-config-prettier`와 `eslint-plugin-prettier`를 설치하여 충돌을 방지하고, Prettier 규칙을 ESLint 안에 통합하는 것이 일반적인 방식입니다.', 21),
                                                                        ('ESLint와 Prettier 자동 적용은 어떻게 하나요?', 'VSCode에서는 `formatOnSave` 옵션과 ESLint/Prettier 확장을 설치하면 저장 시 자동 포맷 및 린트 적용이 가능합니다. 또한 `lint-staged`와 `husky`를 연동하면 Git 커밋 시점에도 자동으로 적용할 수 있습니다.', 21),
                                                                        ('Airbnb, Standard 등 ESLint 스타일 가이드는 무엇인가요?', 'Airbnb, Standard 등의 스타일 가이드는 많은 커뮤니티에서 검증된 린트 규칙 세트를 제공합니다. `eslint-config-airbnb`를 설치하면 코드 컨벤션에 대한 기본 규칙을 빠르게 적용할 수 있습니다.', 21),
                                                                        ('Prettier가 지원하지 않는 스타일 규칙은 어떻게 해결하나요?', 'Prettier는 의도적으로 설정 가능한 옵션을 최소화해 논쟁의 여지를 줄입니다. 이로 인해 매우 세부적인 스타일 조정이 필요한 경우에는 Prettier보다는 ESLint로 설정하거나, 특정 부분은 예외 처리를 해야 합니다.', 21),
                                                                        ('ESLint와 Prettier 도입의 장점은?', '코드 품질 향상, 팀원 간 스타일 통일, 리뷰 시간 단축, 버그 사전 예방 등 개발 생산성과 유지보수성을 향상시킵니다. 자동화된 도구를 통해 사람이 직접 신경 써야 할 부분을 줄일 수 있다는 것이 큰 이점입니다.', 21),
                                                                        ('Next.js란 무엇인가요?', 'Next.js는 React를 기반으로 한 프레임워크로, 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG), 클라이언트 사이드 렌더링(CSR)을 모두 지원합니다. 개발자가 복잡한 설정 없이 빠르게 SEO 친화적이고 성능 좋은 웹앱을 만들 수 있게 도와주는 도구입니다.', 22),
                                                                        ('Next.js에서 SSG와 SSR의 차이는?', 'SSG(Static Site Generation)는 빌드 시 HTML을 생성하고, SSR(Server Side Rendering)은 요청 시 서버에서 HTML을 생성합니다. SSG는 속도가 빠르고 CDN 캐싱이 가능하지만, SSR은 실시간 데이터 반영이 가능하다는 장점이 있습니다.', 22),
                                                                        ('Next.js의 페이지 기반 라우팅은 어떻게 구성되나요?', 'Next.js는 `pages` 디렉토리의 폴더 구조를 기반으로 자동으로 라우팅을 구성합니다. 예를 들어 `pages/about.js`는 `/about` 경로로 매핑되고, 동적 라우팅은 `[param].js` 파일로 처리할 수 있습니다.', 22),
                                                                        ('Next.js에서 API Route는 무엇인가요?', 'Next.js에서는 `pages/api` 폴더 안에 파일을 작성하면 해당 파일이 하나의 API 엔드포인트가 됩니다. 서버리스 함수 형태로 동작하며, 프론트엔드와 동일한 코드베이스에서 간단히 백엔드 기능을 구현할 수 있습니다.', 22),
                                                                        ('Next.js에서 getStaticProps는 어떤 역할을 하나요?', '`getStaticProps`는 정적 페이지를 생성하기 위해 사용되며, 빌드 타임에 데이터를 가져와 HTML을 미리 생성합니다. 이를 통해 빠른 페이지 로딩과 SEO 최적화를 동시에 이룰 수 있습니다.', 22),
                                                                        ('Next.js에서 getServerSideProps는 언제 사용하나요?', '`getServerSideProps`는 SSR에 사용되는 함수로, 매 요청 시 서버에서 실행되어 데이터를 가져온 후 HTML을 생성합니다. 실시간 데이터 반영이 필요한 경우에 유용합니다.', 22),
                                                                        ('Next.js에서 동적 라우팅을 구현하는 방법은?', '파일 이름을 대괄호(`[]`)로 감싸면 동적 라우팅이 가능합니다. 예: `pages/posts/[id].js`는 `/posts/1`, `/posts/2` 같은 URL을 처리하고, `getStaticPaths`와 함께 사용해 SSG로 미리 경로를 생성할 수 있습니다.', 22),
                                                                        ('Next.js에서 이미지 최적화는 어떻게 하나요?', 'Next.js는 `next/image` 컴포넌트를 제공하여 자동 리사이징, 웹 최적화 포맷 변환, 지연 로딩 등을 지원합니다. 이를 통해 성능을 개선하고 페이지 로딩 속도를 빠르게 유지할 수 있습니다.', 22),
                                                                        ('Next.js에서 _app.js와 _document.js의 차이는?', '`_app.js`는 페이지 전환 시 공통 레이아웃이나 전역 상태를 유지할 수 있게 해주는 컴포넌트이며, `_document.js`는 HTML 문서의 구조를 커스터마이징할 때 사용됩니다. 주로 `html`, `head`, `body` 태그를 조작할 수 있습니다.', 22),
                                                                        ('Next.js의 ISR(Incremental Static Regeneration)이란?', 'ISR은 정적 페이지를 일부만 실시간으로 갱신할 수 있도록 해주는 기능입니다. `revalidate` 옵션을 설정하면 특정 시간 간격으로 페이지를 백그라운드에서 재생성하여, 빠른 성능과 실시간 데이터 반영을 동시에 지원합니다.', 22),
                                                                        ('React에서 렌더링이란 무엇인가요?', 'React에서 렌더링은 컴포넌트의 상태나 props가 변경될 때, 이를 기반으로 가상 DOM을 생성하고 실제 DOM과 비교하여 변경된 부분만 업데이트하는 과정입니다. 이를 통해 성능을 최적화하고 효율적으로 UI를 갱신할 수 있습니다.', 23),
                                                                        ('불필요한 렌더링을 줄이기 위한 방법에는 어떤 것이 있나요?', 'React.memo를 사용하면 props가 변경되지 않은 경우 해당 컴포넌트를 재렌더링하지 않습니다. 또한 useMemo나 useCallback 훅을 활용해 연산이나 함수를 메모이제이션함으로써 렌더링 성능을 개선할 수 있습니다.', 23),
                                                                        ('React.memo는 어떻게 작동하나요?', 'React.memo는 고차 컴포넌트(HOC)로, 전달된 props가 이전과 같다면 컴포넌트를 재렌더링하지 않고 결과를 재사용합니다. 얕은 비교(shallow comparison)를 기반으로 작동하며, 함수형 컴포넌트에서 사용됩니다.', 23),
                                                                        ('useMemo와 useCallback의 차이는 무엇인가요?', 'useMemo는 연산의 결과 값을 메모이제이션하고, useCallback은 함수를 메모이제이션합니다. 둘 다 의존성 배열이 변하지 않는 한 이전 값을 유지하므로, 성능 최적화에 도움이 됩니다.', 23),
                                                                        ('Virtual DOM은 렌더링과 어떤 관련이 있나요?', 'React는 상태 변경 시 실제 DOM을 직접 조작하는 대신 Virtual DOM을 먼저 업데이트하고, 이전 Virtual DOM과 비교하여 변경 사항만 실제 DOM에 반영합니다. 이로 인해 전체 DOM을 다시 그리지 않아 성능이 향상됩니다.', 23),
                                                                        ('key props는 React 렌더링에서 어떤 역할을 하나요?', 'key는 리스트 렌더링 시 각 요소를 고유하게 식별하기 위해 사용됩니다. key가 정확하지 않으면 불필요한 재렌더링이 발생하거나, 잘못된 DOM 업데이트로 인해 렌더링 문제가 발생할 수 있습니다.', 23),
                                                                        ('렌더링 최적화가 중요한 이유는?', '불필요한 렌더링은 브라우저의 리소스를 낭비하고 UI 반응성을 떨어뜨립니다. 대규모 애플리케이션에서는 이러한 성능 저하가 사용자 경험에 직접적인 영향을 주기 때문에, 최적화는 필수적입니다.', 23),
                                                                        ('컴포넌트가 자주 렌더링되는 원인은?', '컴포넌트의 state나 props가 변경되면 해당 컴포넌트와 그 자식 컴포넌트까지 렌더링될 수 있습니다. 의존성 배열이 잘못되었거나, 참조가 변경되는 객체나 함수가 전달되면 의도치 않게 렌더링이 발생할 수 있습니다.', 23),
                                                                        ('렌더링 성능을 측정하거나 확인하는 방법은?', 'React Developer Tools의 Profiler 탭을 사용하면 컴포넌트의 렌더링 횟수와 시간 등을 시각적으로 확인할 수 있습니다. 이를 통해 성능 병목 지점을 파악하고 최적화할 수 있습니다.', 23),
                                                                        ('렌더링 최적화 시 주의할 점은?', '무조건 useMemo, useCallback을 사용하는 것은 오히려 불필요한 메모리 사용과 복잡도를 증가시킬 수 있습니다. 실제로 성능 병목이 되는 지점을 분석한 후, 필요한 곳에만 적용하는 것이 바람직합니다.', 23),
                                                                        ('React Query에서 Prefetch란 무엇인가요?', 'Prefetch는 사용자가 데이터를 필요로 하기 전에 미리 데이터를 요청하여 캐시에 저장해두는 기능입니다. 이를 통해 사용자가 페이지를 전환하거나 컴포넌트를 렌더링할 때 이미 데이터를 가져온 상태가 되어, 로딩 없이 빠르게 UI를 보여줄 수 있습니다.', 24),
                                                                        ('Query Key의 역할은 무엇인가요?', 'Query Key는 React Query에서 각 요청을 식별하기 위한 고유한 키입니다. 이 키를 기준으로 캐시를 구분하고, 동일한 키를 가진 요청은 캐시에서 값을 재사용하며, 키가 다르면 새로운 요청을 보냅니다. 또한 Query Invalidation 등 다양한 기능에서 기준점이 됩니다.', 24),
                                                                        ('Query Invalidation은 어떤 상황에서 사용하나요?', 'Query Invalidation은 데이터가 변경되었음을 React Query에 알려주는 메커니즘입니다. 예를 들어, POST, PUT, DELETE 요청 후 해당 데이터와 관련된 쿼리를 무효화하면, React Query는 자동으로 새로운 데이터를 서버에서 다시 가져옵니다.', 24),
                                                                        ('React Query의 staleTime과 cacheTime의 차이는?', 'staleTime은 데이터를 “신선한 상태”로 간주하는 시간이며, 이 시간 내에는 재요청이 발생하지 않습니다. cacheTime은 컴포넌트에서 언마운트된 후에도 데이터를 캐시에 유지하는 시간입니다. staleTime은 요청 빈도에, cacheTime은 메모리 관리에 영향을 줍니다.', 24),
                                                                        ('useQuery와 useMutation의 차이는 무엇인가요?', 'useQuery는 GET 요청처럼 데이터를 가져올 때 사용하고, useMutation은 POST, PUT, DELETE 요청처럼 데이터를 변경하는 작업에 사용됩니다. useMutation은 성공/실패 콜백을 통해 사이드 이펙트를 처리하는 데 적합합니다.', 24),
                                                                        ('React Query에서 refetch는 언제 사용하나요?', 'refetch는 수동으로 데이터를 다시 요청하고 싶을 때 사용합니다. 사용자가 직접 버튼을 클릭하거나, 특정 조건에 따라 데이터를 최신 상태로 유지하려는 경우에 호출됩니다.', 24),
                                                                        ('React Query에서 병렬 요청과 종속 요청은 어떻게 처리하나요?', '병렬 요청은 여러 useQuery를 병렬로 실행하면 자동으로 병렬 처리됩니다. 종속 요청은 useQuery 내에서 enabled 옵션이나 이전 쿼리의 데이터 존재 여부 등을 기반으로 조건부 실행하여 처리할 수 있습니다.', 24),
                                                                        ('React Query Devtools는 어떤 기능을 제공하나요?', 'React Query Devtools는 현재 캐시 상태, 쿼리 키 목록, 쿼리 상태(stale, fetching 등), 무효화 상태 등을 시각적으로 보여주며, 쿼리를 수동으로 refetch하거나 캐시를 초기화할 수 있는 기능을 제공합니다.', 24),
                                                                        ('React Query의 자동 갱신 기능은 어떻게 작동하나요?', 'React Query는 기본적으로 사용자가 탭을 다시 활성화하거나, 네트워크가 다시 연결될 때 자동으로 데이터를 다시 가져옵니다. 이 외에도 refetchInterval을 설정하여 일정 주기로 데이터를 갱신할 수 있습니다.', 24),
                                                                        ('onSuccess와 onSettled의 차이는 무엇인가요?', 'onSuccess는 쿼리가 성공적으로 데이터를 가져왔을 때 호출되는 콜백이며, onSettled는 성공 여부와 관계없이 쿼리가 완료되면 항상 호출됩니다. onSettled는 공통 후처리가 필요할 때 유용하게 사용됩니다.', 24),
                                                                        ('Vue Test Utils란 무엇이고, 어떤 역할을 하나요?', 'Vue Test Utils는 Vue 공식 테스트 라이브러리로, Vue 컴포넌트를 마운트하고 이벤트를 시뮬레이션하거나 DOM을 검사하여 기능이 예상대로 동작하는지 확인하는 데 사용됩니다. 유닛 테스트와 통합 테스트 작성에 매우 유용합니다.', 25),
                                                                        ('mount()와 shallowMount()의 차이는 무엇인가요?', 'mount()는 컴포넌트를 전체 렌더링하며, 하위 컴포넌트까지 모두 포함해서 테스트합니다. 반면, shallowMount()는 최상위 컴포넌트만 렌더링하고, 하위 컴포넌트는 스텁으로 대체하여 독립적인 유닛 테스트를 가능하게 합니다.', 25),
                                                                        ('컴포넌트에 props를 전달하여 테스트하는 방법은?', 'mount() 또는 shallowMount() 시 객체 형태로 props를 전달할 수 있습니다. 예: shallowMount(MyComponent, { props: { title: "테스트 제목" } }) 와 같이 설정하여 props에 따른 렌더링 결과를 확인할 수 있습니다.', 25),
                                                                        ('Vue Test Utils에서 이벤트를 시뮬레이션하는 방법은?', 'trigger() 메서드를 사용하여 클릭, 입력 등의 DOM 이벤트를 시뮬레이션할 수 있습니다. 예: wrapper.find("button").trigger("click") 으로 버튼 클릭 이벤트를 발생시켜 핸들러 작동 여부를 검증합니다.', 25),
                                                                        ('DOM 내용을 검사할 때 어떤 메서드를 사용할 수 있나요?', 'text(), html(), attributes(), classes() 등의 메서드를 사용할 수 있습니다. 예: wrapper.text()를 사용하면 컴포넌트 내부 텍스트를 가져와 기대값과 비교할 수 있습니다.', 25),
                                                                        ('slots를 포함한 컴포넌트를 테스트하려면?', 'shallowMount나 mount 시 slots 옵션을 사용해 테스트할 수 있습니다. 예: shallowMount(MyComponent, { slots: { default: "<p>slot 내용</p>" } }) 와 같이 테스트하면 slot이 제대로 렌더링되는지 확인할 수 있습니다.', 25),
                                                                        ('비동기 로직이 포함된 컴포넌트를 어떻게 테스트하나요?', 'flushPromises() 또는 await wrapper.vm.$nextTick()을 활용하여 비동기 처리 후 DOM 업데이트를 기다려야 합니다. 비동기 호출 이후 결과 반영 여부를 테스트할 수 있도록 동기화가 필요합니다.', 25),
                                                                        ('mock 함수 또는 의존성을 주입하여 테스트하는 방법은?', 'provide/inject 또는 글로벌 플러그인을 mock으로 설정할 수 있으며, jest.mock()과 함께 사용하면 API 호출이나 외부 모듈을 대체하여 독립적인 테스트가 가능합니다.', 25),
                                                                        ('Vue Test Utils에서 v-model은 어떻게 테스트하나요?', 'v-model은 내부적으로 props와 이벤트로 구성되어 있으므로, 해당 input 요소의 값을 변경하고 input 이벤트를 trigger 하면 모델 변경을 테스트할 수 있습니다. 예: setValue("새 값")', 25),
                                                                        ('Vue Test Utils를 사용할 때 주의할 점은?', '컴포넌트의 내부 구현에 의존하지 않고, 사용자 관점에서 기능 중심의 테스트를 작성하는 것이 중요합니다. 또한, 각 테스트는 독립적이어야 하며 상태를 공유하지 않도록 주의해야 합니다.', 25),
                                                                        ('Nuxt.js란 무엇이고 어떤 목적을 위해 사용하나요?', 'Nuxt.js는 Vue.js 기반의 프레임워크로, 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG), 자동 라우팅, 코드 분할 등 고급 기능을 손쉽게 사용할 수 있도록 도와줍니다. 복잡한 설정 없이도 SEO 최적화와 초기 로딩 속도 개선 같은 요구사항을 만족할 수 있어 대규모 웹 애플리케이션 개발에 적합합니다.', 26),
                                                                        ('Nuxt.js에서 페이지 라우팅은 어떻게 구성되나요?', 'Nuxt.js는 파일 기반 라우팅을 채택하고 있어, pages 디렉토리 내부에 .vue 파일을 생성하면 자동으로 해당 파일 경로가 라우팅됩니다. 예를 들어, pages/about.vue 파일은 /about 경로로 자동 연결되며, 추가 설정 없이 라우팅 구성이 완료됩니다.', 26),
                                                                        ('Nuxt.js의 서버 사이드 렌더링(SSR)의 장점은 무엇인가요?', 'SSR은 클라이언트가 아닌 서버에서 HTML을 먼저 렌더링해주는 방식으로, 초기 페이지 로딩 속도가 빠르고 SEO 최적화에 유리합니다. 검색 엔진이 페이지를 크롤링하기 쉬우며, 초기 데이터가 이미 포함된 HTML을 반환함으로써 사용자 경험을 향상시킬 수 있습니다.', 26),
                                                                        ('Nuxt.js에서 정적 사이트 생성(SSG)은 어떻게 활용되나요?', 'Nuxt.js는 nuxt generate 명령을 통해 애플리케이션을 정적 파일로 사전 렌더링할 수 있습니다. 이 방식을 사용하면 CDN을 통한 빠른 배포가 가능하고, 서버 리소스를 최소화할 수 있어 블로그나 문서 사이트 등 정적인 컨텐츠에 매우 적합합니다.', 26),
                                                                        ('Nuxt.js에서 상태 관리는 어떻게 하나요?', 'Nuxt.js는 기본적으로 Vuex를 지원하며, store 디렉토리에 모듈을 생성하면 자동으로 인식됩니다. 전역 상태 관리를 통해 여러 컴포넌트 간의 데이터를 공유하고, 서버에서 초기 상태를 설정할 수도 있어 SSR 환경에서도 일관된 상태를 유지할 수 있습니다.', 26),
                                                                        ('Nuxt.js의 미들웨어(Middleware)는 어떤 역할을 하나요?', '미들웨어는 페이지가 렌더링되기 전에 실행되는 함수로, 인증 검사, 리디렉션, 접근 제어 등에 사용됩니다. 각 페이지 컴포넌트나 글로벌 수준에서 적용할 수 있으며, 사용자 요청이 처리되기 전에 필요한 전처리를 수행할 수 있습니다.', 26),
                                                                        ('Nuxt.js의 asyncData와 fetch 메서드 차이는?', 'asyncData는 컴포넌트 인스턴스가 생성되기 전에 호출되어 데이터를 가져오고, 컴포넌트의 data에 병합됩니다. 반면 fetch는 컴포넌트 인스턴스가 생성된 후 호출되며, this를 사용할 수 있어 컴포넌트 내부 상태에 접근 가능합니다.', 26),
                                                                        ('Nuxt.js에서 SEO를 위한 설정은 어떻게 하나요?', 'Nuxt.js는 vue-meta를 기반으로 하여 head 속성을 통해 페이지별로 meta 태그를 설정할 수 있습니다. 각 컴포넌트에서 head() 메서드를 정의하면 title, description, og 태그 등 SEO 요소를 동적으로 설정할 수 있습니다.', 26),
                                                                        ('Nuxt.js 프로젝트에서 플러그인을 등록하는 방법은?', 'plugins 디렉토리에 JavaScript 파일을 생성하고 nuxt.config.js의 plugins 배열에 해당 파일 경로를 등록하면 전역 플러그인으로 사용할 수 있습니다. 이를 통해 라이브러리 초기화, 전역 믹스인 설정 등을 구성할 수 있습니다.', 26),
                                                                        ('Nuxt.js에서 환경 변수 관리 방법은?', 'Nuxt.js는 .env 파일을 사용해 환경 변수를 정의할 수 있으며, nuxt.config.js에서 runtimeConfig 또는 publicRuntimeConfig 속성을 사용해 클라이언트와 서버에서 각각 사용할 수 있도록 설정할 수 있습니다.', 26),
                                                                        ('Angular Universal이란 무엇이며, 왜 사용하는가?', 'Angular Universal은 Angular 애플리케이션의 서버 사이드 렌더링(SSR)을 가능하게 해주는 도구입니다. 클라이언트가 아닌 서버에서 HTML을 먼저 렌더링해 사용자에게 빠르게 초기 화면을 보여주고, SEO 성능을 향상시켜 검색 엔진 최적화에 유리하게 만들어줍니다.', 27),
                                                                        ('Angular Universal이 Angular와 다른 점은?', '기본 Angular는 클라이언트 사이드 렌더링(CSR)을 사용해 브라우저에서 렌더링이 이루어지지만, Angular Universal은 Node.js 서버에서 HTML을 미리 렌더링하여 초기 로딩 성능과 SEO를 개선합니다.', 27),
                                                                        ('Angular Universal에서 서버 사이드 렌더링의 작동 방식은?', '사용자가 페이지에 접근하면 서버가 Angular 애플리케이션을 실행하여 HTML을 생성한 뒤, 클라이언트에 전송합니다. 이후 Angular가 클라이언트에서 부트스트랩되어 인터랙티브한 SPA로 전환됩니다. 이 과정은 pre-rendered content와 hydration으로 구성됩니다.', 27),
                                                                        ('Angular Universal을 사용할 때 SEO 측면에서의 장점은?', 'SSR 방식은 초기 HTML을 완성된 형태로 반환하므로, 크롤러가 JavaScript 실행 없이도 콘텐츠를 읽을 수 있어 검색 엔진에 잘 노출됩니다. 특히 메타태그 설정과 콘텐츠가 중요할 때 유리합니다.', 27),
                                                                        ('Angular Universal 프로젝트 설정 방법은?', 'Angular CLI에서 `ng add @nguniversal/express-engine` 명령어를 사용하면 서버 렌더링을 위한 설정과 Express 서버가 자동 구성되며, 서버 entry point와 server.ts 파일이 생성됩니다.', 27),
                                                                        ('Angular Universal에서 pre-rendering과 SSR의 차이점은?', 'SSR은 매 요청마다 서버에서 렌더링되며, pre-rendering은 빌드 타임에 미리 HTML을 생성하여 정적 파일로 제공됩니다. SSR은 동적 콘텐츠에 적합하고, pre-rendering은 변경이 적은 정적 페이지에 효율적입니다.', 27),
                                                                        ('Angular Universal에서 lazy loading 모듈은 어떻게 처리되나요?', 'Angular Universal은 lazy-loaded 모듈도 서버에서 렌더링할 수 있지만, SSR 시에는 초기 요청에 포함되지 않으므로, 필요한 모듈의 preload 설정 또는 로딩 전략을 고려해야 합니다.', 27),
                                                                        ('Angular Universal에서 상태(State) 관리는 어떻게 처리되나요?', 'SSR에서는 서버에서 생성한 상태를 클라이언트에 전달해야 하므로, TransferState API를 사용해 서버 렌더링 시의 데이터를 클라이언트에서 재사용하도록 전달할 수 있습니다.', 27),
                                                                        ('Angular Universal에서 발생할 수 있는 공통 오류는?', 'window나 document 객체 참조 같은 브라우저 전용 API를 사용하는 경우 SSR 환경에서는 오류가 발생합니다. 이 문제는 isPlatformBrowser 등의 조건문을 통해 런타임 환경을 구분함으로써 해결할 수 있습니다.', 27),
                                                                        ('Angular Universal을 배포할 때 고려할 점은?', 'SSR은 Node.js 서버가 필요하므로, 정적 호스팅 대신 서버 환경(AWS EC2, Heroku, Vercel 등)에 배포해야 하며, SSR 서버와 정적 파일 빌드를 동시에 처리하도록 설정해야 합니다.', 27),
                                                                        ('Jasmine이란 무엇이며 어떤 용도로 사용되나요?', 'Jasmine은 JavaScript 테스트 프레임워크로, 특히 Angular에서 단위 테스트(unit test)를 작성할 때 널리 사용됩니다. 비동기 코드 지원, 독립적인 테스트 실행, 다양한 matcher와 테스트 스위트 구성이 특징입니다.', 28),
                                                                        ('Jasmine의 describe, it, expect의 역할은 무엇인가요?', 'describe는 테스트 스위트를 정의하고, it은 개별 테스트 케이스를 정의하며, expect는 실제 결과와 예상 결과를 비교하여 테스트의 성공 여부를 결정하는 assertion 역할을 합니다.', 28),
                                                                        ('Jasmine에서 beforeEach와 afterEach는 어떤 용도로 사용되나요?', 'beforeEach는 각 테스트 실행 전에 공통 설정을 초기화하는 데 사용되고, afterEach는 테스트 실행 후 자원을 정리하거나 후처리를 수행하는 데 사용됩니다.', 28),
                                                                        ('Jasmine에서 Spy는 무엇이고 어떻게 사용하나요?', 'Spy는 함수 호출 여부, 인자, 반환값 등을 추적하고 가짜 동작을 지정할 수 있는 기능입니다. 이를 통해 외부 의존성을 격리하여 테스트의 신뢰성을 높일 수 있습니다.', 28),
                                                                        ('비동기 코드를 Jasmine으로 테스트할 때 어떻게 처리하나요?', '비동기 테스트는 done 콜백 또는 async/await를 사용하여 테스트가 완료되었음을 명시적으로 알리고, 비동기 코드가 올바르게 수행되었는지 검증할 수 있습니다.', 28),
                                                                        ('Jasmine의 matcher 예시에는 어떤 것들이 있나요?', '대표적인 matcher로는 toBe, toEqual, toContain, toThrow, toBeTruthy 등이 있으며, 각기 다른 타입과 상황에 맞게 다양한 assertion을 제공합니다.', 28),
                                                                        ('Jasmine에서 커스텀 matcher를 만들 수 있나요?', '예, Jasmine은 사용자 정의 matcher를 만들 수 있도록 지원합니다. 이를 통해 팀 또는 프로젝트 특성에 맞는 테스트 표현식을 구성할 수 있습니다.', 28),
                                                                        ('Jasmine 테스트에서 DOM 관련 기능을 어떻게 테스트하나요?', 'Angular에서는 TestBed와 함께 Jasmine을 사용하여 컴포넌트를 렌더링한 후, nativeElement를 통해 DOM 요소를 검사하거나 이벤트를 시뮬레이션할 수 있습니다.', 28),
                                                                        ('Jasmine을 Angular CLI와 함께 사용할 때 테스트 실행 방법은?', 'Angular CLI에서 `ng test` 명령어를 실행하면 Jasmine 테스트 스위트가 Karma를 통해 브라우저에서 실행되고, 결과가 실시간으로 출력됩니다.', 28),
                                                                        ('Jasmine 테스트의 장점은 무엇인가요?', '자동화된 테스트를 통해 코드의 신뢰성을 확보하고, 리팩터링 시 오류 가능성을 줄이며, 문서화 기능으로도 활용되어 협업 시 코드 이해도를 높이는 데 기여합니다.', 28),
                                                                        ('Webpack이란 무엇이며 어떤 역할을 하나요?', 'Webpack은 자바스크립트 애플리케이션의 모듈 번들러로, 다양한 자원(js, css, 이미지 등)을 하나의 번들 또는 여러 개의 청크로 묶어 웹페이지의 로딩 성능을 최적화하는 역할을 합니다.', 29),
                                                                        ('Webpack의 주요 구성 요소에는 무엇이 있나요?', 'Webpack은 Entry(시작점), Output(결과물 위치), Loaders(파일 변환기), Plugins(기능 확장기), Mode(환경 설정) 등의 구성 요소로 이루어져 있으며, 각각의 역할은 명확하게 분리되어 있습니다.', 29),
                                                                        ('Webpack의 Entry와 Output 옵션은 어떤 의미인가요?', 'Entry는 웹 애플리케이션의 시작점 파일을 지정하고, Output은 번들링된 결과 파일의 이름과 저장 경로를 지정합니다. 이를 통해 전체 번들링 구조를 정의할 수 있습니다.', 29),
                                                                        ('Loaders는 어떤 역할을 하나요?', 'Loaders는 JavaScript 이외의 파일(CSS, 이미지, TypeScript 등)을 Webpack이 이해하고 번들링할 수 있도록 변환해주는 역할을 하며, babel-loader, style-loader, css-loader 등이 자주 사용됩니다.', 29),
                                                                        ('Plugins는 언제 사용하고 어떤 기능을 하나요?', 'Plugins는 번들링 과정에서 다양한 작업(예: HTML 파일 생성, 코드 압축, 환경변수 정의 등)을 수행하며, HtmlWebpackPlugin, DefinePlugin, MiniCssExtractPlugin 등이 대표적입니다.', 29),
                                                                        ('Webpack의 Mode 설정은 어떤 영향을 주나요?', 'Mode는 개발(dev) 또는 프로덕션(prod) 모드를 지정하며, 각 모드에 따라 코드 압축 여부, 디버깅 정보 유무 등 Webpack의 동작 방식이 달라집니다.', 29),
                                                                        ('코드 분할(Code Splitting)은 어떻게 설정하나요?', 'Webpack의 `splitChunks` 설정을 통해 공통 모듈을 별도 청크로 분리하거나, `import()` 문을 사용하여 동적 로딩을 설정해 초기 로딩 속도를 개선할 수 있습니다.', 29),
                                                                        ('HMR(Hot Module Replacement)이란 무엇이고 Webpack에서 어떻게 사용되나요?', 'HMR은 전체 페이지를 새로 고치지 않고도 변경된 모듈만 교체하는 기능으로, 개발 중 빠르게 변경 사항을 반영하고 상태를 유지할 수 있어 생산성을 높여줍니다.', 29),
                                                                        ('Tree Shaking은 무엇이며 어떻게 적용되나요?', 'Tree Shaking은 사용되지 않는 코드를 제거해 번들 크기를 줄이는 최적화 기법으로, ES6 모듈을 사용하고 `mode: "production"`으로 설정하면 자동 적용됩니다.', 29),
                                                                        ('Webpack 설정을 커스터마이징할 때 주의할 점은?', '의존성 충돌, 로더와 플러그인의 순서, 빌드 속도 저하, 경로 설정 오류 등에 유의해야 하며, 설정 파일을 환경별로 분리하여 관리하는 것이 유지보수에 유리합니다.', 29),
                                                                        ('GitHub Actions란 무엇이며 어떤 문제를 해결해주나요?', 'GitHub Actions는 GitHub에서 제공하는 CI/CD 도구로, 코드 변경 시 자동으로 테스트, 빌드, 배포 과정을 실행함으로써 수작업 없이 일관된 개발 파이프라인을 유지할 수 있도록 도와줍니다.', 30),
                                                                        ('GitHub Actions의 Workflow 구성 요소는 무엇인가요?', 'Workflow는 이벤트(trigger), 작업(job), 단계(step)로 구성되며, 각 job은 여러 step으로 이루어져 있고, 각 step은 쉘 명령어나 action을 실행합니다.', 30),
                                                                        ('Workflow 파일은 어디에 작성하며 어떤 형식인가요?', 'Workflow는 `.github/workflows/` 디렉토리에 YAML 형식으로 작성되며, 주로 `.yml` 확장자를 사용하여 구성합니다.', 30),
                                                                        ('빌드/배포 자동화를 위해 자주 사용하는 GitHub Actions 이벤트에는 어떤 것이 있나요?', '주로 사용되는 이벤트는 `push`, `pull_request`, `workflow_dispatch`, `schedule` 등이 있으며, 각각 커밋, PR, 수동 실행, 주기적 실행 등에 사용됩니다.', 30),
                                                                        ('GitHub Actions에서 Secrets은 어떻게 사용되나요?', 'Secrets는 민감한 정보를 암호화해 저장하고, `${{ secrets.SECRET_NAME }}` 형태로 Workflow 내에서 안전하게 참조할 수 있어 보안성을 유지합니다.', 30),
                                                                        ('CI와 CD의 차이점은 무엇이며, GitHub Actions에서 각각 어떻게 구현하나요?', 'CI는 코드 변경 시 자동 테스트 및 빌드 과정이고, CD는 빌드 결과물을 배포하는 과정입니다. GitHub Actions에서는 Job을 나누어 단계별로 CI와 CD 파이프라인을 구현할 수 있습니다.', 30),
                                                                        ('빌드 오류나 테스트 실패 시 Workflow 동작은 어떻게 제어할 수 있나요?', 'Job이나 Step에서 실패하면 이후 단계가 중단되며, `continue-on-error: true`를 설정하면 실패해도 다음 단계로 넘어가게 제어할 수 있습니다.', 30),
                                                                        ('동시에 여러 Job을 실행하거나 순서를 제어하려면 어떻게 해야 하나요?', 'Job 간 의존성은 `needs` 키워드를 사용해 명시할 수 있으며, 서로 독립적인 Job은 병렬로 실행되어 빌드 시간을 단축시킬 수 있습니다.', 30),
                                                                        ('외부 서버에 자동 배포하려면 어떤 방식으로 GitHub Actions를 활용하나요?', 'SSH 연결, FTP, SCP, 또는 클라우드 CLI(AWS CLI, gcloud CLI 등)를 이용해 서버에 접근한 뒤, 빌드 결과물을 배포하거나 컨테이너 이미지를 푸시하여 자동 배포를 구현할 수 있습니다.', 30),
                                                                        ('GitHub Actions으로 자동화된 배포 파이프라인을 설계할 때 주의할 점은?', '비밀 정보 관리, 빌드 실패 대응, 롤백 전략, 브랜치 전략(main, develop 분리) 등을 고려해 안정적이고 안전한 자동화를 설계해야 합니다.', 30),
                                                                        ('Docker로 프론트엔드 앱을 배포하는 이유는 무엇인가요?', 'Docker는 앱을 컨테이너로 패키징하여 환경에 상관없이 동일한 방식으로 실행할 수 있게 해주며, 이를 통해 배포의 일관성과 안정성을 확보할 수 있습니다.', 31),
                                                                        ('프론트엔드 앱의 Dockerfile은 어떻게 구성하나요?', '일반적으로 React나 Vue 앱의 Dockerfile은 Node 환경에서 빌드한 후, Nginx 이미지에 결과물을 복사하는 multi-stage 방식으로 구성됩니다.', 31),
                                                                        ('프론트엔드 앱을 Nginx와 함께 배포할 때의 이점은 무엇인가요?', 'Nginx는 정적 파일 서빙에 최적화되어 있어 프론트엔드 앱의 성능을 높이고, 캐싱, 압축, 리버스 프록시 설정을 통해 효율적인 배포가 가능합니다.', 31),
                                                                        ('Docker에서 빌드된 프론트엔드 앱 이미지는 어떻게 실행하나요?', 'Docker 이미지로부터 컨테이너를 생성할 때 `docker run -p 80:80 이미지명` 명령을 통해 Nginx가 80 포트에서 앱을 서비스하도록 설정합니다.', 31),
                                                                        ('React나 Vue 앱을 Docker로 배포할 때 환경변수를 어떻게 관리하나요?', '빌드 시점에 `.env` 파일을 통해 환경변수를 주입하거나, Nginx 설정에서 `envsubst`를 활용해 런타임에 환경변수를 삽입할 수 있습니다.', 31),
                                                                        ('Docker Compose를 활용하면 어떤 점이 더 편리해지나요?', 'Docker Compose를 사용하면 Nginx, 백엔드, 데이터베이스 등 여러 컨테이너를 하나의 설정 파일로 관리할 수 있어 복잡한 앱 구성을 손쉽게 다룰 수 있습니다.', 31),
                                                                        ('프론트엔드 앱을 Docker로 배포할 때 주의해야 할 점은?', '정적 파일 빌드가 완료된 후 빌드 결과만 배포하도록 하고, Node 환경은 프로덕션 이미지에서 제거해야 용량 절감 및 보안에 유리합니다.', 31),
                                                                        ('Nginx에서 SPA 라우팅 문제를 해결하려면 어떻게 해야 하나요?', 'Nginx 설정 파일에 `try_files $uri /index.html;` 지시어를 추가해 클라이언트 사이드 라우팅이 동작하도록 설정해야 합니다.', 31),
                                                                        ('Docker 이미지 배포 이후 업데이트가 필요할 때는 어떻게 하나요?', '앱 코드를 수정한 뒤 이미지를 다시 빌드하고 기존 컨테이너를 삭제한 후 새 이미지로 컨테이너를 재생성합니다. CI/CD 파이프라인으로 자동화도 가능합니다.', 31),
                                                                        ('클라우드 환경에서 Dockerized 프론트엔드 앱을 배포하려면 어떤 방식을 사용할 수 있나요?', 'AWS ECS, Google Cloud Run, Azure Web App for Containers 등을 통해 도커 이미지를 클라우드에 직접 배포할 수 있으며, GitHub Actions와 연계하면 자동화된 배포도 가능합니다.', 31),
                                                                        ('SPA를 AWS S3에 배포할 때 어떤 설정이 필요한가요?', 'SPA를 S3에 배포하려면 퍼블릭 액세스를 허용하고, 정적 웹 호스팅을 활성화하며, index.html을 기본 문서로 지정해야 합니다.', 32),
                                                                        ('S3에 업로드한 정적 파일을 CloudFront로 연결하는 이유는 무엇인가요?', 'CloudFront는 CDN으로서 전 세계에 있는 엣지 로케이션을 통해 사용자와 가장 가까운 위치에서 정적 파일을 전달하여 로딩 속도를 향상시킵니다.', 32),
                                                                        ('CloudFront 설정 시 SPA 라우팅을 위해 어떤 설정이 필요한가요?', 'SPA의 라우팅 문제를 방지하려면 CloudFront의 에러 페이지 설정에서 403 또는 404 응답에 대해 index.html로 리디렉션하도록 구성해야 합니다.', 32),
                                                                        ('S3 + CloudFront를 사용하는 SPA 배포의 장점은 무엇인가요?', '서버 없이도 안정적인 배포가 가능하고, 자동 캐싱 및 HTTPS, 전 세계 콘텐츠 전송 최적화 기능을 사용할 수 있어 비용 대비 성능이 우수합니다.', 32),
                                                                        ('React/Vue 앱을 S3에 배포할 때 어떻게 업로드하나요?', '앱을 빌드한 후 `aws s3 sync build/ s3://버킷이름` 명령어를 사용하여 정적 파일을 S3에 업로드할 수 있습니다.', 32),
                                                                        ('CloudFront 캐시 무효화는 왜 필요하며 어떻게 하나요?', '정적 파일이 변경되었을 때 최신 버전을 반영하기 위해 캐시 무효화가 필요하며, AWS 콘솔 또는 CLI를 통해 Invalidation 요청을 할 수 있습니다.', 32),
                                                                        ('S3 정적 웹 호스팅과 CloudFront 연결 시 HTTPS를 사용하는 방법은?', 'CloudFront에 ACM에서 발급한 SSL 인증서를 연결하고, S3는 정적 웹 호스팅 대신 CloudFront Origin으로만 접근하도록 설정해야 합니다.', 32),
                                                                        ('SPA를 S3 + CloudFront에 배포할 때 배포 자동화는 어떻게 하나요?', 'GitHub Actions 또는 AWS CodePipeline을 사용해 코드 커밋 시 자동 빌드 후 S3 업로드 및 CloudFront 캐시 무효화를 설정할 수 있습니다.', 32),
                                                                        ('S3 정적 웹 호스팅과 EC2 웹 서버 배포 방식의 차이점은?', 'S3는 서버리스 정적 배포 방식으로 유지 관리가 필요 없고, EC2는 서버를 직접 구성하고 운영해야 하며 동적 페이지에 적합합니다.', 32),
                                                                        ('CloudFront를 통한 S3 SPA 배포 시 SEO 최적화는 어떻게 하나요?', 'SPA는 클라이언트 렌더링 방식이므로 SEO가 어려울 수 있으며, 프리렌더링이나 SSR 도입을 통해 검색 엔진에 노출되도록 개선할 수 있습니다.', 32),
                                                                        ('Unit Test란 무엇이고 어떤 목적을 가지나요?', 'Unit Test는 개별 함수, 메서드, 컴포넌트 단위로 로직이 의도대로 작동하는지를 검증하기 위한 테스트로, 버그를 조기에 발견하고 리팩토링 시 안정성을 확보할 수 있는 기반이 됩니다.', 33),
                                                                        ('Snapshot Test는 언제 사용하고 어떤 장점이 있나요?', 'Snapshot Test는 컴포넌트가 렌더링하는 결과물(HTML 구조 등)이 이전과 동일한지를 자동 비교하여 의도치 않은 UI 변경을 감지할 수 있는 테스트 기법입니다.', 33),
                                                                        ('Integration Test란 무엇이고 Unit Test와 어떤 차이가 있나요?', 'Integration Test는 여러 모듈이나 컴포넌트가 결합되어 동작할 때 예상대로 작동하는지를 검증하며, 단일 유닛이 아닌 전체 흐름에 초점을 맞춘다는 점에서 Unit Test와 다릅니다.', 33),
                                                                        ('Component 테스트를 작성할 때 어떤 도구들을 주로 사용하나요?', 'React에서는 Jest, React Testing Library, Enzyme 같은 도구를 사용하며, Vue에서는 Vue Test Utils, Angular에서는 Jasmine과 Karma 등이 대표적인 테스트 도구입니다.', 33),
                                                                        ('단위 테스트 작성 시 고려해야 할 사항은 무엇인가요?', '단위 테스트는 가능한 한 외부 의존성을 배제하고 순수 함수 기반으로 작성하며, 입력과 출력이 명확한 테스트 케이스를 통해 신뢰성을 확보하는 것이 중요합니다.', 33),
                                                                        ('Snapshot 테스트에서 스냅샷이 자주 깨지는 이유와 해결책은?', '의도치 않은 UI 변경이나 의존성 업데이트로 인해 스냅샷이 자주 변경될 수 있으며, 변경 이유가 명확하지 않다면 코드 변경 내용을 리뷰하고 의도된 변경인 경우 스냅샷을 업데이트해야 합니다.', 33),
                                                                        ('Integration Test 작성 시 주의할 점은 무엇인가요?', '복잡도와 실행 시간이 증가할 수 있으므로 주요 사용자 플로우만 선별하고, 공통 설정 및 Mock 서버 도입 등을 통해 테스트 환경을 제어해야 합니다.', 33),
                                                                        ('테스트 코드를 작성하는 것이 실제 운영 코드보다 중요할 수 있는 이유는?', '테스트 코드는 기능이 변경되더라도 기존 동작을 보장하고 회귀 버그를 방지할 수 있기 때문에, 품질과 유지보수성을 위해 운영 코드만큼 중요하게 다뤄야 합니다.', 33),
                                                                        ('Component 테스트에서 Mocking은 왜 필요하고 어떻게 하나요?', 'Mocking은 외부 API, 데이터베이스, 의존 함수 등을 실제로 호출하지 않고 가짜 동작으로 대체하여 테스트를 독립적이고 빠르게 만들기 위해 사용합니다. Jest에서는 jest.mock() 등을 활용합니다.', 33),
                                                                        ('CI 환경에서 테스트 자동화의 이점은 무엇인가요?', 'CI 환경에서 테스트가 자동으로 실행되면 코드 병합 전 오류를 조기에 발견할 수 있고, 일관된 품질을 유지하면서 개발 속도와 협업 효율이 향상됩니다.', 33),
                                                                        ('E2E 테스트란 무엇이며 어떤 목적을 가지나요?', 'E2E(End-to-End) 테스트는 실제 사용자의 시나리오를 자동화하여 전체 시스템의 흐름이 제대로 작동하는지 확인하는 테스트로, 사용자 경험을 가장 현실적으로 검증할 수 있습니다.', 34),
                                                                        ('Visual Regression Test는 어떤 상황에서 사용하나요?', 'Visual Regression Test는 UI가 변경되었는지 이미지 스냅샷을 비교하여 감지하는 테스트로, 스타일 변경이나 예상치 못한 레이아웃 깨짐 등을 방지할 때 사용됩니다.', 34),
                                                                        ('E2E 테스트와 Unit 테스트의 주요 차이는 무엇인가요?', 'Unit 테스트는 개별 함수나 컴포넌트를 검증하는 반면, E2E 테스트는 전체 사용자 흐름을 실제 환경에서 검증하여 시스템 통합 관점의 신뢰성을 보장합니다.', 34),
                                                                        ('E2E 테스트에서 자주 사용하는 도구는 무엇인가요?', 'Cypress, Playwright, Selenium 등이 대표적인 E2E 테스트 도구로, 사용자 시나리오를 자동화하고 브라우저 상에서의 행동을 시뮬레이션합니다.', 34),
                                                                        ('Visual Regression Test에 사용되는 프레임워크는 무엇이 있나요?', 'Percy, Loki, Chromatic, Storybook의 Visual Test 기능 등은 UI 변경 사항을 이미지 기반으로 자동 비교하는 데 사용됩니다.', 34),
                                                                        ('E2E 테스트 작성 시 고려해야 할 점은 무엇인가요?', '테스트는 실제 사용자 경험을 반영해야 하며, 환경 설정, 테스트 데이터, 인증 흐름 등을 포함하여 신뢰성 있게 자동화될 수 있도록 작성해야 합니다.', 34),
                                                                        ('Visual Regression 테스트에서 false positive를 방지하려면?', '동적 요소 제거, 안정적인 테스트 환경 구성, 이미지 threshold 설정 등을 통해 실제 변경만 감지하고 불필요한 오탐지를 줄일 수 있습니다.', 34),
                                                                        ('E2E 테스트 자동화를 CI/CD에 통합할 때 주의할 점은?', '테스트 실행 시간이 길기 때문에 병렬화하거나 중요 시나리오 위주로 선별 실행하며, 실패 시 빠르게 원인을 파악할 수 있도록 로깅과 스크린샷을 남기는 것이 좋습니다.', 34),
                                                                        ('E2E 테스트의 장점과 단점은 무엇인가요?', '장점은 사용자 시나리오 전체를 검증할 수 있다는 점이고, 단점은 설정이 복잡하고 실행 시간이 길며 불안정할 수 있다는 점입니다.', 34),
                                                                        ('Visual Regression Test를 효율적으로 운영하는 전략은?', '컴포넌트 기반 UI 시스템을 구축하고, Storybook과 연계하여 컴포넌트 단위로 스냅샷을 관리하면 테스트 범위를 축소하고 유지관리가 쉬워집니다.', 34),
                                                                        ('리눅스에서 쉘과 커널의 차이점은 무엇인가요?', '커널은 하드웨어와 사용자 공간을 연결해주는 리눅스 운영체제의 핵심으로, 메모리 관리, 프로세스 스케줄링, 파일 시스템 제어 등 시스템 자원에 대한 접근을 제어합니다. 반면 쉘은 사용자가 명령어를 입력할 수 있도록 해주는 인터페이스이며, 명령어를 해석하여 커널에 전달합니다. 대표적인 쉘로는 bash, zsh, sh 등이 있으며, 커널은 백그라운드에서 실행되고 쉘은 사용자의 입력을 기다리며 동작합니다.', 35),
                                                                        ('리눅스에서 심볼릭 링크와 하드 링크의 차이점은 무엇인가요?', '하드 링크는 동일한 inode를 공유하여 원본 파일과 완전히 동일한 파일을 가리킵니다. 원본이 삭제되어도 하드 링크를 통해 내용에 접근할 수 있습니다. 반면 심볼릭 링크는 원본 파일의 경로를 문자열로 저장한 별도의 파일로, 원본이 삭제되면 링크는 깨집니다. 또한 하드 링크는 디렉토리에 사용할 수 없고 동일한 파일 시스템 내에서만 가능하지만, 심볼릭 링크는 파일 시스템을 넘나들 수 있습니다.', 35),
                                                                        ('리눅스에서 파일 권한은 어떻게 구성되어 있나요?', '리눅스 파일 권한은 소유자(owner), 그룹(group), 기타 사용자(other)로 나뉘며, 각 항목은 읽기(read, r), 쓰기(write, w), 실행(execute, x) 권한을 가집니다. 예를 들어 -rwxr-xr--는 소유자는 읽기, 쓰기, 실행, 그룹은 읽기, 실행, 기타 사용자는 읽기 권한만 있는 상태를 나타냅니다. chmod 명령어를 통해 권한을 숫자(예: 755) 또는 기호 방식으로 변경할 수 있습니다.', 35),
                                                                        ('리눅스에서 background로 실행된 프로세스를 제어하는 방법은?', '명령어 끝에 &를 붙이면 프로세스가 백그라운드에서 실행됩니다. 이후 jobs 명령어로 실행 중인 백그라운드 작업을 확인할 수 있으며, fg %작업번호로 포그라운드로 가져올 수 있습니다. bg 명령어는 일시 중지된 작업을 백그라운드로 재개합니다. kill 또는 kill -9 PID로 프로세스를 종료할 수 있으며, ps나 top으로 PID를 조회할 수 있습니다.', 35),
                                                                        ('리눅스에서 포트를 점유하고 있는 프로세스를 찾는 방법은?', 'lsof -i :포트번호 또는 netstat -tulnp 명령어를 사용하여 해당 포트를 사용하는 프로세스를 찾을 수 있습니다. 예를 들어 lsof -i :8080은 8080 포트를 사용하는 프로세스를 보여주며, netstat은 각 포트와 그에 매핑된 PID를 확인할 수 있습니다. ss 명령어는 netstat보다 빠른 대안으로 사용됩니다.', 35),
                                                                        ('crontab의 구조와 사용법에 대해 설명해주세요.', 'crontab은 리눅스에서 정기적으로 작업을 수행하게 해주는 스케줄링 도구입니다. 형식은 "분 시 일 월 요일 명령어"로 구성되어 있으며, 예를 들어 0 0 * * * /path/to/script.sh 는 매일 자정에 스크립트를 실행합니다. crontab -e 명령어로 등록하고, crontab -l로 확인할 수 있으며, /var/log/cron 또는 /var/log/syslog 파일을 통해 실행 여부를 확인할 수 있습니다.', 35),
                                                                        ('리눅스에서 시스템 부팅 과정은 어떻게 이루어지나요?', '리눅스의 부팅 과정은 BIOS/UEFI → 부트로더(GRUB) → 커널 로드 → init 또는 systemd 실행 순으로 진행됩니다. 부트로더는 커널을 메모리에 올리고 커널은 초기화 과정에서 루트 파일 시스템을 마운트하고 PID 1번 프로세스로 init(systemd)를 실행합니다. 이후 타겟에 따라 필요한 서비스들이 시작되며, 최종적으로 사용자 셸이 활성화되어 로그인할 수 있게 됩니다.', 35),
                                                                        ('리눅스에서 네트워크 설정 확인 및 변경 방법은?', 'ifconfig 또는 ip addr 명령어로 네트워크 인터페이스의 상태를 확인할 수 있으며, ip route로 라우팅 테이블을 확인합니다. 네트워크 설정 변경은 ifconfig 또는 ip 명령어를 통해 임시로 설정 가능하며, /etc/network/interfaces 또는 /etc/netplan/*.yaml 파일에서 영구적으로 설정할 수 있습니다. systemctl restart networking 또는 netplan apply로 설정을 반영합니다.', 35),
                                                                        ('리눅스에서 mount와 umount의 사용 목적과 예시는?', 'mount 명령어는 파일 시스템을 특정 디렉토리에 연결하는 데 사용되며, 예를 들어 mount /dev/sdb1 /mnt는 외장 디스크를 /mnt 디렉토리에 마운트합니다. umount는 해당 연결을 해제하는 명령어입니다. 마운트된 파일 시스템은 /etc/mtab이나 mount 명령어로 확인할 수 있으며, fstab 파일에 설정을 추가하면 시스템 부팅 시 자동으로 마운트됩니다.', 35),
                                                                        ('top 명령어의 주요 항목과 해석 방법은?', 'top 명령어는 실시간으로 CPU, 메모리 등 시스템 자원 사용량과 각 프로세스를 보여주는 도구입니다. 주요 항목으로는 PID(프로세스 ID), USER(사용자), %CPU, %MEM, TIME+(누적 CPU 시간), COMMAND(실행 중인 명령어)가 있습니다. 상단에는 load average, CPU 사용률(us, sy, id 등), 메모리(Swap, RAM) 사용 현황이 표시됩니다. 이를 통해 시스템의 병목 현상이나 과부하 원인을 파악할 수 있습니다.', 35),
                                                                        ('HTTP와 HTTPS의 차이점은 무엇인가요?', 'HTTP는 HyperText Transfer Protocol의 약자로, 웹에서 클라이언트와 서버 간에 데이터를 주고받는 프로토콜입니다. 하지만 암호화되지 않아 중간에서 도청이나 변조가 가능하다는 보안 문제가 있습니다. 반면 HTTPS는 여기에 SSL/TLS를 결합한 프로토콜로, 전송되는 데이터를 암호화하여 보안을 강화합니다. HTTPS는 서버 인증서를 통해 클라이언트와 서버 간의 신뢰를 보장하고, 대칭키 방식으로 데이터를 암호화하여 정보 유출을 방지합니다.', 36),
                                                                        ('DNS는 어떤 역할을 하며 작동 원리는 어떻게 되나요?', 'DNS(Domain Name System)는 사용자가 입력한 도메인 주소를 해당 서버의 IP 주소로 변환해주는 시스템입니다. 사용자가 브라우저에 www.example.com을 입력하면, 먼저 로컬 캐시나 ISP의 DNS 서버에서 IP를 조회하고, 없으면 루트 네임서버 → TLD 네임서버 → 권한 있는 네임서버 순으로 질의하여 최종 IP를 받아옵니다. 이 과정을 통해 사용자는 복잡한 숫자 대신 기억하기 쉬운 도메인으로 서비스를 이용할 수 있습니다.', 36),
                                                                        ('TCP와 UDP의 차이점은 무엇인가요?', 'TCP(Transmission Control Protocol)는 연결지향적 프로토콜로, 데이터 전송 전에 연결을 설정하고 전송된 데이터의 순서와 무결성을 보장합니다. 반면 UDP(User Datagram Protocol)는 비연결형 프로토콜로, 연결 설정 없이 빠르게 데이터를 전송하지만, 순서 보장이나 재전송은 하지 않습니다. TCP는 웹 페이지 로딩이나 파일 전송처럼 신뢰성이 필요한 상황에, UDP는 실시간 스트리밍이나 게임처럼 속도가 중요한 상황에 적합합니다.', 36),
                                                                        ('3-way Handshake 과정에 대해 설명해주세요.', '3-way Handshake는 TCP 연결을 수립할 때 사용하는 세 단계의 통신 과정입니다. 먼저 클라이언트가 SYN 패킷을 서버에 보내고, 서버는 SYN-ACK 패킷으로 응답합니다. 마지막으로 클라이언트가 ACK를 보내면 연결이 성립됩니다. 이 과정을 통해 양쪽 모두 연결을 준비했음을 확인하고, 초기 순서 번호 등을 교환합니다.', 36),
                                                                        ('4-way Handshake 과정은 무엇이며, 어떤 상황에서 사용되나요?', '4-way Handshake는 TCP 연결을 종료할 때 사용됩니다. 클라이언트가 FIN 패킷을 보내 연결 종료를 요청하고, 서버가 ACK로 응답합니다. 이후 서버도 FIN 패킷을 보내며, 클라이언트가 ACK로 응답하면 연결이 종료됩니다. 이 방식은 전이중(Full-duplex) 연결에서 양방향 통신을 모두 종료하기 위해 필요한 절차입니다.', 36),
                                                                        ('OSI 7계층과 TCP/IP 4계층은 어떻게 대응되며 각각 어떤 역할을 하나요?', 'OSI 7계층은 응용, 표현, 세션, 전송, 네트워크, 데이터 링크, 물리 계층으로 구성되며, TCP/IP는 응용, 전송, 인터넷, 네트워크 인터페이스 계층으로 나뉩니다. OSI의 응용~세션은 TCP/IP의 응용 계층에 해당하고, 전송 계층은 동일하며, 네트워크는 인터넷 계층, 데이터 링크와 물리는 네트워크 인터페이스 계층에 대응됩니다. 각각의 계층은 독립적으로 설계되어 기능을 분리하고, 네트워크 통신의 복잡성을 관리합니다.', 36),
                                                                        ('HTTPS는 어떻게 보안을 보장하나요?', 'HTTPS는 SSL/TLS를 통해 통신 데이터를 암호화하여 도청과 변조를 방지합니다. SSL/TLS는 대칭키 암호화를 사용하지만, 세션 키를 교환할 때는 공개키 기반의 비대칭키 암호화를 사용합니다. 서버는 인증서를 통해 자신의 신원을 클라이언트에게 증명하고, 이 인증서는 공인된 CA가 서명하여 신뢰성을 보장합니다. 이렇게 클라이언트와 서버 간에 안전한 채널이 형성되어 데이터가 보호됩니다.', 36),
                                                                        ('IP 주소와 도메인의 관계는 무엇인가요?', 'IP 주소는 인터넷 상의 각 기기를 식별하기 위한 고유한 숫자 주소이며, 도메인은 사람이 기억하기 쉬운 문자열 주소입니다. DNS는 이러한 도메인을 대응되는 IP 주소로 변환하여 통신이 가능하도록 합니다. 예를 들어, www.example.com이라는 도메인은 DNS 질의를 통해 93.184.216.34와 같은 IP 주소로 해석되고, 클라이언트는 해당 IP를 통해 서버와 통신을 수행합니다.', 36),
                                                                        ('라우터와 스위치의 차이점은 무엇인가요?', '스위치는 같은 네트워크 내에서 장비들을 연결하고, MAC 주소 기반으로 데이터 프레임을 전달합니다. 반면 라우터는 서로 다른 네트워크 간의 연결을 담당하며, IP 주소 기반으로 패킷을 전달합니다. 라우터는 게이트웨이 역할을 하며 외부 네트워크와의 통신을 가능하게 하고, 스위치는 내부 네트워크 성능을 향상시키기 위해 사용됩니다.', 36),
                                                                        ('브라우저에 URL을 입력했을 때 일어나는 과정을 설명해주세요.', '브라우저 주소창에 URL을 입력하면, 먼저 DNS를 통해 도메인을 IP 주소로 변환합니다. 이후 해당 IP로 TCP 연결을 수행하기 위해 3-way Handshake가 일어나고, 연결이 완료되면 HTTP/HTTPS 요청이 서버로 전송됩니다. 서버는 요청을 처리한 후 응답을 전송하며, 브라우저는 이를 렌더링하여 웹 페이지를 사용자에게 보여줍니다. 이 과정은 매우 짧은 시간 내에 일어나며, 네트워크, 보안, 렌더링 등의 여러 기술이 함께 작동합니다.', 36),
                                                                        ('GitHub란 무엇인가요?', 'GitHub는 Git 저장소를 온라인에서 호스팅해주는 플랫폼으로, 코드 공유, 협업, 이슈 추적, Pull Request 등을 통해 개발자 간 협업을 원활하게 도와줍니다. 또한 GitHub Actions와 같은 CI/CD 기능도 제공하여 자동화된 배포와 테스트를 수행할 수 있습니다.', 37),
                                                                        ('commit과 push의 차이는 무엇인가요?', 'commit은 로컬 저장소에 변경 사항을 저장하는 작업이며, 메시지를 통해 해당 변경의 목적을 기록합니다. 반면 push는 로컬 저장소의 커밋 내역을 원격 저장소(GitHub 등)로 전송하는 명령으로, 협업을 위해 변경사항을 공유할 때 사용됩니다.', 37),
                                                                        ('브랜치(branch)의 개념과 사용하는 이유는 무엇인가요?', '브랜치는 독립적인 개발 흐름을 만들기 위한 기능으로, 메인 코드에 영향을 주지 않고 기능 개발, 버그 수정 등을 진행할 수 있게 해줍니다. 브랜치를 사용하면 여러 개발자가 동시에 작업할 수 있으며, 완료된 후 병합(merge)을 통해 메인 브랜치에 통합합니다.', 37),
                                                                        ('merge와 rebase의 차이점은 무엇인가요?', 'merge는 두 브랜치의 커밋을 병합하여 새로운 커밋을 생성하는 방식이며, 커밋 히스토리가 분기 형태로 유지됩니다. rebase는 브랜치의 베이스를 옮겨 일직선 형태의 히스토리를 만들며, 커밋 로그가 깔끔해지는 장점이 있지만 충돌 관리가 필요합니다.', 37),
                                                                        ('Git에서 충돌(conflict)은 언제 발생하고 어떻게 해결하나요?', '충돌은 두 브랜치에서 동일한 파일의 동일한 위치를 수정했을 때 발생합니다. Git은 자동 병합을 하지 못하고 수동 해결을 요구합니다. 이 경우 충돌 표시(<<<<<, =====, >>>>> 등)를 기준으로 어느 쪽을 선택할지 편집한 후, add → commit 순으로 해결합니다.', 37),
                                                                        ('Git에서 .gitignore 파일의 역할은 무엇인가요?', '.gitignore 파일은 Git이 추적하지 않아야 할 파일이나 디렉토리를 명시하는 설정 파일입니다. 예를 들어 로그 파일, 빌드 결과물, IDE 설정 파일 등 프로젝트 외부 요소를 무시하도록 하여 저장소를 깔끔하게 유지할 수 있습니다.', 37),
                                                                        ('fork와 clone의 차이는 무엇인가요?', 'fork는 GitHub 상에서 타인의 저장소를 자신의 GitHub 계정으로 복사하여 독립적으로 작업할 수 있도록 하는 기능이며, clone은 로컬 컴퓨터에 원격 저장소를 복제하는 명령입니다. fork는 협업 시, clone은 개발 환경 설정 시 주로 사용됩니다.', 37),
                                                                        ('pull request란 무엇이고 왜 사용하나요?', 'pull request(PR)는 다른 개발자가 작성한 브랜치를 메인 브랜치에 병합해달라고 요청하는 작업입니다. 리뷰와 토론 과정을 거쳐 품질을 보장하고 코드 일관성을 유지할 수 있으며, 팀 협업 시 필수적인 기능입니다.', 37),
                                                                        ('Git의 stash 기능은 무엇인가요?', 'stash는 현재 작업 중인 변경 사항을 임시로 저장해두고 작업 공간을 깨끗이 초기화할 수 있게 해주는 기능입니다. 예를 들어 긴급한 브랜치 변경이 필요한 경우 stash로 현재 작업을 저장하고, 브랜치 전환 후 다시 pop하여 복원할 수 있습니다.', 37),
                                                                        ('Git Hook이란 무엇인가요?', 'Git Hook은 Git의 특정 이벤트가 발생할 때 자동으로 실행되는 스크립트입니다. 예를 들어 커밋 전(pre-commit), 커밋 후(post-commit), 푸시 전(pre-push) 등 다양한 시점에 스크립트를 연결할 수 있어, 자동화된 검사, 포맷팅, 테스트 실행 등 개발 워크플로우를 자동화하는 데 활용됩니다.', 38),
                                                                        ('Husky는 무엇이며 왜 사용하나요?', 'Husky는 Git Hook을 쉽게 설정하고 관리할 수 있도록 도와주는 도구입니다. 복잡한 shell 스크립트를 작성하지 않아도, JavaScript 기반으로 pre-commit, pre-push 등 여러 훅에 간단하게 명령을 등록할 수 있어 프로젝트의 일관된 코드 품질을 유지하는 데 유용합니다.', 38),
                                                                        ('lint-staged는 무엇인가요?', 'lint-staged는 Git stage에 올라간 파일들만 대상으로 린트(lint) 또는 포맷팅 작업을 수행하는 도구입니다. pre-commit 훅과 함께 사용하면, 변경된 파일만 검사하여 성능을 높이고, 불필요한 전체 검사로 인한 시간 낭비를 줄일 수 있습니다.', 38),
                                                                        ('Husky를 설치하고 설정하는 방법은?', 'Husky는 npm 또는 yarn으로 설치한 후, `husky install` 명령어로 Git Hook을 활성화할 수 있습니다. 이후 `husky add .husky/pre-commit "npm test"`와 같이 훅을 생성하고 명령어를 등록하여 사용합니다. package.json에서 prepare 스크립트를 설정하면 설치 후 자동 초기화도 가능합니다.', 38),
                                                                        ('pre-commit 훅에서는 어떤 작업을 수행할 수 있나요?', 'pre-commit 훅에서는 커밋 직전에 실행할 작업을 설정할 수 있습니다. 대표적으로 ESLint를 통한 코드 스타일 검사, Prettier로 코드 포맷 정리, Jest 같은 테스트 도구 실행, 타입 체크 등을 통해 코드 품질을 사전에 보장할 수 있습니다.', 38),
                                                                        ('pre-push 훅은 어떤 상황에 유용한가요?', 'pre-push 훅은 커밋 내용을 원격 저장소에 푸시하기 전에 실행됩니다. 주요 사용 예로는 전체 테스트 실행, 빌드 성공 여부 확인, 배포 환경 조건 체크 등이 있으며, 품질 기준을 충족하지 못한 코드를 푸시하지 않도록 막는 데 유용합니다.', 38),
                                                                        ('lint-staged는 어떤 방식으로 작동하나요?', 'lint-staged는 Git의 staged 상태에 있는 파일 목록을 받아와, 설정된 확장자나 경로에 따라 명령어를 실행합니다. 예: `"*.ts": "eslint --fix"`와 같이 설정하면 커밋 직전 변경된 .ts 파일만 ESLint로 자동 포맷팅할 수 있습니다.', 38),
                                                                        ('Git Hook 자동화를 통해 얻는 이점은 무엇인가요?', 'Git Hook 자동화를 통해 실수나 스타일 일관성 문제를 사전에 차단할 수 있어 코드 품질을 유지할 수 있습니다. 팀 내 규칙을 코드 레벨에서 자동으로 강제할 수 있으며, 리뷰어의 반복적인 피드백을 줄여 생산성과 협업 효율을 높일 수 있습니다.', 38),
                                                                        ('Husky와 lint-staged를 함께 사용할 때의 시너지는?', 'Husky는 Git Hook 트리거를 관리하고, lint-staged는 변경된 파일만을 대상으로 린팅 및 포맷팅을 수행합니다. 이 둘을 함께 사용하면 최소한의 연산으로 최대한의 품질 검사를 할 수 있어, 커밋 속도는 빠르게 유지하면서도 코드 기준을 자동으로 적용할 수 있습니다.', 38),
                                                                        ('Git Hook 설정 시 주의할 점은 무엇인가요?', 'Git Hook은 개발자의 로컬 환경에만 적용되므로, 팀원 간 설정이 일치하지 않으면 동작이 다를 수 있습니다. 이를 방지하기 위해 Husky 설치 및 설정은 package.json과 함께 관리하고, `prepare` 스크립트를 통해 자동화해야 합니다. 또한 너무 많은 작업을 pre-commit에 몰아넣으면 개발 흐름을 방해할 수 있으므로 적절한 분배가 필요합니다.', 38),
                                                                        ('Java의 플랫폼 독립성이란 무엇인가요?', 'Java의 플랫폼 독립성은 "Write Once, Run Anywhere"라는 철학에 기반합니다. 자바 소스 코드는 JVM(Java Virtual Machine)을 위한 바이트코드(.class)로 컴파일되며, JVM은 각 운영체제에 맞게 구현되어 있어 동일한 바이트코드를 어떤 플랫폼에서든 실행할 수 있습니다. 이 덕분에 Java 프로그램은 OS에 상관없이 호환성과 이식성이 뛰어납니다.', 39),
                                                                        ('Java의 객체지향 4대 특성은 무엇이며 각각을 설명해주세요.', 'Java는 대표적인 객체지향 언어로 캡슐화, 상속, 다형성, 추상화의 4대 특성을 가집니다. 캡슐화는 데이터를 외부로부터 보호하며, 상속은 기존 클래스를 확장해 코드 재사용을 가능하게 합니다. 다형성은 하나의 메서드나 객체가 다양한 형태로 동작하게 하며, 추상화는 복잡한 로직을 숨기고 필요한 인터페이스만 외부에 제공해 설계를 단순화합니다.', 39),
                                                                        ('Java에서 static 키워드의 의미는 무엇인가요?', 'static 키워드는 클래스 레벨에서 메모리를 공유하고자 할 때 사용됩니다. static으로 선언된 변수나 메서드는 인스턴스화 없이 클래스명으로 접근할 수 있으며, 클래스 로딩 시 메모리에 할당됩니다. 예를 들어 static 변수는 모든 인스턴스가 동일한 값을 공유하고, static 메서드는 객체 상태와 무관한 유틸성 기능을 구현할 때 유용합니다.', 39),
                                                                        ('Java에서 예외 처리 방식은 어떻게 되나요?', 'Java는 예외 처리를 위해 try-catch-finally 구조와 throws 키워드를 제공합니다. try 블록에 예외가 발생할 수 있는 코드를 작성하고, catch 블록에서 예외를 처리하며, finally는 예외 발생 여부와 상관없이 반드시 실행됩니다. Java는 Checked Exception과 Unchecked Exception으로 구분하며, Checked Exception은 컴파일 시 반드시 처리해야 합니다.', 39),
                                                                        ('Java의 컬렉션 프레임워크에는 어떤 것들이 있나요?', 'Java의 컬렉션 프레임워크는 데이터를 효율적으로 저장하고 관리하기 위한 구조들을 제공합니다. 대표적으로 List (ArrayList, LinkedList), Set (HashSet, TreeSet), Map (HashMap, TreeMap)이 있으며, 각 자료구조는 저장 방식, 정렬 여부, 중복 허용 여부 등에 따라 다르게 사용됩니다. 예를 들어, HashMap은 키-값 쌍 저장에 적합하고, ArrayList는 순차적 데이터 처리에 효과적입니다.', 39),
                                                                        ('Java의 가비지 컬렉션(GC)은 어떻게 동작하나요?', 'Java의 가비지 컬렉션은 더 이상 참조되지 않는 객체를 자동으로 메모리에서 제거하여 메모리 누수를 방지합니다. JVM의 GC는 주기적으로 Heap 영역을 스캔하고, 참조되지 않는 객체를 수집합니다. 주요 알고리즘에는 Mark and Sweep, Generational GC 등이 있으며, 최근에는 G1 GC, ZGC 등도 사용됩니다. 개발자는 명시적으로 객체를 해제할 필요 없이 메모리 관리를 자동화할 수 있습니다.', 39),
                                                                        ('Java의 인터페이스와 추상 클래스의 차이점은?', '인터페이스는 모든 메서드가 기본적으로 추상적이며, 다중 상속이 가능하고, 구현 클래스가 반드시 모든 메서드를 오버라이딩해야 합니다. 추상 클래스는 일반 메서드와 추상 메서드를 혼합해서 가질 수 있으며, 상태(필드)를 가질 수 있습니다. 인터페이스는 행동(기능)의 명세에, 추상 클래스는 공통된 로직의 상속에 적합합니다.', 39),
                                                                        ('Java에서 제네릭(Generic)을 사용하는 이유는 무엇인가요?', '제네릭은 클래스나 메서드에서 사용할 데이터 타입을 파라미터화하여, 컴파일 시 타입 안정성을 제공하고 형변환을 줄일 수 있게 합니다. 예를 들어 List<String>은 문자열만 저장할 수 있도록 보장하며, 타입 불일치에 대한 오류를 컴파일 타임에 잡을 수 있습니다. 제네릭을 통해 코드의 재사용성과 안정성을 높일 수 있습니다.', 39),
                                                                        ('Java에서 쓰레드는 어떻게 생성하고 동작하나요?', 'Java에서 쓰레드는 Thread 클래스를 상속하거나 Runnable 인터페이스를 구현하여 생성합니다. Thread 객체의 start() 메서드를 호출하면 새로운 쓰레드가 생성되고 run() 메서드가 실행됩니다. 쓰레드는 병렬로 작업을 처리할 수 있게 해주며, 동기화 문제를 피하기 위해 synchronized 키워드나 Lock 객체를 사용할 수 있습니다.', 39),
                                                                        ('Java에서 JVM의 구조와 역할은 무엇인가요?', 'JVM(Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 머신으로, 클래스 로더, 메모리 영역(Heap, Stack, Method Area 등), 실행 엔진, 가비지 컬렉터로 구성됩니다. 클래스 로더는 클래스를 로딩하고, 실행 엔진은 바이트코드를 해석하거나 JIT 컴파일을 통해 실행하며, 가비지 컬렉터는 메모리를 자동 관리합니다. JVM 덕분에 Java는 플랫폼 독립성과 보안성을 가질 수 있습니다.', 39),
                                                                        ('파이썬의 주요 특징은 무엇인가요?', '파이썬은 간결하고 읽기 쉬운 문법을 가진 고급 프로그래밍 언어입니다. 인터프리터 언어로, 플랫폼에 상관없이 실행 가능하며, 동적 타이핑과 자동 메모리 관리를 지원합니다. 객체지향, 절차지향, 함수형 프로그래밍을 모두 지원하고, 방대한 표준 라이브러리와 서드파티 패키지를 활용할 수 있어 웹 개발, 데이터 분석, 인공지능, 자동화 등 다양한 분야에 사용됩니다.', 40),
                                                                        ('파이썬에서 리스트와 튜플의 차이점은?', '리스트(List)는 변경 가능한(mutable) 시퀀스 자료형으로, 요소를 추가, 삭제, 수정할 수 있습니다. 반면 튜플(Tuple)은 변경 불가능한(immutable) 자료형으로, 생성 후 내부 값을 바꿀 수 없습니다. 리스트는 대괄호 []로, 튜플은 소괄호 ()로 정의하며, 튜플은 변경이 불가능하므로 해시 가능한 키로 사용될 수 있다는 장점이 있습니다.', 40),
                                                                        ('파이썬의 함수 정의와 호출 방식은?', '파이썬에서는 def 키워드를 사용하여 함수를 정의합니다. 예: def add(a, b): return a + b. 함수는 이름으로 호출하며, 위치 인자, 키워드 인자, 기본값 인자, 가변 인자(*args, **kwargs) 등을 지원합니다. 파이썬의 함수는 일급 객체로, 변수에 할당하거나 인자로 전달할 수 있으며, 람다(lambda)를 사용하여 익명 함수도 정의할 수 있습니다.', 40),
                                                                        ('파이썬의 클래스와 self 키워드의 역할은?', '파이썬에서 클래스는 객체 지향 프로그래밍을 구현하기 위한 구조이며, 클래스 내 메서드는 반드시 첫 번째 인자로 self를 받아야 합니다. self는 현재 인스턴스를 가리키며, 클래스 내 속성 및 메서드에 접근할 수 있게 해줍니다. 생성자는 __init__ 메서드로 정의되며, 객체 생성 시 자동으로 호출되어 초기화를 수행합니다.', 40),
                                                                        ('파이썬에서 예외 처리 방법은?', '파이썬은 try-except 블록을 사용해 예외를 처리합니다. 예를 들어 try: ... except ZeroDivisionError: ... 구문으로 특정 예외를 처리하고, except Exception as e: 를 통해 일반적인 예외를 포괄적으로 처리할 수 있습니다. finally 블록은 예외 발생 여부와 관계없이 항상 실행되며, raise 키워드를 사용해 예외를 수동으로 발생시킬 수 있습니다.', 40),
                                                                        ('파이썬의 리스트 컴프리헨션이란?', '리스트 컴프리헨션은 기존 리스트를 기반으로 간결하게 새로운 리스트를 생성하는 문법입니다. 예: [x * 2 for x in range(5) if x % 2 == 0]은 0~4까지의 수 중 짝수만 2배로 만들어 리스트를 생성합니다. 코드 가독성과 성능이 향상되며, set이나 dict에서도 응용 가능합니다.', 40),
                                                                        ('파이썬에서 데코레이터의 개념과 사용법은?', '데코레이터는 함수를 감싸는 함수로, 기존 함수의 동작을 확장하거나 수정할 수 있습니다. @decorator 형식으로 함수 위에 선언하며, 로깅, 접근 제어, 캐싱 등에 사용됩니다. 내부적으로는 고차 함수와 클로저를 활용하여 구현되며, functools.wraps를 사용해 원래 함수의 메타데이터를 유지할 수 있습니다.', 40),
                                                                        ('파이썬의 GIL(Global Interpreter Lock)이란?', 'GIL은 파이썬 인터프리터(CPython)에서 동시에 하나의 쓰레드만 실행되도록 제한하는 잠금 메커니즘입니다. 멀티쓰레딩 환경에서도 한 번에 하나의 쓰레드만 바이트코드를 실행할 수 있어 CPU 바운드 작업에서는 성능이 저하될 수 있습니다. 이를 보완하기 위해 multiprocessing 모듈을 사용해 프로세스를 병렬로 실행하거나, C 확장을 사용해 병렬 처리 성능을 향상시킬 수 있습니다.', 40),
                                                                        ('파이썬에서 모듈과 패키지의 차이는?', '모듈은 .py 확장자를 가진 파이썬 파일로, 변수, 함수, 클래스 등을 정의할 수 있는 단위입니다. 패키지는 __init__.py 파일이 포함된 디렉토리로, 여러 모듈을 계층적으로 구성해 관리할 수 있도록 합니다. import 문을 통해 모듈이나 패키지를 로드할 수 있으며, from ... import ... 형식으로 특정 객체만 가져올 수도 있습니다.', 40),
                                                                        ('파이썬에서 with 구문의 사용 목적은?', 'with 구문은 컨텍스트 매니저(Context Manager)를 통해 자원 해제를 자동으로 처리하는 구조입니다. 예를 들어 파일 입출력 시 with open(\'file.txt\', \'r\') as f: 와 같이 사용하면, 작업이 끝난 후 파일이 자동으로 닫힙니다. 내부적으로 __enter__와 __exit__ 메서드를 구현한 객체를 사용하여 리소스 누수를 방지합니다.', 40),
                                                                        ('JavaScript란 무엇인가요?', 'JavaScript는 웹 브라우저에서 동적으로 동작하는 기능을 구현하기 위한 객체 기반의 스크립트 언어입니다. HTML과 CSS가 각각 콘텐츠와 스타일을 담당한다면, JavaScript는 사용자 인터랙션, DOM 조작, 이벤트 처리, 비동기 통신 등을 담당하여 웹 페이지를 동적으로 만듭니다.', 41),
                                                                        ('var, let, const의 차이는 무엇인가요?', 'var는 함수 스코프를 가지며, 호이스팅될 때 undefined로 초기화됩니다. let과 const는 블록 스코프를 가지며, 호이스팅은 되지만 TDZ(Temporal Dead Zone) 때문에 선언 전에 접근할 수 없습니다. const는 재할당이 불가능하여 상수로 사용됩니다.', 41),
                                                                        ('JavaScript의 호이스팅이란 무엇인가요?', '호이스팅은 변수나 함수 선언이 코드 실행 전에 해당 스코프의 최상단으로 끌어올려지는 JavaScript의 동작 방식입니다. var 변수는 undefined로 초기화되며 호이스팅되고, 함수 선언문은 전체 함수가 끌어올려집니다. 반면 let, const는 TDZ로 인해 선언 전에 접근 시 ReferenceError가 발생합니다.', 41),
                                                                        ('== 와 === 의 차이는 무엇인가요?', '==는 느슨한 동등 비교로 타입이 다르면 타입을 강제로 변환한 후 비교합니다. 반면 ===는 엄격한 동등 비교로 타입과 값이 모두 일치해야 true를 반환합니다. 일반적으로 예기치 않은 타입 변환을 방지하기 위해 === 사용이 권장됩니다.', 41),
                                                                        ('클로저(Closure)란 무엇인가요?', '클로저는 함수가 선언될 당시의 렉시컬 환경을 기억하여, 함수 외부에서 정의된 변수에 접근할 수 있는 기능입니다. 클로저는 데이터 은닉, private 변수 구현, 상태 유지 등에 활용되며, 자바스크립트의 고급 기능 중 하나입니다.', 41),
                                                                        ('this 키워드는 무엇을 가리키나요?', 'this는 함수가 호출되는 방식에 따라 동적으로 결정됩니다. 일반 함수에서는 전역 객체(window)를, 객체의 메서드에서는 해당 객체를 가리킵니다. 화살표 함수는 this를 렉시컬하게 결정하여 상위 스코프의 this를 그대로 사용합니다.', 41),
                                                                        ('이벤트 버블링과 캡처링이란 무엇인가요?', '이벤트 버블링은 이벤트가 가장 깊은 요소에서 발생해 상위 요소로 전파되는 방식이고, 캡처링은 반대로 최상위 요소에서 시작하여 타겟 요소까지 내려가는 방식입니다. addEventListener에서 세 번째 인자를 true로 설정하면 캡처링 단계에서 이벤트를 처리할 수 있습니다.', 41),
                                                                        ('Promise란 무엇이며 왜 사용하나요?', 'Promise는 비동기 작업의 완료 또는 실패를 나타내는 객체로, 콜백 지옥을 해결하고 코드의 가독성을 높입니다. then(), catch(), finally()를 사용하여 비동기 로직을 체계적으로 구성할 수 있으며, async/await 구문과 함께 사용되면 더욱 직관적인 코드 구성이 가능합니다.', 41),
                                                                        ('async/await는 어떻게 동작하나요?', 'async 함수는 항상 Promise를 반환하며, 내부에서 await 키워드를 사용하여 Promise가 해결될 때까지 대기합니다. 이는 비동기 코드를 마치 동기 코드처럼 작성할 수 있게 해주어 가독성을 높이고 예외 처리를 try/catch로 통일할 수 있습니다.', 41),
                                                                        ('DOM이란 무엇이며 어떻게 조작하나요?', 'DOM(Document Object Model)은 HTML 문서를 객체로 표현한 구조로, JavaScript를 통해 문서 구조를 동적으로 조작할 수 있게 해줍니다. document.querySelector, getElementById 등의 메서드로 요소를 선택하고, innerText, classList, setAttribute 등의 속성을 통해 수정할 수 있습니다.', 41),
                                                                        ('Kotlin의 주요 특징은 무엇인가요?', 'Kotlin은 간결함, 안전성, 상호운용성, 함수형 프로그래밍 지원이라는 특징을 가진 현대적인 언어입니다. Java보다 코드가 간결하며, NullPointerException을 방지하기 위한 안전한 null 처리, 고차 함수 및 람다식 등을 지원해 함수형 프로그래밍이 가능합니다. 또한 Java와 100% 호환되어 기존 Java 코드와 함께 사용할 수 있어 Android 개발 및 서버 개발에 적합합니다.', 42),
                                                                        ('Kotlin에서 null 안전성은 어떻게 보장되나요?', 'Kotlin은 Nullable과 Non-nullable 타입을 명시적으로 구분하여 컴파일 타임에 null 가능성을 체크합니다. 예를 들어 String은 null을 허용하지 않지만 String?은 null을 허용합니다. 안전 호출 연산자(?.), 엘비스 연산자(?:), !! 연산자를 통해 null을 안전하게 처리할 수 있으며, 이로 인해 NullPointerException 발생 가능성을 크게 줄일 수 있습니다.', 42),
                                                                        ('Kotlin과 Java의 주요 문법 차이는?', 'Kotlin은 Java보다 간결한 문법을 제공합니다. 변수 선언 시 val(불변)과 var(가변) 키워드를 사용하며, 세미콜론이 필요 없습니다. 게터/세터, 데이터 클래스, 람다식, 스마트 캐스트 등의 기능을 통해 생산성과 안정성을 높입니다. 또한 함수형 프로그래밍 스타일을 지원하고, Null 안전성을 문법 수준에서 제공합니다.', 42),
                                                                        ('Kotlin의 data class는 무엇이며 언제 사용하나요?', 'data class는 데이터를 저장하기 위한 클래스로, equals(), hashCode(), toString(), copy(), componentN() 메서드를 자동 생성해줍니다. 주로 DTO(Data Transfer Object)나 간단한 데이터 보관 객체에 사용되며, 클래스 선언 시 최소 하나 이상의 프로퍼티가 필요합니다. 예: data class User(val name: String, val age: Int)', 42),
                                                                        ('Kotlin의 고차 함수란?', '고차 함수는 함수를 인자로 받거나 반환하는 함수입니다. Kotlin에서는 함수가 일급 객체로 취급되어 변수에 할당하거나 인자로 전달할 수 있습니다. 예: fun operate(x: Int, y: Int, op: (Int, Int) -> Int): Int { return op(x, y) }. 고차 함수는 코드 재사용성과 가독성을 높이며 함수형 프로그래밍 스타일을 구현할 수 있게 해줍니다.', 42),
                                                                        ('Kotlin의 확장 함수(Extension Function)란?', '확장 함수는 기존 클래스에 새로운 함수를 추가하는 기능으로, 클래스 원본을 수정하지 않고도 기능을 확장할 수 있습니다. 클래스 이름.함수 형식으로 정의되며, this 키워드를 통해 수신 객체에 접근할 수 있습니다. 예: fun String.lastChar(): Char = this.get(this.length - 1). 확장 함수는 유틸성 함수를 정의할 때 유용하게 사용됩니다.', 42),
                                                                        ('Kotlin에서 lateinit과 lazy의 차이는?', 'lateinit은 var에만 사용할 수 있으며, 나중에 초기화되는 프로퍼티에 사용됩니다. 주로 의존성 주입이나 Android View 바인딩에서 사용됩니다. 반면 lazy는 val에만 사용되며, 최초 접근 시 초기화되어 이후에는 캐싱됩니다. lazy는 지연 초기화가 필요하고 값이 변하지 않는 경우에 적합합니다.', 42),
                                                                        ('Kotlin의 sealed class는 무엇이며 어떤 경우에 사용하나요?', 'sealed class는 클래스 계층의 제한된 집합을 정의할 수 있는 추상 클래스입니다. 같은 파일 내에서만 하위 클래스를 정의할 수 있어 when 식을 사용할 때 모든 경우를 컴파일러가 검사할 수 있습니다. 상태나 이벤트 모델링 등에 활용되며, 안전하고 명확한 분기 처리를 가능하게 해줍니다.', 42),
                                                                        ('Kotlin에서 companion object의 역할은?', 'companion object는 클래스 내부에 정의된 싱글턴 객체로, Java의 static 멤버처럼 동작합니다. 클래스 인스턴스 없이 접근 가능한 정적 멤버를 선언할 수 있으며, factory 메서드 패턴, 상수 정의 등에 사용됩니다. 예: companion object { const val VERSION = "1.0" }', 42),
                                                                        ('Kotlin Coroutine은 무엇이며 왜 사용하는가?', 'Coroutine은 Kotlin에서 제공하는 경량 스레드로, 비동기 작업을 보다 간결하고 효율적으로 처리할 수 있게 합니다. suspend 키워드를 사용해 중단 가능한 함수를 정의하며, launch, async 등의 빌더를 통해 Coroutine을 실행합니다. 기존의 콜백 기반 비동기 처리보다 가독성이 뛰어나고, 코드 흐름이 직관적이며, 메모리 사용도 효율적입니다.', 42),
                                                                        ('SQL의 DDL, DML, DCL은 각각 어떤 역할을 하나요?', 'SQL은 크게 세 가지 분류로 나뉩니다. DDL(Data Definition Language)은 CREATE, ALTER, DROP 등을 포함하며 데이터베이스 객체의 구조를 정의합니다. DML(Data Manipulation Language)은 SELECT, INSERT, UPDATE, DELETE 등으로 데이터를 조회하고 조작합니다. DCL(Data Control Language)은 GRANT, REVOKE 등으로 사용자 권한을 관리합니다. 각 역할은 데이터베이스 시스템 내에서 구조 설계, 데이터 조작, 접근 제어를 나눠서 수행하는 데 사용됩니다.', 43),
                                                                        ('SELECT 문에서 WHERE 절과 HAVING 절의 차이는?', 'WHERE 절은 SELECT, UPDATE, DELETE 문에서 레코드를 필터링할 때 사용되며, 그룹핑 이전 단계에서 동작합니다. 반면 HAVING 절은 GROUP BY 이후 집계된 결과에 조건을 걸 때 사용됩니다. 예를 들어 특정 조건을 만족하는 개별 레코드를 찾을 때는 WHERE을, 그룹별 평균이나 합계에 조건을 걸 때는 HAVING을 사용합니다.', 43),
                                                                        ('JOIN에는 어떤 종류가 있으며 차이점은?', 'SQL JOIN은 두 개 이상의 테이블을 연결하여 데이터를 조회하는 데 사용되며, INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN이 있습니다. INNER JOIN은 양쪽 테이블에 공통된 키가 있을 때만 결과를 반환하고, LEFT/RIGHT JOIN은 한쪽 테이블의 모든 행과 매칭되는 행을 포함합니다. FULL OUTER JOIN은 양쪽 모두의 모든 행을 포함합니다.', 43),
                                                                        ('SQL에서 인덱스(Index)의 역할과 장단점은?', '인덱스는 테이블 내 데이터를 빠르게 조회할 수 있도록 도와주는 자료구조입니다. SELECT 성능을 향상시키지만, INSERT, UPDATE, DELETE와 같은 쓰기 작업에는 오버헤드가 발생합니다. 또한, 인덱스는 추가적인 저장 공간을 차지합니다. 적절한 인덱스 설계는 조회 성능을 높이는 데 매우 중요합니다.', 43),
                                                                        ('GROUP BY와 ORDER BY의 차이는?', 'GROUP BY는 동일한 값을 가진 행들을 그룹화하여 집계 함수(SUM, AVG, COUNT 등)와 함께 사용합니다. 반면 ORDER BY는 결과 집합을 하나의 기준 열 또는 여러 열 기준으로 정렬하는 데 사용됩니다. GROUP BY는 데이터를 요약하는 데, ORDER BY는 결과를 정렬하는 데 목적이 있습니다.', 43),
                                                                        ('서브쿼리(Subquery)와 조인(JOIN)의 차이점은?', '서브쿼리는 다른 쿼리 안에 포함된 쿼리로, SELECT, FROM, WHERE 절 등에 사용할 수 있습니다. 조인은 여러 테이블을 동시에 병합하여 결과를 반환하는 방식입니다. 성능 측면에서 서브쿼리는 읽기 쉬우나 복잡한 경우 비효율적일 수 있으며, 조인은 대량 데이터를 처리할 때 더 효과적입니다. 상황에 따라 적절한 방식 선택이 중요합니다.', 43),
                                                                        ('SQL의 트랜잭션(TRANSACTION)이란?', '트랜잭션은 하나의 논리적 작업 단위를 의미하며, 작업이 모두 성공하거나 하나라도 실패 시 전체 작업을 되돌리는 원자성을 보장합니다. BEGIN, COMMIT, ROLLBACK 문으로 트랜잭션을 제어하며, 일관성, 격리성, 지속성(ACID 특성)을 충족시켜 데이터 무결성을 유지합니다.', 43),
                                                                        ('SQL에서 NULL 값은 어떻게 처리되나요?', 'NULL은 값이 없음을 의미하며, = 연산자로 비교할 수 없습니다. IS NULL 또는 IS NOT NULL을 사용해 비교합니다. 집계 함수는 NULL을 무시하고 처리되며, COALESCE 함수로 NULL 값을 다른 기본값으로 대체할 수 있습니다. NULL 처리에 주의하지 않으면 조건 비교나 집계 결과에서 예기치 않은 결과가 발생할 수 있습니다.', 43),
                                                                        ('VIEW는 무엇이며 언제 사용하나요?', 'VIEW는 하나 이상의 테이블에서 SELECT한 결과를 가상 테이블 형태로 저장한 것입니다. 실제 데이터를 저장하지 않으며, 보안성 향상, 쿼리 재사용, 복잡한 조합의 단순화 등을 위해 사용됩니다. VIEW를 통해 민감한 컬럼을 숨기거나 비즈니스 로직에 따라 데이터를 가공하여 제공할 수 있습니다.', 43),
                                                                        ('SQL에서 EXISTS와 IN의 차이점은?', 'EXISTS는 서브쿼리의 결과가 존재하는지만 확인하고, IN은 서브쿼리 결과에 특정 값이 포함되어 있는지 비교합니다. EXISTS는 조건을 만족하는 첫 번째 레코드를 찾으면 즉시 TRUE를 반환하므로 대규모 서브쿼리에서 성능이 우수할 수 있습니다. 반면 IN은 전체 결과 집합을 비교하므로 소규모 데이터에서 간결하게 사용할 수 있습니다.', 43),
                                                                        ('관계형 데이터베이스(RDB)와 NoSQL 데이터베이스의 차이점은?', '관계형 데이터베이스는 정형화된 스키마를 기반으로 데이터를 테이블 형식으로 저장하며, SQL을 통해 데이터를 관리합니다. ACID 특성을 보장하여 데이터 무결성과 일관성을 유지하는 데 강점이 있습니다. NoSQL은 스키마가 유연하고, Key-Value, 문서(Document), 컬럼(Column), 그래프(Graph) 등 다양한 모델을 제공합니다. 대용량 데이터 처리, 수평적 확장성, 빠른 응답성이 필요한 경우에 적합합니다.', 44),
                                                                        ('정규화(Normalization)란 무엇이며, 그 목적은?', '정규화는 데이터베이스 설계 시 중복을 최소화하고 데이터 무결성을 보장하기 위해 테이블을 구조화하는 과정입니다. 일반적으로 제1정규형(1NF)부터 제3정규형(3NF) 또는 BCNF까지 적용되며, 이를 통해 삽입, 삭제, 갱신 이상(anomaly)을 방지할 수 있습니다. 정규화는 데이터 일관성 유지와 저장 공간 최적화를 도와줍니다.', 44),
                                                                        ('비정규화(Denormalization)는 언제 사용하나요?', '비정규화는 정규화를 일부 해제하여 성능을 개선하고자 할 때 사용됩니다. 정규화된 데이터는 조인을 많이 요구하여 조회 성능이 떨어질 수 있는데, 이를 줄이기 위해 데이터를 중복 저장하거나 테이블을 병합하는 방식으로 비정규화를 적용합니다. 주로 조회 성능이 중요한 시스템에서 사용되며, 쓰기 작업 시 데이터 일관성 관리가 중요해집니다.', 44),
                                                                        ('CAP 이론이란 무엇이고 각 요소는 무엇을 의미하나요?', 'CAP 이론은 분산 시스템에서 일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition Tolerance) 중 두 가지만 동시에 보장할 수 있다는 이론입니다. Consistency는 모든 노드에서 동일한 데이터를 보장하는 것이고, Availability는 요청이 항상 응답을 받는 성질, Partition Tolerance는 네트워크 분할 상황에서도 시스템이 동작하는 성질을 의미합니다. NoSQL 시스템 설계 시 중요한 고려사항입니다.', 44),
                                                                        ('ACID 특성에 대해 설명해주세요.', 'ACID는 트랜잭션의 안정성과 무결성을 보장하기 위한 4가지 속성입니다. Atomicity(원자성)는 트랜잭션의 모든 작업이 전부 수행되거나 전혀 수행되지 않아야 함을, Consistency(일관성)는 트랜잭션 수행 전후에 데이터베이스가 일관된 상태를 유지해야 함을, Isolation(격리성)은 동시에 실행되는 트랜잭션이 서로 간섭하지 않아야 함을, Durability(지속성)는 트랜잭션이 완료된 후 그 결과가 영구적으로 저장되어야 함을 의미합니다.', 44),
                                                                        ('MongoDB의 특징과 사용 사례는?', 'MongoDB는 문서 지향(Document-Oriented) NoSQL 데이터베이스로, 유연한 스키마 구조를 가진 JSON(BSON) 형식의 문서를 저장합니다. 대규모 비정형 데이터 처리에 강하며, 수평 확장이 쉬워 분산 처리에 적합합니다. 빠른 개발 속도와 스키마 유연성 덕분에 채팅, IoT, 로그 분석, 콘텐츠 저장 등의 분야에서 자주 사용됩니다.', 44),
                                                                        ('Redis는 어떤 데이터베이스이며, 주로 어떤 용도에 사용되나요?', 'Redis는 메모리 기반의 Key-Value NoSQL 데이터베이스로, 매우 빠른 속도를 제공하는 것이 특징입니다. 문자열, 리스트, 해시, 집합, 정렬된 집합 등의 다양한 데이터 구조를 지원하며, 캐싱, 세션 저장, 실시간 분석, 순위표 구현 등에 자주 사용됩니다. 또한 퍼블리시/서브스크라이브(pub/sub) 기능으로 메시지 큐로도 활용됩니다.', 44),
                                                                        ('Index와 Partitioning은 어떤 차이가 있나요?', 'Index는 특정 컬럼을 기준으로 정렬된 포인터 목록을 생성하여 데이터 조회 성능을 높이는 기법입니다. 반면 Partitioning은 테이블 자체를 물리적으로 여러 파티션으로 나누어 저장하고, 각 파티션에 대해 병렬적으로 데이터를 처리할 수 있게 해 성능을 향상시킵니다. 인덱스는 빠른 검색에, 파티셔닝은 대용량 데이터 처리와 관리에 유리합니다.', 44),
                                                                        ('샤딩(Sharding)이란 무엇이며 언제 필요한가요?', '샤딩은 데이터를 여러 서버에 분산 저장하여 확장성과 성능을 향상시키는 수평적 확장 방식입니다. 각 샤드는 전체 데이터의 일부만을 저장하며, 특정 키 또는 해시값 기준으로 샤드가 결정됩니다. 대규모 트래픽 처리나 데이터가 매우 커서 하나의 서버로 감당이 어려운 경우에 적용됩니다.', 44),
                                                                        ('Document 기반 NoSQL과 Column 기반 NoSQL의 차이는?', 'Document 기반 NoSQL(DB)은 MongoDB처럼 JSON 또는 BSON 형식의 문서를 저장하며, 데이터 구조가 유연하고 중첩된 데이터를 처리하기 용이합니다. 반면 Column 기반 NoSQL(DB)은 Cassandra, HBase 등에서 사용되며, 각 컬럼 패밀리 단위로 데이터를 저장하여 특정 컬럼 기반 쿼리에 최적화되어 있습니다. Document DB는 유연한 모델링에, Column DB는 빠른 집계 연산에 적합합니다.', 44),
                                                                        ('데이터베이스에서 스케일 업(Scale-Up)과 스케일 아웃(Scale-Out)의 차이는?', '스케일 업은 기존 서버의 성능(CPU, RAM, 디스크 등)을 업그레이드하여 처리 능력을 높이는 방식이며, 구조 변경이 적고 구현이 간단하지만 하드웨어 한계에 부딪힐 수 있습니다. 반면 스케일 아웃은 서버를 여러 대로 분산시켜 부하를 분산하는 방식으로, 수평 확장성이 뛰어나지만 분산 처리와 데이터 일관성 관리가 복잡해질 수 있습니다.', 45),
                                                                        ('쿼리 튜닝(Query Tuning)이란 무엇이며, 어떤 방식으로 수행되나요?', '쿼리 튜닝은 SQL 성능을 개선하기 위해 쿼리를 최적화하는 과정입니다. 주요 방법에는 실행 계획(Explain Plan) 분석, 인덱스 활용 여부 확인, 불필요한 서브쿼리 제거, 조인 순서 최적화, LIMIT/WHERE 조건 사용 등이 있습니다. 튜닝을 통해 처리 속도를 높이고 시스템 자원 소모를 줄일 수 있습니다.', 45),
                                                                        ('정규화의 장점과 단점은 무엇인가요?', '정규화는 데이터 중복을 제거하고 무결성을 유지하며 저장 공간을 절약할 수 있는 장점이 있습니다. 반면 높은 정규화 수준에서는 테이블 수가 많아지고 조인 연산이 증가하여 조회 성능이 저하될 수 있습니다. 따라서 성능 요구사항에 따라 비정규화도 함께 고려해야 합니다.', 45),
                                                                        ('데이터베이스에서 인덱스(Index)를 사용할 때 주의할 점은?', '인덱스는 검색 속도를 향상시키지만, 너무 많은 인덱스를 생성하면 INSERT, UPDATE, DELETE 시 오버헤드가 증가합니다. 또한 인덱스가 자주 수정되는 컬럼에 적용되면 성능이 오히려 저하될 수 있습니다. 따라서 조회 빈도가 높고 조건절에 자주 사용되는 컬럼에만 인덱스를 적용하는 것이 효율적입니다.', 45),
                                                                        ('파티셔닝(Partitioning)의 개념과 이점은?', '파티셔닝은 테이블을 물리적으로 여러 개의 파티션으로 나누어 저장하는 기법으로, 파티션 단위로 쿼리를 수행하여 대용량 데이터를 보다 빠르게 처리할 수 있습니다. 종류에는 범위 분할(Range), 해시 분할(Hash), 리스트 분할(List) 등이 있으며, 성능 개선, 관리 용이성, 백업 단순화 등의 장점이 있습니다.', 45),
                                                                        ('샤딩(Sharding)과 파티셔닝(Partitioning)의 차이점은?', '샤딩은 데이터베이스 자체를 여러 서버에 나눠 저장하는 수평 확장 방식이며, 각 샤드는 독립적인 DB 인스턴스를 가집니다. 반면 파티셔닝은 하나의 DB 인스턴스 내에서 테이블을 나누는 방식입니다. 샤딩은 분산 시스템 전체를 관리하는 복잡성이 있지만 확장성은 높고, 파티셔닝은 상대적으로 관리가 간단하며 단일 서버의 리소스를 활용합니다.', 45),
                                                                        ('커버링 인덱스(Covering Index)란 무엇이며 어떤 장점이 있나요?', '커버링 인덱스는 쿼리에서 사용하는 모든 컬럼이 인덱스에 포함되어 있어, 테이블 접근 없이 인덱스만으로 결과를 반환할 수 있는 인덱스입니다. 이를 통해 I/O 횟수를 줄이고, 쿼리 응답 속도를 크게 향상시킬 수 있습니다. 주로 SELECT 절, WHERE 절, ORDER BY 절에 사용하는 컬럼들을 포함해 인덱스를 설계합니다.', 45),
                                                                        ('데이터베이스 병목 현상은 어떻게 진단하고 해결하나요?', '병목 현상은 특정 자원(CPU, 디스크, 네트워크, 쿼리 등)에 과부하가 발생해 전체 성능 저하를 초래합니다. 진단 방법으로는 쿼리 실행 계획 분석, 슬로우 쿼리 로그 확인, 모니터링 툴(Grafana, Prometheus 등)을 활용할 수 있습니다. 해결 방안은 인덱스 추가, 쿼리 튜닝, 캐싱 도입, 파티셔닝 및 샤딩 설계 등이 있습니다.', 45),
                                                                        ('읽기 성능 향상을 위한 방법에는 어떤 것들이 있나요?', '읽기 성능 향상을 위해 인덱스 설계, 읽기 전용 복제(Replica), 캐시 시스템(Redis, Memcached), 정규화/비정규화 병행, 읽기 전용 파티션 활용, 쿼리 튜닝 등이 있습니다. 상황에 따라 적절한 방법을 조합하여 시스템 리소스를 효율적으로 사용할 수 있도록 설계해야 합니다.', 45),
                                                                        ('데이터베이스 복제(Replication)의 목적과 종류는?', '복제는 데이터를 여러 서버에 복제하여 고가용성, 데이터 백업, 읽기 분산 등을 가능하게 하는 기법입니다. Master-Slave 복제는 쓰기는 마스터가, 읽기는 슬레이브가 처리하도록 하며, Master-Master 복제는 양쪽에서 읽기/쓰기를 모두 허용하지만 충돌 관리가 필요합니다. 비동기, 반동기, 동기 방식 등으로 나뉘며 목적에 따라 선택됩니다.', 45),
                                                                        ('Spring Framework와 Spring Boot의 차이점은?', 'Spring Framework는 Java 기반의 엔터프라이즈 애플리케이션 개발을 위한 프레임워크로, 다양한 기능을 제공하지만 설정이 복잡합니다. 반면 Spring Boot는 이러한 설정을 자동화하고, 내장 서버(Tomcat 등)를 제공하여 독립 실행형 애플리케이션을 빠르게 개발할 수 있도록 지원합니다. 설정의 간소화, production-ready 기능 내장, 의존성 관리의 편리함이 주요 차이점입니다.', 46),
                                                                        ('Spring에서 의존성 주입(Dependency Injection)이란 무엇인가요?', '의존성 주입은 객체 간의 의존 관계를 외부에서 주입하는 방식으로, 객체의 생성과 의존성 관리를 컨테이너(Spring)가 대신 수행합니다. 생성자 주입, 필드 주입, 세터 주입이 있으며, 주로 생성자 주입이 권장됩니다. DI를 통해 결합도를 낮추고 테스트와 유지보수가 용이한 구조를 만들 수 있습니다.', 46),
                                                                        ('Spring Boot에서 @RestController와 @Controller의 차이점은?', '@Controller는 View를 반환하는 MVC 패턴의 컴포넌트를 의미하며, 반환값은 ViewResolver를 통해 HTML 등의 뷰로 렌더링됩니다. 반면 @RestController는 @Controller와 @ResponseBody가 결합된 어노테이션으로, 반환값이 JSON이나 XML 등 응답 본문으로 직렬화되어 클라이언트에 전달됩니다. 주로 RESTful API 개발에 사용됩니다.', 46),
                                                                        ('Spring Boot에서 의존성 관리는 어떻게 이루어지나요?', 'Spring Boot는 스타터(Starter) 의존성을 사용하여 관련 라이브러리들을 일괄적으로 관리합니다. 예를 들어 spring-boot-starter-web은 웹 개발에 필요한 Tomcat, Spring MVC 등을 포함합니다. 또한, 부모 프로젝트의 spring-boot-dependencies에서 버전이 고정되어 있어 호환성 문제가 줄어듭니다.', 46),
                                                                        ('Spring Data JPA의 주요 개념은 무엇인가요?', 'Spring Data JPA는 JPA의 반복적인 코드 작성 없이 데이터 접근 계층을 간단히 구현할 수 있도록 도와줍니다. Repository 인터페이스를 상속받아 메서드 이름만으로도 쿼리를 자동 생성하거나, @Query로 JPQL을 직접 작성할 수 있습니다. 또한 페이징(Pageable), 정렬(Sort), 커스텀 쿼리 구현 등도 손쉽게 적용 가능합니다.', 46),
                                                                        ('Spring Boot의 실행 방식은?', 'Spring Boot 애플리케이션은 main 메서드에서 SpringApplication.run()을 호출함으로써 실행됩니다. 이 과정에서 @SpringBootApplication 어노테이션이 설정된 클래스를 기준으로 컴포넌트 스캔, 자동 설정, 빈 등록 등이 수행됩니다. 내장된 Tomcat 서버가 함께 실행되어 별도 WAS 설정 없이도 실행 가능합니다.', 46),
                                                                        ('Spring에서 AOP(관점 지향 프로그래밍)는 무엇인가요?', 'AOP는 공통 기능(로깅, 트랜잭션, 보안 등)을 핵심 비즈니스 로직과 분리하여 모듈화하는 프로그래밍 방식입니다. Spring에서는 @Aspect, @Around, @Before, @After 등의 어노테이션을 통해 메서드 실행 전후 또는 예외 발생 시 특정 로직을 삽입할 수 있습니다. 이를 통해 코드 중복을 줄이고 유지보수를 용이하게 할 수 있습니다.', 46),
                                                                        ('Spring Boot에서 @Transactional의 역할은?', '@Transactional은 메서드 또는 클래스에 선언되어 해당 범위 내에서 트랜잭션을 시작하고, 예외 발생 시 자동으로 롤백하도록 합니다. 주로 서비스 계층에 사용되며, 선언적 트랜잭션 관리를 통해 명시적인 commit/rollback 코드를 줄이고 데이터 일관성을 유지할 수 있게 합니다.', 46),
                                                                        ('Spring Security의 주요 기능은?', 'Spring Security는 인증(Authentication)과 권한(Authorization) 처리를 위한 보안 프레임워크입니다. HTTP 요청 필터 체인 기반으로 동작하며, 로그인/로그아웃 처리, CSRF 보호, 세션 관리, 메서드 수준 접근 제어(@PreAuthorize 등)를 제공합니다. 커스터마이징이 유연하고 OAuth2, JWT 등 다양한 인증 방식과 연동이 가능합니다.', 46),
                                                                        ('Spring에서 Bean의 생명주기(Lifecycle)는 어떻게 되나요?', 'Spring Bean은 생성 → 의존성 주입 → 초기화 → 사용 → 소멸의 생명주기를 가집니다. 초기화와 소멸 과정은 @PostConstruct와 @PreDestroy 어노테이션을 통해 커스터마이징할 수 있으며, InitializingBean, DisposableBean 인터페이스나 BeanPostProcessor를 사용하여 세밀하게 조정할 수도 있습니다. 이 생명주기는 Spring 컨테이너가 관리합니다.', 46),
                                                                        ('Node.js의 주요 특징은 무엇인가요?', 'Node.js는 Chrome V8 JavaScript 엔진 기반의 런타임 환경으로, 비동기 이벤트 기반 아키텍처를 통해 높은 처리 성능을 제공합니다. 단일 스레드로 작동하지만 이벤트 루프와 논블로킹 I/O를 통해 많은 요청을 효율적으로 처리할 수 있습니다. 또한 JavaScript를 서버에서도 사용할 수 있어 프론트엔드와 백엔드를 동일한 언어로 개발할 수 있습니다.', 47),
                                                                        ('Express.js는 무엇이며 Node.js와 어떤 관계인가요?', 'Express.js는 Node.js 위에서 동작하는 경량 웹 프레임워크로, 라우팅, 미들웨어, 요청 및 응답 처리 등 서버 개발에 필요한 기능들을 간결하게 제공합니다. Node.js의 기본 http 모듈보다 직관적이며 구조화된 방식으로 웹 애플리케이션과 RESTful API를 구축할 수 있도록 도와줍니다.', 47),
                                                                        ('Node.js에서 비동기 처리는 어떻게 이루어지나요?', 'Node.js는 기본적으로 비동기 I/O를 지원하며, 콜백, Promise, async/await 등 다양한 방식으로 비동기 작업을 처리합니다. 이벤트 루프와 콜백 큐를 통해 처리되며, 블로킹 없이 많은 요청을 동시에 처리할 수 있습니다. 이를 통해 높은 처리량과 빠른 응답을 제공하는 서버 개발이 가능합니다.', 47),
                                                                        ('미들웨어(Middleware)란 무엇이며 Express.js에서의 역할은?', '미들웨어는 요청(Request)과 응답(Response) 사이에서 실행되는 함수로, 요청 처리 로직을 계층적으로 구성할 수 있게 해줍니다. 로깅, 인증, 요청 데이터 파싱, 에러 처리 등을 공통적으로 처리하며, app.use()나 라우터 레벨에서 연결할 수 있습니다. next() 함수를 호출해 다음 미들웨어로 흐름을 넘깁니다.', 47),
                                                                        ('Node.js에서 싱글 스레드인데도 높은 동시성을 처리할 수 있는 이유는?', 'Node.js는 싱글 스레드지만 이벤트 루프와 비동기 I/O 처리 방식 덕분에 높은 동시성을 지원합니다. 시간이 오래 걸리는 작업은 콜백 큐나 작업 큐로 넘겨지고, 이벤트 루프는 준비된 작업만 빠르게 처리합니다. 이러한 구조는 CPU 작업보다 I/O 중심의 서버에 적합합니다.', 47),
                                                                        ('Express.js에서 라우팅(Routing)은 어떻게 동작하나요?', 'Express에서는 app.get(), app.post(), app.put(), app.delete() 등의 메서드를 통해 HTTP 요청 방식에 따른 라우팅을 정의합니다. URL 패턴에 따라 클라이언트 요청을 적절한 컨트롤러로 연결하며, 파라미터나 쿼리 문자열도 req.params, req.query로 쉽게 처리할 수 있습니다.', 47),
                                                                        ('Node.js에서 모듈 시스템은 어떻게 구성되나요?', 'Node.js는 CommonJS 모듈 시스템을 사용하며, require() 함수로 모듈을 불러오고 module.exports 또는 exports 객체를 통해 외부로 기능을 제공합니다. ES6 이후에는 import/export 구문도 지원되며, 모듈 단위로 코드를 나누어 재사용성과 유지보수성을 향상시킬 수 있습니다.', 47),
                                                                        ('Express에서 에러 처리는 어떻게 구현하나요?', 'Express에서는 네 개의 인자를 갖는 함수(err, req, res, next)를 통해 에러 핸들링 미들웨어를 정의합니다. 모든 라우팅 이후에 선언해야 하며, 예외 발생 시 next(err)를 호출하여 에러 핸들러로 흐름을 전달합니다. 이를 통해 중앙 집중식 에러 처리가 가능하며, 적절한 HTTP 상태 코드와 응답 메시지를 반환할 수 있습니다.', 47),
                                                                        ('Node.js에서 환경변수는 어떻게 관리하나요?', 'Node.js에서는 process.env를 통해 환경변수에 접근할 수 있으며, dotenv 모듈을 활용해 .env 파일에 정의된 환경변수를 불러와 사용할 수 있습니다. 이를 통해 DB 비밀번호, API 키 등 민감한 정보를 코드에 직접 노출하지 않고 관리할 수 있으며, 개발/운영 환경을 유연하게 분리할 수 있습니다.', 47),
                                                                        ('Node.js에서 클러스터링(Clustering)은 무엇이며 왜 필요한가요?', 'Node.js는 기본적으로 단일 스레드이기 때문에 CPU 코어를 모두 활용하지 못합니다. Cluster 모듈을 사용하면 여러 프로세스를 생성하여 멀티코어 환경에서 병렬 처리를 할 수 있습니다. 이는 트래픽 분산, 장애 격리, 성능 향상에 기여하며, master-worker 구조로 운영됩니다.', 47),
                                                                        ('Django의 주요 특징은 무엇인가요?', 'Django는 Python 기반의 고수준 웹 프레임워크로, "배터리 포함(batteries-included)" 철학을 바탕으로 많은 기능을 기본으로 제공합니다. ORM, 관리자 페이지, 인증 시스템, 폼 처리, 보안 기능, URL 라우팅 등이 내장되어 있어 빠르고 효율적인 개발이 가능하며, MTV(Model-Template-View) 아키텍처를 기반으로 동작합니다.', 48),
                                                                        ('Django의 MTV 패턴은 무엇인가요?', 'MTV는 Model-Template-View의 약자로, Django의 아키텍처 패턴입니다. Model은 데이터베이스 구조를 정의하며 ORM을 통해 SQL 없이 데이터를 다룰 수 있게 합니다. Template은 사용자에게 보여질 HTML을 구성하는 레이어이고, View는 클라이언트 요청을 받아 로직을 처리하고 적절한 응답을 반환합니다. 이 구조는 MVC 패턴과 유사하지만 Django만의 용어를 사용합니다.', 48),
                                                                        ('Django ORM이란 무엇인가요?', 'Django ORM(Object-Relational Mapping)은 SQL 문 없이 Python 코드로 데이터베이스 조작을 가능하게 하는 기능입니다. 개발자는 모델 클래스에 필드를 정의하고, 이를 통해 insert, update, delete, select 작업을 객체 지향적으로 수행할 수 있습니다. 장점은 SQL에 대한 추상화, 코드 일관성 유지, 보안성 향상입니다.', 48),
                                                                        ('Django에서 URLconf란?', 'URLconf(URL configuration)는 Django 애플리케이션에서 클라이언트 요청 URL과 View 함수 또는 클래스의 매핑을 정의하는 모듈입니다. 일반적으로 urls.py 파일에 정의되며, path() 또는 re_path()를 사용해 URL 패턴을 설정합니다. 이를 통해 클린하고 RESTful한 URL을 구성할 수 있습니다.', 48),
                                                                        ('Django의 Admin 기능은 무엇인가요?', 'Django는 기본적으로 admin 사이트를 제공하여 데이터베이스의 내용을 웹 인터페이스를 통해 쉽게 관리할 수 있게 해줍니다. Model을 admin.py에 등록하면 관리자가 객체를 생성, 수정, 삭제할 수 있는 UI가 자동으로 생성됩니다. 이는 개발자와 운영자가 백오피스를 빠르게 구축할 수 있도록 지원합니다.', 48),
                                                                        ('Django에서 Form과 ModelForm의 차이는?', 'Form은 사용자의 입력 데이터를 수집하고 검증하는 일반적인 폼 클래스로, 필드를 수동으로 정의해야 합니다. 반면 ModelForm은 특정 모델 클래스와 연결되어 있어 해당 모델의 필드를 기반으로 자동으로 폼 필드를 생성합니다. ModelForm을 사용하면 데이터베이스 연동 작업이 간편해지고 코드가 간결해집니다.', 48),
                                                                        ('Django에서 미들웨어(Middleware)의 역할은?', '미들웨어는 요청(Request)과 응답(Response) 사이에서 동작하는 처리 로직으로, 보안, 인증, 세션 관리, 메시지 처리, 요청 로깅 등 다양한 용도로 사용됩니다. settings.py 파일의 MIDDLEWARE 리스트에 정의된 순서대로 실행되며, 요청을 가로채거나 응답을 수정할 수 있습니다.', 48),
                                                                        ('Django의 장고 템플릿 시스템(DTL)이란?', 'Django Template Language(DTL)는 Django가 제공하는 템플릿 시스템으로, HTML 안에서 {{ 변수 }}와 {% 태그 %} 문법을 통해 데이터를 출력하거나 로직을 구현할 수 있습니다. 템플릿 상속, 필터, 커스텀 템플릿 태그 등을 지원하며, 표현과 로직을 명확히 분리하여 가독성과 유지보수성을 높여줍니다.', 48),
                                                                        ('Django에서 static 파일과 media 파일은 어떻게 다루나요?', 'static 파일은 CSS, JS, 이미지 등 앱의 정적 리소스를 의미하며, media 파일은 사용자가 업로드한 파일을 의미합니다. Django는 STATIC_URL, STATICFILES_DIRS, MEDIA_URL, MEDIA_ROOT 등의 설정을 통해 이들을 관리하며, 개발 환경에서는 django.contrib.staticfiles 앱과 runserver가 이를 서빙합니다. 배포 시에는 웹 서버(Nginx 등)를 통해 서빙해야 합니다.', 48),
                                                                        ('Django에서 보안 강화를 위해 어떤 기능을 제공하나요?', 'Django는 CSRF(Cross-Site Request Forgery) 방지, XSS 방지, SQL Injection 보호, 세션 관리, 패스워드 해싱 등 다양한 보안 기능을 기본적으로 제공합니다. 또한 @login_required 데코레이터, PermissionMixin, SecureCookie 설정 등 인증과 권한에 대한 제어도 체계적으로 제공되어 안전한 웹 애플리케이션 개발이 가능합니다.', 48),
                                                                        ('Flask의 주요 특징은 무엇인가요?', 'Flask는 Python 기반의 마이크로 웹 프레임워크로, 최소한의 기능만 내장하고 있어 개발자가 필요한 라이브러리를 직접 선택하고 구성할 수 있는 유연성이 특징입니다. 라우팅, 요청 처리, 템플릿 렌더링 등의 기본 기능을 제공하며, 확장성이 뛰어나 작고 간단한 프로젝트부터 RESTful API, 대규모 웹 애플리케이션까지 개발할 수 있습니다.', 49),
                                                                        ('Flask에서 라우팅은 어떻게 구성하나요?', 'Flask는 @app.route 데코레이터를 사용해 URL 경로와 해당 뷰 함수를 연결합니다. 예를 들어 @app.route("/hello") 위에 정의된 함수는 "/hello" 요청이 들어왔을 때 실행됩니다. 메서드(GET, POST 등)를 지정하려면 methods 파라미터를 사용할 수 있으며, 동적 URL 파라미터도 <변수명> 형태로 선언할 수 있습니다.', 49),
                                                                        ('Flask와 Django의 주요 차이점은?', 'Django는 "배터리 포함" 철학을 기반으로 많은 기능을 기본 제공하며, 일관된 프로젝트 구조와 빠른 개발을 목표로 합니다. 반면 Flask는 경량화된 프레임워크로, 필요한 기능을 직접 선택하여 조립할 수 있어 자유도가 높고 유연합니다. Flask는 단순한 API 서버나 소형 서비스에 적합하며, Django는 복잡한 웹 애플리케이션에 더 적합합니다.', 49),
                                                                        ('Flask에서 템플릿 렌더링은 어떻게 작동하나요?', 'Flask는 Jinja2 템플릿 엔진을 사용하며, render_template() 함수를 통해 HTML 템플릿을 렌더링합니다. {{ 변수 }} 문법으로 데이터를 출력하고 {% if %}, {% for %}와 같은 제어 구조도 지원합니다. 템플릿 상속을 통해 레이아웃을 재사용할 수 있으며, templates 폴더에 HTML 파일을 저장합니다.', 49),
                                                                        ('Flask의 request와 response 객체의 역할은?', 'request 객체는 클라이언트가 보낸 요청 데이터를 다루며, form, args, json, headers 등을 통해 데이터를 가져올 수 있습니다. response 객체는 서버에서 클라이언트로 보내는 응답을 구성하며, 응답 코드, 헤더, 본문 등을 설정할 수 있습니다. Flask는 기본적으로 view 함수의 반환값을 자동으로 응답 객체로 변환해줍니다.', 49),
                                                                        ('Flask에서 Form 데이터를 처리하는 방법은?', 'HTML form을 통해 전달된 데이터는 Flask의 request.form 속성을 통해 접근할 수 있으며, POST 요청에서 주로 사용됩니다. Flask-WTF 확장 모듈을 활용하면 폼 클래스 생성, CSRF 보호, 유효성 검사 등을 보다 간편하게 처리할 수 있습니다. 데이터는 유효성 검사를 거친 후 모델이나 DB에 저장됩니다.', 49),
                                                                        ('Flask에서 세션(Session) 관리는 어떻게 하나요?', 'Flask는 클라이언트 측 세션을 기본으로 제공하며, 서명된 쿠키를 사용하여 데이터를 저장합니다. session 객체는 딕셔너리처럼 사용되며, 사용자 정보를 저장하거나 인증 상태를 유지하는 데 활용됩니다. Flask의 시크릿 키(secret_key)는 세션 데이터의 무결성과 보안을 위해 필수 설정입니다.', 49),
                                                                        ('Flask에서 블루프린트(Blueprint)의 역할은?', '블루프린트는 Flask 애플리케이션을 여러 모듈로 분리하여 구조화할 수 있도록 돕는 기능입니다. 각 블루프린트는 독립된 라우팅, 뷰, 템플릿, static 파일 등을 가질 수 있으며, register_blueprint()를 통해 앱에 등록됩니다. 이를 통해 대규모 프로젝트에서 유지보수성과 확장성을 높일 수 있습니다.', 49),
                                                                        ('Flask에서 에러 핸들링은 어떻게 구현하나요?', 'Flask는 @app.errorhandler 데코레이터를 통해 특정 상태 코드(예: 404, 500)에 대한 커스텀 에러 페이지를 정의할 수 있습니다. 예외 발생 시 해당 핸들러 함수가 호출되어 적절한 응답을 반환하며, abort() 함수를 사용해 명시적으로 에러를 발생시킬 수도 있습니다.', 49),
                                                                        ('Flask에서 데이터베이스 연동 방법은?', 'Flask는 SQLAlchemy, Flask-SQLAlchemy 등의 ORM을 사용하여 데이터베이스와 연동할 수 있습니다. 모델 클래스는 db.Model을 상속받아 정의하며, 객체 지향적으로 CRUD 작업을 수행할 수 있습니다. 초기 설정 시 데이터베이스 URI를 앱 설정에 포함하고, db.create_all()을 통해 테이블을 생성합니다.', 49),
                                                                        ('Kotlin의 주요 특징은 무엇인가요?', 'Kotlin은 JVM에서 실행되는 현대적인 프로그래밍 언어로, 간결한 문법과 높은 안정성, 강력한 타입 시스템을 갖추고 있습니다. 대표적인 특징으로는 널 안정성(null safety), 스마트 캐스팅, 확장 함수, 데이터 클래스, 코루틴을 통한 비동기 처리 등이 있습니다. Kotlin은 Java와 100% 호환되기 때문에 기존 Java 기반 Spring 프로젝트에도 쉽게 통합할 수 있어, 점진적인 마이그레이션이 가능합니다.', 50),
                                                                        ('Spring Boot의 핵심 개념과 장점은 무엇인가요?', 'Spring Boot는 기존 Spring 프레임워크의 복잡한 설정을 자동화하고 빠르게 애플리케이션을 개발할 수 있도록 도와주는 프레임워크입니다. 주요 장점으로는 내장 톰캣을 통한 간편한 실행, 의존성 관리를 돕는 스타터(start) 패키지 제공, Auto Configuration 기능, 다양한 운영 환경 설정 지원 등이 있습니다. 이로 인해 빠른 개발과 테스트, 배포가 가능해집니다.', 50),
                                                                        ('Kotlin으로 Spring Boot를 개발할 때 자주 사용하는 문법이나 패턴은 무엇인가요?', 'Kotlin에서는 data class, sealed class, extension function, 고차 함수, 람다 표현식 등이 자주 사용됩니다. 예를 들어 DTO나 Entity는 data class로 선언해 boilerplate 코드를 줄일 수 있고, 함수형 스타일로 controller나 service 로직을 작성할 수 있습니다. 또한, Spring DI를 사용할 때는 생성자 주입을 선호하며, lateinit보다는 constructor injection을 활용하는 것이 안전한 방식입니다.', 50),
                                                                        ('Spring Boot에서 Kotlin 코루틴은 어떤 상황에서 사용되며, 장점은 무엇인가요?', 'Kotlin 코루틴은 논블로킹 방식으로 비동기 작업을 수행할 수 있게 해줍니다. Spring WebFlux 환경에서 코루틴을 활용하면 서버의 리소스를 효율적으로 사용할 수 있으며, suspend 함수로 비동기 로직을 마치 동기처럼 읽기 쉽게 작성할 수 있습니다. 예를 들어, 데이터베이스 호출이나 외부 API 호출과 같이 I/O 바운드 작업에 적합합니다.', 50),
                                                                        ('Spring Boot에서 RESTful API를 만들 때 고려해야 할 사항은 무엇인가요?', 'RESTful API를 만들 때는 HTTP 메서드(GET, POST, PUT, DELETE)에 맞는 의미 있는 URI 설계, 상태 코드 사용, 요청과 응답의 DTO 분리, 예외 처리, 인증/인가 처리 등이 중요합니다. Spring Boot에서는 @RestController, @RequestMapping 등의 어노테이션과 Jackson, Spring Validation, Spring Security 등을 함께 사용해 체계적인 REST API를 설계할 수 있습니다.', 50),
                                                                        ('Kotlin과 Java의 차이점은 무엇이며, Spring Boot 개발에 어떤 영향을 미치나요?', 'Kotlin은 Java보다 문법이 간결하며, 널 안정성을 제공하여 NullPointerException을 방지할 수 있습니다. 또한 코루틴을 통한 비동기 처리, 확장 함수, 스마트 캐스팅 등을 통해 생산성을 높일 수 있습니다. 이러한 Kotlin의 기능은 Spring Boot의 기능들과 결합되어 더 효율적이고 안전한 백엔드 개발을 가능하게 합니다.', 50),
                                                                        ('Spring Boot 프로젝트에서 의존성 주입(DI)은 어떻게 이루어지며 Kotlin에서는 어떻게 활용되나요?', 'Spring Boot에서는 @Component, @Service, @Repository, @Autowired 등을 통해 의존성 주입을 구현합니다. Kotlin에서는 생성자 주입이 일반적으로 사용되며, lateinit var는 가능한 지양하고 constructor injection을 선호합니다. 이를 통해 더 안전하고 테스트하기 쉬운 코드를 작성할 수 있습니다.', 50),
                                                                        ('Spring Boot에서 Kotlin을 사용할 때 open class가 필요한 이유는 무엇인가요?', 'Spring의 AOP(Aspect-Oriented Programming) 기능은 프록시 객체 생성을 통해 동작하는데, Kotlin의 클래스는 기본적으로 final입니다. 따라서 AOP 기능을 적용하기 위해선 클래스나 메서드에 open 키워드를 사용하여 상속 가능하도록 해야 합니다. 이를 자동화하기 위해 spring-kotlin plugin에서 all-open 플러그인을 사용하기도 합니다.', 50),
                                                                        ('Kotlin + Spring Boot 환경에서 테스트 코드를 작성할 때 어떤 점을 고려해야 하나요?', 'Kotlin으로 테스트 코드를 작성할 때는 JUnit5와 MockK 또는 Mockito를 함께 사용합니다. 코루틴 테스트에서는 runBlockingTest 또는 kotlinx.coroutines-test 라이브러리를 활용하며, Controller 테스트는 WebMvcTest, 통합 테스트는 @SpringBootTest로 구성합니다. 또한 DI와 널 안정성을 고려한 테스트 설계가 중요합니다.', 50),
                                                                        ('Spring Boot에서 Kotlin 기반 API 서버를 운영 환경에 배포할 때 고려해야 할 점은?', '운영 환경 배포 시에는 빌드 툴로 Gradle/Kotlin DSL을 사용하여 의존성을 관리하고, Docker로 컨테이너화한 후 CI/CD 도구(Jenkins, GitHub Actions 등)를 활용해 자동 배포 파이프라인을 구축하는 것이 일반적입니다. 또한 환경별 설정은 application.yml 또는 application-{profile}.yml을 통해 분리하며, 모니터링과 로깅 도구(Spring Actuator, ELK 등)를 함께 사용하는 것이 좋습니다.', 50),
                                                                        ('Spring Security란 무엇이며 어떤 기능을 제공하나요?', 'Spring Security는 Spring 기반 애플리케이션의 인증(Authentication)과 권한 부여(Authorization)를 담당하는 보안 프레임워크입니다. 주요 기능으로는 로그인/로그아웃 처리, URL 접근 제어, 사용자 역할(Role) 기반 권한 부여, CSRF/XSS 방어, OAuth2, JWT 기반 인증 등이 있습니다. SecurityFilterChain을 통한 필터 체인 구성과 WebSecurityConfigurerAdapter 혹은 SecurityFilterChain Bean 설정으로 커스터마이징할 수 있습니다.', 51),
                                                                        ('Spring Data JPA란 무엇이고 어떤 장점을 제공하나요?', 'Spring Data JPA는 JPA(Java Persistence API)를 기반으로, 복잡한 SQL 쿼리를 작성하지 않고도 데이터베이스 작업을 간편하게 할 수 있도록 도와주는 추상화된 데이터 액세스 프레임워크입니다. 인터페이스만 정의해도 자동으로 쿼리를 생성해주는 메서드 네이밍 전략, 페이징 및 정렬 기능, 동적 쿼리 지원(JPA Criteria API, QueryDSL), 커스텀 리포지토리 구성 등이 주요 장점입니다.', 51),
                                                                        ('Spring Batch란 무엇이며 어떤 경우에 사용하나요?', 'Spring Batch는 대량의 데이터 일괄 처리(Batch Processing)를 위한 프레임워크로, 정형화된 처리 프로세스(읽기-가공-쓰기)를 통해 안정적이고 효율적인 배치 애플리케이션을 구현할 수 있습니다. 주로 정기적으로 반복되는 대량 데이터 작업(예: 정산, 통계 집계, 데이터 마이그레이션 등)에 사용되며, 잡(Job), 스텝(Step), 아이템 리더/프로세서/라이터 등 명확한 구성 요소로 구성됩니다.', 51),
                                                                        ('Spring에서 AOP(Aspect-Oriented Programming)는 무엇이며, 어떤 상황에서 사용하나요?', 'AOP는 관점 지향 프로그래밍으로, 핵심 로직과 부가 기능(트랜잭션 처리, 로깅, 보안 검사 등)을 분리하여 모듈화할 수 있도록 도와줍니다. Spring AOP는 프록시 기반의 구현을 사용하며, @Aspect, @Before, @After, @Around 등의 어노테이션을 통해 공통 관심사를 캡슐화합니다. 주로 로깅, 트랜잭션 처리, 예외 처리 등 반복적인 작업을 분리할 때 사용됩니다.', 51),
                                                                        ('Spring Validation은 어떻게 동작하며 어떤 어노테이션을 사용하나요?', 'Spring Validation은 javax.validation 패키지의 Bean Validation 기반으로, @Valid 혹은 @Validated 어노테이션을 통해 컨트롤러에서 요청 객체를 검증할 수 있습니다. 주로 사용하는 제약 어노테이션으로는 @NotNull, @Size, @Email, @Pattern 등이 있으며, 검증 실패 시 BindingResult나 @ExceptionHandler로 처리할 수 있습니다.', 51),
                                                                        ('Spring WebClient는 무엇이며 어떤 경우에 사용되나요?', 'WebClient는 Spring 5에서 도입된 비동기 HTTP 클라이언트로, RestTemplate의 대체제입니다. 비동기 논블로킹 방식으로 외부 API를 호출할 수 있으며, Mono/Flux를 반환해 WebFlux와 함께 사용할 수 있습니다. 인증 헤더 설정, 커스텀 타임아웃 설정, 필터 체인 구성 등도 가능합니다. 대규모 API 호출 시 리소스를 효율적으로 활용할 수 있다는 점이 장점입니다.', 51),
                                                                        ('Spring Retry 라이브러리는 어떤 문제를 해결하고 어떻게 활용하나요?', 'Spring Retry는 일시적인 네트워크 오류나 장애가 발생했을 때 재시도를 통해 안정적인 서비스를 유지하도록 돕는 라이브러리입니다. @Retryable 어노테이션을 통해 예외 발생 시 자동으로 재시도할 수 있으며, 최대 시도 횟수, 지연 간격, 백오프 정책 등을 설정할 수 있습니다. 예를 들어, 외부 API 호출 시 네트워크 불안정으로 인해 실패할 경우 자동 재시도를 구현할 수 있습니다.', 51),
                                                                        ('Spring Cache는 어떤 목적을 가지고 있으며 어떻게 설정하나요?', 'Spring Cache는 자주 접근되는 데이터를 메모리에 캐싱하여 성능을 향상시키는 기능을 제공합니다. @Cacheable, @CachePut, @CacheEvict 등의 어노테이션을 통해 메서드 단위로 캐싱을 적용할 수 있으며, 기본 제공 캐시 매니저 외에도 Redis, Caffeine, EhCache 등의 외부 캐시 솔루션과 연동 가능합니다. 설정은 application.yml에서 캐시 전략을 정의하거나 Bean으로 캐시 매니저를 등록해 구성할 수 있습니다.', 51),
                                                                        ('Spring에서 트랜잭션 관리는 어떻게 구현되며 어떤 어노테이션을 사용하나요?', 'Spring에서는 @Transactional 어노테이션을 통해 선언적 트랜잭션을 지원합니다. 해당 어노테이션이 붙은 메서드는 하나의 트랜잭션 내에서 실행되며, 예외 발생 시 자동으로 롤백됩니다. 트랜잭션 전파(propagation), 격리 수준(isolation), 롤백 조건 등을 세부적으로 설정할 수 있어 복잡한 트랜잭션 시나리오도 제어할 수 있습니다.', 51),
                                                                        ('Spring에서 Actuator는 어떤 기능을 제공하나요?', 'Spring Boot Actuator는 애플리케이션의 상태와 동작 정보를 외부에 노출할 수 있도록 도와주는 모듈입니다. /actuator/health, /metrics, /info, /env 등 다양한 엔드포인트를 통해 애플리케이션의 내부 상태를 모니터링할 수 있으며, Prometheus, Grafana와 연동해 실시간 대시보드 구축도 가능합니다. 보안을 위해 actuator 엔드포인트 접근 제어 설정이 필요합니다.', 51),
                                                                        ('Kotlin에서 Spring Security를 사용할 때 주의할 점은 무엇인가요?', 'Kotlin에서 Spring Security를 사용할 때는 클래스나 메서드가 기본적으로 final이기 때문에 AOP나 프록시 기반 기능이 정상적으로 동작하지 않을 수 있습니다. 이를 해결하기 위해 open 키워드를 명시하거나, all-open 플러그인을 사용해야 합니다. 또한, Kotlin에서는 lateinit var를 사용할 때 NPE에 주의해야 하며, 생성자 주입 방식으로 Security 설정을 구성하는 것이 안전하고 권장됩니다.', 52),
                                                                        ('Spring Data JPA를 Kotlin에서 사용할 때 자주 사용하는 문법은 무엇인가요?', 'Kotlin에서는 Spring Data JPA의 Repository 인터페이스를 정의할 때 data class를 함께 활용하면 엔티티 정의가 간결해지고 가독성이 향상됩니다. 또한, Kotlin의 nullable 타입과 기본값을 함께 사용해 NPE를 방지할 수 있으며, Optional 대신 Kotlin의 null 처리 방식을 적용합니다. Querydsl을 사용할 경우 Kotlin DSL을 함께 적용하면 타입 안전성과 유지보수성이 향상됩니다.', 52),
                                                                        ('Spring Batch를 Kotlin과 함께 사용할 때 장점은 무엇인가요?', 'Spring Batch는 Kotlin의 람다식과 DSL 문법과 함께 사용할 때 설정이 더 간결해지고, 코드의 가독성이 향상됩니다. 예를 들어, StepBuilderFactory와 JobBuilderFactory를 통해 람다 블록 안에서 리더, 프로세서, 라이터를 명확하게 구성할 수 있습니다. 또한, Kotlin 코루틴을 통해 비동기 I/O 기반의 배치 처리도 가능하며, 스케줄링과 통합하여 효율적인 대용량 처리 작업을 구현할 수 있습니다.', 52),
                                                                        ('Kotlin + Spring에서 비동기 처리 시 사용할 수 있는 방법은 무엇인가요?', '비동기 처리를 위해 Kotlin 코루틴과 Spring의 WebFlux를 함께 사용하는 것이 대표적인 방법입니다. 코루틴은 suspend 함수를 통해 논블로킹 방식으로 비동기 로직을 동기식처럼 작성할 수 있으며, WebClient와 함께 사용하면 외부 API 호출이나 DB 비동기 작업을 효과적으로 수행할 수 있습니다. 또한, @Async와 CoroutineScope을 적절히 조합해 복잡한 비동기 흐름을 구조화할 수 있습니다.', 52),
                                                                        ('Spring에서 Kotlin을 사용할 때 DI(의존성 주입) 방식은 어떻게 구성하나요?', 'Kotlin에서는 생성자 주입(Constructor Injection)을 가장 많이 사용합니다. 생성자 주입은 불변성과 테스트 용이성을 제공하며, lateinit var를 사용할 필요가 없어 NPE를 방지할 수 있습니다. @Autowired 대신 생성자에 파라미터로 주입할 객체를 명시하면 Spring이 자동으로 주입해줍니다. 이는 Kotlin 언어의 철학과 잘 맞는 방식입니다.', 52),
                                                                        ('Kotlin 환경에서 Spring Validation을 사용하는 방법은?', 'Kotlin에서는 javax.validation의 표준 어노테이션(@NotBlank, @Size, @Email 등)과 함께 @Valid, @Validated를 사용해 DTO의 유효성을 검증합니다. 특히 Kotlin에서는 모든 필드를 val로 정의하거나, 기본값을 지정하고 null-safe하게 설계하는 것이 중요합니다. 커스텀 Validator를 만들거나 BindingResult를 통해 세부 검증 로직도 처리할 수 있습니다.', 52),
                                                                        ('Kotlin + Spring 프로젝트에서 테스트 코드를 어떻게 작성하나요?', 'Kotlin에서는 JUnit5와 MockK을 주로 사용하여 테스트를 작성합니다. Spring Boot의 @SpringBootTest, @WebMvcTest 등을 활용해 통합 테스트 및 컨트롤러 테스트를 구성하며, MockK은 Kotlin 친화적인 mocking 프레임워크로, DSL 형식으로 직관적인 테스트 작성이 가능합니다. 코루틴이 포함된 함수 테스트는 runTest 혹은 runBlockingTest를 사용합니다.', 52),
                                                                        ('Kotlin + Spring 프로젝트에서 Redis 캐시는 어떻게 구성하나요?', 'Spring Cache 추상화를 통해 Redis를 캐시 저장소로 사용할 수 있으며, application.yml에서 Redis 설정을 구성하고, @Cacheable, @CacheEvict, @CachePut 등의 어노테이션으로 캐싱 로직을 적용합니다. Kotlin에서는 캐싱 대상 객체에 data class를 활용하면 equals/hashCode 구현이 쉬워지며, @EnableCaching 어노테이션으로 전체 캐시 기능을 활성화합니다.', 52),
                                                                        ('Kotlin + Spring에서 JWT 기반 인증 시스템은 어떻게 구현하나요?', 'JWT 기반 인증 시스템은 Spring Security 필터 체인을 커스터마이징하고, 사용자 인증 요청 시 JWT 토큰을 생성하여 클라이언트에 전달합니다. 이후 요청 헤더에 토큰을 포함시켜 서버에서 필터를 통해 유효성 검사를 수행합니다. Kotlin에서는 JWT 생성 및 파싱 로직을 DSL 스타일로 명확하게 구현할 수 있으며, SecurityConfig 설정에서 AuthenticationEntryPoint, FilterChain 등도 함께 구성합니다.', 52),
                                                                        ('Kotlin + Spring 프로젝트에서 모니터링을 위한 Spring Actuator 활용법은?', 'Spring Boot Actuator는 서비스의 상태, 성능, 환경 설정 등을 모니터링할 수 있는 엔드포인트를 제공합니다. /actuator/health, /metrics, /env 등 다양한 엔드포인트를 통해 정보를 수집하고, Prometheus, Grafana와 연동하여 실시간 시각화가 가능합니다. Kotlin에서도 동일하게 사용할 수 있으며, application.yml을 통해 엔드포인트를 설정하고, 보안 설정도 함께 구성합니다.', 52),
                                                                        ('Spring Boot 애플리케이션을 운영 환경에 배포할 때 주로 사용하는 방법은 무엇인가요?', 'Spring Boot 애플리케이션은 보통 JAR 형태로 패키징하여 배포하며, 이를 실행 가능한 단일 파일로 운영 서버에 업로드하여 `java -jar` 명령어로 실행합니다. 실무에서는 Docker로 이미지를 생성하고 컨테이너화하여 Kubernetes, AWS ECS, EC2, GCP, Azure 등 다양한 클라우드 인프라에 배포합니다. 배포 자동화를 위해 Jenkins, GitHub Actions 같은 CI/CD 도구와 함께 사용하는 경우가 많으며, 운영 중 애플리케이션 재시작이나 무중단 배포 전략도 고려됩니다.', 53),
                                                                        ('운영 환경에서 환경변수를 어떻게 관리하나요?', '운영 환경에서는 코드에 환경설정을 하드코딩하지 않고 환경변수 또는 외부 설정파일(application-prod.yml 등)로 분리하여 관리합니다. Spring에서는 `@Value` 또는 `Environment` 객체를 사용해 환경변수를 주입할 수 있고, 운영 시스템에서는 `.env` 파일, Docker의 `--env` 플래그, Kubernetes의 ConfigMap 및 Secret 등을 통해 민감한 정보를 안전하게 주입합니다. 이를 통해 동일한 코드베이스로 다양한 환경(개발, 스테이징, 운영)에 유연하게 대응할 수 있습니다.', 53),
                                                                        ('무중단 배포란 무엇이며 어떻게 구현하나요?', '무중단 배포는 서비스 중단 없이 새로운 버전의 애플리케이션을 배포하는 방식입니다. 일반적으로 블루-그린 배포(Blue-Green Deployment), 롤링 배포(Rolling Update), Canary 배포(Canary Release) 전략을 사용하며, NGINX, ALB(Application Load Balancer), Kubernetes의 rolling update 기능 등을 활용합니다. 무중단 배포 구현 시에는 트래픽 전환 전략과 데이터 마이그레이션 시점, 세션 처리 방식 등을 함께 고려해야 합니다.', 53),
                                                                        ('운영 환경에서 Java 또는 Kotlin 기반 Spring 애플리케이션의 성능을 최적화하기 위한 설정은 무엇이 있나요?', 'JVM 기반 애플리케이션은 메모리 설정(-Xms, -Xmx), GC 전략(G1GC, ZGC), Thread pool 사이즈, DB 커넥션 풀 사이즈 등의 튜닝이 중요합니다. application.yml에서 Tomcat의 connectionTimeout, maxThreads 등을 조정하거나, Spring의 TaskExecutor 설정으로 병렬 처리 성능을 개선할 수 있습니다. 또한, 정적 리소스 캐싱, DB 인덱싱, 쿼리 튜닝도 병행하여 최적화합니다.', 53),
                                                                        ('운영 중 애플리케이션 장애 발생 시 어떻게 대응하나요?', '장애 발생 시 로그 분석, 메트릭 수집, 알람 시스템을 활용해 원인을 파악하고 대응합니다. 로그는 Spring Boot의 기본 로깅 설정이나 ELK(Stack), Grafana+Loki 등을 통해 실시간으로 수집하고, Prometheus + Alertmanager를 활용해 메트릭 기반의 알림을 받을 수 있습니다. 오류 유형에 따라 서버 재기동, 롤백, DB 복구, 외부 API 연동 점검 등을 순차적으로 진행합니다. 평소에는 장애 시나리오별 대응 매뉴얼을 갖추고 있는 것이 중요합니다.', 53),
                                                                        ('Spring Boot 애플리케이션의 로깅은 어떻게 구성하고 운영하나요?', 'Spring Boot는 기본적으로 Logback을 사용하며, application.yml에서 로그 레벨, 출력 포맷, 파일 저장 경로 등을 설정할 수 있습니다. 운영 환경에서는 로그를 파일로 남기고, Filebeat, Fluentd 등을 통해 중앙 로그 시스템(예: Elasticsearch)으로 전송합니다. 로그 레벨은 DEBUG, INFO, WARN, ERROR 등으로 구분하여 적절히 설정하며, MDC를 통해 트랜잭션별 로그 추적도 가능하게 구성합니다.', 53),
                                                                        ('Docker를 사용한 Spring 애플리케이션 배포 방식은 어떻게 구성하나요?', 'Docker를 활용하면 Spring Boot 애플리케이션을 컨테이너로 패키징해 이식성과 일관성을 확보할 수 있습니다. 일반적으로 Dockerfile을 작성해 JAR 파일을 기반으로 이미지 빌드하고, `docker run` 명령어 또는 docker-compose를 통해 실행합니다. 운영 환경에서는 Kubernetes 또는 ECS와 같은 컨테이너 오케스트레이션 도구와 함께 사용하여 확장성과 안정성을 확보합니다.', 53),
                                                                        ('Spring 애플리케이션의 상태를 모니터링하기 위해 어떤 도구를 활용하나요?', 'Spring Boot Actuator를 활용하면 `/actuator/health`, `/metrics`, `/info` 등의 엔드포인트를 통해 애플리케이션의 상태를 확인할 수 있습니다. Prometheus + Grafana 조합으로 메트릭을 시각화하거나, ELK Stack 또는 Loki를 통해 로그 기반 모니터링을 구성할 수 있습니다. 또한, 클라우드 환경에서는 CloudWatch, GCP Monitoring, Datadog 등 SaaS 기반 모니터링 도구도 널리 사용됩니다.', 53),
                                                                        ('애플리케이션의 로그 수준은 어떻게 설정하며, 어떤 기준으로 구분하나요?', '로그 수준은 TRACE < DEBUG < INFO < WARN < ERROR < FATAL 순으로 중요도가 높아지며, Spring에서는 application.yml 또는 logback-spring.xml을 통해 전역 혹은 패키지별 로그 레벨을 설정합니다. 개발 환경에서는 DEBUG를 기본으로 하고, 운영 환경에서는 INFO 이상으로 설정해 불필요한 로그를 줄이는 것이 일반적입니다. 예외 발생 시에는 stack trace를 포함해 ERROR 로그로 출력하는 것이 좋습니다.', 53),
                                                                        ('Java/Kotlin + Spring 배포 시 CI/CD 파이프라인은 어떻게 구성하나요?', 'CI/CD 파이프라인은 Git 기반의 코드 변경을 감지하여 테스트, 빌드, 배포까지 자동화하는 방식입니다. Jenkins, GitHub Actions, GitLab CI, CircleCI 등을 사용하며, 테스트 단계(JUnit, MockK 등), 빌드(Maven/Gradle), 도커 이미지 빌드 및 푸시, 서버 혹은 Kubernetes 배포 단계로 구성됩니다. 환경변수 및 시크릿 관리는 Vault, AWS Parameter Store 등을 사용하고, 롤백 전략도 함께 설계합니다.', 53),
                                                                        ('Express란 무엇이며 Node.js에서 어떤 역할을 하나요?', 'Express는 Node.js의 가장 대표적인 웹 프레임워크로, 서버를 빠르게 구축할 수 있도록 도와주는 경량 프레임워크입니다. 라우팅, 미들웨어 관리, 요청/응답 처리, 템플릿 렌더링 등을 간단한 API로 제공하며, RESTful API 개발에 널리 사용됩니다. 또한 구조화된 MVC 아키텍처로 확장이 쉬워 다양한 규모의 백엔드 프로젝트에 적합합니다.', 54),
                                                                        ('Multer는 무엇이며 어떤 상황에서 사용되나요?', 'Multer는 Node.js에서 multipart/form-data 형식의 요청을 처리하기 위한 미들웨어입니다. 주로 이미지, 파일 등 사용자가 업로드하는 데이터를 서버에 저장할 때 사용됩니다. 업로드된 파일을 메모리에 저장하거나 디스크에 저장하도록 설정할 수 있으며, 파일 필터링, 파일명 자동 생성, 업로드 경로 지정 등의 기능도 제공합니다.', 54),
                                                                        ('jsonwebtoken 라이브러리는 어떤 용도로 사용되며 어떻게 동작하나요?', 'jsonwebtoken은 JWT(Json Web Token)를 생성하고 검증하는 데 사용되는 라이브러리입니다. 로그인 시 사용자 정보를 담은 토큰을 서버에서 발급하고, 클라이언트는 이후 요청에서 이 토큰을 Authorization 헤더에 담아 보냅니다. 서버는 이 토큰을 검증하여 사용자의 인증 상태를 확인합니다. 비대칭키 또는 대칭키를 사용해 서명되며, 탈취 방지를 위한 토큰 만료 및 갱신 전략도 함께 고려됩니다.', 54),
                                                                        ('bcrypt 라이브러리는 어떤 상황에서 사용되며, 사용 시 주의할 점은?', 'bcrypt는 비밀번호를 안전하게 해싱하기 위해 사용하는 라이브러리입니다. 사용자로부터 받은 비밀번호를 그대로 저장하지 않고 해싱하여 DB에 저장하고, 로그인 시 입력된 비밀번호와 해시된 값의 일치 여부를 비교합니다. 해시 함수는 단방향성이므로 복호화가 불가능하며, saltRounds 값을 조정하여 보안 강도를 설정할 수 있습니다. 너무 낮으면 취약하고, 너무 높으면 성능 저하가 발생할 수 있습니다.', 54),
                                                                        ('CORS란 무엇이며 Node.js에서 어떻게 설정하나요?', 'CORS(Cross-Origin Resource Sharing)는 브라우저가 다른 도메인 간의 요청을 제한하는 보안 정책입니다. Node.js에서는 `cors` 미들웨어를 통해 특정 도메인에서의 요청만 허용할 수 있습니다. 예를 들어, `app.use(cors({ origin: "https://example.com" }))`처럼 설정하면 해당 도메인에서 오는 요청만 허용되며, 자격 증명 포함 여부, HTTP 메서드 제한 등도 추가로 설정 가능합니다.', 54),
                                                                        ('dotenv는 무엇이며 Node.js 프로젝트에서 어떻게 활용되나요?', 'dotenv는 `.env` 파일에 정의된 환경변수를 Node.js 애플리케이션에서 불러올 수 있도록 도와주는 라이브러리입니다. `require("dotenv").config()`로 설정 후 `process.env`를 통해 접근할 수 있으며, DB 접속 정보, 시크릿 키, 포트 번호 등 민감한 설정 값을 코드와 분리하여 보안과 유지보수성을 높이는 데 유용합니다.', 54),
                                                                        ('nodemon은 무엇이며 어떤 개발 단계에서 유용하게 사용되나요?', 'nodemon은 소스코드에 변경이 생기면 자동으로 서버를 재시작해주는 도구입니다. 개발 도중 코드 수정을 반복적으로 할 때 일일이 서버를 재시작할 필요가 없어 개발 생산성이 크게 향상됩니다. `nodemon app.js`처럼 실행하며, `.nodemon.json` 파일로 설정을 커스터마이징할 수도 있습니다. 단, 운영 환경에서는 사용하지 않습니다.', 54),
                                                                        ('winston 또는 morgan은 어떤 용도의 라이브러리이며 차이점은 무엇인가요?', 'winston과 morgan은 로깅을 위한 Node.js 라이브러리입니다. morgan은 HTTP 요청 로깅에 특화되어 있으며 Express 미들웨어로 사용됩니다. 반면, winston은 더 일반적인 로깅 솔루션으로, 다양한 로그 레벨, 파일 출력, 포맷팅, 로그 회전 기능 등을 지원합니다. 두 라이브러리는 함께 사용할 수 있으며, morgan으로 요청 로그를 수집하고 winston으로 파일에 저장하거나 외부 시스템으로 전송하는 방식이 일반적입니다.', 54),
                                                                        ('express-validator는 무엇이며 어떻게 사용하나요?', 'express-validator는 요청(request)의 입력 값을 검증하기 위한 미들웨어입니다. 체이닝 방식으로 다양한 유효성 검사 메서드를 제공하며, 입력값의 형식, 길이, 공백 여부 등을 검사할 수 있습니다. 예를 들어 `body("email").isEmail()`처럼 사용하며, 검증 결과는 `validationResult(req)`를 통해 확인하여 에러 응답을 반환하거나 다음 단계로 진행할 수 있습니다.', 54),
                                                                        ('helmet은 어떤 보안 기능을 제공하며 Express 앱에서 어떻게 사용되나요?', 'helmet은 Express 애플리케이션의 보안을 강화하기 위한 미들웨어 모음입니다. HTTP 응답 헤더를 설정하여 XSS, 클릭재킹, MIME 타입 스니핑 등의 보안 위협을 방지합니다. 예를 들어, `app.use(helmet())`을 통해 기본 설정을 적용할 수 있으며, 각 기능은 개별 설정도 가능합니다. 운영 환경에서는 CSP(Content Security Policy) 설정도 함께 고려하면 보안 수준을 더욱 높일 수 있습니다.', 54),
                                                                        ('Node.js 애플리케이션을 운영 환경에 배포할 때 어떤 방식을 사용할 수 있나요?', 'Node.js 애플리케이션은 다양한 방식으로 배포할 수 있으며, 대표적으로는 직접 서버에 배포하는 방식, Docker를 사용한 컨테이너 배포, 클라우드 서비스(AWS Elastic Beanstalk, GCP App Engine 등)를 이용한 배포가 있습니다. Docker 기반 배포는 환경 일관성과 이식성을 확보할 수 있고, CI/CD 파이프라인과 결합하면 자동화된 안정적 배포가 가능합니다. 또한, 운영 환경에서는 process manager(PM2 등)를 활용하여 애플리케이션을 백그라운드에서 안정적으로 실행하는 것이 중요합니다.', 55),
                                                                        ('PM2는 무엇이며 어떻게 사용하나요?', 'PM2는 Node.js 애플리케이션의 프로세스를 관리해주는 프로세스 매니저입니다. 애플리케이션을 데몬 형태로 실행하여 서버가 재부팅되거나 오류가 발생해도 자동으로 재시작할 수 있게 해줍니다. `pm2 start app.js` 명령으로 앱을 실행하고, `pm2 list`, `pm2 logs`, `pm2 restart` 등을 통해 상태 관리가 가능합니다. 설정 파일(ecosystem.config.js)을 통해 여러 애플리케이션의 실행 정보를 일괄 관리할 수 있습니다.', 55),
                                                                        ('Node.js 환경에서 환경변수는 어떻게 관리하나요?', 'Node.js에서는 `.env` 파일과 `dotenv` 패키지를 사용하여 환경변수를 관리할 수 있습니다. 환경별로 설정을 분리하여 코드에 민감한 정보를 하드코딩하지 않고 `process.env.KEY` 형태로 접근합니다. Docker 환경에서는 `--env` 옵션 또는 `.env` 파일을 컨테이너에 전달하며, Kubernetes에서는 ConfigMap이나 Secret 리소스를 사용해 환경변수를 주입합니다.', 55),
                                                                        ('Node.js 애플리케이션의 로깅은 어떻게 구성하나요?', 'Node.js에서는 `winston`, `bunyan`, `pino` 같은 로깅 라이브러리를 활용해 로그를 수집하고 관리할 수 있습니다. 로그는 console뿐 아니라 파일 또는 외부 시스템(예: Elasticsearch, Loggly 등)으로 전송할 수 있으며, 로그 레벨(예: info, warn, error)을 설정하여 필터링도 가능합니다. 운영 환경에서는 로그 회전(log rotation)이나 중앙화된 로그 수집 시스템과 연동하는 것이 좋습니다.', 55),
                                                                        ('Node.js 앱에서 발생하는 에러는 어떻게 처리하고 대응하나요?', 'Node.js에서는 try-catch를 통한 동기 에러 처리와 `.catch()` 또는 `async/await` 기반의 비동기 에러 처리가 중요합니다. 예기치 않은 에러에 대비하기 위해 `process.on("uncaughtException")`과 `process.on("unhandledRejection")`을 등록해 전체 앱 크래시를 막고 로깅 또는 graceful shutdown을 수행합니다. 실시간 알림을 위해 Sentry와 같은 에러 추적 도구를 사용하는 것도 권장됩니다.', 55),
                                                                        ('Node.js 애플리케이션을 Docker로 배포할 때 고려할 점은?', 'Docker를 사용할 경우, 애플리케이션을 컨테이너 이미지로 빌드하고, 이 이미지를 다양한 환경에서 동일하게 실행할 수 있습니다. Dockerfile 작성 시 `node:alpine`과 같은 경량 베이스 이미지를 선택하고, `npm ci`를 사용해 의존성을 빠르게 설치하며, `EXPOSE`와 `CMD` 설정을 명확히 해야 합니다. 또한 `.dockerignore`를 설정하여 불필요한 파일 포함을 방지하고, 멀티스테이지 빌드를 통해 이미지 용량을 최소화할 수 있습니다.', 55),
                                                                        ('CI/CD 환경에서 Node.js 프로젝트의 배포 파이프라인은 어떻게 구성하나요?', 'CI/CD 파이프라인은 보통 다음과 같은 단계로 구성됩니다: (1) Git 저장소에 코드 푸시 감지 → (2) 테스트 실행(Jest, Mocha 등) → (3) 빌드 및 린트 → (4) Docker 이미지 빌드 및 푸시 → (5) 서버 또는 클러스터에 배포. GitHub Actions, GitLab CI, Jenkins 등이 자주 사용되며, 환경변수와 비밀 키는 CI 환경 내에서 안전하게 관리되어야 합니다.', 55),
                                                                        ('무중단 배포(Zero Downtime Deployment)는 Node.js에서 어떻게 구현할 수 있나요?', 'Node.js에서 무중단 배포를 위해서는 PM2의 cluster 모드 또는 reload 명령어(`pm2 reload all`)를 활용할 수 있습니다. 이 외에도 NGINX 리버스 프록시를 사용하여 새 프로세스로 트래픽을 점진적으로 전환하거나, 로드 밸런서 수준에서 헬스체크를 통과한 인스턴스에만 요청을 보내도록 구성할 수 있습니다. 배포 도중의 세션 유지 전략도 함께 고려해야 합니다.', 55),
                                                                        ('Node.js 앱의 상태를 모니터링하려면 어떤 도구를 사용할 수 있나요?', 'Node.js 애플리케이션의 상태 모니터링을 위해 Prometheus + Grafana 조합을 사용할 수 있으며, PM2 자체의 dashboard(pm2.io)도 활용할 수 있습니다. 또한, 외부 APM 도구(New Relic, Datadog, Elastic APM 등)를 연동하면 요청 응답 시간, 에러율, 메모리 사용량 등을 시각적으로 모니터링하고 알림 설정도 가능합니다.', 55),
                                                                        ('Node.js 애플리케이션의 메모리 누수나 성능 문제를 어떻게 디버깅하나요?', '메모리 누수나 성능 문제는 `--inspect` 플래그를 통해 Chrome DevTools에서 힙 스냅샷을 분석하거나, `clinic.js`, `heapdump`, `node --trace-gc` 등을 사용해 분석할 수 있습니다. 또한 `process.memoryUsage()`를 주기적으로 기록하거나, `v8-profiler`를 통해 CPU 및 메모리 프로파일링을 수행하여 병목 구간을 파악할 수 있습니다.', 55),
                                                                        ('Django REST framework는 무엇이며 어떤 기능을 제공하나요?', 'Django REST framework(DRF)는 Django 기반에서 RESTful API를 쉽게 구축할 수 있도록 도와주는 강력한 라이브러리입니다. Serializer를 통해 데이터 모델을 JSON으로 직렬화하고, ViewSet과 Router를 이용해 URL과 비즈니스 로직을 효율적으로 연결할 수 있습니다. 인증 및 권한 관리, 페이징, 필터링, 브라우징 가능한 API UI 등 다양한 기능이 기본 제공되며, 복잡한 API도 빠르게 구현할 수 있습니다.', 56),
                                                                        ('django-allauth는 어떤 기능을 제공하며, 어떻게 설정하나요?', 'django-allauth는 이메일/비밀번호 기반 인증은 물론 구글, 페이스북, 깃허브 등 다양한 소셜 로그인을 통합 제공하는 인증 라이브러리입니다. `INSTALLED_APPS`에 `allauth` 관련 앱을 등록하고, `AUTHENTICATION_BACKENDS`, `SITE_ID`, `LOGIN_REDIRECT_URL` 등을 설정해야 합니다. 다양한 인증 전략을 일관된 방식으로 통합해 관리할 수 있어 사용자 인증 구현이 훨씬 간편해집니다.', 56),
                                                                        ('django-environ은 무엇이며 어떤 이점을 제공하나요?', 'django-environ은 `.env` 파일에 정의된 환경변수를 Django 설정 파일(settings.py)에서 쉽게 불러와 사용할 수 있도록 도와주는 라이브러리입니다. 운영 환경과 개발 환경을 분리할 수 있어 민감한 정보(DB 비밀번호, 시크릿 키 등)를 안전하게 관리할 수 있으며, 설정 파일의 가독성도 높아집니다. `env = environ.Env()`를 선언하고, 필요한 설정을 `env("KEY")` 방식으로 불러오면 됩니다.', 56),
                                                                        ('Django에서 파일 업로드 처리를 위한 도구는 어떤 것이 있나요?', 'Django 기본 기능으로 `FileField`, `ImageField`를 통해 파일 업로드를 처리할 수 있으며, `MEDIA_ROOT`, `MEDIA_URL` 설정이 필요합니다. 더 나아가 `django-storages`를 사용하면 AWS S3, Google Cloud Storage 등 외부 저장소와 연동이 가능해 확장성이 높아집니다. 업로드된 파일은 모델 필드와 연동되며, 사용자 인증과 접근 제어도 함께 고려해야 합니다.', 56),
                                                                        ('Django 프로젝트에서 Celery는 어떤 역할을 하나요?', 'Celery는 Django 프로젝트에서 비동기 작업(백그라운드 태스크)을 처리하기 위한 분산 작업 큐 시스템입니다. 이메일 전송, 파일 처리, 대용량 데이터 연산 등 응답 지연을 유발할 수 있는 작업을 비동기로 처리하여 사용자 경험을 개선할 수 있습니다. Redis나 RabbitMQ를 브로커로 사용하며, `@shared_task` 데코레이터로 태스크를 정의하고, Celery 워커가 이를 실행합니다.', 56),
                                                                        ('Django에서 시간대 처리를 효율적으로 하기 위해 어떤 설정이 필요한가요?', 'Django에서는 기본적으로 UTC 시간대를 기준으로 저장하며, `USE_TZ = True` 설정이 필요합니다. 사용자 로컬 시간대로 변환하려면 `pytz` 라이브러리와 함께 `timezone.localtime()` 함수를 사용하거나, 프론트엔드에서 클라이언트 시간대를 고려해 출력합니다. 서버-클라이언트 간 시간 동기화를 위해 ISO 8601 포맷 사용도 권장됩니다.', 56),
                                                                        ('Django-filter는 어떤 역할을 하며 어떻게 사용하나요?', 'Django-filter는 DRF나 Django의 쿼리셋에서 필터링 기능을 간단히 구현할 수 있도록 도와주는 라이브러리입니다. 클래스 기반 필터셋을 정의하고, 뷰에서 `filterset_class`로 연결하면 URL 파라미터를 통해 동적으로 필터링이 가능합니다. 예를 들어, 특정 날짜 범위, 카테고리, 키워드 검색 등을 손쉽게 구현할 수 있습니다.', 56),
                                                                        ('Django에서 커스텀 유저 모델을 정의하는 이유와 방법은?', '기본 User 모델은 제한적인 필드 구조를 가지기 때문에, 실제 서비스에 필요한 추가 정보(예: 닉네임, 전화번호, 생년월일 등)를 저장하려면 커스텀 유저 모델을 사용하는 것이 좋습니다. `AbstractBaseUser` 또는 `AbstractUser`를 상속한 모델을 정의하고, `AUTH_USER_MODEL`을 설정하면 됩니다. 커스텀 모델을 프로젝트 초기 단계에 정의하는 것이 마이그레이션 충돌을 방지하는 데 유리합니다.', 56),
                                                                        ('Django에서 API 문서를 자동으로 생성해주는 도구는?', '대표적으로 `drf-yasg`, `drf-spectacular`, `django-rest-swagger` 등이 있으며, Django REST framework 기반 API 문서를 자동으로 생성해줍니다. Swagger(OpenAPI) 기반의 UI를 제공하여 API 명세를 시각화하고 테스트할 수 있으며, 스키마 자동 생성, 파라미터 설명, 응답 예시 등 문서화 작업을 효율화할 수 있습니다.', 56),
                                                                        ('Django Debug Toolbar는 무엇이며 어떤 상황에서 유용한가요?', 'Django Debug Toolbar는 개발 중 애플리케이션의 SQL 쿼리, 캐시, 로그, 템플릿, 설정 값 등을 실시간으로 시각화해주는 디버깅 도구입니다. 성능 병목 지점을 파악하거나 ORM 쿼리를 최적화할 때 유용하며, 개발 환경에서만 활성화되도록 `INTERNAL_IPS` 설정과 함께 사용하는 것이 일반적입니다.', 56),
                                                                        ('Django에서 uWSGI는 어떤 역할을 하며 Gunicorn과 비교했을 때 차이점은 무엇인가요?', 'uWSGI는 WSGI(Web Server Gateway Interface)를 구현한 애플리케이션 서버로, Django 같은 Python 웹 애플리케이션을 실제로 실행하는 데 사용됩니다. Gunicorn도 같은 역할을 하지만, uWSGI는 보다 세밀한 설정이 가능하고, 다양한 프로토콜 지원(HTTP, FastCGI, uWSGI 등)과 성능 최적화 기능이 탑재되어 있어 복잡한 대규모 서비스에서 사용됩니다. Gunicorn은 비교적 설정이 단순하고 실행이 간편하여 빠르게 배포하고자 할 때 유리합니다.', 57),
                                                                        ('Django에서 커스텀 에러 페이지(404, 500 등)는 어떻게 설정하나요?', 'Django에서는 `handler404`, `handler500` 등의 변수를 URLConf 파일에 설정하여 커스텀 에러 페이지를 지정할 수 있습니다. 예를 들어, `handler404 = "myapp.views.custom_404"`처럼 뷰 함수를 연결하고, 해당 뷰에서 사용자 친화적인 템플릿을 렌더링합니다. 또한 운영 환경에서는 DEBUG=False 상태에서만 해당 핸들러가 적용되며, 사용자 경험 개선과 동시에 보안 정보 노출 방지에도 유리합니다.', 57),
                                                                        ('운영 환경에서 Django의 캐시(Cache) 시스템은 어떻게 활용할 수 있나요?', 'Django는 다양한 캐시 백엔드(Redis, Memcached 등)를 지원하며, 페이지 캐싱, 뷰 캐싱, 템플릿 프래그먼트 캐싱, 로우 레벨 API 캐싱 등의 기능을 제공합니다. 운영 환경에서는 Redis를 캐시 서버로 자주 사용하며, `CACHES` 설정을 통해 캐시 백엔드를 등록합니다. 적절한 캐시 전략을 사용하면 DB 부하를 줄이고 애플리케이션 응답 속도를 향상시킬 수 있습니다.', 57),
                                                                        ('운영 환경에서 Django 세션 데이터는 어떻게 관리하나요?', 'Django는 기본적으로 DB에 세션 데이터를 저장하지만, 운영 환경에서는 Redis나 Memcached와 같은 인메모리 저장소를 사용하는 것이 일반적입니다. 이를 통해 세션 읽기/쓰기 속도를 개선하고 서버 간 세션 공유를 가능하게 합니다. `SESSION_ENGINE` 설정을 통해 저장 방식을 변경하며, 세션 보안을 위해 `SESSION_COOKIE_SECURE`와 같은 설정도 함께 고려해야 합니다.', 57),
                                                                        ('운영 환경에서 Django의 스케줄링 작업은 어떻게 구현하나요?', 'Django는 자체적인 스케줄링 기능을 제공하지 않기 때문에, `Celery`와 `celery-beat`, 또는 운영체제의 `cron`을 사용하여 주기적인 작업을 실행합니다. 예를 들어, `celery-beat`는 주기적으로 특정 작업을 Celery 워커에게 전달하며, 백업, 알림 전송, 통계 갱신 등의 반복 작업에 활용됩니다. 환경에 따라 cronjob으로 `manage.py` 명령어를 직접 실행하기도 합니다.', 57),
                                                                        ('Django에서 서드파티 라이브러리를 운영 환경에 설치하고 유지관리할 때 주의할 점은?', '운영 환경에 라이브러리를 설치할 때는 `requirements.txt`나 `Pipfile.lock`을 통해 버전을 고정하고, 검증된 패키지만 사용하는 것이 중요합니다. 또한, 보안 업데이트 여부를 주기적으로 확인하고, 가상환경(venv, poetry 등)을 사용하여 시스템 전체에 영향을 주지 않도록 분리 관리합니다. 테스트 환경에서 먼저 검증한 후 운영 환경에 반영하는 것도 좋은 습관입니다.', 57),
                                                                        ('운영 환경에서 Django의 데이터베이스 성능을 개선하기 위한 전략은?', '인덱스 최적화, 쿼리 최적화(select_related, prefetch_related 사용), 커넥션 풀링, DB 쿼리 로깅을 통한 병목 분석 등이 있습니다. 또한, ORM을 사용하는 경우 쿼리 수를 최소화하도록 설계하며, 복잡한 쿼리는 `RawSQL`이나 DB 뷰로 처리할 수도 있습니다. PostgreSQL, MySQL 같은 RDBMS의 튜닝도 함께 고려되어야 하며, 정기적인 vacuum, analyze 작업이 필요할 수 있습니다.', 57),
                                                                        ('운영 환경에서 발생할 수 있는 보안 위협과 Django의 방어 기법은?', 'Django는 CSRF, XSS, SQL Injection 방지를 위한 기본적인 보안 기능을 제공합니다. CSRF는 `csrftoken`을 통해, XSS는 템플릿 자동 이스케이핑을 통해 방어됩니다. `SECURE_BROWSER_XSS_FILTER`, `X_FRAME_OPTIONS`, `SECURE_CONTENT_TYPE_NOSNIFF` 등 추가적인 보안 헤더 설정을 통해 공격을 예방하고, 운영 환경에서는 반드시 HTTPS를 적용해야 하며, 관리자의 접근을 제한하는 것도 중요합니다.', 57),
                                                                        ('운영 환경에서 Django 앱의 헬스 체크는 어떻게 구성하나요?', '헬스 체크는 로드 밸런서 또는 오케스트레이션 툴(Kubernetes 등)이 애플리케이션 상태를 확인하는 데 사용됩니다. Django에서는 `/health/`와 같은 URL을 만들어 DB 연결, 캐시 상태, 애플리케이션 로직 등의 상태를 체크한 후 JSON 형식으로 결과를 반환하도록 구성합니다. `django-health-check` 같은 라이브러리를 사용하면 다양한 체크 항목을 손쉽게 구성할 수 있습니다.', 57),
                                                                        ('운영 중 트래픽이 급증했을 때 Django 프로젝트는 어떻게 확장할 수 있나요?', '수평 확장을 위해 여러 인스턴스를 실행하고, Nginx 또는 클라우드 로드 밸런서를 통해 트래픽을 분산시킵니다. 데이터베이스는 읽기/쓰기 분리(Read Replica), 캐시는 Redis 클러스터 구성 등으로 확장성을 확보하며, 정적 파일은 CDN으로 오프로드합니다. 또한, Celery를 이용한 비동기 처리로 백엔드 병목을 분산하고, DB 커넥션 수 제한이나 Gunicorn 워커 수 조정 등도 성능 개선에 기여합니다.', 57),
                                                                        ('Flask-SQLAlchemy란 무엇이며 어떤 기능을 제공하나요?', 'Flask-SQLAlchemy는 Flask 애플리케이션에서 SQLAlchemy ORM을 쉽게 사용할 수 있도록 래핑한 확장 라이브러리입니다. SQLAlchemy는 Python에서 SQL을 객체 지향적으로 다룰 수 있게 해주는 ORM이며, Flask-SQLAlchemy는 애플리케이션 컨텍스트에 맞춰 DB 세션 관리, 모델 선언, 쿼리 실행 등을 간편하게 처리할 수 있게 해줍니다. 선언형 클래스 기반으로 테이블과 컬럼을 정의하고, 관계 설정, 마이그레이션 연동 등도 유연하게 지원합니다.', 58),
                                                                        ('Flask-Migrate는 어떤 역할을 하며 어떻게 사용하나요?', 'Flask-Migrate는 SQLAlchemy 모델의 변경 사항을 데이터베이스에 반영할 수 있도록 Alembic을 기반으로 마이그레이션 기능을 제공하는 Flask 확장 도구입니다. `flask db init`, `flask db migrate`, `flask db upgrade` 명령어로 DB 버전을 관리할 수 있으며, 스키마 변경 이력을 추적할 수 있어 협업 시 매우 유용합니다. 실제 운영 환경에서도 데이터 손실 없이 구조를 점진적으로 변경할 수 있습니다.', 58),
                                                                        ('Flask-Login은 어떤 기능을 제공하며 어떻게 구성하나요?', 'Flask-Login은 Flask 애플리케이션에 사용자 로그인 기능을 추가해주는 확장 라이브러리입니다. 세션 기반 인증을 지원하며, 로그인 상태 유지, 로그인/로그아웃, 접근 제한, Remember Me 등의 기능을 제공합니다. `UserMixin`을 상속한 사용자 모델과 `@login_required` 데코레이터를 활용해 인증이 필요한 뷰를 보호할 수 있으며, 사용자 객체는 `current_user`를 통해 접근 가능합니다.', 58),
                                                                        ('Flask-WTF는 무엇이며 어떤 장점이 있나요?', 'Flask-WTF는 Flask에서 폼 처리를 쉽게 할 수 있도록 도와주는 라이브러리로, WTForms와 연동되어 입력 유효성 검사, CSRF 보호, 필드 정의 등을 간단하게 구현할 수 있습니다. Flask-WTF는 HTML 폼과 Python 백엔드 간의 브릿지 역할을 하며, 커스텀 검증 로직, 동적 폼 생성 등도 지원합니다. 사용자 입력의 안정성과 보안성을 높이기 위한 필수 도구입니다.', 58),
                                                                        ('Flask에서 RESTful API를 구축할 때 자주 사용하는 확장 도구는 무엇인가요?', 'Flask에서 RESTful API를 구축할 때는 Flask-RESTful 또는 Flask-Smorest, Flask-RESTX 같은 확장을 사용합니다. 이들 라이브러리는 라우팅, 요청 파싱, 응답 직렬화, 오류 처리 등을 체계적으로 관리할 수 있게 해주며, Swagger 문서 생성, 스키마 검증 등도 지원합니다. API의 일관성과 확장성을 확보하고자 할 때 매우 유용합니다.', 58),
                                                                        ('Flask-Admin은 어떤 기능을 제공하며 언제 사용하나요?', 'Flask-Admin은 Flask 애플리케이션에 관리용 백오피스 UI를 빠르게 추가할 수 있는 확장 라이브러리입니다. SQLAlchemy 모델을 자동으로 폼에 매핑하고, CRUD 인터페이스를 웹 UI로 제공합니다. 사용자 정의 필터, 검색, 정렬, 외래 키 참조 등 다양한 기능이 내장되어 있어 관리자가 직접 데이터를 편집하거나 모니터링하는 도구로 적합합니다.', 58),
                                                                        ('Flask에서 환경변수나 설정값을 안전하게 관리하려면 어떤 도구를 사용할 수 있나요?', 'Flask에서는 python-dotenv 또는 Flask-Environments 같은 도구를 활용해 `.env` 파일에 설정값을 정의하고 `os.environ` 또는 `app.config.from_envvar()`로 불러올 수 있습니다. 이를 통해 민감한 정보(비밀번호, API 키 등)를 코드에서 분리하여 보안성을 높이고, 개발/운영 환경별 설정을 유연하게 관리할 수 있습니다.', 58),
                                                                        ('Flask에서 요청 전/후에 공통 작업을 처리할 수 있는 방법은?', 'Flask는 `@app.before_request`, `@app.after_request`, `@app.teardown_request` 데코레이터를 통해 요청 처리 전후에 공통 작업을 실행할 수 있습니다. 예를 들어, 사용자 인증 검사, DB 세션 시작, 로깅, 응답 헤더 추가 등이 가능하며, 요청 흐름을 전역적으로 제어할 수 있어 유지보수에 유리합니다.', 58),
                                                                        ('Flask 앱에서 Blueprint는 어떤 역할을 하나요?', 'Blueprint는 Flask 애플리케이션을 여러 모듈로 나누어 구성할 수 있도록 해주는 구조적 도구입니다. 각각의 기능(예: auth, blog 등)을 독립적인 Blueprint로 분리하면 코드 재사용성과 유지보수성이 향상되며, URL prefix 및 템플릿 경로도 각 Blueprint별로 설정할 수 있어 대규모 프로젝트에서 유용합니다.', 58),
                                                                        ('Flask 앱에서 CORS 설정은 어떻게 구현하나요?', 'Flask에서 CORS(Cross-Origin Resource Sharing)를 설정하려면 Flask-CORS 확장 라이브러리를 사용합니다. `from flask_cors import CORS`로 가져오고 `CORS(app)`으로 전체 앱에 적용하거나, 특정 라우트에만 데코레이터로 적용할 수 있습니다. 프론트엔드와 백엔드가 서로 다른 도메인에서 동작할 경우, 브라우저의 보안 정책을 우회하기 위해 필수 설정입니다.', 58),
                                                                        ('Flask 애플리케이션에서 Gunicorn 워커 수는 어떻게 결정하나요?', 'Gunicorn은 여러 워커 프로세스를 통해 병렬로 요청을 처리할 수 있으며, 워커 수는 보통 서버의 CPU 코어 수에 따라 결정합니다. 일반적인 공식은 `(2 × CPU 코어 수) + 1`로, 이 방식은 대부분의 웹 애플리케이션에서 효율적인 병렬 처리를 가능하게 합니다. 단, 워커 수가 많다고 무조건 성능이 좋아지는 것은 아니며, 애플리케이션의 I/O 성격이나 리소스 사용량을 고려해 조절해야 합니다.', 59),
                                                                        ('Flask 운영 시 WSGI 서버를 직접 구현하는 대신 Gunicorn을 사용하는 이유는?', 'Flask 내장 서버는 개발 목적으로 만들어졌으며, 운영 환경에서는 안정성, 성능, 보안 측면에서 적절하지 않습니다. Gunicorn은 성숙한 WSGI 서버로, 멀티 워커 기반 구조, 오류 복구, 타임아웃, 로깅, 커넥션 관리 등의 기능을 제공해 실서비스에 적합합니다. 또한 Nginx와 조합하여 확장성과 트래픽 처리 능력을 향상시킬 수 있습니다.', 59),
                                                                        ('Flask 애플리케이션에서 리버스 프록시인 Nginx를 사용하면 얻을 수 있는 이점은?', 'Nginx는 클라이언트 요청을 Gunicorn에 전달하는 리버스 프록시로 동작하며, 성능 향상, 보안 강화, 정적 파일 처리, HTTPS 적용, 요청 제한, 로드밸런싱 등의 이점을 제공합니다. Flask는 요청 처리에 집중하고, Nginx는 외부 네트워크와의 인터페이스를 담당함으로써 책임 분리가 이루어지고, 확장성과 안정성이 크게 향상됩니다.', 59),
                                                                        ('운영 환경에서 Flask 애플리케이션의 오류를 추적하는 방법은?', 'Flask는 logging 모듈을 통해 예외를 기록할 수 있으며, `app.logger`를 통해 커스텀 로그 메시지를 추가할 수 있습니다. 운영 환경에서는 Sentry, Rollbar 같은 APM 도구를 연동하여 예외 발생 시 실시간 알림과 스택 트레이스를 확인할 수 있습니다. 이를 통해 장애 대응 시간을 단축하고, 빠른 문제 해결이 가능합니다.', 59),
                                                                        ('Flask 운영 환경에서 권장되는 디렉토리 구조는 어떻게 구성되나요?', '운영 환경에서는 애플리케이션의 가독성과 유지보수를 위해 `app/`, `config/`, `static/`, `templates/`, `migrations/`, `tests/` 등의 구조를 사용하는 것이 일반적입니다. 예를 들어, `app/` 디렉토리 안에는 블루프린트, 모델, 서비스, 유틸리티 등을 역할별로 모듈화하며, 설정은 `config.py`나 `.env` 파일로 분리하여 다양한 환경에 대응할 수 있도록 합니다.', 59),
                                                                        ('Flask 프로젝트를 운영 환경에 배포할 때, 보안을 강화하기 위한 설정은?', '운영 환경에서는 `DEBUG=False`로 설정하고, `SECRET_KEY`를 안전하게 관리해야 합니다. 또한 CSRF 보호, HTTPS 적용, 보안 헤더 설정(X-Frame-Options, X-Content-Type-Options 등), 세션 쿠키 보안 설정(`SESSION_COOKIE_SECURE=True`, `SESSION_COOKIE_HTTPONLY=True`)을 통해 보안을 강화합니다. 외부에서 접근 가능한 관리 URL 경로를 비공개로 유지하거나 인증을 추가하는 것도 중요합니다.', 59),
                                                                        ('Flask 애플리케이션에서 헬스 체크 엔드포인트는 왜 필요하고 어떻게 구현하나요?', '헬스 체크 엔드포인트는 운영 중 서비스 상태를 모니터링하거나 로드밸런서가 인스턴스의 상태를 판단하는 데 사용됩니다. Flask에서는 `/health`와 같은 경로를 정의하고, 데이터베이스 연결, 외부 서비스 상태 등을 점검한 후 JSON 형식으로 "OK" 또는 상태 코드를 반환하는 방식으로 구현합니다. 이 엔드포인트는 무거운 연산 없이 빠르게 응답해야 하며, 인증 없이 접근 가능하도록 설정하는 것이 일반적입니다.', 59),
                                                                        ('운영 환경에서 Flask 애플리케이션이 메모리 누수나 과도한 리소스를 사용하는 경우 어떻게 분석하나요?', 'Flask는 Python 기반이므로 `psutil`, `objgraph`, `memory_profiler` 같은 도구로 메모리 사용량을 추적할 수 있습니다. 또한 Gunicorn의 로그, OS-level 모니터링 도구(top, htop), 프로파일링 도구(Py-Spy, cProfile) 등을 활용해 리소스 병목을 분석합니다. 반복 테스트를 통해 재현성을 확보하고, GC(Garbage Collection) 설정이나 DB 커넥션 관리 등을 점검해 원인을 제거합니다.', 59),
                                                                        ('Flask 애플리케이션의 배포 시 Docker Compose를 사용하는 이유는?', 'Docker Compose를 사용하면 Flask 앱, Nginx, Redis, PostgreSQL 등 다양한 서비스를 하나의 `docker-compose.yml` 파일로 정의하고 동시에 실행할 수 있어 배포 및 로컬 개발 환경 구성이 간편해집니다. 의존성 컨테이너를 함께 관리할 수 있으며, 환경 변수 설정, 볼륨 마운트, 네트워크 설정 등을 쉽게 구성할 수 있는 장점이 있습니다.', 59),
                                                                        ('운영 중 Flask 서버가 갑자기 다운되는 현상을 방지하기 위한 방안은?', '서버 다운을 방지하기 위해 Gunicorn의 워커 자동 재시작, Nginx의 타임아웃 및 재시도 설정, 프로세스 매니저(supervisord, systemd) 사용을 통해 장애 복구를 자동화할 수 있습니다. 또한 애플리케이션 레벨에서 예외 처리를 철저히 하고, 외부 API 호출이나 DB 연결 시 타임아웃을 명확히 설정하며, 메모리 누수 및 무한 루프 등 치명적인 오류를 사전에 방지하도록 설계하는 것이 중요합니다.', 59);

-- feedback_fail_log 테이블 생성
CREATE TABLE feedback_fail_log (
                                   id BIGINT AUTO_INCREMENT PRIMARY KEY,
                                   user_id BIGINT NOT NULL,
                                   subject_id BIGINT NOT NULL,
                                   type VARCHAR(255) NOT NULL,
                                   nth INT NOT NULL,
                                   error_code VARCHAR(255) NOT NULL,
                                   error_message VARCHAR(1000) NOT NULL,
                                   created_dt DATETIME(6) NOT NULL
);