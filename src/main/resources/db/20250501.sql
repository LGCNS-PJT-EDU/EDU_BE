-- users 테이블 삭제
DROP TABLE IF EXISTS users;

-- users 테이블 생성
CREATE TABLE users (
  user_id BIGINT AUTO_INCREMENT PRIMARY KEY,
  email VARCHAR(255) NOT NULL,
  nickname VARCHAR(255) NOT NULL,
  password VARCHAR(255),
  login_type VARCHAR(50) NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT TRUE
);

-- diagnosis, choice 테이블 삭제
DROP TABLE IF EXISTS choice;
DROP TABLE IF EXISTS diagnosis;

-- diagnosis 테이블 생성
CREATE TABLE diagnosis (
    diagnosis_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    question TEXT NOT NULL,
    question_type VARCHAR(50) NOT NULL,
    created_dt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- choice 테이블 생성
CREATE TABLE choice (
    choice_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    choice_num INT NOT NULL,
    choice TEXT NOT NULL,
    value VARCHAR(255) NOT NULL,
    created_dt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    diagnosis_id BIGINT NOT NULL,
    CONSTRAINT fk_choice_diagnosis FOREIGN KEY (diagnosis_id) REFERENCES diagnosis(diagnosis_id)
);

-- 공통 질문 1
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (1, '어느 분야에서 성장하고 싶으신가요?', 'COMMON');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(1, 1, '프론트엔드', 'FE'),
(1, 2, '백엔드', 'BE');

-- 공통 질문 2
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (2, '당신이 원하는 강의 분량은 어느정도 인가요?', 'COMMON');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(2, 1, '가볍게 30분!', '0'),
(2, 2, '짧고 굵게 1시간!', '1'),
(2, 3, '찐득하게 3시간!', '2'),
(2, 4, '깊게 공부하는게 좋아 5시간!', '3'),
(2, 5, '나는야 공부벌레 10시간!', '4');

-- 공통 질문 3
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (3, '한 강의에 얼마까지 투자할 생각이 있으신가요?', 'COMMON');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(3, 1, '무료', '0'),
(3, 2, '5만원 이하', '1'),
(3, 3, '5만원 ~ 10만원', '2'),
(3, 4, '10만원 ~ 20만원', '3'),
(3, 5, '20만원 ~ 50만원', '4'),
(3, 6, '50만원 이상', '5');

-- 공통 질문 4
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (4, '책을 통해 공부하는 것을 좋아하시나요?', 'COMMON');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(4, 1, '네.', 'Y'),
(4, 2, '아니오.', 'N');

-- 프론트엔드 질문 1
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (5, '배우고 싶은 프레임워크가 무엇인가요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(5, 1, 'React', 'React'),
(5, 2, 'Vue', 'Vue'),
(5, 3, 'Angular', 'Angular');

-- 프론트엔드 질문 2
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (6, '코드를 깔끔하고 일관되게 관리하는 방법(EsLint & Prettier)에 대해 배우고 싶나요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(6, 1, '네', 'Y'),
(6, 2, '아니오', 'N');

-- 프론트엔드 질문 3
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (7, 'UI를 깔끔하고 체계적으로 만들기 위한 디자인 시스템과 스타일링 방법을 배워보고 싶나요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(7, 1, '네', 'Y'),
(7, 2, '아니오', 'N');

-- 프론트엔드 질문 4
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (8, '프론트엔드 배포를 자동화하는 과정(CI/CD)에 대해 배우고 싶나요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(8, 1, '네', 'Y'),
(8, 2, '아니오', 'N');

-- 프론트엔드 질문 5
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (9, '컴포넌트 단위의 UI 테스트 방법론(예: Storybook, Jest + React Testing Library)을 배우고 싶나요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(9, 1, '네', 'Y'),
(9, 2, '아니오', 'N');

-- 프론트엔드 질문 6
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (10, '사용자의 실제 사용 흐름(E2E 테스트, Cypress 등)을 테스트하는 방법에 대해 배우고 싶나요?', 'FE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(10, 1, '네', 'Y'),
(10, 2, '아니오', 'N');

-- 백엔드 질문 1
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (11, '선호하는 프레임워크는 무엇인가요?', 'BE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(11, 1, 'Java/Spring', 'Java/Spring'),
(11, 2, 'Python/Flask', 'Python/Flask'),
(11, 3, 'Python/Django', 'Python/Django'),
(11, 4, 'JavaScript/Node.js', 'Js/Node'),
(11, 5, 'Kotlin/Spring', 'Kotlin/Spring');

-- 백엔드 질문 2
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (12, 'RDB 종류별 장단점을 학습하고 싶으신가요?', 'BE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(12, 1, '네', 'Y'),
(12, 2, '아니오', 'N');

-- 백엔드 질문 3
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (13, '쿼리 최적화, 데이터 정규화에 대해 학습하고 싶으신가요?', 'BE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(13, 1, '네', 'Y'),
(13, 2, '아니오', 'N');

-- 백엔드 질문 4
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (14, '프레임워크 라이브러리 종류를 학습하고 싶으신가요?', 'BE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(14, 1, '네', 'Y'),
(14, 2, '아니오', 'N');

-- 백엔드 질문 5
INSERT INTO diagnosis (diagnosis_id, question, question_type) VALUES (15, '프로젝트 운영 배포 방법을 학습하고 싶으신가요?', 'BE');
INSERT INTO choice (diagnosis_id, choice_num, choice, value) VALUES
(15, 1, '네', 'Y'),
(15, 2, '아니오', 'N');

-- roadmap, roadmap_management, subject, track 테이블 삭제
DROP TABLE IF EXISTS roadmap;
DROP TABLE IF EXISTS roadmap_management;
DROP TABLE IF EXISTS chapter;
DROP TABLE IF EXISTS subject;
DROP TABLE IF EXISTS track;



-- track(과정) 테이블 생성
CREATE TABLE track(
    track_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    track_nm VARCHAR(255) NOT NULL,
    UNIQUE KEY uk_track (track_nm)
);

-- subject(과목) 테이블 생성
CREATE TABLE subject(
    sub_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    sub_nm VARCHAR(255) NOT NULL,
    sub_type VARCHAR(50) NOT NULL,
    sub_essential VARCHAR(1) NOT NULL,
    base_sub_order INT NOT NULL,
    sub_overview TEXT,
    track_id BIGINT NOT NULL,
    CONSTRAINT fk_subject_track FOREIGN KEY (track_id) REFERENCES track(track_id)
);

-- roadmap_management(로드맵 관리) 테이블 생성
CREATE TABLE roadmap_management(
    roadmap_management_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    roadmap_nm VARCHAR(255),
    roadmap_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    lecture_amount VARCHAR(255),
    price_level VARCHAR(255),
    likes_books BOOLEAN
);

-- roadmap(로드맵) 테이블 생성
CREATE TABLE roadmap(
    roadmap_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    order_sub INT NOT NULL,
    user_id BIGINT NOT NULL,
    sub_id BIGINT NOT NULL,
    roadmap_management_id BIGINT NOT NULL,
    is_complete BOOLEAN NOT NULL DEFAULT FALSE,
    pre_submit_count INT NOT NULL,
    post_submit_count INT NOT NULL,
    level INT NOT NULL DEFAULT 0,
    CONSTRAINT fk_roadmap_user FOREIGN KEY (user_id) REFERENCES users(user_id),
    CONSTRAINT fk_roadmap_subject FOREIGN KEY (sub_id) REFERENCES subject(sub_id),
    CONSTRAINT fk_roadmap_roadmap_management FOREIGN KEY (roadmap_management_id) REFERENCES roadmap_management(roadmap_management_id)
);

-- chapter(단원) 테이블 생성
CREATE TABLE chapter(
    chapter_id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    chapter_nm VARCHAR(255) NOT NULL,
    chapter_order INT NOT NULL,
    sub_id BIGINT NOT NULL,
    CONSTRAINT fk_chapter_subject FOREIGN KEY (sub_id) REFERENCES subject(sub_id)
);

-- track(과정) 정보 주입
INSERT INTO track (track_id, track_nm) VALUES
    (1, '기초지식'),
    (2, 'VCS'),
    (3, 'HTTP 통신 및 상태 동기화 고도화'),
    (4, 'React 기본'),
    (5, 'Vue 기본'),
    (6, 'Angular 기본'),
    (7, '디자인'),
    (8, '상태관리'),
    (9, 'React 심화'),
    (10, 'Vue 심화'),
    (11, 'Angular 심화'),
    (12, '번들링과 빌드 최적화'),
    (13, '배포 자동화 및 인프라 연계'),
    (14, '컴포넌트 테스트 방법론'),
    (15, '화면 테스트 방법론'),
    (16, 'Linux & Internet'),
    (17, 'Java'),
    (18, 'Python'),
    (19, 'JavaScript'),
    (20, 'Kotlin'),
    (21, 'SQL문'),
    (22, 'More About Database'),
    (23, 'Scaling Database'),
    (24, 'Spring & Spring Boot(Java)'),
    (25, 'Node.js & Express.js'),
    (26, 'Django'),
    (27, 'Flask'),
    (28, 'Spring & Spring Boot(Kotlin)'),
    (29, 'Java Advanced'),
    (30, 'Kotlin Advanced'),
    (31, 'Java & Kotlin Advanced'),
    (32, 'Node.js Advanced'),
    (33, 'Django Advanced'),
    (34, 'Flask Advanced');

-- subject(과목) 정보 주입
INSERT INTO subject (sub_id, sub_nm, track_id, sub_type, sub_essential, base_sub_order, sub_overview) VALUES
    (1, 'HTML', 1, 'FE', 'Y', 1, 'HTML이란? 웹페이지의 뼈대!웹사이트에서 내용을 담당해요.예를 들면, 제목, 글, 버튼, 이미지, 표 같은 걸 HTML로 만들어줍니다.마치 건물의 설계도 같다고 생각하면 돼요. 벽이 어디 있는지, 문은 어디 있는지 알려주는 거죠.'),
    (2, 'CSS', 1, 'FE', 'Y', 2, 'CSS란? 웹페이지에 스타일을 입히는 도구!색깔, 크기, 글꼴, 위치 같은 디자인 요소를 조절해요.예를 들면, 글자의 색을 바꾸거나 버튼의 모양을 다듬고,이미지 간 간격을 조정하고 배경 색을 설정할 수 있어요.마치 집 안을 꾸미는 인테리어처럼,보는 사람이 더 편하고 예쁘게 느낄 수 있도록 만드는 역할을 해요.'),
    (3, 'JavaScript', 1, 'FE', 'Y', 3, 'JavaScript란? 웹페이지를 움직이게 하는 도구!클릭, 입력, 스크롤 같은 사용자 행동에 반응하게 만들어요.예를 들면, 버튼을 누르면 팝업이 뜨거나,입력한 정보를 검사하고, 이미지가 자동으로 바뀌는 기능을 만들 수 있어요.마치 리모컨을 눌렀을 때 TV가 반응하듯,웹페이지에 동작과 반응을 더해주는 역할을 해요.'),
    (4, 'TypeScript', 1, 'FE', 'Y', 4, 'TypeScript란? 더 안전하고 체계적인 코드를 쓰게 도와주는 도구!코드를 작성할 때 변수의 타입을 미리 정해서, 실수를 줄이고 예측 가능한 코드를 만들 수 있어요.예를 들면, 숫자만 받아야 하는 자리에 문자를 넣으면 작성 단계에서 오류를 알려줘요.협업할 때 서로의 코드가 어떻게 작동하는지 쉽게 이해할 수 있도록 도와줘요.마치 도면에 치수를 적어두는 것처럼,코드에 규칙과 설명을 더해서 더 튼튼하고 믿을 수 있는 프로그램을 만들게 해줘요.'),
    (5, 'Virtual DOM', 1, 'FE', 'Y', 5, 'Virtual DOM이란? 웹페이지의 변화를 더 빠르게 처리하기 위한 가상의 화면!화면 전체를 매번 다시 그리지 않고, 변경된 부분만 똑똑하게 찾아서 업데이트해줘요.예를 들면, 리스트 하나만 바뀌었을 때 전체를 새로 그리는 대신바뀐 리스트 항목만 바꿔주는 식으로 효율적으로 작동해요.마치 복사본을 두고 비교해서 바뀐 부분만 바꿔주는 것처럼,화면 성능을 높이고 부드럽게 동작하도록 도와주는 기술이에요.'),
    (6, 'Git & GitHub', 2, 'FE', 'Y', 6, 'Git & GitHub란? 코드를 안전하게 관리하고, 함께 작업할 수 있게 해주는 도구!코드를 버전별로 저장하고, 이전 상태로 되돌리거나 여러 사람이 동시에 작업해도 충돌 없이 관리할 수 있어요.예를 들면, 실수로 코드를 잘못 고쳐도 이전 상태로 복원할 수 있고,팀원이 만든 기능을 병합하거나 비교할 수도 있어요.Git은 버전 관리 시스템,GitHub는 이 Git 저장소를 인터넷에 저장하고 협업할 수 있게 해주는 서비스라고 생각하면 돼요.'),
    (7, 'Git Hook (Husky, lint-staged) 자동화', 2, 'FE', 'Y', 7, 'Git Hook (Husky, lint-staged) 자동화란? 코드 저장 전에 자동으로 검사하거나 정리해주는 도구!커밋하거나 푸시할 때, 코드 스타일을 체크하거나 테스트를 실행해서실수나 버그를 미리 막아주는 역할을 해요.예를 들면, 커밋 전에 코드 포맷을 자동으로 맞추거나,오류가 있는 코드는 커밋되지 않도록 차단할 수 있어요.마치 택배를 보내기 전에 포장 상태를 검사하는 것처럼,코드를 안전하게 관리하고 팀의 품질 기준을 지킬 수 있도록 도와주는 도구예요.'),
    (8, 'Axios 인스턴스 관리, 공통 인터셉터 구성', 3, 'FE', 'Y', 8, 'Axios 인스턴스 관리, 공통 인터셉터 구성이란? API 요청을 더 효율적이고 일관되게 관리하는 방법!반복되는 설정을 줄이고, 요청이나 응답에 공통적으로 해야 할 작업을 자동으로 처리할 수 있어요.예를 들면, 모든 요청에 토큰을 자동으로 넣거나,오류가 났을 때 공통 에러 처리 로직을 한 번에 적용할 수 있어요.마치 배달을 보낼 때마다 포장, 주소, 확인 절차를 자동화하는 것처럼,코드 중복을 줄이고 안정적인 통신 흐름을 만들어주는 설정 방식이에요.'),
    (9, 'REST API 기반 에러 처리 / 재시도 로직', 3, 'FE', 'Y', 9, 'REST API 기반 에러 처리 / 재시도 로직이란? API 통신 중 문제가 생겼을 때, 똑똑하게 대응하는 방법!요청이 실패했을 때 사용자에게 알리고,필요하면 자동으로 다시 시도하거나 적절한 조치를 취할 수 있어요.예를 들면, 네트워크 오류로 요청이 실패하면 일정 시간 뒤 다시 보내거나,인증 오류가 나면 자동으로 로그아웃 처리하는 식이에요.마치 배달 실패 시 다시 시도하거나 고객에게 안내하는 시스템처럼,더 안정적이고 사용자 친화적인 API 통신 흐름을 만드는 데 꼭 필요한 기술이에요.'),
    (10, 'React', 4, 'FE', 'N', 10, 'React란? 웹페이지를 빠르고 효율적으로 만들 수 있게 도와주는 JavaScript 라이브러리!화면을 여러 개의 컴포넌트로 나누어 관리하고,데이터가 바뀌면 필요한 부분만 다시 그려줘요.예를 들면, 버튼을 누르면 숫자가 증가하거나,리스트가 자동으로 갱신되는 인터페이스를 쉽게 만들 수 있어요.마치 블록처럼 조각을 쌓아 올리듯 화면을 구성하고,변화에 빠르게 반응하는 인터랙티브한 웹앱을 만들 수 있는 도구예요.'),
    (11, 'Redux', 4, 'FE', 'N', 11, 'Redux란? 복잡한 상태(state)를 한 곳에서 깔끔하게 관리해주는 도구!여러 컴포넌트들이 사용하는 데이터를 중앙에서 모아서 관리하고,필요할 때만 정확하게 바꿔줘요.예를 들면, 로그인 상태, 장바구니 정보, 알림 같은 걸 앱 전체에서 공유하고 업데이트할 수 있어요.마치 중앙 창고에서 필요한 물건을 꺼내 쓰고 바꾸는 것처럼,예측 가능한 방식으로 상태를 관리해서 큰 규모의 앱도 안정적으로 만들 수 있어요.'),
    (12, 'Zustand', 4, 'FE', 'N', 12, 'Zustand란? 가볍고 간단하게 상태를 관리할 수 있는 상태 관리 라이브러리!코드가 적고 구조가 단순해서, 빠르게 사용할 수 있고필요한 데이터만 골라서 효율적으로 관리할 수 있어요.예를 들면, 버튼 클릭으로 숫자를 바꾸거나,로그인 상태를 여러 컴포넌트에서 쉽게 공유할 수 있어요.마치 작은 도구 상자처럼 꼭 필요한 기능만 담겨 있어서,리액트 앱의 상태를 부담 없이 관리할 수 있는 실용적인 도구예요.'),
    (13, 'Vue', 5, 'FE', 'N', 13, 'Vue란? 직관적이고 빠르게 웹 인터페이스를 만들 수 있는 프론트엔드 프레임워크!HTML, CSS, JavaScript를 함께 사용해 화면을 구성하고 데이터와 연결하는 작업을 쉽게 할 수 있어요.예를 들면, 입력한 내용을 화면에 바로 보여주거나,버튼 클릭에 따라 리스트가 자동으로 바뀌는 기능을 간단하게 만들 수 있어요.마치 조립식 블록처럼 구조가 명확하고 유연해서,초보자도 쉽게 배우고, 복잡한 앱도 빠르게 개발할 수 있는 도구예요.'),
    (14, 'Vuex & Pinia', 5, 'FE', 'N', 14, 'Vuex & Pinia란? Vue 앱에서 상태를 체계적으로 관리하기 위한 도구들이에요!Vuex는 **중앙 저장소(store)**를 통해 모든 컴포넌트가 공유하는 데이터를 관리하고,Pinia는 이를 더 간단하고 직관적으로 사용할 수 있도록 도와주는 경량 도구예요.예를 들면, 로그인 정보, 사용자 설정, 장바구니처럼 여러 컴포넌트에서 함께 사용하는 데이터를한 곳에 모아서 변경하고 추적할 수 있어요. 마치 모든 정보를 기록하는 하나의 통제 센터처럼,Vue 애플리케이션을 예측 가능하고 안정적으로 유지해주는 역할을 해요.'),
    (15, 'Angular', 6, 'FE', 'N', 15, 'Angular란? 대규모 웹 애플리케이션을 체계적으로 만들 수 있는 프레임워크! 컴포넌트 기반 구조와 강력한 타입 시스템, 모듈, 라우팅, 폼, HTTP 처리까지웹 개발에 필요한 기능을 하나의 도구로 통합해서 제공해요. 예를 들면, 사용자 인증, 데이터 처리, 화면 전환 등 복잡한 기능들을 분리된 구성으로 깔끔하게 관리할 수 있어요. 마치 잘 정리된 설계도와 작업 도구가 모두 갖춰진 공장처럼, 복잡한 웹앱을 안정적이고 효율적으로 개발할 수 있게 도와주는 프레임워크예요.'),
    (16, 'NgRx', 6, 'FE', 'N', 16, 'NgRx란? Angular에서 애플리케이션의 상태를 일관되게 관리할 수 있도록 도와주는 라이브러리! Redux 패턴을 기반으로 해서, 액션(action), 리듀서(reducer), 스토어(store)를 통해상태의 흐름을 예측 가능하고 체계적으로 관리할 수 있어요. 예를 들면, 사용자 정보, 알림 상태, 페이지 전환 등앱 전체에서 공유되는 데이터를 한 곳에서 처리하고 추적할 수 있어요. 마치 중앙 지휘본부에서 모든 정보를 받아 분석하고 지시하는 것처럼, 복잡한 Angular 앱의 상태를 명확하게 관리해주는 강력한 도구예요.'),
    (17, '컴포넌트 디자인 시스템(Storybook)', 7, 'FE', 'N', 17, '컴포넌트 디자인 시스템 (Storybook)이란? 컴포넌트를 독립적으로 만들고, 테스트하고, 문서화할 수 있는 도구! UI 컴포넌트를 실제 화면처럼 하나씩 확인하고 조작해보면서, 디자인과 기능이 제대로 작동하는지 쉽게 검토할 수 있어요. 예를 들면, 버튼, 카드, 모달 같은 컴포넌트를 페이지와 분리해서 개발하고, 다양한 상태나 테마로 미리보기할 수 있어요. 마치 부품을 미리 조립해보는 전시 공간처럼, 컴포넌트를 체계적으로 관리하고 재사용성을 높여주는 개발 환경이에요.'),
    (18, 'Tailwind CSS', 7, 'FE', 'N', 18, 'Tailwind CSS란? 클래스 이름만으로 빠르게 스타일을 적용할 수 있는 유틸리티 기반 CSS 프레임워크!미리 정의된 클래스들을 조합해서 디자인을 만들 수 있어서,별도로 CSS 파일을 작성하지 않고도 바로 스타일링할 수 있어요.예를 들면, bg-blue-500, text-center, p-4 같은 클래스를 조합해서배경색, 정렬, 여백을 한눈에 설정할 수 있어요. 마치 레고 블록을 조립하듯 필요한 스타일만 골라 붙이는 방식이라서, 반응형 디자인과 빠른 개발에 특히 유용한 도구예요.'),
    (19, 'SCSS', 7, 'FE', 'N', 19, 'SCSS란? CSS를 더 편리하고 체계적으로 작성할 수 있게 도와주는 스타일 확장 문법!중첩, 변수, 함수, 반복문 같은 기능을 활용해서 복잡한 스타일도 재사용 가능하고 깔끔하게 관리할 수 있어요.예를 들면, 색상 값을 변수로 저장하거나,버튼 스타일을 한 번에 정의해서 여러 곳에서 쓸 수 있어요.마치 정리된 노트처럼 규칙 있고 효율적인 방식으로 스타일을 관리할 수 있게 해주는 도구예요.'),
    (20, 'styled', 7, 'FE', 'N', 20, 'styled란? JavaScript 코드 안에서 스타일을 바로 작성할 수 있게 해주는 CSS-in-JS 도구! 컴포넌트 단위로 스타일을 만들 수 있어서, 디자인과 기능을 하나로 묶어 재사용성과 유지보수성을 높일 수 있어요. 예를 들면, styled.button을 만들어서 버튼 스타일을 설정하고, 필요한 곳에 불러와서 바로 사용할 수 있어요. 마치 디자인과 코드를 하나의 부품처럼 함께 관리하는 방식이라서, React 개발에 특히 잘 어울리는 스타일링 도구예요.'),
    (21, 'EsLint & Prettier', 8, 'FE', 'N', 21, 'ESLint & Prettier란? 코드의 품질과 스타일을 자동으로 검사하고 정리해주는 도구! ESLint는 코드에서 잘못된 문법이나 위험한 패턴을 찾아내고, Prettier는 들여쓰기, 줄바꿈, 공백 같은 스타일을 자동으로 정리해줘요. 예를 들면, 세미콜론이 빠졌거나, 들여쓰기가 틀렸을 때 자동으로 수정하거나 경고를 띄워줘서 실수를 줄일 수 있어요. 마치 글을 쓰기 전에 맞춤법 검사기와 문장 정리기를 함께 사용하는 것처럼, 코드를 더 깔끔하고 일관되게 유지해주는 필수 개발 도구예요.'),
    (22, 'Next.js', 9, 'FE', 'N', 22, 'Next.js란? 빠르고 효율적인 웹앱을 만들 수 있게 해주는 React 기반 프레임워크! 정적 사이트 생성(SSG), 서버 사이드 렌더링(SSR), 라우팅, API 구성 같은 기능이 기본으로 제공돼요. 예를 들면, 페이지를 미리 만들어 빠르게 보여주거나, 사용자 요청에 따라 서버에서 데이터를 받아 동적으로 화면을 그릴 수 있어요. 마치 기능이 갖춰진 올인원 개발 도구 세트처럼, 복잡한 설정 없이도 강력한 웹 서비스를 빠르게 개발할 수 있는 프레임워크예요.'),
    (23, 'React 렌더링 최적화 (React.memo, useMemo, useCallback)', 9, 'FE', 'N', 23, 'React 렌더링 최적화란? 불필요한 컴포넌트 렌더링을 줄여서 앱을 더 빠르게 만드는 방법! React.memo, useMemo, useCallback 같은 기능을 활용하면 변경이 없는 부분은 다시 그리지 않고, 계산 비용이 큰 작업도 효율적으로 처리할 수 있어요. 예를 들면, 같은 props를 가진 컴포넌트를 다시 그리지 않거나, 계산된 값을 기억해서 다시 계산하지 않게 할 수 있어요. 마치 필요한 부분만 다시 고치는 스마트한 설계 방식처럼, 성능을 높이고 렌더링을 효율적으로 관리하는 데 꼭 필요한 기술이에요.'),
    (24, 'React Query 심화 (Prefetch, Query Keys, Invalidations)', 9, 'FE', 'N', 24, 'React Query 심화란? 데이터를 똑똑하게 미리 불러오고, 효율적으로 갱신할 수 있는 고급 기술! Prefetch로 사용자가 보기 전에 데이터를 미리 준비하고, Query Keys로 요청을 구분하고 관리하며, Invalidation으로 필요한 시점에 데이터를 자동으로 다시 가져올 수 있어요. 예를 들면, 목록 화면에서 상세 정보를 미리 받아두거나, 수정 후 자동으로 데이터를 새로 고치는 기능을 쉽게 구현할 수 있어요. 마치 냉장고에 미리 음식을 채워두고, 바뀐 재료만 새로 담는 것처럼, 사용자 경험을 끊김 없이 유지하고 네트워크 요청을 최적화할 수 있는 기술이에요.'),
    (25, 'Vue Test Utils (Vue)', 10, 'FE', 'N', 25, 'Vue Test Utils란? Vue 컴포넌트를 테스트할 수 있도록 도와주는 공식 테스트 도구! 컴포넌트를 렌더링하고, 내부 동작을 검사하거나 사용자 이벤트를 시뮬레이션할 수 있어요. 예를 들면, 버튼 클릭 시 이벤트가 잘 작동하는지 확인하거나, 전달된 props에 따라 화면이 올바르게 바뀌는지를 테스트할 수 있어요. 마치 부품 하나하나를 따로 꺼내서 기능을 점검하는 검사 장비처럼, Vue 컴포넌트의 동작을 정확하고 안정적으로 검증할 수 있게 해주는 도구예요.'),
    (26, 'Nuxt.js (Vue)', 10, 'FE', 'N', 26, 'Nuxt.js란? Vue 기반의 웹 애플리케이션을 더 빠르고 쉽게 만들 수 있게 해주는 프레임워크! 페이지 라우팅, 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG) 등 복잡한 설정 없이도 강력한 기능을 바로 사용할 수 있어요. 예를 들면, 파일만 만들어도 자동으로 라우팅되고, SEO에 유리한 방식으로 페이지를 미리 렌더링할 수 있어요. 마치 기본 기능이 잘 갖춰진 웹 개발 전용 템플릿처럼, Vue로 만들 수 있는 프로젝트를 더 효율적이고 확장성 있게 개발할 수 있게 해주는 도구예요.'),
    (27, 'Angular Universal (Angular SSR)', 11, 'FE', 'N', 27, 'Angular Universal이란? Angular 애플리케이션을 서버에서 먼저 렌더링해주는 도구! 브라우저가 아닌 서버에서 HTML을 먼저 만들어서 사용자에게 빠르게 보여주고, 검색 엔진(SEO)에도 잘 노출될 수 있도록 도와줘요. 예를 들면, 사용자가 페이지를 열었을 때 화면이 바로 보이고, 뒤늦게 Angular가 연결되어 상호작용이 이어지는 구조예요. 마치 공장에서 미리 조립된 제품을 바로 전달하는 것처럼, 초기 로딩 속도와 검색 최적화에 강한 Angular 전용 서버 사이드 렌더링 기술이에요.'),
    (28, 'Jasmine (Angular)', 11, 'FE', 'N', 28, 'Jasmine이란? Angular 애플리케이션의 기능이 제대로 동작하는지 확인할 수 있게 해주는 테스트 프레임워크! 함수나 컴포넌트의 결과가 예상대로 나오는지 자동으로 검사할 수 있어요. 테스트 코드를 통해 버그를 줄이고, 리팩터링도 더 안전하게 할 수 있어요. 예를 들면, 특정 함수가 정확한 값을 반환하는지, 버튼 클릭 시 원하는 동작이 일어나는지를 미리 확인할 수 있어요. 마치 기계를 출고하기 전에 작동 여부를 테스트하는 품질 검사 도구처럼, Angular 코드의 신뢰성과 안정성을 높여주는 중요한 테스트 도구예요.'),
    (29, 'Webpack 개념과 설정', 12, 'FE', 'Y', 29, 'Webpack이란? 웹 애플리케이션에서 사용하는 파일들을 하나로 묶어주는 모듈 번들러! HTML, CSS, JavaScript, 이미지 같은 자원들을 의존성에 따라 정리하고, 브라우저가 효율적으로 로딩할 수 있게 하나로 패키징해줘요. 예를 들면, 여러 개의 JS 파일을 하나로 합치거나, 코드를 압축하고, 필요할 때만 불러오도록 설정할 수 있어요. 마치 여러 자재를 정리해서 하나의 박스로 포장하는 공정처럼, 웹 프로젝트를 최적화하고 배포하기 좋게 만들어주는 핵심 도구예요.'),
    (30, 'GitHub Actions로 빌드/배포 자동화', 13, 'FE', 'N', 30, 'GitHub Actions로 빌드/배포 자동화란? 코드가 변경될 때마다 자동으로 테스트하고, 빌드하고, 배포까지 해주는 자동화 도구!정해진 조건에 따라 작업이 자동으로 실행되기 때문에 수작업 없이도 일관된 개발과 배포 환경을 유지할 수 있어요. 예를 들면, 코드를 푸시하면 테스트가 돌고, 빌드가 완료되면 서버에 자동으로 배포되도록 설정할 수 있어요. 마치 공장 자동화 시스템처럼 정해진 순서로 작업이 척척 진행되게 만들어주는 도구로, 지속적인 통합(CI)과 지속적인 배포(CD)를 손쉽게 구현할 수 있어요.'),
    (31, 'Dockerize된 프론트엔드 앱 배포 (Nginx 등)', 13, 'FE', 'N', 31, 'Dockerize된 프론트엔드 앱 배포란? 프론트엔드 애플리케이션을 Docker로 감싸서 어디서든 쉽게 실행하고 배포할 수 있게 만드는 방법! 앱을 Nginx 같은 웹 서버에 올리고, Docker 이미지로 만들면 환경에 상관없이 동일한 방식으로 실행할 수 있어요. 예를 들면, React나 Vue 앱을 빌드한 후 Nginx에 연결하고, 이걸 하나의 Docker 이미지로 만들어서 서버나 클라우드에 배포할 수 있어요. 마치 앱을 하나의 컨테이너에 담아 포장한 후 어떤 환경에서도 똑같이 꺼내 쓸 수 있게 만드는 것처럼, 배포 속도와 안정성을 높여주는 현대적인 프론트엔드 배포 방식이에요.'),
    (32, 'AWS S3 + CloudFront 기반 SPA 배포', 13, 'FE', 'N', 32, 'AWS S3 + CloudFront 기반 SPA 배포란? 정적 웹 애플리케이션(SPA)을 빠르고 안정적으로 전 세계에 배포하는 방법! S3에 앱 파일을 저장하고, CloudFront를 통해 전 세계 사용자에게 빠르게 전달할 수 있어요. 예를 들면, React나 Vue로 만든 앱을 S3에 업로드하고, CloudFront를 통해 CDN으로 연결하면 지연 없이 콘텐츠를 제공할 수 있어요. 마치 전 세계에 배포 센터를 두고 가장 가까운 곳에서 파일을 꺼내주는 구조처럼, SPA를 빠르고 안정적으로 서비스할 수 있는 클라우드 배포 방식이에요.'),
    (33, 'Unit Test, Snapshot Test, Integration Test', 14, 'FE', 'N', 33, 'Unit Test, Snapshot Test, Integration Test란? 코드가 의도한 대로 작동하는지 다양한 수준에서 확인하는 테스트 기법들이에요! Unit Test는 함수나 컴포넌트 하나만 따로 검사하고, Snapshot Test는 출력 결과가 이전과 같은지 자동으로 비교하며, Integration Test는 여러 기능이 함께 잘 작동하는지를 확인해요. 예를 들면, 버튼 클릭 시 동작하는 함수만 테스트하거나, 컴포넌트가 렌더링하는 HTML이 바뀌지 않았는지를 체크하거나, 로그인 → 페이지 이동 흐름까지 전체를 점검할 수 있어요. 마치 부품 테스트, 조립 상태 확인, 실제 작동 테스트를 모두 거치는 품질 검증 과정처럼, 안정적이고 신뢰할 수 있는 코드를 만들기 위한 중요한 개발 절차예요.'),
    (34, 'E2E Test, Visual Regression Test', 15, 'FE', 'N', 34, 'E2E Test, Visual Regression Test란? 앱의 모든 흐름이 실제 사용자처럼 잘 작동하는지, 화면이 이상 없이 보이는지 확인하는 테스트 방법이에요! E2E 테스트는 사용자가 버튼을 클릭하거나 페이지를 이동하는 과정을 자동화된 시나리오로 실행해보고, Visual Regression 테스트는 UI가 예전과 달라진 부분이 없는지 화면을 이미지로 비교해요. 예를 들면, 로그인 → 상품 선택 → 결제 완료까지의 과정을 자동으로 따라가며 검증하거나, 디자인이 바뀌었는지 픽셀 단위로 비교해서 알려줄 수 있어요. 마치 사람처럼 앱을 실제로 사용해보고, 화면을 눈으로 비교하는 것처럼, 전체 동작과 시각적인 완성도를 함께 검증할 수 있는 고급 테스트 방식이에요.'),
    (35, '리눅스 명령어', 16, 'BE', 'Y', 1, '리눅스 명령어란? 터미널에서 직접 컴퓨터를 조작할 수 있게 해주는 텍스트 기반의 도구! 파일 생성, 복사, 이동부터 시스템 관리, 프로세스 확인, 서버 설정까지 명령어 한 줄로 다양한 작업을 빠르고 정확하게 수행할 수 있어요. 예를 들면, ls로 폴더 목록을 확인하고, cd로 위치를 옮기거나, chmod, ps, top 같은 명령어로 권한과 시스템 상태를 관리할 수 있어요. 마치 명령 센터에서 키워드 하나로 기계를 제어하듯, 개발과 운영 환경에서 효율적이고 강력한 제어력을 제공해주는 기본 도구예요.'),
    (36, 'HTTP, HTTPS, DNS, TCP/IP 기본 개념', 16, 'BE', 'Y', 2, 'HTTP, HTTPS, DNS, TCP/IP 기본 개념이란? 인터넷이 어떻게 작동하는지를 이해하는 데 꼭 필요한 핵심 네트워크 개념들이에요! HTTP/HTTPS는 웹에서 정보를 주고받는 방식이고, DNS는 사람이 기억하기 쉬운 주소(도메인)를 숫자 IP로 바꿔주는 시스템이며, TCP/IP는 데이터가 안전하고 정확하게 목적지에 도착하도록 돕는 전달 규칙이에요. 예를 들면, 브라우저에 주소를 입력하면 DNS가 서버를 찾아주고, HTTP가 서버에 요청을 보내고, TCP/IP가 그 데이터를 안정적으로 전달해줘요. 마치 우편 주소를 찾아 편지를 보내고, 정확히 배달되는 전체 과정처럼, 웹과 앱이 원활하게 통신할 수 있도록 돕는 기본 원리들이에요.'),
    (37, 'Git & GitHub', 2, 'BE', 'Y', 3, 'Git & GitHub란? 코드를 안전하게 관리하고, 함께 작업할 수 있게 해주는 도구! 코드를 버전별로 저장하고, 이전 상태로 되돌리거나 여러 사람이 동시에 작업해도 충돌 없이 관리할 수 있어요. 예를 들면, 실수로 코드를 잘못 고쳐도 이전 상태로 복원할 수 있고, 팀원이 만든 기능을 병합하거나 비교할 수도 있어요. Git은 버전 관리 시스템, GitHub는 이 Git 저장소를 인터넷에 저장하고 협업할 수 있게 해주는 서비스라고 생각하면 돼요.'),
    (38, 'Git Hook (Husky, lint-staged) 자동화', 2, 'BE', 'Y', 4, 'Git Hook (Husky, lint-staged) 자동화란?코드 저장 전에 자동으로 검사하거나 정리해주는 도구!커밋하거나 푸시할 때, 코드 스타일을 체크하거나 테스트를 실행해서실수나 버그를 미리 막아주는 역할을 해요.예를 들면, 커밋 전에 코드 포맷을 자동으로 맞추거나,오류가 있는 코드는 커밋되지 않도록 차단할 수 있어요.마치 택배를 보내기 전에 포장 상태를 검사하는 것처럼,코드를 안전하게 관리하고 팀의 품질 기준을 지킬 수 있도록 도와주는 도구예요.'),
    (39, 'Java', 17, 'BE', 'N', 5, 'Java란? 안정적이고 확장성 있는 프로그램을 만들 수 있는 대표적인 객체지향 프로그래밍 언어! 운영체제에 상관없이 어디서나 실행할 수 있고, 대규모 시스템부터 모바일 앱, 웹 서비스, 서버 개발까지 폭넓게 사용돼요. 예를 들면, 은행의 거래 시스템, 안드로이드 앱, 기업용 백엔드 서버 등이 Java로 만들어져요. 마치 한 번 만들면 어디서든 쓸 수 있는 범용 기계처럼, 신뢰성과 이식성이 뛰어난 실무 중심의 프로그래밍 언어예요.'),
    (40, 'Python', 18, 'BE', 'N', 6, 'Python이란? 간결하고 읽기 쉬운 문법으로 다양한 분야에서 활용되는 범용 프로그래밍 언어! 웹 개발, 데이터 분석, 인공지능, 자동화 스크립트 등 다양한 목적에 맞게 빠르게 개발할 수 있어요. 예를 들면, 웹 서버를 만들거나, 엑셀 데이터를 처리하거나, AI 모델을 학습시키는 작업도 Python으로 할 수 있어요. 마치 쉽고 유연한 만능 도구처럼, 입문자부터 전문가까지 널리 사용하는 실용적인 프로그래밍 언어예요.'),
    (41, 'JavaScript', 19, 'BE', 'N', 7, 'JavaScript란? 웹페이지에 동작을 추가하고 사용자와의 상호작용을 가능하게 해주는 프로그래밍 언어! 클릭, 입력, 스크롤 같은 이벤트에 반응하거나 화면의 내용을 동적으로 바꾸는 기능을 구현할 수 있어요. 예를 들면, 버튼을 눌렀을 때 팝업이 뜨거나, 실시간으로 입력값을 확인하고 결과를 보여줄 수 있어요. 마치 정적인 화면에 생명을 불어넣는 조종 장치처럼, 웹을 더 풍부하고 인터랙티브하게 만들어주는 핵심 기술이에요.'),
    (42, 'Kotlin', 20, 'BE', 'N', 8, 'Kotlin이란? 간결하면서도 안정적인 코드를 작성할 수 있게 해주는 현대적인 프로그래밍 언어! Java보다 적은 코드로 동일한 기능을 구현할 수 있고, 안드로이드 앱 개발을 비롯해 서버, 웹, 데스크탑 등 다양한 분야에서 사용돼요. 예를 들면, 앱의 버튼 클릭 동작을 쉽게 구현하거나, 안전한 방식으로 null 값을 처리할 수 있어요. 마치 사용하기 편하면서도 강력한 기능이 담긴 도구 상자처럼, 생산성과 안정성을 모두 갖춘 실용적인 프로그래밍 언어예요.'),
    (43, 'SQL문', 21, 'BE', 'Y', 9, 'SQL문이란? 데이터베이스에 저장된 정보를 조회하고 수정할 수 있게 해주는 데이터 처리 언어! 데이터를 추가하거나 검색하고, 변경하거나 삭제하는 작업을 명령문 한 줄로 빠르고 정확하게 실행할 수 있어요. 예를 들면, 회원 목록을 불러오거나, 특정 조건에 맞는 데이터를 찾고, 필요한 내용을 새로 추가하거나 삭제할 수도 있어요. 마치 창고 안의 정보를 검색하고 정리하는 명령어 세트처럼, 데이터를 다루는 데 꼭 필요한 기본 도구예요.'),
    (44, 'More About Database(RDB 종류, NoSQL)', 22, 'BE', 'N', 10, 'More About Database란? 다양한 형태의 데이터베이스 구조와 특성을 이해하고, 상황에 맞게 선택할 수 있도록 돕는 개념이에요! 관계형 데이터베이스(RDB)는 표 형식으로 데이터를 저장하고 SQL로 관리하며, NoSQL은 유연한 구조로 대규모 데이터나 빠른 처리에 적합한 방식이에요. 예를 들면, MySQL, PostgreSQL 같은 RDB는 정형 데이터를 정확하게 관리할 때, MongoDB, Redis 같은 NoSQL은 유동적인 데이터나 실시간 처리에 자주 사용돼요. 마치 서류 캐비닛처럼 정리된 방식과, 메모장처럼 자유로운 방식을 모두 이해하는 것처럼, 데이터의 성격과 목적에 따라 적절한 저장 방식을 선택하는 데 필요한 핵심 지식이에요.'),
    (45, 'Scaling Databases(쿼리튜닝, 정규화)', 23, 'BE', 'N', 11, 'Scaling Databases란? 많은 데이터를 빠르고 안정적으로 처리하기 위해 데이터베이스를 최적화하는 방법이에요! 쿼리 튜닝은 느린 쿼리를 분석하고 개선해서 성능을 높이는 작업이고, 정규화는 데이터를 구조적으로 나눠 중복을 줄이고 일관성을 유지하는 방식이에요. 예를 들면, 느린 검색 속도를 개선하거나, 하나의 테이블을 여러 개로 나눠 효율적으로 관리할 수 있어요. 마치 창고의 물건을 빠르게 찾기 위해 선반을 정리하고 동선을 최적화하는 것처럼, 데이터를 효과적으로 저장하고 처리하기 위한 필수적인 설계와 운영 기술이에요.'),
    (46, 'Spring & Spring Boot(Java)', 24, 'BE', 'N', 12, 'Java & Spring이란? 견고하고 확장성 있는 백엔드 애플리케이션을 만들기 위한 대표적인 기술 조합이에요! Java는 안정성과 범용성이 뛰어난 프로그래밍 언어이고, Spring은 Java 기반으로 웹 서버, API, 데이터 처리 등을 효율적으로 구성할 수 있게 도와주는 프레임워크예요. 예를 들면, 회원가입 기능이나 데이터베이스 연동, API 서버 구축을 안정적으로 구현할 수 있어요. 마치 튼튼한 재료(Java) 위에 체계적인 설계도(Spring)를 얹는 건축처럼, 기업에서도 널리 사용하는 신뢰도 높은 백엔드 개발 기술이에요.'),
    (47, 'Node.js & Express.js', 25, 'BE', 'N', 13, 'Node.js란? JavaScript로 서버를 만들 수 있게 해주는 런타임 환경이에요! 비동기 처리와 이벤트 기반 구조 덕분에 가볍고 빠르게 동작하며, 웹 서버, API, 실시간 채팅, 파일 처리 등 다양한 백엔드 기능을 구현할 수 있어요. 예를 들면, 웹사이트의 로그인 처리나 데이터 전송 API, 실시간 메시징 기능 같은 서버 역할을 JavaScript로 만들 수 있어요. 마치 한 가지 언어로 프론트엔드와 백엔드를 모두 다룰 수 있는 멀티툴처럼, 유연하고 효율적인 웹 서비스 구축에 적합한 서버 사이드 기술이에요.'),
    (48, 'Django', 26, 'BE', 'N', 14, 'Django란? 빠르고 효율적으로 웹 애플리케이션을 만들 수 있게 도와주는 Python 기반의 웹 프레임워크예요! 프로젝트 구조, 관리자 페이지, 인증 시스템 같은 기능이 기본으로 포함돼 있어서 복잡한 웹 서비스를 빠르게 개발할 수 있어요. 예를 들면, 게시판, 블로그, 쇼핑몰처럼 로그인, 글쓰기, 데이터 저장이 필요한 웹사이트를 쉽게 만들 수 있어요. 마치 필수 도구가 다 갖춰진 웹 개발용 공구 세트처럼, 안정적이고 생산성 높은 백엔드 웹 개발을 가능하게 해주는 프레임워크예요.'),
    (49, 'Flask', 27, 'BE', 'N', 15, 'Flask란? 가볍고 유연하게 웹 애플리케이션을 만들 수 있는 Python 기반의 마이크로 웹 프레임워크예요! 필수 기능만 최소한으로 제공하고, 필요한 구성은 개발자가 자유롭게 선택해서 확장할 수 있어요. 예를 들면, 간단한 웹 페이지부터 API 서버, 데이터 시각화 도구까지 작고 빠르게 시작해서 점점 발전시켜 나갈 수 있어요. 마치 필요한 부품만 골라 조립할 수 있는 맞춤형 키트처럼, 단순하지만 강력하게 웹 서비스를 만들 수 있는 실용적인 프레임워크예요.'),
    (50, 'Spring & Spring Boot(Kotlin)', 28, 'BE', 'N', 16, 'Kotlin & Spring이란? 간결한 문법의 Kotlin 언어로, 강력한 Spring 프레임워크 기반의 백엔드 애플리케이션을 만드는 기술 조합이에요! Kotlin은 안정성과 생산성이 뛰어나고, Spring은 다양한 웹 기능을 체계적으로 제공해요. 두 기술이 만나면 더 짧고 명확한 코드로 효율적인 서버 개발이 가능해요. 예를 들면, API 서버 구축, 데이터베이스 연결, 인증 시스템 구현 등을 더 읽기 쉬운 코드로 빠르게 만들 수 있어요. 마치 스마트한 언어와 견고한 설계가 결합된 개발 환경처럼, 안정성과 개발 속도를 모두 잡고 싶은 백엔드 개발자에게 최적의 조합이에요.'),
    (51, 'Java + Spring 라이브러리 & 유틸', 29, 'BE', 'N', 17, 'Spring 라이브러리 & 유틸이란? 복잡한 웹 애플리케이션을 더 쉽게 만들 수 있도록 도와주는 Spring의 구성 요소와 도구들이에요! 보안, 데이터 처리, 배치 작업 등 다양한 기능을 담당하는 라이브러리들이 Spring 생태계 안에 잘 정리되어 있고, 개발자가 필요한 기능만 선택해 사용할 수 있어요. 예를 들면, Spring Security로 로그인과 권한을 관리하고, Spring Data JPA로 복잡한 SQL 없이 DB를 다루며, Spring Batch로 대용량 데이터를 순차적으로 처리할 수 있어요. 마치 전문 공정별로 나뉜 자동화 도구 세트처럼, 웹 서비스의 복잡한 요구사항을 손쉽게 해결할 수 있도록 도와주는 실전 중심의 유틸 모음이에요.'),
    (52, 'Kotlin + Spring 라이브러리 & 유틸', 30, 'BE', 'N', 18, 'Spring 라이브러리 & 유틸이란? 웹 애플리케이션을 더 강력하고 효율적으로 만들 수 있도록 도와주는 Spring의 확장 도구 모음이에요! 보안, 데이터 관리, 배치 처리, 메시지 큐 연동 등 복잡한 기능들을 쉽게 구현할 수 있는 다양한 라이브러리와 유틸리티가 포함돼 있어요. 예를 들면, Spring Security로 인증과 권한을 설정하고, Spring Data JPA로 데이터베이스와 편리하게 연결하며, Spring Batch로 정기적인 데이터 처리 작업을 자동화할 수 있어요. 마치 다양한 기능을 플러그처럼 추가할 수 있는 개발 키트처럼, 복잡한 웹 시스템을 간단하고 일관된 방식으로 개발할 수 있도록 도와주는 도구들이에요.'),
    (53, 'Java,Kotlin + Spring 운영 & 배포', 31, 'BE', 'N', 19, 'Java, Kotlin + Spring 운영 & 배포란? Spring으로 만든 웹 애플리케이션을 실제 서비스 환경에 올리고, 안정적으로 관리하는 방법이에요! 빌드, 설정, 서버 배포, 로깅, 모니터링 같은 운영 전반의 과정과 Java 또는 Kotlin 코드 기반에서 효율적인 실행 환경을 구성하는 내용을 다뤄요. 예를 들면, 애플리케이션을 Docker로 감싸서 배포하거나, 서버에서 환경변수 설정, 무중단 배포, 장애 대응 방법까지 실무 중심으로 관리할 수 있어요. 마치 완성된 제품을 고객에게 전달하고 유지 관리하는 전 과정처럼, 개발된 서비스를 실제로 운영하며 신뢰성 있게 제공하기 위한 핵심 실무 과정이에요.'),
    (54, 'Node.js 라이브러리 & 유틸', 32, 'BE', 'N', 20, 'Node.js 라이브러리 & 유틸이란? 백엔드 개발을 더 빠르고 효율적으로 도와주는 Node.js의 필수 도구와 유틸리티 모음이에요! 서버 구축, 파일 처리, 인증, 데이터 검증, 로깅 등 반복되는 기능을 간단하게 구현할 수 있도록 도와주는 다양한 라이브러리를 활용할 수 있어요. 예를 들면, Express로 간단한 웹 서버를 만들고, Multer로 파일 업로드를 처리하거나, jsonwebtoken으로 로그인 인증을 구현할 수 있어요. 마치 자주 쓰는 부품을 모아둔 공구 세트처럼, Node.js 프로젝트를 더 간결하고 실용적으로 완성할 수 있게 해주는 핵심 도구들이에요.'),
    (55, 'Node.js 운영 & 배포', 32, 'BE', 'N', 21, 'Node.js 운영 & 배포란? Node.js로 만든 서버 애플리케이션을 실제 환경에서 실행하고 안정적으로 서비스하는 방법이에요! 프로세스 관리, 환경 설정, 배포 자동화, 로깅, 에러 대응 등 앱이 끊김 없이 잘 작동하도록 뒷단에서 돌보는 모든 운영 작업을 다뤄요. 예를 들면, PM2로 서버를 항상 켜두거나, Docker로 패키징해서 배포하고, CI/CD로 코드 변경을 자동 반영할 수 있어요. 마치 서비스를 매끄럽게 유지하는 무대 뒤 기술팀처럼, Node.js 앱을 실제 사용자에게 안정적으로 제공하기 위한 실무 중심의 기술이에요.'),
    (56, 'Django 라이브러리 & 유틸', 33, 'BE', 'N', 22, 'Django 라이브러리 & 유틸이란? Django 개발을 더 빠르고 편리하게 만들어주는 확장 도구와 유용한 패키지들의 모음이에요! 인증, 권한 관리, 파일 업로드, API 구축, 시간 처리 등 웹 개발에서 자주 쓰이는 기능들을 쉽게 구현할 수 있도록 도와줘요. 예를 들면, Django REST framework로 API 서버를 만들고, django-allauth로 소셜 로그인 기능을 추가하거나, django-environ으로 환경변수를 깔끔하게 관리할 수 있어요. 마치 자주 쓰는 기능들을 미리 조립해둔 보조 키트처럼, Django 프로젝트를 더 강력하고 효율적으로 완성할 수 있도록 도와주는 도구들이에요.'),
    (57, 'Django 운영 & 배포', 33, 'BE', 'N', 23, 'Django 운영 & 배포란? Django로 만든 웹 애플리케이션을 실제 서버에 배포하고 안정적으로 운영하는 방법이에요! 서버 환경 구성, 보안 설정, 데이터베이스 연결, 로그 관리, 배포 자동화 등 서비스를 사용자에게 문제없이 제공하기 위한 실전 기술들을 다뤄요. 예를 들면, Gunicorn과 Nginx를 함께 사용해 앱을 배포하거나, 환경변수 설정, 정적 파일 처리, CI/CD 파이프라인 구성 등을 수행할 수 있어요. 마치 개발된 웹서비스를 무대 위에 올려 안전하게 공연하는 운영팀처럼, Django 프로젝트를 실서비스로 전환하고 안정적으로 유지하는 데 필요한 핵심 과정이에요.'),
    (58, 'Flask 라이브러리 & 유틸', 34, 'BE', 'N', 24, 'Flask 라이브러리 & 유틸이란? Flask 개발을 더 빠르고 확장성 있게 만들어주는 다양한 도구와 확장 패키지들의 모음이에요! ORM, 인증, 폼 처리, REST API 구축, 환경 설정 등 기본 Flask 위에 필요한 기능을 유연하게 붙일 수 있어요. 예를 들면, Flask-SQLAlchemy로 데이터베이스를 다루고, Flask-Login으로 사용자 인증을 구현하거나, Flask-Migrate로 DB 변경 사항을 관리할 수 있어요. 마치 심플한 프레임워크를 확장 가능한 플랫폼으로 바꿔주는 조립 부품들처럼, 작고 유연한 Flask 프로젝트를 실전 서비스 수준으로 키워주는 실용적인 도구들이에요.'),
    (59, 'Flask 운영 & 배포', 34, 'BE', 'N', 25, 'Flask 운영 & 배포란? Flask로 만든 웹 애플리케이션을 실제 서버에 올리고 안정적으로 서비스하는 방법이에요! 서버 설정, 프로세스 관리, 정적 파일 처리, 환경변수 구성, 배포 자동화 등을 통해 Flask 앱을 실사용 환경에서 안전하게 운영할 수 있어요. 예를 들면, Gunicorn으로 애플리케이션을 실행하고, Nginx를 통해 외부 요청을 받아 전달하며, Docker나 CI/CD로 배포 작업을 자동화할 수 있어요. 마치 간단한 웹 앱을 실제 제품으로 포장하고 고객에게 전달하는 과정처럼, Flask 프로젝트를 실서비스 수준으로 끌어올리기 위한 핵심 운영 기술이에요.');

-- chapter(단원) 정보 주입
INSERT INTO chapter (chapter_id, chapter_nm, chapter_order, sub_id) VALUES
       (1, '기본 구조와 시맨틱 태그', 1, 1),
       (2, '텍스트 & 목록 요소', 2, 1),
       (3, '이미지·멀티미디어 & IFrame', 3, 1),
       (4, '폼 & 입력 요소', 4, 1),
       (5, '테이블·메타데이터 & 접근성', 5, 1),
       (6, '선택자 & 우선순위', 1, 2),
       (7, '박스 모델 & 배치', 2, 2),
       (8, 'Flexbox · Grid 레이아웃', 3, 2),
       (9, '색상·타이포그래피·배경', 4, 2),
       (10, '애니메이션·전환·반응형 디자인', 5, 2),
       (11, '기초 문법과 데이터 타입', 1, 3),
       (12, '조건문과 반복문', 2, 3),
       (13, '함수와 스코프', 3, 3),
       (14, '배열과 객체', 4, 3),
       (15, 'DOM 조작과 이벤트 처리', 5, 3),
       (16, '기본 타입 · 타입 단언 & 타입 추론', 1, 4),
       (17, '함수 · 제네릭 & 오버로드', 2, 4),
       (18, '인터페이스 · 타입 별칭 & 고급 타입', 3, 4),
       (19, '클래스 · 모듈 · 데코레이터 & 접근 제한자', 4, 4),
       (20, '고급 제네릭 · 조건부 타입 & 유틸리티 타입', 5, 4),
       (21, 'Virtual DOM 원리 & 역사', 1, 5),
       (22, 'Diff 알고리즘 & 키의 역할', 2, 5),
       (23, '리컨실리에이션(재조정) 사이클', 3, 5),
       (24, '실제 DOM 패치(Patching) 최적화', 4, 5),
       (25, '한계·대안 & 최신 동향', 5, 5),
       (26, 'Git 기본 개념과 설치', 1, 6),
       (27, '로컬 저장소 관리', 2, 6),
       (28, '브랜치와 병합 전략', 3, 6),
       (29, 'GitHub와 원격 저장소 활용', 4, 6),
       (30, '협업, PR, 이슈 및 고급 기능', 5, 6),
       (31, 'Git Hook 기본 개념', 1, 7),
       (32, 'Husky 소개와 설치', 2, 7),
       (33, 'Husky로 Git Hook 제어하기', 3, 7),
       (34, 'lint-staged 소개와 활용', 4, 7),
       (35, 'Husky + lint-staged 통합 자동화 실습', 5, 7),
       (36, 'Axios 인스턴스 기초 & 환경별 설정', 1, 8),
       (37, '전역 Request 인터셉터 구성', 2, 8),
       (38, '전역 Response 인터셉터 구성', 3, 8),
       (39, '토큰 자동 갱신 & 충돌 방지 패턴', 4, 8),
       (40, '고급 패턴·유틸리티화 & 테스트', 5, 8),
       (41, '에러 모델 설계 & 표준 HTTP 상태 코드', 1, 9),
       (42, '클라이언트-측 에러 분류 & 처리 전략', 2, 9),
       (43, '재시도 기본 전략 & 안전한 멱등성', 3, 9),
       (44, '고급 재시도 관리(회로 차단·폴리시)', 4, 9),
       (45, '관측·테스트 & 운영 베스트 프랙티스', 5, 9),
       (46, 'JSX 및 컴포넌트 기초', 1, 10),
       (47, 'Props와 State', 2, 10),
       (48, '이벤트 처리와 조건부 렌더링', 3, 10),
       (49, '리스트 렌더링과 키', 4, 10),
       (50, 'Hooks 및 고급 컴포넌트 구성', 5, 10),
       (51, 'Redux 기본 개념', 1, 11),
       (52, '액션과 리듀서', 2, 11),
       (53, '스토어와 상태 관리', 3, 11),
       (54, '미들웨어와 비동기 처리', 4, 11),
       (55, 'Redux Toolkit', 5, 11),
       (56, 'Zustand 기본 개념과 설치', 1, 12),
       (57, '상태 생성 및 구독 (get, set)', 2, 12),
       (58, 'store 분리 및 커스텀 훅 패턴', 3, 12),
       (59, '미들웨어 활용 (persist, devtools 등)', 4, 12),
       (60, 'Zustand 실전 예제 및 성능 최적화', 5, 12),
       (61, '템플릿 구문 & 인스턴스 기초', 1, 13),
       (62, '반응형 시스템', 2, 13),
       (63, '디렉티브 & 라이프사이클 훅', 3, 13),
       (64, '컴포넌트·Props·슬롯', 4, 13),
       (65, '라우팅·상태 관리 & Composition API', 5, 13),
       (66, 'Vuex 기본 개념', 1, 14),
       (67, 'State, Getters, Mutations', 2, 14),
       (68, 'Actions와 비동기 처리', 3, 14),
       (69, 'Pinia 기본 사용법', 4, 14),
       (70, 'Pinia와 Vue 생태계 통합', 5, 14),
       (71, '템플릿 구문 & 인스턴스 기초', 1, 15),
       (72, '반응형 시스템', 2, 15),
       (73, '디렉티브 & 라이프사이클 훅', 3, 15),
       (74, '컴포넌트·Props·슬롯', 4, 15),
       (75, '라우팅·상태 관리 & Composition API', 5, 15),
       (76, 'NgRx 기본 개념', 1, 16),
       (77, 'State, Actions, Reducers', 2, 16),
       (78, 'Effects와 비동기 처리', 3, 16),
       (79, 'Selectors와 Store 접근', 4, 16),
       (80, 'NgRx Entity와 고급 기능', 5, 16),
       (81, '디자인 시스템 기초와 Atomic Design', 1, 17),
       (82, 'Storybook 기본 설정과 사용법', 2, 17),
       (83, 'Args, Controls, Docs를 활용한 컴포넌트 문서화', 3, 17),
       (84, '컴포넌트 테스트 및 접근성 검증', 4, 17),
       (85, '디자인 시스템 확장 전략과 협업 방식', 5, 17),
       (86, 'Tailwind 기본 문법과 구성요소', 1, 18),
       (87, '레이아웃과 Flex/Grid 활용', 2, 18),
       (88, '반응형 디자인과 상태 기반 클래스', 3, 18),
       (89, 'Tailwind 구성 및 커스터마이징', 4, 18),
       (90, '프로젝트 설계 및 실전 적용 전략', 5, 18),
       (91, 'SCSS 기본 문법과 변수 사용', 1, 19),
       (92, 'Mixin, Function, Extend', 2, 19),
       (93, '조건문과 반복문', 3, 19),
       (94, 'SCSS 모듈화 및 import', 4, 19),
       (95, 'SCSS를 활용한 프로젝트 구조 설계', 5, 19),
       (96, '선택자 & 우선순위', 1, 20),
       (97, '박스 모델 & 레이아웃', 2, 20),
       (98, 'Flexbox & Grid', 3, 20),
       (99, '반응형 디자인 & 미디어 쿼리', 4, 20),
       (100, '애니메이션 & 트랜지션', 5, 20),
       (101, 'ESLint 기본 개념과 설치', 1, 21),
       (102, 'ESLint 규칙과 설정 파일', 2, 21),
       (103, 'Prettier 기본 개념과 포맷팅', 3, 21),
       (104, 'ESLint와 Prettier 통합 설정', 4, 21),
       (105, '실제 적용 및 커스텀 규칙 작성', 5, 21),
       (106, 'Next.js 기본 개념과 프로젝트 설정', 1, 22),
       (107, '라우팅과 네비게이션', 2, 22),
       (108, '데이터 페칭과 렌더링 방식', 3, 22),
       (109, 'API Routes와 서버 기능', 4, 22),
       (110, 'Next.js 고급 기능 및 최적화', 5, 22),
       (111, '렌더링 비용 이해 & 불필요한 리렌더 탐지', 1, 23),
       (112, 'React.memo 로 컴포넌트 메모이제이션', 2, 23),
       (113, '계산 값 캐싱 — useMemo', 3, 23),
       (114, '콜백 재생성 방지 — useCallback', 4, 23),
       (115, '실전 튜닝 & 측정', 5, 23),
       (116, 'Query Keys & 캐싱 기본', 1, 24),
       (117, 'Prefetch & 백그라운드 업데이트', 2, 24),
       (118, 'Mutations & 캐시 무효화', 3, 24),
       (119, '고급 Query Key 패턴', 4, 24),
       (120, '성능 튜닝 & 테스트', 5, 24),
       (121, 'Vue Test Utils 기본 개념', 1, 25),
       (122, 'Mount와 ShallowMount', 2, 25),
       (123, '컴포넌트 상호작용 테스트', 3, 25),
       (124, '비동기 및 이벤트 테스트', 4, 25),
       (125, 'Mock, Stub, 플러그인 테스트', 5, 25),
       (126, 'Nuxt.js 기본 구조 및 라우팅', 1, 26),
       (127, '페이지 및 레이아웃', 2, 26),
       (128, '상태 관리와 Vuex', 3, 26),
       (129, '비동기 데이터 처리와 API 연동', 4, 26),
       (130, 'Nuxt.js 고급 기능과 배포', 5, 26),
       (131, 'Angular Universal 기본 개념', 1, 27),
       (132, 'SSR 설정 및 빌드', 2, 27),
       (133, '서버 측 렌더링 흐름 이해', 3, 27),
       (134, '라우팅과 데이터 프리페칭', 4, 27),
       (135, '고급 최적화 및 배포 전략', 5, 27),
       (136, 'Jasmine 기본 개념', 1, 28),
       (137, 'Matchers와 테스트 구조', 2, 28),
       (138, '비동기 테스트', 3, 28),
       (139, '스파이(Spy)와 Mock', 4, 28),
       (140, 'Angular 테스트 통합', 5, 28),
       (141, 'Webpack의 동작 원리와 핵심 개념', 1, 29),
       (142, '기본 설정 파일 작성 (webpack.config.js)', 2, 29),
       (143, '로더(Loader) 개념과 적용', 3, 29),
       (144, '플러그인(Plugin) 개념과 활용', 4, 29),
       (145, '최적화와 개발 서버 설정', 5, 29),
       (146, 'GitHub Actions 기본 개념', 1, 30),
       (147, 'Workflow 트리거와 조건 설정', 2, 30),
       (148, 'Job & Step 구성 및 실행 환경', 3, 30),
       (149, 'CI/CD 구축 실전 - 빌드 & 테스트', 4, 30),
       (150, 'CD 실전 - 배포 자동화 & 시크릿 관리', 5, 30),
       (151, '프론트엔드 정적 빌드 이해', 1, 31),
       (152, 'Docker 기본 및 이미지 생성', 2, 31),
       (153, 'Nginx 설정 및 정적 파일 서빙', 3, 31),
       (154, 'Docker Compose 및 포트 연결', 4, 31),
       (155, '클라우드/서버 환경 배포 전략', 5, 31),
       (156, 'S3 버킷 생성 및 정적 웹사이트 호스팅', 1, 32),
       (157, 'CloudFront 배포 생성 및 연결', 2, 32),
       (158, '정적 자산 업로드 및 캐싱 전략', 3, 32),
       (159, '도메인 연결 및 HTTPS 설정', 4, 32),
       (160, '배포 자동화 및 CI/CD 연동', 5, 32),
       (161, '테스트 기본 개념 & 종류', 1, 33),
       (162, 'Unit Test 실전 – 로직 & 함수 테스트', 2, 33),
       (163, 'React 컴포넌트 테스트', 3, 33),
       (164, 'Snapshot Test & Mock 전략', 4, 33),
       (165, 'Integration Test & 실전 패턴', 5, 33),
       (166, 'E2E 테스트 개요 & 자동화 흐름 이해', 1, 34),
       (167, 'Cypress 실습 – 기본 명령어 & 흐름 구성', 2, 34),
       (168, '고급 E2E 전략 – 인증, 라우팅, 상태 검증', 3, 34),
       (169, 'Visual Regression Test 원리 & 도구', 4, 34),
       (170, 'E2E + VRT 통합 테스트 전략', 5, 34),
       (171, '기본 명령어와 파일 시스템', 1, 35),
       (172, '사용자와 권한 관리', 2, 35),
       (173, '프로세스와 작업 관리', 3, 35),
       (174, '패키지 및 소프트웨어 설치', 4, 35),
       (175, '시스템 관리와 로그 분석', 5, 35),
       (176, '네트워크 기본 개념', 1, 36),
       (177, 'IP 주소와 서브넷', 2, 36),
       (178, 'HTTP와 HTTPS', 3, 36),
       (179, 'DNS와 도메인', 4, 36),
       (180, '웹 보안 및 인증', 5, 36),
       (181, 'Git 기본 개념과 설치', 1, 37),
       (182, '로컬 저장소 관리', 2, 37),
       (183, '브랜치와 병합 전략', 3, 37),
       (184, 'GitHub와 원격 저장소 활용', 4, 37),
       (185, '협업, PR, 이슈 및 고급 기능', 5, 37),
       (186, 'Git Hook 기본 개념', 1, 38),
       (187, 'Husky 소개와 설치', 2, 38),
       (188, 'Husky로 Git Hook 제어하기', 3, 38),
       (189, 'lint-staged 소개와 활용', 4, 38),
       (190, 'Husky + lint-staged 통합 자동화 실습', 5, 38),
       (191, '기초 문법과 자료형', 1, 39),
       (192, '제어문과 반복문', 2, 39),
       (193, '객체 지향 프로그래밍', 3, 39),
       (194, '컬렉션과 제네릭', 4, 39),
       (195, '예외 처리와 파일 I/O', 5, 39),
       (196, '기초 문법과 자료형', 1, 40),
       (197, '조건문과 반복문', 2, 40),
       (198, '함수와 모듈', 3, 40),
       (199, '자료구조 (리스트, 튜플, 딕셔너리, 세트)', 4, 40),
       (200, '파일 입출력과 예외 처리', 5, 40),
       (201, '기초 문법과 데이터 타입', 1, 41),
       (202, '조건문과 반복문', 2, 41),
       (203, '함수와 스코프', 3, 41),
       (204, '배열과 객체', 4, 41),
       (205, 'DOM 조작과 이벤트 처리', 5, 41),
       (206, '기초 문법과 변수', 1, 42),
       (207, '조건문과 반복문', 2, 42),
       (208, '함수와 람다', 3, 42),
       (209, '클래스와 객체', 4, 42),
       (210, '컬렉션과 널 안정성', 5, 42),
       (211, '기본 SELECT 및 조건절', 1, 43),
       (212, '집계 함수 및 그룹핑', 2, 43),
       (213, 'JOIN 및 서브쿼리', 3, 43),
       (214, 'DDL/DML/제약 조건', 4, 43),
       (215, '트랜잭션 & 고급 기능', 5, 43),
       (216, 'RDB 기초 개념', 1, 44),
       (217, 'RDB 종류와 특징', 2, 44),
       (218, 'NoSQL 개요 및 분류', 3, 44),
       (219, 'NoSQL 대표 사례', 4, 44),
       (220, '상황에 맞는 DB 선택 전략', 5, 44),
       (221, 'SQL 성능 이해', 1, 45),
       (222, '인덱스와 데이터 접근 방식', 2, 45),
       (223, '쿼리 튜닝 전략', 3, 45),
       (224, '정규화와 비정규화', 4, 45),
       (225, '실무 성능 이슈 및 해결 사례', 5, 45),
       (226, 'Java & Spring 기초 개념 이해', 1, 46),
       (227, '계층 구조 및 실무 설계 패턴', 2, 46),
       (228, 'Spring Data JPA & 트랜잭션', 3, 46),
       (229, '인증, 보안 및 문서화 도구 활용', 4, 46),
       (230, '실전 고급 기술 & 배포 전략', 5, 46),
       (231, 'Node.js 기본 개념 및 실행 구조', 1, 47),
       (232, 'Express.js와 REST API 설계', 2, 47),
       (233, '인증, 환경 변수 및 에러 핸들링', 3, 47),
       (234, '데이터베이스 연동 및 테스트', 4, 47),
       (235, '아키텍처 설계, 확장성 및 배포 전략', 5, 47),
       (236, 'Django 기초 개념', 1, 48),
       (237, 'URL 및 뷰 처리', 2, 48),
       (238, '템플릿과 정적 파일', 3, 48),
       (239, '모델과 ORM', 4, 48),
       (240, 'DRF(REST API)', 5, 48),
       (241, 'Flask 기본 개념', 1, 49),
       (242, '라우팅과 뷰 함수', 2, 49),
       (243, '템플릿과 Jinja2', 3, 49),
       (244, 'Flask-SQLAlchemy 및 CRUD', 4, 49),
       (245, 'Flask 보안 및 배포', 5, 49),
       (246, 'Kotlin과 Spring Boot의 통합 기초', 1, 50),
       (247, 'Kotlin 스타일의 컨트롤러 & 라우팅 설계', 2, 50),
       (248, 'Kotlin 기반의 서비스 계층 설계 및 예외 처리', 3, 50),
       (249, '코틀린 JPA와 엔티티 설계 시 고려할 점', 4, 50),
       (250, '비동기 흐름과 코루틴을 활용한 API 처리', 5, 50),
       (251, 'ORM과 쿼리 매핑 도구', 1, 51),
       (252, '인증, 검증 및 시큐리티 유틸', 2, 51),
       (253, 'API 문서화 & 직렬화 도구', 3, 51),
       (254, '로깅, 캐시, 배치 처리 도구', 4, 51),
       (255, '테스트, 빌드, 개발 유틸 통합', 5, 51),
       (256, 'Kotlin 기반 ORM 및 쿼리 도구', 1, 52),
       (257, '인증, 보안 및 Validation 유틸', 2, 52),
       (258, '비동기 처리 및 웹 클라이언트 활용', 3, 52),
       (259, 'API 문서화, 로깅 및 캐시 유틸', 4, 52),
       (260, '테스트, 빌드, 배포 자동화 도구', 5, 52),
       (261, 'Spring 애플리케이션 실행 및 운영 (Jar 실행, 내장 톰캣, profile 등)', 1, 53),
       (262, '배포 환경 구성 (Docker, Nginx, Reverse Proxy, SSL 등)', 2, 53),
       (263, '환경 변수 및 설정 관리 (.env, application.yml, Spring Profile 등)', 3, 53),
       (264, 'CI/CD (GitHub Actions, DockerHub, Gradle 등)', 4, 53),
       (265, '모니터링 & 로깅 (Spring Boot Actuator, Micrometer, Prometheus, Grafana, ELK 등)', 5, 53),
       (266, 'Node.js Core Modules', 1, 54),
       (267, 'Express.js', 2, 54),
       (268, 'NPM과 모듈 시스템', 3, 54),
       (269, '비동기 처리와 이벤트 루프', 4, 54),
       (270, 'Node.js와 데이터베이스', 5, 54),
       (271, 'Node.js 프로세스 관리 (PM2 등)', 1, 55),
       (272, 'Node.js 배포 (Docker, Nginx, Reverse Proxy)', 2, 55),
       (273, '환경 변수 및 설정 관리 (.env, config 등)', 3, 55),
       (274, 'CI/CD (GitHub Actions, DockerHub 등)', 4, 55),
       (275, '모니터링 & 로깅 (Winston, Logrotate, Sentry 등)', 5, 55),
       (276, 'Django ORM과 모델 유틸', 1, 56),
       (277, '인증, 권한, 시리얼라이저 검증', 2, 56),
       (278, 'Django REST Framework 및 API 구축', 3, 56),
       (279, '캐시, 비동기 작업, 로깅 처리', 4, 56),
       (280, '테스트, 문서화 및 배포 도구 활용', 5, 56),
       (281, 'Django ORM (기본 내장)', 1, 57),
       (282, 'Django Auth, Simple JWT', 2, 57),
       (283, 'Django REST Framework (DRF)', 3, 57),
       (284, 'drf-yasg, drf-spectacular', 4, 57),
       (285, 'DRF Serializer Validation', 5, 57),
       (286, 'Flask 기본 구조 및 서버 프레임워크', 1, 58),
       (287, 'ORM 및 인증/인가 도구', 2, 58),
       (288, 'REST API 구축 및 유효성 검사', 3, 58),
       (289, '캐싱, 스케줄링, 로깅', 4, 58),
       (290, '테스트 및 배포 자동화 도구', 5, 58),
       (291, 'Flask 실행 및 운영 (Gunicorn, Waitress 등)', 1, 59),
       (292, 'Flask 배포 (Docker, Nginx)', 2, 59),
       (293, '환경 설정 (.env, Flask.config)', 3, 59),
       (294, 'CI/CD (GitHub Actions, DockerHub)', 4, 59),
       (295, '정적파일 & 모니터링 (S3, logging, Sentry, Prometheus)', 5, 59);

-- 로드맵 주입용 더미 user
INSERT INTO users(user_id, is_active, email, login_type, nickname) VALUES
    (1, 1, 'user@user.com', 'LOCAL', 'user');

-- 프론트엔드 기본 로드맵 주입
INSERT INTO roadmap_management(roadmap_management_id, roadmap_nm) VALUES
    (1, 'FE_DEFAULT_ROADMAP');

INSERT INTO roadmap(roadmap_id, order_sub, user_id, sub_id, roadmap_management_id, is_complete, pre_submit_count, post_submit_count) VALUES
    (1, 1, 1, 1, 1, 0, 0, 0),
    (2, 2, 1, 2, 1, 0, 0, 0),
    (3, 3, 1, 3, 1, 0, 0, 0),
    (4, 4, 1, 4, 1, 0, 0, 0),
    (5, 5, 1, 5, 1, 0, 0, 0),
    (6, 6, 1, 6, 1, 0, 0, 0),
    (7, 7, 1, 7, 1, 0, 0, 0),
    (8, 8, 1, 8, 1, 0, 0, 0),
    (9, 9, 1, 9, 1, 0, 0, 0),
    (10, 10, 1, 10, 1, 0, 0, 0),
    (11, 11, 1, 11, 1, 0, 0, 0),
    (12, 12, 1, 12, 1, 0, 0, 0),
    (13, 13, 1, 17, 1, 0, 0, 0),
    (14, 14, 1, 18, 1, 0, 0, 0),
    (15, 15, 1, 19, 1, 0, 0, 0),
    (16, 16, 1, 20, 1, 0, 0, 0),
    (17, 17, 1, 21, 1, 0, 0, 0),
    (18, 18, 1, 22, 1, 0, 0, 0),
    (19, 19, 1, 23, 1, 0, 0, 0),
    (20, 20, 1, 24, 1, 0, 0, 0),
    (21, 21, 1, 29, 1, 0, 0, 0),
    (22, 22, 1, 30, 1, 0, 0, 0),
    (23, 23, 1, 31, 1, 0, 0, 0),
    (24, 24, 1, 32, 1, 0, 0, 0),
    (25, 25, 1, 33, 1, 0, 0, 0),
    (26, 26, 1, 34, 1, 0, 0, 0);


-- 백엔드 기본 로드맵 주입
INSERT INTO roadmap_management(roadmap_management_id, roadmap_nm) VALUES
    (2, 'BE_DEFAULT_ROADMAP');

INSERT INTO roadmap(roadmap_id, order_sub, user_id, sub_id, roadmap_management_id, is_complete, pre_submit_count, post_submit_count) VALUES
    (27, 1, 1, 35, 2, 0, 0, 0),
    (28, 2, 1, 36, 2, 0, 0, 0),
    (29, 3, 1, 37, 2, 0, 0, 0),
    (30, 4, 1, 38, 2, 0, 0, 0),
    (31, 5, 1, 39, 2, 0, 0, 0),
    (32, 6, 1, 43, 2, 0, 0, 0),
    (33, 7, 1, 44, 2, 0, 0, 0),
    (34, 8, 1, 45, 2, 0, 0, 0),
    (35, 9, 1, 46, 2, 0, 0, 0),
    (36, 10, 1, 51, 2, 0, 0, 0),
    (37, 11, 1, 53, 2, 0, 0, 0);
